{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/gov.png","path":"img/gov.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/titleTip.js","path":"js/titleTip.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","path":"css/fonts/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/3-hexo/.git","hash":"fe2a0a3908ae1bdd926c9b286e67f07073f5be2a","modified":1599536178870},{"_id":"themes/3-hexo/.gitignore","hash":"86a50fa08e69cab561892aa5edef24f9081bbde1","modified":1600831362960},{"_id":"source/.DS_Store","hash":"4df03d7ea4128af9fa2a6fcf09400677314490b7","modified":1599535400714},{"_id":"themes/3-hexo/README.md","hash":"d2c42534ceabcb7cd2e58ed994bf7d6f734d1f3b","modified":1600831362960},{"_id":"themes/3-hexo/LICENSE","hash":"b04140c5f682db2b300428f97bb164fd7f5f18bd","modified":1600831362960},{"_id":"themes/3-hexo/.DS_Store","hash":"0770f9d42bfdd8d420de48fed463015e001cf579","modified":1599536178922},{"_id":"themes/3-hexo/_config.yml","hash":"227801240e4b70bea904ce4d839c771b83de3f6a","modified":1604137403000},{"_id":"source/_posts/C++ 复习1.md","hash":"7359e9c85aa935fa8933a1e66ab0d127d930a9f2","modified":1599535400714},{"_id":"source/_posts/Addressable 研究.md","hash":"50c4209d20cd79335167b614fd5f6949c5433e0c","modified":1599548366565},{"_id":"source/_posts/Addressable打包流程.md","hash":"7941004c924af6c72f84fcccb9dc2ead46ae5f5e","modified":1600780832651},{"_id":"source/_posts/.DS_Store","hash":"998d695f6df497b3659af2eb20f24dedfbcb0092","modified":1599535400714},{"_id":"source/_posts/DOTS-事件.md","hash":"75a7149d36188d3bef5a34034a0fa4f703fab899","modified":1599535400714},{"_id":"source/_posts/Centos 部署 Django.md","hash":"e8c46ce6234d76e52923fce98d692f6750f58285","modified":1599535400714},{"_id":"source/_posts/C与C++开源项目学习.md","hash":"d3d8116068b72a9a5ecfb90f567b1dfe6487df65","modified":1599535400714},{"_id":"source/_posts/Conda 常用操作.md","hash":"90e4edcb024845f1104e3d115462d6a8a37146c7","modified":1599535400714},{"_id":"source/_posts/DrawCall优化.md","hash":"857f767b5c825eee2ea6e13e01fdb14759079ec1","modified":1599535400714},{"_id":"source/_posts/Django 实例 Web Application.md","hash":"2b8723ed3e0f41dfad6dd7eb850af9e85c306c33","modified":1599535400714},{"_id":"source/_posts/Django  初步构建.md","hash":"109fb189f65aa74e16896b43d50943f05f8610a5","modified":1599535400714},{"_id":"source/_posts/Django  初始测试.md","hash":"f00809844dec1c95feec4941273829d962c93135","modified":1599535400714},{"_id":"source/_posts/GEA-P1.md","hash":"f2c28fa1d75fb75da67927a0c7087a4820bbd6b5","modified":1599619611345},{"_id":"source/_posts/ECS框架的思考.md","hash":"4bfe8d1dbbe97659bf62631bba1345575cd61d58","modified":1599535400714},{"_id":"source/_posts/ECS-研究学习.md","hash":"88637cc56847711148b699bf58fb82913bdb496c","modified":1599535400714},{"_id":"source/_posts/Effective C++学习记录.md","hash":"40bd8a8d0d64d9ac42b51aa1aa93aff845077a34","modified":1599535400714},{"_id":"source/_posts/GEA-P3.md","hash":"27ca46e8cae9f983071629a6b147eedc2e5de357","modified":1602766016197},{"_id":"source/_posts/GEA-P2.md","hash":"16877aaac9baf64db560343fd7bfa07e42711c27","modified":1602766016197},{"_id":"source/_posts/GEA-P4.md","hash":"db62599f6a0f431f5634d702f890f6d35d1daaa3","modified":1602766016198},{"_id":"source/_posts/IT-English.md","hash":"102d8b43f3ff4b91cd5d8a13674aa377ddd29aad","modified":1599619611346},{"_id":"source/_posts/LWRP官方说明.md","hash":"3873bcb87864ed2815c1ea19fb93a3c2f954b6d5","modified":1599535400715},{"_id":"source/_posts/Linux与window常用指令.md","hash":"643a75530edca84c7c8b39a9f71ce909ddc17f65","modified":1599535400715},{"_id":"source/_posts/Python Core Programming Note 1.md","hash":"780a75d1c219b7a13615572bf09ba7e109c5a409","modified":1599535400715},{"_id":"source/_posts/Jenkins打包事项.md","hash":"5f3c3ff8b62ab7398f815ffef48a60a422eed556","modified":1599535400715},{"_id":"source/_posts/Python Core Programming Note 3.md","hash":"c9e5ec95d1d6c71c239ae2aba093e4a684f8c6d5","modified":1599535400715},{"_id":"source/_posts/Python Core Programming Note 2.md","hash":"c4c708fdb65ebbccae483f494524304c5246112d","modified":1599535400715},{"_id":"source/_posts/Python_3.md","hash":"ac55bfc95b9812dd94662d1bee6a503cee373d07","modified":1599535400715},{"_id":"source/_posts/Python 杂项.md","hash":"b21da23177fc61831063334fd7d9098746ebdf53","modified":1601180281674},{"_id":"source/_posts/Smargit  简单使用说明.md","hash":"f2ff1388e7d52157acf4a2ca7384e2af8e32bf2a","modified":1599535400715},{"_id":"source/_posts/Shader Variant.md","hash":"64cbe4962855d89b00cfc3a87470473c40a937b7","modified":1599535400715},{"_id":"source/_posts/UI系统制作流程.md","hash":"5381112546fc613d148b8632ae5ddaad627c7555","modified":1599535400716},{"_id":"source/_posts/Twisted  介绍.md","hash":"d9ba779079f03ca0a778a78dbb24a22ca6dddf47","modified":1599535400716},{"_id":"source/_posts/VS Code最佳插件.md","hash":"e1a6801eecd7e181a1d4e7b5bc9726069ce5b888","modified":1599535400716},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1599535400716},{"_id":"source/_posts/python_2.md","hash":"b3ac2ce6d4ab552f22acff5fa26ecfd26cc78286","modified":1599535400889},{"_id":"source/_posts/力扣刷题记录.md","hash":"2ad576c527a5bcb1d3573b276e853b75bab6c272","modified":1604579178542},{"_id":"source/_posts/python_1.md","hash":"1180f967868175857ec01b7fc4b991bc330be91d","modified":1599535400889},{"_id":"source/_posts/动态规划.md","hash":"a4dc849e17654b7c6cb0c0280fc8afa09d0ec9db","modified":1599535400889},{"_id":"source/_posts/内存管理.md","hash":"d910ff678bb7486a04160906bc8488bd6c4f9202","modified":1599535400889},{"_id":"source/_posts/力扣刷题顺序.md","hash":"2bb7e9261af77afa627a19854e0eba438c7e29ca","modified":1599535400889},{"_id":"source/_posts/python_4.md","hash":"4c28360b976146adfaf1d2f1320aff80d715313d","modified":1599535400889},{"_id":"source/_posts/客户端更换Git指南.md","hash":"28061582f49db5ab9b8526d2fd8bf7ff31ccce38","modified":1599535400890},{"_id":"source/_posts/天天生鲜项目实例.md","hash":"57edfb0b5b0b3f1d2f7df2db63a24f16eb64b113","modified":1599535400890},{"_id":"source/_posts/四元数旋转函数学习.md","hash":"6709e1d8681429ee7b328745fd65210f5d83e227","modified":1599535400889},{"_id":"source/_posts/天天生鲜项目实例P2.md","hash":"1b9befb1b2f6ff044bc6d9f814312658139636df","modified":1599535400890},{"_id":"source/_posts/开言_Bargaining in the market.md","hash":"59c6c683efcfb779743c2a3fe61c0bfc7c2554cd","modified":1599535400890},{"_id":"source/_posts/开言_Happy Hour Drinks with Coworks.md","hash":"9ffa0dc44c43ab4647d854220d93689adc3456aa","modified":1599535400890},{"_id":"source/_posts/开言- To tip or not to tip.md","hash":"a36c89afc5a62a9cb8fc1593c44616af989249e7","modified":1599535400890},{"_id":"source/_posts/常用单词学习.md","hash":"6e5888491336d6f589c17f42fe1963d971bcdda7","modified":1599535400890},{"_id":"source/_posts/开言体验营 - Day1.md","hash":"88c2f68b7dea55a680936a80022ed85b2b84a737","modified":1599535400890},{"_id":"source/_posts/开言体验营 - Day4.md","hash":"a4710221f4830911ab1f42feaa7bd7f96d7065fe","modified":1599535400890},{"_id":"source/_posts/开言体验营 - Day2.md","hash":"869ffb6f3b04801479684d7de7f7464ec8845420","modified":1599535400890},{"_id":"source/_posts/开言体验营 - Day5.md","hash":"7e9203c3db5d3cbe7f8af572c5652ec2539a0586","modified":1599535400890},{"_id":"source/_posts/数据结构-数组链表结构.md","hash":"b2bd4b202dd9b339258a426813495d6518895ae6","modified":1599535400891},{"_id":"source/_posts/排序算法.md","hash":"99f1e1a2fc7bfbc6bd193ba00abd14ab47975cff","modified":1599535400891},{"_id":"source/_posts/性能优化相关.md","hash":"c3f46f4630ae87768a378e741a94bfa78a2fb4eb","modified":1599535400891},{"_id":"source/_posts/开言学习笔记1.md","hash":"2ae1e411a1fd05beb7ae867c12fb15f4eaeed020","modified":1599535400890},{"_id":"source/_posts/最新Addressable资源打包与加载框架.md","hash":"d4daf5eef92b03889139c19eaee33a9b4046e3d3","modified":1599535400891},{"_id":"source/_posts/数据结构-笔记1.md","hash":"9c4dd36a3d9f89badc6af6e7369e47cbb90e577c","modified":1599535400891},{"_id":"source/_posts/数据结构在Charp.md","hash":"95d709fec3a1c8ee730c22ae884fb3912215a340","modified":1599535400891},{"_id":"source/_posts/深度优先与广度优先算法.md","hash":"976d89809ba9b83fbb83d7b55b5684831d7e2db7","modified":1599535400891},{"_id":"source/_posts/计算机图形学编程笔记1.md","hash":"e741a047e601c1dcbf731695e0e0525ffa8102ce","modified":1599535400891},{"_id":"source/_posts/算法课程笔记1.md","hash":"33c5edf78ee186b64376bb034b0b14446f4ccd4e","modified":1599535400891},{"_id":"source/_posts/线性代数-笔记1.md","hash":"bb7dec88a668b5a0664384885ae1d793239a6d54","modified":1599535400891},{"_id":"source/_posts/计算机图形学编程笔记2.md","hash":"41432a48e1a729c5f3a2b8df97e756f2839ab3e0","modified":1601201962431},{"_id":"themes/3-hexo/languages/en.yml","hash":"9bcbff8c02c922012f2b85d1db8e0af7e6d9e818","modified":1600833499931},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"fd9b1585b378ee07f98fbe5c055310d0ff0b0de0","modified":1600833499931},{"_id":"source/about/index.md","hash":"830f712dc85e3e35fd05dd07d191bb6888a98162","modified":1599535400891},{"_id":"source/_posts/递归算法.md","hash":"1ace42409e33d9daad30d9f125e947986f6c110b","modified":1599535400891},{"_id":"themes/3-hexo/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1599536178924},{"_id":"themes/3-hexo/layout/indexs.md","hash":"390fca74303e320800f9d372a0a514075af0fd42","modified":1600831362961},{"_id":"themes/3-hexo/layout/index.ejs","hash":"27ea3dac053d501b79bbef5117b4f3aff063d8cd","modified":1600831362961},{"_id":"themes/3-hexo/layout/post.ejs","hash":"4abd16c0f5e3f51103d23b73710d695dc7fdc5d2","modified":1600831362962},{"_id":"source/_posts/img/1571216524617_1.png","hash":"9b519adac7868969a0f85cc0c5d9d3bb4c1a579c","modified":1599535400721},{"_id":"source/_posts/img/1571216524617.png","hash":"9b519adac7868969a0f85cc0c5d9d3bb4c1a579c","modified":1599535400721},{"_id":"source/_posts/img/1571217610540.png","hash":"0be73462800326944c1ac227a7bd3d81cae2e98a","modified":1599535400721},{"_id":"source/_posts/img/1571216565243.png","hash":"d0d68f0a4f058aac5eb6f7a7967faaa62851202f","modified":1599535400721},{"_id":"source/_posts/img/1573442010455.png","hash":"2849f7a718dd4c1bfd621f8954aec3246e303ca2","modified":1599535400724},{"_id":"source/_posts/img/1573883470572.png","hash":"0910dac317d43e2a3d48d0ba5d56eae695d9b5dd","modified":1599535400731},{"_id":"source/_posts/img/1574504169104.png","hash":"1cab6bf6fd98ffc7c458e1bccc2bf54fb5065a09","modified":1599535400744},{"_id":"source/_posts/img/1574504183153.png","hash":"07e7c21ab5b5c66c148cd756aef788b63a63f0c9","modified":1599535400744},{"_id":"source/_posts/img/1574504426236.png","hash":"b68ef683a8c3a0cedf8098d217e6c9d15b249ef2","modified":1599535400745},{"_id":"source/_posts/img/1574504420111.png","hash":"bf103ec2becc01d26206a77cae33e2b611a659a3","modified":1599535400745},{"_id":"source/_posts/img/1574504408755.png","hash":"cbe0fa2b2d02a0ac87f48d76e411c47e4fe37f4a","modified":1599535400744},{"_id":"source/_posts/img/1574504516272.png","hash":"252bd12f644d82547335c25462b0afbe6025196c","modified":1599535400745},{"_id":"source/_posts/img/1574504592931.png","hash":"8fc78a7e2e80ee10b897f7771c41a10c065205ea","modified":1599535400745},{"_id":"source/_posts/img/1574504495536.png","hash":"e18be35e5c430c18fea8dbdc44d2c75dfba6852c","modified":1599535400745},{"_id":"source/_posts/img/1574504738524.png","hash":"4903bfd82a285d0a167e9bbea13e25297539f4b3","modified":1599535400746},{"_id":"source/_posts/img/1574504645523.png","hash":"909de20e344326ea11c7924ea2f3b15f1ba3b7cb","modified":1599535400746},{"_id":"source/_posts/img/1574656680199.png","hash":"2fb643af57091a6253536f67b065514ff87c8358","modified":1599535400746},{"_id":"source/_posts/img/1574656656928.png","hash":"2fb643af57091a6253536f67b065514ff87c8358","modified":1599535400746},{"_id":"source/_posts/img/1574656713397.png","hash":"2fb643af57091a6253536f67b065514ff87c8358","modified":1599535400746},{"_id":"source/_posts/img/1574756479212.png","hash":"f9bbbd5abd6160107c684f070f2ca8c99c957aad","modified":1599535400748},{"_id":"source/_posts/img/1574826629863.png","hash":"0f73db75d7ada0a9a35f6722fd256dd15081ccb8","modified":1599535400749},{"_id":"source/_posts/img/1574759871996.png","hash":"03413fdf8c8b191e2603eb03596f24add852bbff","modified":1599535400749},{"_id":"source/_posts/img/1574912330296.png","hash":"5d03bc141a42a8afa9671dfec516191b611cd73a","modified":1599535400750},{"_id":"source/_posts/img/1574937788143.png","hash":"3c9c3951f086b97333ca02543bbf837e93378523","modified":1599535400751},{"_id":"source/_posts/img/1574937768754.png","hash":"d49a606066d8599ecb21b67296e869ce2e78ebae","modified":1599535400751},{"_id":"source/_posts/img/1574937645193.png","hash":"4605caabd420bd2537944ea3cd357cc47113d11a","modified":1599535400750},{"_id":"source/_posts/img/1574937430699.png","hash":"bc9eb2ae92c68de1bb7630b3a03f1734847edf2c","modified":1599535400750},{"_id":"source/_posts/img/1575033223646.png","hash":"7ec1598988d7bd3876c028cba664be5cda46b06a","modified":1599535400753},{"_id":"source/_posts/img/1575034858096.png","hash":"8944d6cb1e45019122eeb119eb04ef80b4dd0433","modified":1599535400756},{"_id":"source/_posts/img/1575083796324.png","hash":"7447fa4f01fc3cedd1a0b4d4536c51987ac29be4","modified":1599535400761},{"_id":"source/_posts/img/1575083811284.png","hash":"ddca8a6b2de24ec86fe81514677f862aba3f5bbd","modified":1599535400761},{"_id":"source/_posts/img/1575255482902.png","hash":"907f3724a8fb017a6d125179a44ba48af86323fa","modified":1599535400761},{"_id":"source/_posts/img/1575255814499.png","hash":"e1ca2896837e6e879d3f2b2a98bed0b04a7c103a","modified":1599535400762},{"_id":"source/_posts/img/1575290314506.png","hash":"b362346cf7073a91a94f4e15ed2061ff87a9f3ea","modified":1599535400766},{"_id":"source/_posts/img/1575635485238.png","hash":"3d36284dc1b8e8770219f2679419d4bed2219f61","modified":1599535400768},{"_id":"source/_posts/img/1575635246200.png","hash":"f6f4386b3328492d21951da3988a34da013c84ab","modified":1599535400768},{"_id":"source/_posts/img/1575634466665.png","hash":"415fdd0a4181e37c27c07574dbd7a8445e266672","modified":1599535400768},{"_id":"source/_posts/img/1576549292557.png","hash":"79a27c6f190944f8f04fb112a8e342e9f103bbae","modified":1599535400769},{"_id":"source/_posts/img/1575984532516.png","hash":"5dd2caff585e0d7bdf4029f66fbf82117f8c0d97","modified":1599535400769},{"_id":"source/_posts/img/1576551196217.png","hash":"dc39363e946367d7b6eda2485540d6a439bdbe5e","modified":1599535400770},{"_id":"source/_posts/img/1576810673369.png","hash":"56d6a40b0295761897637a1702d257d4f6f85a26","modified":1599535400772},{"_id":"source/_posts/img/1577414335373.png","hash":"598b2cc67db4c09eb5b6aab1b947a6f1374095b9","modified":1599535400779},{"_id":"source/_posts/img/1578122441016.png","hash":"2dd80c567a5697ab74c8432ffb804be96dedd974","modified":1599535400780},{"_id":"source/_posts/img/1578122991267.png","hash":"8fcac9b54c912af33d9cd4f97fcdafd838d57ce7","modified":1599535400781},{"_id":"source/_posts/img/1578122530429.png","hash":"24620e2900853e9ff24bccf3ec6833f64ecd5d47","modified":1599535400780},{"_id":"source/_posts/img/1578377646492.png","hash":"55b295677bd71cfb06d8ab963bbc6e0df90fba92","modified":1599535400783},{"_id":"source/_posts/img/1578380227603.png","hash":"36f7d05362b0f63929520b427e6dcd8b17723935","modified":1599535400789},{"_id":"source/_posts/img/1578454158486.png","hash":"fe84b70de9e75445bf5ce1980b997df527f87b26","modified":1599535400801},{"_id":"source/_posts/img/1578469737158.png","hash":"2bd36a9e1eb00a17aa34b065b8ae9816fbcbe4a0","modified":1599535400808},{"_id":"source/_posts/img/1578469710690.png","hash":"f493c0b1d6253a249fac777039afac503cb3c973","modified":1599535400808},{"_id":"source/_posts/img/1578646594733.png","hash":"8be67b6e36c69a9149b8fe3e3b1aabe99c71207a","modified":1599535400825},{"_id":"source/_posts/img/1578566566815.png","hash":"b65e0c1e82f134a46c13f398b9a5edf1f4007685","modified":1599535400825},{"_id":"source/_posts/img/1578566598445.png","hash":"0055ab13603b9fbad97e43efdb782bb15a29c63f","modified":1599535400825},{"_id":"source/_posts/img/1578646743161.png","hash":"7f0297a66abf8ae67f8ed36377bcd54d56ab3197","modified":1599535400825},{"_id":"source/_posts/img/1578652129043.png","hash":"ed634cc790e0adc59bc5e919f2d32d12764726a1","modified":1599535400825},{"_id":"source/_posts/img/1578647010062.png","hash":"461d2059116f6c4a67cc53a05e49976ff3d1f4ba","modified":1599535400825},{"_id":"source/_posts/img/1578651845843.png","hash":"fc73712e7a1b4f8e04da2270a54e200cb3ddbd40","modified":1599535400825},{"_id":"source/_posts/img/1578652955011.png","hash":"827c4d2e99ed72d78a4834b7f8e8c521648ea461","modified":1599535400826},{"_id":"source/_posts/img/1579078890824.png","hash":"8168c3f6f0f63f316ef7bf7fe619f6b1eddd6a82","modified":1599535400832},{"_id":"source/_posts/img/1585907380155.png","hash":"b04fe6070471ca5b4876b33512edeff19852f399","modified":1599535400851},{"_id":"source/_posts/img/1585909136108.png","hash":"a0b920358a22007b16f2215115efc43816cd0beb","modified":1599535400853},{"_id":"source/_posts/img/1585908824999.png","hash":"18771705c5eaf59930ae219dee09aabe93e5ed6b","modified":1599535400852},{"_id":"source/_posts/img/1586247286704.png","hash":"9319a15e486ddb2b9613d347ef00839ce80b48f2","modified":1599535400854},{"_id":"source/_posts/img/1586247034757.png","hash":"8e4edfd9f2403a902bb4c1f531d44489fbfdd049","modified":1599535400854},{"_id":"source/_posts/img/1585909191700.png","hash":"a68e5129594630ced04708de2726fd940d65f338","modified":1599535400853},{"_id":"source/_posts/img/1586415991649.png","hash":"b6e6ce92529ab97f490b33a71e7c7486a6f0c4f4","modified":1599535400856},{"_id":"source/_posts/img/1586247445746.png","hash":"f7ff3c22cf003ba079ac188a53e149ef72a0336c","modified":1599535400854},{"_id":"source/_posts/img/1586248831375.png","hash":"15e6552b123b340a1ab1526aaa58049b8eb1c636","modified":1599535400854},{"_id":"source/_posts/img/1586416101201.png","hash":"367e8e209614bddafb4cac1f7f90472ae4acb158","modified":1599535400857},{"_id":"source/_posts/img/1586416055487.png","hash":"b4ae79cb84f5b39e438b0f4150e7d9eb247e4ee7","modified":1599535400857},{"_id":"source/_posts/img/1586416029304.png","hash":"c920f95f08bbcfd49d9ba41765cf5012628e8bd3","modified":1599535400856},{"_id":"source/_posts/img/1586419084172.png","hash":"2b91290a5ba89b626ed10f57d0fb757306093132","modified":1599535400859},{"_id":"source/_posts/img/1586423672607.png","hash":"052b5667530fbe8216761cf9a452dd72345856c9","modified":1599535400860},{"_id":"source/_posts/img/1586434219909.png","hash":"908b91deaa2c87d3abeaf6819646f6c28273b5ee","modified":1599535400864},{"_id":"source/_posts/img/1586434247273.png","hash":"84ac7d2e03545cf52fece9e5b00fe0d9019abb96","modified":1599535400864},{"_id":"source/_posts/img/1586434407387.png","hash":"af5ab1966c6a411e7066a2fe7c6f2b23b4edb561","modified":1599535400866},{"_id":"source/_posts/img/1586435194085.png","hash":"07fca678821aff0e0b3d4302dc4445b5cb1720a9","modified":1599535400871},{"_id":"source/_posts/img/1586435663044.png","hash":"9751510a51a125b63aa0e566a48ce88a3b6c4f4c","modified":1599535400873},{"_id":"source/_posts/img/1587018007123.png","hash":"a9d8444a3a254258fdd0792010189f542777b436","modified":1599535400875},{"_id":"source/_posts/img/1587018052146.png","hash":"d1ca6f82eb92777d05e122aa58ecfef13a0f538f","modified":1599535400875},{"_id":"source/_posts/img/1587018034122.png","hash":"f27a7e34f1cd88321c9054e8b3157e0b5218a596","modified":1599535400875},{"_id":"source/_posts/img/1587018065979.png","hash":"57307b7e2f6678cd911ef7a42f3ae1759f90e317","modified":1599535400875},{"_id":"source/_posts/img/1587018141563.png","hash":"9ca96ecb6ca5a669ab555c42d022341c9ef6ee07","modified":1599535400877},{"_id":"source/_posts/img/1587018132041.png","hash":"8aeaa49ea6a34bdfb427f23e4ce56fab398faf3d","modified":1599535400877},{"_id":"source/_posts/img/1587018118278.png","hash":"6f247487fcb8eade956736f3a7ad27a0f322e414","modified":1599535400877},{"_id":"source/_posts/img/1587018086814.png","hash":"b6dcf06860a0756155e0c18c453930beb5fb1298","modified":1599535400876},{"_id":"source/_posts/img/1598259821964.png","hash":"20b50aeb93957c87a8d992e17ecb587f9a159fac","modified":1599535400878},{"_id":"source/_posts/img/1598260018452.png","hash":"2bdc6f5c5d22e31afe96b65d95283ddea82cc3be","modified":1599535400885},{"_id":"source/_posts/img/1598260733232.png","hash":"60c276f2ab0afe172a66b99b7c20250f342a8658","modified":1599535400885},{"_id":"source/_posts/img/1598273932723.png","hash":"987f0929235af72ccf91f30dcb0fd6c04d510192","modified":1599535400886},{"_id":"source/_posts/img/1598274190104.png","hash":"78cce7503768fe28f591c407010ca7d734c5e27a","modified":1599535400886},{"_id":"source/_posts/img/1598273763851.png","hash":"adc48c8e4f50b296d5ba1fd45a8808a2342d9b35","modified":1599535400886},{"_id":"source/_posts/img/1598273584691.png","hash":"4de4d438af46e37823c33107709ee428d4ac5272","modified":1599535400885},{"_id":"source/_posts/img/1598274276096.png","hash":"fdaf8b260a4cf1859b53245bb6a62fc60807a1b2","modified":1599535400887},{"_id":"source/_posts/img/1598274216079.png","hash":"ffafacde47c7b7a77676e3162dc8ee2e3295b9ab","modified":1599535400887},{"_id":"source/_posts/img/1599634811580.png","hash":"c404449efd8523521b1d350701bba371b9493509","modified":1600239067045},{"_id":"source/_posts/img/1599634350864.png","hash":"29179a817ac12398357da34ea1666e53df45831a","modified":1600239067045},{"_id":"source/_posts/img/1600236947016.png","hash":"c974d09e22089467aa836310811e107e5a3e50e2","modified":1600239067047},{"_id":"source/_posts/img/1600238404872.png","hash":"3b0a86d8cead7a53cfac66ce0f97d8ac8cc202b4","modified":1600239067047},{"_id":"source/_posts/img/1600395139064.png","hash":"96c98ad80f5b054e112d0be12680e746fd63ff67","modified":1600780832651},{"_id":"source/_posts/img/1601178139148.png","hash":"52d78af5ffd426f105fb45e160b6d1ea444c5b10","modified":1601180281674},{"_id":"source/_posts/img/1602736500822.png","hash":"d469656212e230db2041df696c7aef204079f06a","modified":1602766016199},{"_id":"source/_posts/img/1602742636082.png","hash":"2d943c25e024a1d78e467943d6a7eee601492aa8","modified":1602766016200},{"_id":"source/_posts/img/1602742566579.png","hash":"1337b53b945719679711e5102c7bb11c181dc4a0","modified":1602766016200},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"516844c4a0e13d6773f6029849f51c59613b6f69","modified":1600831362960},{"_id":"source/_posts/img/1602742820576.png","hash":"c7b0405220b6a7776ae623e2d3ce87073ab64e6b","modified":1602766016200},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"f66939a8c9d5258948b47842b8b4495e6ec45988","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"0ebb17d001cb7bb7606c616c380049a2e7124496","modified":1600831362960},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1599536178922},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"bc94eee27701b67d238f328737b578e8270989eb","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"d0b84370ca81c3baa02a05613ff040003acd2985","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"a734c26d86da6697003ed27672c1b9b82b216c82","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"d11092791e5c140ff81f2aefa0d1b051f403239d","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"ed479aa9affee3b02a76da06de45a7c40a97a706","modified":1604579749210},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"3f9d91215ff36a6bcdaaf86e5b028dafc5a6a6fc","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"e1bb54edfa0f666f829afa839fbb24c22bc17757","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"8a9e93f9cbe80763264018290da0b14b4bbe8ac5","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1599536178923},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"3cf8ba0c6112dfa8089603b8df3e31f70a272715","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1599536178924},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"59a4abd36cc8ff2107f1fcb3c0fe48d0492c9030","modified":1600831362963},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"0954774b67b25148c9bac76613557e6b0ed84c83","modified":1599536178927},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1599536178928},{"_id":"themes/3-hexo/source/css/style.styl","hash":"7090b81f34e26172670c68da6a366ca186523779","modified":1600831362963},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1599536178927},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1599536178928},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1599536178928},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1599536178928},{"_id":"themes/3-hexo/source/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1600831362963},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1599536178931},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"5fe79b9fc9124a67b3f1276c04124900f1226a2c","modified":1599536178929},{"_id":"themes/3-hexo/source/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1599536178932},{"_id":"source/_posts/img/1570783134086.png","hash":"ba31616e3183191bdc9280fd30acbaa419e69e2a","modified":1599535400721},{"_id":"source/_posts/img/1573441070020.png","hash":"66cfd013b868590ed516382e1edaf4b3ca25384c","modified":1599535400724},{"_id":"source/_posts/img/1573442404015.png","hash":"aa8517f27a4f31bd23dfa27afdccde34f87c81be","modified":1599535400725},{"_id":"source/_posts/img/1573881886011.png","hash":"da6d8be633e57115d26bb55b6d850a2984933f9c","modified":1599535400730},{"_id":"source/_posts/img/1574171584470.png","hash":"200a42f2892059e28578993f92007846ef7ba75d","modified":1599535400743},{"_id":"source/_posts/img/1573881914065.png","hash":"d7d03ccf5160377d64e8ca2415d9adb57a6d9f1f","modified":1599535400731},{"_id":"source/_posts/img/1574504634973.png","hash":"fd240f6c82967a5e7fb3f3a92f868bd0b297d4b9","modified":1599535400746},{"_id":"source/_posts/img/1574757440291.png","hash":"6a381a9b0e8ee9068aed7b21d41a1e6f616344e4","modified":1599535400749},{"_id":"source/_posts/img/1574826985515.png","hash":"a821fa7110b7b786f9ac8ec3a678f3f451c1851c","modified":1599535400750},{"_id":"source/_posts/img/1575035161292.png","hash":"4df4617e563ad963e381edde37a39233de358663","modified":1599535400759},{"_id":"source/_posts/img/1575035213445.png","hash":"3665f0ba3d2f5b8e854c72241081a3c4b7291064","modified":1599535400760},{"_id":"source/_posts/img/1575035246421.png","hash":"fa59f6757af688bb3ef1327a92869d20f3513725","modified":1599535400761},{"_id":"source/_posts/img/1575603749178.png","hash":"8a572aee78a06101efc759c8856e3fdf5b9c9496","modified":1599535400766},{"_id":"source/_posts/img/1575640031870.png","hash":"ed3b2c3a73eb48ab84ec4bff189ecccc01349527","modified":1599535400768},{"_id":"source/_posts/img/1575981798051.png","hash":"8232140fdbfd9ec30899dffd31ac9506bc403442","modified":1599535400769},{"_id":"source/_posts/img/1576810604102.png","hash":"282a3241200da2377501175dc2cdb89630899a2a","modified":1599535400772},{"_id":"source/_posts/img/1576722037256.png","hash":"5b5390f1f9b578c291ba610fbabae53ecc458834","modified":1599535400771},{"_id":"source/_posts/img/1576636756891.png","hash":"be62c1783c41229045b4a2934672ad0f1e3b1fcc","modified":1599535400771},{"_id":"source/_posts/img/1577414816762.png","hash":"18b40c9eaad605eada89bf2bc20b776a5f8ae411","modified":1599535400780},{"_id":"source/_posts/img/1578122591339.png","hash":"b2ea31874b792b8f00ff44a9ee931026c8d49603","modified":1599535400781},{"_id":"source/_posts/img/1578123391128.png","hash":"4ea369ba03811b4d8967508b5a098584d03b5900","modified":1599535400782},{"_id":"source/_posts/img/1578123481409.png","hash":"38397c9eab04b442594e8e9d7f9d6f402ee886cc","modified":1599535400782},{"_id":"source/_posts/img/1578453790169.png","hash":"7b36492ff9c46d8d7e8b66d9d825ee5106e21c56","modified":1599535400801},{"_id":"source/_posts/img/1578454302221.png","hash":"c65046a8d6dbc06e61a5ab4347c15e88fe64943c","modified":1599535400802},{"_id":"source/_posts/img/1578470577651.png","hash":"e51c688f056f50634ce4adc3073a8acb32c80f3c","modified":1599535400825},{"_id":"source/_posts/img/1578652476304.png","hash":"85d2ebed8d72a034c6a3dee7bac71e04360e1624","modified":1599535400826},{"_id":"source/_posts/img/1579081031342.png","hash":"d83d92b8caa4db8129c748c2f3ab9aab75446d81","modified":1599535400833},{"_id":"source/_posts/img/1579081015473.png","hash":"92955dc73658c8704f080bfab33c50aa7e612273","modified":1599535400833},{"_id":"source/_posts/img/1584499995727.png","hash":"f003a628ea6b5f0930c2508e0a7aa0df2a426045","modified":1599535400836},{"_id":"source/_posts/img/1585708632739.png","hash":"056b00d2c4076707e33eea51c6b8fbb1ff9ecc29","modified":1599535400839},{"_id":"source/_posts/img/1585710628207.png","hash":"4e95a8df75f250870a128afdb77771e22b1250ef","modified":1599535400840},{"_id":"source/_posts/img/1585713033340.png","hash":"55cb859a0bf3f8945fbdd2fc26a0fa21f6d15eed","modified":1599535400843},{"_id":"source/_posts/img/1585714787406.png","hash":"6a2d00b7d7d6b57f50dfe2077accb745ff1f68c1","modified":1599535400844},{"_id":"source/_posts/img/1585742120344.png","hash":"1741d60b6501bb96b8f2b1125303c8833f618d34","modified":1599535400848},{"_id":"source/_posts/img/1585742361670.png","hash":"6e2d4f218fb4524741b62189368626904c24f785","modified":1599535400848},{"_id":"source/_posts/img/1585903822933.png","hash":"45396c8874dd0d82d07f355646c8d0f9c2409761","modified":1599535400851},{"_id":"source/_posts/img/1585908857419.png","hash":"7bb044d670fe31c8f0be0417b259e728195c5a38","modified":1599535400853},{"_id":"source/_posts/img/1585908731720.png","hash":"70588034f6524f6d39ab1b644af0fb047be945e1","modified":1599535400852},{"_id":"source/_posts/img/1585909201370.png","hash":"8e2af7862891d1bdb48f9b3846116978388be244","modified":1599535400854},{"_id":"source/_posts/img/1586415301619.png","hash":"bdbbcf09d2a190c7ac2806a668674276a2cda02c","modified":1599535400855},{"_id":"source/_posts/img/1586416006714.png","hash":"bf29f9922c33f6902cde715ec8728a5d2af1bf2e","modified":1599535400856},{"_id":"source/_posts/img/1586416261865.png","hash":"2e2d841a79b2af6b703002c870084adfd32e1b1f","modified":1599535400858},{"_id":"source/_posts/img/1586418715552.png","hash":"2146ee0dac0d76a997032804b72f635f8eb4ac67","modified":1599535400859},{"_id":"source/_posts/img/1586416480976.png","hash":"9ea65b15180a951f8c95b8d502df6cfb74d597f0","modified":1599535400858},{"_id":"source/_posts/img/1586423739245.png","hash":"7e46c392bc1b551352402f617b548ccba0965f88","modified":1599535400862},{"_id":"source/_posts/img/1586434191932.png","hash":"f27d5b1edec395e5c7d3dbca36c9c6c23927b4c5","modified":1599535400864},{"_id":"source/_posts/img/1586423973441.png","hash":"99d1e6be6f1284986db6681d57efea39b9db144a","modified":1599535400863},{"_id":"source/_posts/img/1586423782860.png","hash":"bca7f274cb84deac8d02548f6c2851f5705c00e7","modified":1599535400862},{"_id":"source/_posts/img/1586434361642.png","hash":"c48e7237b5cf36b8a719569abb7ce919f27bb850","modified":1599535400865},{"_id":"source/_posts/img/1586434970193.png","hash":"97d09737a4f388543f2f0aa0e02edd2cbb0f0d29","modified":1599535400869},{"_id":"source/_posts/img/1586434845632.png","hash":"d9016ec4480115fe9da612bcd39e79db8fe7f07d","modified":1599535400869},{"_id":"source/_posts/img/1586434733368.png","hash":"12a3a69dbffb0415f41603fcb9bafb51c93d5daa","modified":1599535400868},{"_id":"source/_posts/img/1586434756126.png","hash":"8915d2f018f90e10f8f34b113145b3d67079a07a","modified":1599535400868},{"_id":"source/_posts/img/1586435164143.png","hash":"6c68efa7ad68e846806404d06e165ce4e932f7d7","modified":1599535400870},{"_id":"source/_posts/img/1586435618505.png","hash":"beefd679c639e80da652f23dbc19196be8f92deb","modified":1599535400872},{"_id":"source/_posts/img/1586435106444.png","hash":"6d4864e359e1646ce7da3be1e7a1cd4265742664","modified":1599535400870},{"_id":"source/_posts/img/1586435636294.png","hash":"977b60b194294b34f105193932650206f48cd940","modified":1599535400872},{"_id":"source/_posts/img/1587018079539.png","hash":"ccd57e441bde5b710201ee0ede93319ab41cf5b9","modified":1599535400876},{"_id":"source/_posts/img/1587018151039.png","hash":"540adf367aa3124d3c2e01b2d49ed71a5336dec0","modified":1599535400878},{"_id":"source/_posts/img/1598514940240.png","hash":"de76acc11bdd97608dfe02ffb5db64b56a3a0536","modified":1599535400887},{"_id":"source/_posts/img/1598516074235.png","hash":"a89a3d9dee44b375bef4e72792ad6b695c28d640","modified":1599535400888},{"_id":"source/_posts/img/1600233059102.png","hash":"16193a0a0a390e957b8c9c56d1ea7817c3cd7552","modified":1600239067046},{"_id":"source/_posts/img/1600238267260.png","hash":"5543903bfa5349f49a059ddaf974d54393df4618","modified":1600239067047},{"_id":"source/_posts/img/1602736304626.png","hash":"213d9977e87743c3ab9ca6a329f8ad4a8fd47cab","modified":1602766016198},{"_id":"source/_posts/img/1602736411263.png","hash":"1ef27c00070cce448f4ee114190d6741738dbe57","modified":1602766016199},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1599536178932},{"_id":"themes/3-hexo/source/js/script.js","hash":"03fc06177b47fd6bac7ae393f9712c726272467b","modified":1600831362967},{"_id":"themes/3-hexo/source/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1600831362967},{"_id":"source/_posts/img/1570674939333.png","hash":"a944ffb9ba0afeaad24cacc53f734a8e6c89eb01","modified":1599535400719},{"_id":"source/_posts/img/1574995793894.png","hash":"b27642512001f8f7cd108f8ea99e028d91e911db","modified":1599535400752},{"_id":"source/_posts/img/1575290159935.png","hash":"6ab04e77c43fa6bb037c1273ad37a1d23547163b","modified":1599535400763},{"_id":"source/_posts/img/1575290242736.png","hash":"f55e46aa23020bd24d9711c2591bf213b8560789","modified":1599535400763},{"_id":"source/_posts/img/1576554364999.png","hash":"ca9b05e5ebc7e9d94fd7c9d1e4b11fd5d57b8d37","modified":1599535400770},{"_id":"source/_posts/img/1576811148925.png","hash":"653a4d7709285a63502cb899f6aa74e8aac74bdc","modified":1599535400774},{"_id":"source/_posts/img/1576810958695.png","hash":"6be7635f04abc958fdfab34a000898df7011caeb","modified":1599535400773},{"_id":"source/_posts/img/1578380391307.png","hash":"dcc1e9e47301b7c90867c4f7ac1e6af0914c1a45","modified":1599535400790},{"_id":"source/_posts/img/1578454203406.png","hash":"100f20cd1ba5199c86bbc24eb0c7104a1cf0d352","modified":1599535400802},{"_id":"source/_posts/img/1584500576606.png","hash":"2e093d58fa105f0a773df5c67538275bf9078410","modified":1599535400837},{"_id":"source/_posts/img/1585742844977.png","hash":"67ba934dddacd29ed645c954fb94e31c829d60db","modified":1599535400849},{"_id":"source/_posts/img/1585743156869.png","hash":"af024fab0eea0a54835b56f8184c19df78042364","modified":1599535400850},{"_id":"source/_posts/img/1586434291192.png","hash":"bc71c04b1fd49241fb9e8cde110888e99c10dff4","modified":1599535400865},{"_id":"source/_posts/img/1598929159605.png","hash":"954f41067ef1cfcbfa8e10ec57622d3200dadf4c","modified":1599535400889},{"_id":"source/_posts/img/1600240709174.png","hash":"5a5a58d18587ab5a1d5c7985f4be7cbc87f11fcb","modified":1600240845616},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"fbd3c7d72c8354d700918390c6cbfc0a11408277","modified":1599536178923},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"f16442568b43d034faaa8e3507f5ae8da34c7b72","modified":1599536178923},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1599536178922},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"fa6675230f8c313236604e26926b142f4f418bdd","modified":1599536178922},{"_id":"themes/3-hexo/layout/_partial/comments/utteranc.ejs","hash":"c76773b96860940083baf16470b7b80ac098e645","modified":1600831362961},{"_id":"themes/3-hexo/layout/_partial/comments/livere.ejs","hash":"e820aa16b5ed4e024616b5e2d424925820d43e56","modified":1600831362961},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1599536178924},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"2a9b5ffb759be85545a89f6d1194579a800f51a5","modified":1600831362962},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"0143711c1221cb4e70a3db866754d79c8a81d253","modified":1600831362962},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"4f1621f52e24ea35fa5bb32ce1cee2c7de9d0dc2","modified":1600831362962},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"ea78c9f23b3f44b6c665721ebe74eac9675b6499","modified":1600831362962},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1599536178924},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"e3c30d618d9e1b7a6a3274cff2ca42f054e99ddd","modified":1600831362962},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1599536178924},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"0dd8d208081b92e05d6db3361743c520a2816828","modified":1600831362962},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1599536178924},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1599536178925},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1599536178925},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1599536178925},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1599536178925},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1600831362963},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1600831362963},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1600831362962},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1599536178926},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"553987211d3323a7dfc0b08786b183a3435978c9","modified":1600831362963},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1600831362963},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1599536178927},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1599536178931},{"_id":"source/_posts/img/1570674953248.png","hash":"bae9bd1b0dafbee6df631f87d77ad33e4c8fefba","modified":1599535400720},{"_id":"source/_posts/img/1575029000281.png","hash":"5a080b1bcfc61af9793c7b3ec3e885087f5c5075","modified":1599535400753},{"_id":"source/_posts/img/1575290288546.png","hash":"7e658df239a52fb818e7b69f10118fc4bdaafba6","modified":1599535400766},{"_id":"source/_posts/img/1578365001196.png","hash":"3607f0614b71cc266e6162e8122e6c542a3a974d","modified":1599535400783},{"_id":"source/_posts/img/1578379986297.png","hash":"7397670a9034c321557139473f208a3d90115e07","modified":1599535400787},{"_id":"source/_posts/img/1578453777774.png","hash":"683befa028c8093d245db31f5c6382777b4689a1","modified":1599535400801},{"_id":"source/_posts/img/1578469925626.png","hash":"e6e2c31f4294c77056102e3d0dd1a2923eacccb2","modified":1599535400809},{"_id":"source/_posts/img/1579077588215.png","hash":"e7774c9918d58a7582579b6af9a14dd8805e06b9","modified":1599535400828},{"_id":"source/_posts/img/1583549878874.png","hash":"d2baef767403a013794217e3dbfd64597cf71e9c","modified":1599535400835},{"_id":"source/_posts/img/1585710578747.png","hash":"8c35694192006651a08e397504d87af2e07996a6","modified":1599535400840},{"_id":"source/_posts/img/1585710256442.png","hash":"19929e0c74f14b50d7c399754434ad555837342e","modified":1599535400840},{"_id":"source/_posts/img/1586423622273.png","hash":"fb715dfaa85eb3cc07d4ecf153830190f641276f","modified":1599535400860},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1599536178927},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1600831362963},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1599536178927},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1599536178927},{"_id":"source/_posts/img/1574738644796.png","hash":"fcca387d7cf8670261dc87b0602836c5eea1d95b","modified":1599535400748},{"_id":"source/_posts/img/1579072055300.png","hash":"4aca0090e0ae0a9ac27472dd8c187dec0346fd58","modified":1599535400827},{"_id":"source/_posts/img/1583550030862.png","hash":"e82717471d46cf90267d070f15e149790c7635f1","modified":1599535400835},{"_id":"source/_posts/img/1585710777047.png","hash":"0825d194c1a4c835f1a13926614bd3c049dccf43","modified":1599535400841},{"_id":"source/_posts/img/1585712085363.png","hash":"d33c9638d9fdf04c35abbc3222909134b6666480","modified":1599535400842},{"_id":"source/_posts/img/1585711991004.png","hash":"5918f512f3eada676bb27f894dd72089f9d4ddd8","modified":1599535400841},{"_id":"source/_posts/img/1585712479371.png","hash":"5e90274e7d19b811edb82826d8c41f744f4d3e9f","modified":1599535400842},{"_id":"source/_posts/img/1585714606930.png","hash":"e01dc317e9e8029e7f47e3928f3a77d50bc6c83e","modified":1599535400843},{"_id":"source/_posts/img/1585722630933.png","hash":"075632bed79c97dead0429bea6b7e3c44470cc22","modified":1599535400845},{"_id":"source/_posts/img/1573879504277.png","hash":"2b8d9bea3a8ad233bd90187e200d35fbbdc0160f","modified":1599535400726},{"_id":"source/_posts/img/1575290266752.png","hash":"5647b1e1457fb313032fff25c4f23e9fca6447fd","modified":1599535400764},{"_id":"source/_posts/img/1575634128185.png","hash":"0a3a3da380a2a42a47cecba7234d188d85974db9","modified":1599535400767},{"_id":"source/_posts/img/1583548259212.png","hash":"192c67aab6160aa7f2647e0b1b87899a4268f415","modified":1599535400834},{"_id":"source/_posts/img/1584500759081.png","hash":"feccfaa23c8f26c02c2d171dd7c1aaf9ca6f0ccc","modified":1599535400837},{"_id":"source/_posts/img/1584501076960.png","hash":"5ae90da1801b6c57a8351f4a4142ba6fbfbd7f72","modified":1599535400838},{"_id":"source/_posts/img/1584501108996.png","hash":"15f107f6f0a59871f587ebc645370df7df30eda1","modified":1599535400838},{"_id":"source/_posts/img/1584502302892.png","hash":"0498ecb4e708d9cc45f66bc68736dc7f7f48fcda","modified":1599535400839},{"_id":"source/_posts/img/1573880787198.png","hash":"852d7d8c483c0fa942c1afc31f5b1bdccd09d1ff","modified":1599535400730},{"_id":"source/_posts/img/1575035108391.png","hash":"280c89f1280b5895ffe0afafad91b47028085972","modified":1599535400759},{"_id":"source/_posts/img/1578378838931.png","hash":"8ac80897da191aa37c3f63fca2fa4bd5c657a588","modified":1599535400784},{"_id":"source/_posts/img/1578380200054.png","hash":"e1c426dcc2871bf101690fb2b0509ef9408e9e95","modified":1599535400789},{"_id":"source/_posts/img/1578380648851.png","hash":"46a273cfe495638bdcb74e80e7c260c3d644ba65","modified":1599535400798},{"_id":"source/_posts/img/1579078623846.png","hash":"9ac9c897c7ad07029b27452da7fe3e0c70bdd549","modified":1599535400832},{"_id":"source/_posts/img/1584499275880.png","hash":"7eeb37e1116e4ae6075242eb3c0f3e0d73ef94d3","modified":1599535400836},{"_id":"source/_posts/img/1585709533268.png","hash":"7f2cb728e9cad73a712a991a064e494e7ae26096","modified":1599535400839},{"_id":"source/_posts/img/1585722584708.png","hash":"d9dd0743858cb051494dda9cbc67eb30f512801d","modified":1599535400845},{"_id":"source/_posts/img/1585714939207.png","hash":"bcbc321d9e48d8f83b3af2d19a257733c8005f1c","modified":1599535400844},{"_id":"source/_posts/img/1586423705879.png","hash":"9d16e4f2ba8b17c2fa71012b8f6706de942a883b","modified":1599535400861},{"_id":"source/_posts/img/1573879565628.png","hash":"c9347d343ff700a8a438e1182aa43ffd7c3bf4f6","modified":1599535400728},{"_id":"source/_posts/img/1578378917671.png","hash":"47ea5cf408a00e137a82df58ac5cecad602c2a4d","modified":1599535400786},{"_id":"source/_posts/img/1584498872491.png","hash":"5320aa486e4d4c3cbd5f8aa2d948ea21deccc0e4","modified":1599535400836},{"_id":"source/_posts/img/1585742087660.png","hash":"f46cc2a75c5a1a076576963a6c9ca5ddb131113f","modified":1599535400848},{"_id":"source/_posts/img/1585819226392.png","hash":"26a409a5de22d7ba5437ffa22eeaefae08e6f41c","modified":1599535400851},{"_id":"source/_posts/img/1587017641511.png","hash":"ed3c47de91d8f354ee78510ea553d404422ce5a3","modified":1599535400874},{"_id":"source/_posts/img/1570613306377.png","hash":"cbd6c68dc495c55df5010e0af487eac3a7fcbb43","modified":1599535400718},{"_id":"source/_posts/img/1577068738684.png","hash":"9bc0d2bb0ba8189d7dcdcd12afc6714c0b5f5958","modified":1599535400776},{"_id":"source/_posts/img/1583549163720.png","hash":"83f89ea8e6891a4fb3483d660ad65266976c834d","modified":1599535400834},{"_id":"source/_posts/img/1575033456146.png","hash":"cff615e0a5771d7cf724f3858e5734bf198d71cd","modified":1599535400756},{"_id":"source/_posts/img/1577068784300.png","hash":"af7562f9151170c52bcc0fb500436e819ee4a48a","modified":1599535400779},{"_id":"source/_posts/img/1585711969955.png","hash":"6839969b9cb94e7c4afbe9fc19da9367ad5f4da1","modified":1599535400841},{"_id":"source/_posts/img/1585712995976.png","hash":"2081741dd2d84c0618232b4379a404ccbca52e22","modified":1599535400843},{"_id":"source/_posts/img/1575033366217.png","hash":"49923905e9ab61bb5eb5852ef3c54d41ae72ddab","modified":1599535400754},{"_id":"source/_posts/img/1578470471751.png","hash":"9eeabd227fc9a70382a690a90e5ea4e8091a4115","modified":1599535400819},{"_id":"source/_posts/img/1578470183627.png","hash":"969379825bd85d91f32767d315485bbe0452a151","modified":1599535400814},{"_id":"source/_posts/img/1578470217523.png","hash":"c6d8e26c793c30f8d508ea36876f5d7ef588a727","modified":1599535400817},{"_id":"source/_posts/img/1578470502893.png","hash":"eb566054529af469630fb7b57683a941d591ed3c","modified":1599535400824},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"a75ead28e6a1fab2a006cc7332ca2d2e868ce8e1","modified":1600831362967},{"_id":"source/_posts/img/1572531014589.png","hash":"058d5e76206a1e3d486cf3067f8433be80f72cef","modified":1599535400724},{"_id":"source/_posts/img/1578468782581.png","hash":"258b7eb8ee60e16fc5974e9f4ee9844df3bc4c8e","modified":1599535400808},{"_id":"public/search.xml","hash":"ff2978ee30a478604cc76b122c129b70329f16c4","modified":1649500865571},{"_id":"public/about/index.html","hash":"07e6e328a77fc02a49b53e44c0e2d431a084c7f7","modified":1649500865822},{"_id":"public/2020/10/15/GEA-P4/index.html","hash":"f936533f9154e2a6fbb7ae265365965e5daee5fa","modified":1649500865828},{"_id":"public/2020/10/15/GEA-P3/index.html","hash":"e34867c967ea423fd4751c41c00455431436744c","modified":1649500865829},{"_id":"public/2020/10/15/GEA-P2/index.html","hash":"7f6f014114be4dc4224febc97bd970825954249b","modified":1649500865829},{"_id":"public/2020/09/27/计算机图形学编程笔记2/index.html","hash":"92d8562c3e4bdfbef55aa4a2d1037a3e1690d110","modified":1649500865829},{"_id":"public/2020/09/27/Python 杂项/index.html","hash":"ea513ee49a325f2d332c03c691721b0a1461d7ea","modified":1649500865829},{"_id":"public/2020/09/22/Addressable打包流程/index.html","hash":"9d40816becdd5765bc39589485410c42e58a1663","modified":1649500865829},{"_id":"public/2020/09/09/IT-English/index.html","hash":"a91d67d33108e8ec50bfcdb5c8d2ae885497f756","modified":1649500865829},{"_id":"public/2020/09/09/GEA-P1/index.html","hash":"dabab7a6896d900b0a58e778c2f224005c6011a9","modified":1649500865829},{"_id":"public/2020/09/08/数据结构-数组链表结构/index.html","hash":"d299b2cf09519499aa7c93ec2ffcb757e0d9f307","modified":1649500865829},{"_id":"public/2020/09/08/排序算法/index.html","hash":"0be47dfdb46adf7fc3e665ff5819ffe6d3a1d0ae","modified":1649500865829},{"_id":"public/2020/09/08/性能优化相关/index.html","hash":"e4e32957896f875b82a90adbb57a225f57014e7e","modified":1649500865829},{"_id":"public/2020/09/08/最新Addressable资源打包与加载框架/index.html","hash":"845f4d7bc8ac813255abbe5794a3739da012b2a1","modified":1649500865830},{"_id":"public/2020/09/08/数据结构-笔记1/index.html","hash":"588be62a012d02284e5c198210914780c0430945","modified":1649500865830},{"_id":"public/2020/09/08/数据结构在Charp/index.html","hash":"28d75758155014c2afc9ea698118c450662c8f9c","modified":1649500865830},{"_id":"public/2020/09/08/深度优先与广度优先算法/index.html","hash":"39ab89b5c514e88503c777b3dbed373df5aa385c","modified":1649500865830},{"_id":"public/2020/09/08/计算机图形学编程笔记1/index.html","hash":"4fab6e11be4baddeadf7936a232e19c2e1f2add6","modified":1649500865830},{"_id":"public/2020/09/08/线性代数-笔记1/index.html","hash":"fbacf464f2f66c3fe6f4e3455e915283975fe67b","modified":1649500865830},{"_id":"public/2020/09/08/递归算法/index.html","hash":"5aeead32702e7c0d49a632713eb9bf995d130162","modified":1649500865830},{"_id":"public/2020/09/08/客户端更换Git指南/index.html","hash":"b566ab8bfc45a4a2b23bbb53aab58a520c5b7d35","modified":1649500865830},{"_id":"public/2020/09/08/天天生鲜项目实例/index.html","hash":"5a09f48d726366bf802b6de5372c6c539ef43fca","modified":1649500865830},{"_id":"public/2020/09/08/天天生鲜项目实例P2/index.html","hash":"efda662fe6c053688f9194b541c53e6369d92e1d","modified":1649500865830},{"_id":"public/2020/09/08/开言_Bargaining in the market/index.html","hash":"3034aab0c85aab4563efee0d96f5d91bcb091b4a","modified":1649500865830},{"_id":"public/2020/09/08/开言_Happy Hour Drinks with Coworks/index.html","hash":"49b1215bacad4f15efee044f75001a597e9af027","modified":1649500865830},{"_id":"public/2020/09/08/开言- To tip or not to tip/index.html","hash":"0c72b3c66c26fb3a3a7fc8f509b22c3e2db5016b","modified":1649500865830},{"_id":"public/2020/09/08/常用单词学习/index.html","hash":"6e80e60276f1e2fef6dc9a7b6b98d2dd54456e81","modified":1649500865831},{"_id":"public/2020/09/08/开言体验营 - Day1/index.html","hash":"21876937ae94a0383c1f0ed36255876eab66af3f","modified":1649500865831},{"_id":"public/2020/09/08/开言体验营 - Day4/index.html","hash":"ba06289935fb4558330d39d46f89b7e99aef5597","modified":1649500865831},{"_id":"public/2020/09/08/开言体验营 - Day2/index.html","hash":"30ba3668bb33272a28c6e50f2d313ec4cdb4152e","modified":1649500865831},{"_id":"public/2020/09/08/开言体验营 - Day5/index.html","hash":"1ceda6301489e4e4a491b4a37d585a217ceda92c","modified":1649500865831},{"_id":"public/2020/09/08/开言学习笔记1/index.html","hash":"be4328fe6cb727641b8e9f29f29b181524c8a450","modified":1649500865831},{"_id":"public/2020/09/08/python_2/index.html","hash":"db4bbf858bc0e44d0f634f030de473211b8454e2","modified":1649500865831},{"_id":"public/2020/09/08/python_1/index.html","hash":"72c9a23ef1c60cc5088375350dab1d6fa3556e2e","modified":1649500865831},{"_id":"public/2020/09/08/动态规划/index.html","hash":"ac597db0fd9843acac1242b52f1ac8802eb08b0f","modified":1649500865831},{"_id":"public/2020/09/08/内存管理/index.html","hash":"ebac0f94d3ed0e540c296b5c9cc6383cc6ccce37","modified":1649500865831},{"_id":"public/2020/09/08/力扣刷题顺序/index.html","hash":"179881a246a8f51dda850b8ab28e8f0f84eb79db","modified":1649500865831},{"_id":"public/2020/09/08/四元数旋转函数学习/index.html","hash":"b6e01ddb360f6f39c14491990163ff3dd804284d","modified":1649500865831},{"_id":"public/2020/09/08/UI系统制作流程/index.html","hash":"aa3a1bb49a46a91d321213b65a4d7ae936038ef9","modified":1649500865831},{"_id":"public/2020/09/08/VS Code最佳插件/index.html","hash":"190cb093eedb5ce64de1ec184922ea1397d11312","modified":1649500865832},{"_id":"public/2020/09/08/hello-world/index.html","hash":"d4feb0ce346eed45c9163a317d2eec6f402d8413","modified":1649500865832},{"_id":"public/2020/09/08/LWRP官方说明/index.html","hash":"3b3d01e3dffdd007fe29a6e1a7896a4d42db0c13","modified":1649500865832},{"_id":"public/2020/09/08/Linux与window常用指令/index.html","hash":"eeeb416b8416e947a7fafd13e177382282bf958d","modified":1649500865832},{"_id":"public/2020/09/08/Jenkins打包事项/index.html","hash":"9554fa9c254205e4ed05452e92a8d21e70ae30d4","modified":1649500865832},{"_id":"public/2020/09/08/Python Core Programming Note 3/index.html","hash":"14bb8bccf0e5caa12247154afbf788c133875f49","modified":1649500865832},{"_id":"public/2020/09/08/Python_3/index.html","hash":"918e9fc8f9243203cdc0d91de6d8d97794714daf","modified":1649500865832},{"_id":"public/2020/09/08/Smargit  简单使用说明/index.html","hash":"439c70f683235c838870988c1be48f4576c7920f","modified":1649500865832},{"_id":"public/2020/09/08/Shader Variant/index.html","hash":"bcd20566c6d9411777f43af36a34ae9cc50ef02d","modified":1649500865832},{"_id":"public/2020/09/08/C++ 复习1/index.html","hash":"593310e78adfb103ce5c372ee7debd4af3086569","modified":1649500865832},{"_id":"public/2020/09/08/DOTS-事件/index.html","hash":"63c430419cd1d310032282c3981ef40068577966","modified":1649500865833},{"_id":"public/2020/09/08/Centos 部署 Django/index.html","hash":"bafd361212bc9bd16a3cada462ff23b6fe776681","modified":1649500865833},{"_id":"public/2020/09/08/C与C++开源项目学习/index.html","hash":"5941f4af9bd756729004767f169fedee0d5bcbe7","modified":1649500865833},{"_id":"public/2020/09/08/Conda 常用操作/index.html","hash":"6b44156accb25ec9ddf6d71241d42e3ea70530f3","modified":1649500865833},{"_id":"public/2020/09/08/DrawCall优化/index.html","hash":"b387d7e078a0721cfcf7c5040b4dfa51b49bddf5","modified":1649500865833},{"_id":"public/2020/09/08/Django 实例 Web Application/index.html","hash":"a1e4c1e4e6b3680d2e440939ea2a8bfb53953185","modified":1649500865833},{"_id":"public/2020/09/08/Django  初步构建/index.html","hash":"3b01587cd8bae7e27368cd35cab904e44911d9ff","modified":1649500865833},{"_id":"public/2020/09/08/Django  初始测试/index.html","hash":"681baec418c69172d2acad8a73ca74abb8f40baf","modified":1649500865833},{"_id":"public/2020/09/08/ECS框架的思考/index.html","hash":"f47a5bfb4c1cec60e1879a7269cf30680cfe6741","modified":1649500865833},{"_id":"public/2020/09/08/ECS-研究学习/index.html","hash":"9f8ee6af574eeb439cd8c547481ed404de67bc69","modified":1649500865833},{"_id":"public/2020/09/08/Effective C++学习记录/index.html","hash":"0ce3f9d1f8829d48b40b1b3e3eeab7ef03f804bf","modified":1649500865833},{"_id":"public/archives/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865833},{"_id":"public/archives/page/2/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865833},{"_id":"public/archives/page/3/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/page/4/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/page/5/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/page/6/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/page/7/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2020/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2020/page/2/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2020/page/3/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2020/page/4/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2020/page/5/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2020/page/6/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2020/page/7/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2020/09/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/archives/2020/09/page/2/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/archives/2020/09/page/3/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/archives/2020/09/page/4/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/archives/2020/09/page/5/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/archives/2020/09/page/6/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/archives/2020/10/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/categories/CPlusPlus/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/Unity学习/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/工作相关/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/Unity/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/Python/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/Python/page/2/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/IT阅读/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/公司/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/杂项资料/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/算法/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/英语学习/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/数据结构/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"public/categories/图形学/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/categories/数学/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/page/2/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/page/3/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/page/4/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/page/5/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/page/6/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/page/7/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/tags/C/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/tags/Unity学习/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/tags/CI/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/tags/Python/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/tags/Python/page/2/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"public/tags/Note/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/Note/page/2/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/Note/page/3/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/Django/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/Conda/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/实例/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/Game/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/English/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/linux/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/指令/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/Core-Programming/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/Jenkins/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/Git/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/tags/图形学/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865848},{"_id":"public/2020/10/28/力扣刷题记录/index.html","hash":"59f6ac20ec3dd8a48ff2b395925f75661ead2064","modified":1603853311846},{"_id":"public/2020/09/08/Addressable 研究/index.html","hash":"4ac0b5f831748e97fc974aa1aa49a5fb171a4229","modified":1649500865829},{"_id":"public/2020/09/08/算法课程笔记1/index.html","hash":"fc395cc10ac0a31dc02a4fd7c3141c760d37902a","modified":1649500865830},{"_id":"public/2020/09/08/python_4/index.html","hash":"c6cf63aa02d5bd81c8223cd8146c9bf47009cab0","modified":1649500865831},{"_id":"public/2020/09/08/Twisted  介绍/index.html","hash":"cd2d87e34cb07bd49e09c8865c32b8bfb1ab589f","modified":1649500865832},{"_id":"public/2020/09/08/Python Core Programming Note 1/index.html","hash":"716b73e4a5a3f7e9148bbb0094089531d14de2de","modified":1649500865832},{"_id":"public/2020/09/08/Python Core Programming Note 2/index.html","hash":"bcd69fbd2f89eb9720fbbc03db7680e8f917495d","modified":1649500865832},{"_id":"public/archives/2020/09/page/7/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/img/alipay.jpg","hash":"0954774b67b25148c9bac76613557e6b0ed84c83","modified":1603852681233},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1603852681233},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1603852681233},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1603852681234},{"_id":"public/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1603852681234},{"_id":"public/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1603852681234},{"_id":"public/img/weixin.jpg","hash":"5fe79b9fc9124a67b3f1276c04124900f1226a2c","modified":1603852681234},{"_id":"public/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1603852681234},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1603852681234},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1603852681234},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1603852681234},{"_id":"public/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1603852681234},{"_id":"public/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1603852681234},{"_id":"public/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1603852681234},{"_id":"public/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1603852681234},{"_id":"public/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1603852681234},{"_id":"public/css/mobile.css","hash":"5998f6fc27998596beb1e40e4bc3c43be2ed764c","modified":1603852682511},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1603852682511},{"_id":"public/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1603852682514},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1603852682515},{"_id":"public/css/hl_theme/atom-light.css","hash":"d31edb9816dae6b01410028bceb91757a962f780","modified":1603852682515},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1603852682515},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1603852682515},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1603852682515},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1603852682515},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1603852682515},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1603852682515},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1603852682515},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1603852682515},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1603852682515},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1603852682515},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1603852682515},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1603852682515},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1603852682515},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1603852682515},{"_id":"public/css/style.css","hash":"2dc2f3d794d4102d3ce4c807d41903277e4585e7","modified":1603852682515},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1603852682515},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1603852682515},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1603852682515},{"_id":"public/js/script.js","hash":"03fc06177b47fd6bac7ae393f9712c726272467b","modified":1603852682515},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1603852682515},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1603852682515},{"_id":"public/js/gitalk.js","hash":"a75ead28e6a1fab2a006cc7332ca2d2e868ce8e1","modified":1603852682524},{"_id":"source/_posts/img/1603943631534.png","hash":"a82618d37c78ff685b31d6e79c0302eb12873983","modified":1603977898129},{"_id":"public/2020/10/29/力扣刷题记录/index.html","hash":"5afa471c4540826a2c66b0619e93d44b4553e4ed","modified":1603977918754},{"_id":"source/_posts/img/1604063667003.png","hash":"02082b99bf499a395f58f689ce6ebc659f38ac7d","modified":1604064291186},{"_id":"public/2020/10/30/力扣刷题记录/index.html","hash":"4e6e05f54352e79803067a2383b9a7a9fdce7505","modified":1604064311044},{"_id":"public/2020/10/31/力扣刷题记录/index.html","hash":"68a7048a1746808b05002d19bd6b6c53e3d38825","modified":1604137414926},{"_id":"source/_posts/img/1604578953107.png","hash":"8841fd7406e31d50905ebbc0a9d0e772231f30c5","modified":1604579178541},{"_id":"public/2020/11/05/力扣刷题记录/index.html","hash":"71660b7b263de0e56df5c557767fae4168aa6942","modified":1649500865828},{"_id":"public/archives/2020/11/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"source/_posts/Playable动画系统研究.md","hash":"bfe3d8ac8a515028969fb5d900f217c7b8f5e18b","modified":1605695428606},{"_id":"source/_posts/腾讯云开发-使用Unity开发服务器逻辑并自动部署.md","hash":"baccd621079a46c58e165a4ae9e2738962c75c0d","modified":1605706325383},{"_id":"source/_posts/img/1605701291767.png","hash":"2f40fe19bbdf81bbdef7a24d13c47254fef6b318","modified":1605706325381},{"_id":"source/_posts/img/1605701305959.png","hash":"f787516e0bd7255ae2a2c5554907c53e3c12409c","modified":1605706325382},{"_id":"source/_posts/img/1605701442216.png","hash":"f58bd110ae2d664a53ace6269271ce75c785be50","modified":1605706325383},{"_id":"public/2020/11/18/腾讯云开发-使用Unity开发服务器逻辑并自动部署/index.html","hash":"9c0267df611daaed11c7298a0ac7b13af39fd3d9","modified":1649500865828},{"_id":"public/2020/11/18/Playable动画系统研究/index.html","hash":"a3e7790f0bb6bcc5a8c9defdd7fe3f71303e5c41","modified":1649500865828},{"_id":"source/_posts/img/1605700406892.png","hash":"2b2acc1dedb47b677f4caea265bf44519b840866","modified":1605706912001},{"_id":"source/_posts/img/1605700473654.png","hash":"8bc4ef1b2ad6a13b270447b322f6cfff3b744a48","modified":1605706912004},{"_id":"source/_posts/C#编译器.md","hash":"678c9e9c6599b6259721724ce369412c2e787171","modified":1608265518340},{"_id":"source/_posts/ECSSamples研究.md","hash":"f256423607c1f4f69ab03ef6d254d47c174ebee4","modified":1608265518340},{"_id":"source/_posts/Unity内存剖析.md","hash":"2d0023fcfe48cbece4cfd7165c5a11bb35723564","modified":1608265518340},{"_id":"source/_posts/骨骼蒙皮动画(SkinnedMesh)的原理解析.md","hash":"c9fa9fbc51565b3e367f6db9a7ce6551ca41b429","modified":1608265518347},{"_id":"source/_posts/img/1605751556990.png","hash":"986e7cf67b57036bb29a2c62e3ca8ca0eca2a749","modified":1608265518341},{"_id":"source/_posts/img/1605751595361.png","hash":"ee2d2c71ea15676e1e7e9ca4f68f5663e5d52909","modified":1608265518342},{"_id":"source/_posts/img/1606017719921.png","hash":"24ad653270910fbfe772941ee31473107e600b84","modified":1608265518344},{"_id":"source/_posts/img/1606017848540.png","hash":"73dd5ed2366277d87db41c79b2cfde7b6d24c4ec","modified":1608265518346},{"_id":"source/_posts/img/1606017767279.png","hash":"bb7af5729edc3fe51b596a434153e90ee0812b0c","modified":1608265518346},{"_id":"public/2020/12/18/骨骼蒙皮动画(SkinnedMesh)的原理解析/index.html","hash":"53dcd9851b32bbd74197140725e19e721afc44dd","modified":1649500865828},{"_id":"public/2020/12/18/C#编译器/index.html","hash":"7d289b791f0329174d5c666da101ffc42fb47926","modified":1608695131967},{"_id":"public/2020/12/18/ECSSamples研究/index.html","hash":"795a33b7c44c4e947377254ded6c7fd9b4b2bb0e","modified":1649500865828},{"_id":"public/2020/12/18/Unity内存剖析/index.html","hash":"7dacc186053bbf1c2cf4c7870e38f7e1ec7589d6","modified":1649500865828},{"_id":"public/archives/page/8/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2020/page/8/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/archives/2020/12/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/page/8/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"source/_posts/基于物理的渲染-PBR.md","hash":"69f8eb20248f1afcaa144bf3eb83768cc29100e4","modified":1608610920823},{"_id":"source/_posts/img/1608604177769.png","hash":"2ba9dbb0a982f4ae40985963e54ba209c5f29003","modified":1608610920815},{"_id":"source/_posts/img/1608604253600.png","hash":"0bd11b286b642c35e3c47a40f21ee859c03122a3","modified":1608610920815},{"_id":"source/_posts/img/1608604419905.png","hash":"d42c345553b5268b1fc21e4a373f3e56869ceba4","modified":1608610920816},{"_id":"source/_posts/img/1608607797277.png","hash":"b716c9a2f2dda5470292238bad0d72f1fd457233","modified":1608610920821},{"_id":"source/_posts/img/1608608155043.png","hash":"9e4a02852fea81cd7fbcc1b3b41521fcd335d239","modified":1608610920822},{"_id":"source/_posts/img/1608608340955.png","hash":"81f449df7746a0534d09df401175618395499e29","modified":1608610920822},{"_id":"source/_posts/img/1608609564859.png","hash":"3d9ee82fa5942b269d7d46ceb58af7cfacf116c4","modified":1608610920822},{"_id":"source/_posts/img/1608609585831.png","hash":"93325a4cc5e9a3d1fef00990ba57e17bd40f9720","modified":1608610920822},{"_id":"source/_posts/img/1608610266103.png","hash":"05561e54abc2c593fb2cd995025c5bffef39facd","modified":1608610920823},{"_id":"source/_posts/img/1608610379037.png","hash":"60b605c5d7956a394b12ab86089bb073e97fe905","modified":1608610920823},{"_id":"source/_posts/img/1608608044790.png","hash":"ee58062656a930cd3a7bfcc897b0003dc1fee106","modified":1608610920821},{"_id":"source/_posts/img/1608607682403.png","hash":"e4ec166b7d0ddeb8d964316de0252161c92f4967","modified":1608610920821},{"_id":"source/_posts/img/1608607466758.png","hash":"2d0139860c2984d285612e4b92b4a2b7eecc7054","modified":1608610920820},{"_id":"source/_posts/img/1608606276958.png","hash":"7fb9a5d42718b175a7a4ae46563ee665f42355f7","modified":1608610920819},{"_id":"public/2020/12/22/基于物理的渲染-PBR/index.html","hash":"254971e969da99cc15d4b92262e6d517fd47af00","modified":1649500865828},{"_id":"source/_posts/C# Dictionary.md","hash":"5ba5a786a72fabba7b1ea56f2d6ac0e95cfa0361","modified":1608695106498},{"_id":"source/_posts/C# GC.md","hash":"e3bef497fafe00ad664d90f67e9523cab8d8728c","modified":1608695106499},{"_id":"source/_posts/Lua源码研究.md","hash":"59e8f0be1d1751d226303e76aa61d5b52ce7c55a","modified":1608695106499},{"_id":"source/_posts/Lua源码编译流程.md","hash":"3f3735a02568c04302ba7306694964466ebb5f68","modified":1608695106499},{"_id":"source/_posts/img/1608690535258.png","hash":"2883ee4d16f3be8c13b1417ed0410e5e232e68fe","modified":1608695106499},{"_id":"source/_posts/img/1608693746908.png","hash":"5c51e0854873a172fc1c2170049a502753684faa","modified":1608695106501},{"_id":"source/_posts/img/1608693760326.png","hash":"50ad8dfe4142a1331d7ee18c482a3099ca7bb387","modified":1608695106502},{"_id":"source/_posts/img/1608693801943.png","hash":"e501b3fb05f33cd9c97d56ca809346f8d646230b","modified":1608695106503},{"_id":"source/_posts/img/1608693812822.png","hash":"bbbd0b4a6735b6b492e426621485c6e26a119890","modified":1608695106503},{"_id":"source/_posts/img/1608693331816.png","hash":"5438ae3628b18eac2663f19d56094ce46f7d731b","modified":1608695106500},{"_id":"source/_posts/img/1608694646427.png","hash":"9660c853671357f5b690b2d4e3b99ef617882bb4","modified":1608695106505},{"_id":"source/_posts/img/1608694671258.png","hash":"0746d7f87873aa3252f8527b66128bbf20e6000a","modified":1608695106506},{"_id":"public/2020/12/23/C# GC/index.html","hash":"717ef01898d3ca7e218cf6f9a3d92182a5a0dbd5","modified":1608695131992},{"_id":"public/2020/12/23/Lua源码研究/index.html","hash":"e5a0a2b5d47a4d47933238a868ccd31a814bbeac","modified":1649500865827},{"_id":"public/2020/12/23/Lua源码编译流程/index.html","hash":"26d2d01e539b8b4dc1ca3560453ed8d09e1c4ff9","modified":1649500865828},{"_id":"public/2020/12/23/C# Dictionary/index.html","hash":"8bc5111abed5728b46320bbde6ee5aa5588c1e6f","modified":1608695131993},{"_id":"public/categories/Unity/page/2/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"source/_posts/CSHARP的Dictionary.md","hash":"181cc562fea6d955f05b82f220a64c1f778ee662","modified":1608705998548},{"_id":"source/_posts/CSHARP的GC.md","hash":"be241da9dad4a3d527139f7dd3316bc702d3f08e","modified":1608705998549},{"_id":"source/_posts/CSHARP的编译器.md","hash":"acf003dfaf6a596ae7d1b456132d58adb3aa272a","modified":1608705998549},{"_id":"source/_posts/img/1605751484739.png","hash":"47304710e876e140ff874b36d54583c200a641b1","modified":1608705998550},{"_id":"source/_posts/img/1605751344921.png","hash":"0ae32cd3d78ba2f004a3c436830be728e9201264","modified":1608705998549},{"_id":"public/2020/12/23/CSHARP的GC/index.html","hash":"13cccceff7116c72782fb0fa4fff1d59eefbc507","modified":1649500865826},{"_id":"public/2020/12/23/CSHARP的编译器/index.html","hash":"b084e8a96f67d1910c3bcb7f0744dee80e19d7cc","modified":1649500865826},{"_id":"public/2020/12/23/CSHARP的Dictionary/index.html","hash":"1a8e1c9097950bfa4d06c07f273066a289674521","modified":1649500865826},{"_id":"source/_posts/CSHARP的内置引用类型.md","hash":"48a0ae554086ed9e25e65b89eb62e1c2aac4c0a8","modified":1608974208221},{"_id":"source/_posts/LUA与CSHARP交互.md","hash":"a220879d2352865123ce52d927c09237b9261f60","modified":1608974208221},{"_id":"source/_posts/贝塞尔曲线.md","hash":"7ec629b0d53ae68547b5947aca36be94fc2303c3","modified":1608974208222},{"_id":"source/_posts/img/1608707782744.png","hash":"47df3a4ba369861d93147dc05278aace6b1f54c5","modified":1608974208221},{"_id":"source/_posts/img/1608804894728.png","hash":"01b4df59796200fd2ef0f3cb9e5bb4400bff95f1","modified":1608974208222},{"_id":"source/_posts/img/1608709965913.png","hash":"47c899b84819ec5bbea7893f7977c6a15c99bb54","modified":1608974208222},{"_id":"public/2020/12/26/贝塞尔曲线/index.html","hash":"df3b4aa5543b37f1ec4e22a2843086c48d7d93f5","modified":1649500865825},{"_id":"public/2020/12/26/CSHARP的内置引用类型/index.html","hash":"66b8cbf003c0f7e6b24900b0a72e2edd08f22f55","modified":1649500865826},{"_id":"public/2020/12/26/LUA与CSHARP交互/index.html","hash":"52f56995687149422bed8c97ad6028f1fe1ed1b5","modified":1649500865826},{"_id":"public/archives/2020/12/page/2/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"source/_posts/img/1608803433152.png","hash":"5fe426b5c2022a63463f12bf955ad1f2aeb60693","modified":1608976694893},{"_id":"source/_posts/img/1608803474166.png","hash":"d7a800c8f791f2a7652ccea83ae45245af3ea961","modified":1608976694894},{"_id":"source/_posts/img/1608803453009.png","hash":"91c3dfec858b63f9a4039b2ce58adda9f645b744","modified":1608976694894},{"_id":"source/_posts/Python知识汇总1.md","hash":"bfff3eeba881f6543d163c7a8d7533c4e4fd059d","modified":1614311762088},{"_id":"source/_posts/img/2021/19.png","hash":"b572f751e2cb24cc1491137aa3e28abf3fef182d","modified":1614311762104},{"_id":"source/_posts/img/2021/18.png","hash":"4bb29bbae4b0fd9cf785463858a91944dbf90c1e","modified":1614311762104},{"_id":"source/_posts/img/2021/3.png","hash":"4f80d17e531eed2aa4d086c61c750e15a5be99e5","modified":1614311762110},{"_id":"source/_posts/img/2021/13.png","hash":"ad4ffa8624ed7ad5d6069207a5fd17079816a8ad","modified":1614311762096},{"_id":"source/_posts/img/2021/12.png","hash":"3ffd2a72fc8967b435535df18a9215a97091c49e","modified":1614311762096},{"_id":"source/_posts/img/2021/17.png","hash":"eb6dcf63c0a57f3f67a491319144f17b0d88839f","modified":1614311762104},{"_id":"source/_posts/img/2021/14.png","hash":"19441df876a46cecf2470f0d74875e9795766bd4","modified":1614311762097},{"_id":"source/_posts/img/2021/4.png","hash":"30c93e89c56a4b1f14ac9b79a472cc9885a8dc8d","modified":1614311762111},{"_id":"source/_posts/img/2021/2.png","hash":"3868e6a420bec883a1774b1f5a2c09ae9e8cff6a","modified":1614311762104},{"_id":"source/_posts/img/2021/20.png","hash":"16d66a938eceab9fce8e4247eeaf886badf7a6d6","modified":1614311762106},{"_id":"source/_posts/img/2021/15.png","hash":"bf4618df544532e3780a58f874bed1e05aec21d6","modified":1614311762099},{"_id":"source/_posts/img/2021/9.png","hash":"3b4c3b2958b3640b59d2979cc23497b42e54e850","modified":1614311762135},{"_id":"source/_posts/img/2021/1.png","hash":"1309ac5560d2205f1cbd6772bd131f511132d0cc","modified":1614311762090},{"_id":"source/_posts/img/2021/7.png","hash":"32d90752c37fefe73ccae8acf9d0a1f9e8c0fd69","modified":1614311762130},{"_id":"source/_posts/img/2021/10.png","hash":"b1908571c433a857f69eda6c8aaaaf0dc7a36457","modified":1614311762093},{"_id":"source/_posts/img/2021/11.png","hash":"280a6b5da33d5da029227d3350c59077f7bc2c0b","modified":1614311762095},{"_id":"source/_posts/img/2021/8.png","hash":"40b97be5ff6f545f205a4c5abe0352987b1a2dc3","modified":1614311762133},{"_id":"source/_posts/img/2021/16.png","hash":"df086faca3a84846a7a5c54bced0cfca8c82b9bc","modified":1614311762103},{"_id":"source/_posts/img/2021/5.png","hash":"d2dfbfb56ff2a6a355250498cb29d75807195fa8","modified":1614311762115},{"_id":"source/_posts/img/2021/6.png","hash":"cdb9a94e2175ca777df904ac88abfe81cff672de","modified":1614311762128},{"_id":"source/_posts/img/2021/21.png","hash":"9bcecfffc023cee417274c515fc6eb3bce5522be","modified":1614311762110},{"_id":"public/archives/2021/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/archives/2021/02/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/2021/02/26/Python知识汇总1/index.html","hash":"a234709aab87c9836e89451da35aabf7e961edce","modified":1649500865825},{"_id":"source/_posts/Python源码剖析-Note1.md","hash":"020cb150abf80d21fd432aceb64fc7a4cc1d274d","modified":1622776942100},{"_id":"public/2021/06/04/Python源码剖析-Note1/index.html","hash":"f1a37ee0977747100ea2a3c75afb8c5ddab63005","modified":1649500865825},{"_id":"public/archives/page/9/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865834},{"_id":"public/archives/2021/06/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865835},{"_id":"public/page/9/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865847},{"_id":"source/_posts/Python源码剖析-Note2.md","hash":"2b1bb59a68677d46db69a28e1d3772a77f80d77a","modified":1627811023427},{"_id":"source/_posts/img/image-20210429161214642.png","hash":"50035669ffb5327e96f965e08162870dde14f5bc","modified":1627811023427},{"_id":"source/_posts/img/image-20210801173440707.png","hash":"72ebdbd3ddb5073db29933036a70ba9425029276","modified":1627811023429},{"_id":"source/_posts/img/image-20210801173427803.png","hash":"7388fe523b32a83cf5edbde8152d4bca2a0e75ef","modified":1627811023429},{"_id":"source/_posts/img/image-20210730174828153.png","hash":"4bc1e12ea73963beee94ae86091cfd6b3c72d932","modified":1627811023428},{"_id":"public/2021/08/01/Python源码剖析-Note2/index.html","hash":"71a2628a15459b04fab4ba6b5e45c861c8ae6d7d","modified":1649500865825},{"_id":"public/archives/2021/08/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865845},{"_id":"source/_posts/python_5.md","hash":"500ef5482a8aa98d0b9fa464e585b553dfe9c8fc","modified":1649499811861},{"_id":"public/2022/04/09/python_5/index.html","hash":"798ccbe47c6ee42574a7ec6971c8d2353c84f480","modified":1649500865822},{"_id":"public/archives/2022/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865845},{"_id":"public/archives/2022/04/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865846},{"_id":"source/_posts/UE5初入.md","hash":"a5ccaebd277e26a1e558e39be15a1b9963edf8c6","modified":1649500813145},{"_id":"public/2022/04/09/UE5初入/index.html","hash":"89adb7e769773208da3903221eb9d42e5ef32628","modified":1649500865854},{"_id":"public/categories/UE/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865854},{"_id":"public/tags/Note/page/4/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865854},{"_id":"public/tags/UE/index.html","hash":"071a4fc86ed523070bd44a5838ad6250445e40e6","modified":1649500865854}],"Category":[{"name":"CPlusPlus","_id":"ckgssh0y000034wf0a6643620"},{"name":"Unity学习","_id":"ckgssh0y800084wf0093rtsfa"},{"name":"工作相关","_id":"ckgssh0yh000e4wf09m2ax3g3"},{"name":"Unity","_id":"ckgssh0yl000l4wf0bh0atetq"},{"name":"Python","_id":"ckgssh0yo000s4wf0nqlti2ys"},{"name":"IT阅读","_id":"ckgssh106001v4wf0lk2yiedm"},{"name":"公司","_id":"ckgssh10u002z4wf0n4s5qh93"},{"name":"杂项资料","_id":"ckgssh118003f4wf06go56f39"},{"name":"算法","_id":"ckgssh11f003o4wf0dtlbkgub"},{"name":"英语学习","_id":"ckgssh12b004d4wf0fckbshoa"},{"name":"数据结构","_id":"ckgssh12z00574wf01vzqx66x"},{"name":"图形学","_id":"ckgssh13t00614wf07xhieukd"},{"name":"数学","_id":"ckgssh13z006a4wf0rvc4llea"},{"name":"UE","_id":"cl1rq81fg00012kf02owy2kn9"}],"Data":[],"Page":[{"title":"about","date":"2019-10-06T01:42:53.000Z","_content":"# 这是关于我，有空再加吧\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-10-06 09:42:53\n---\n# 这是关于我，有空再加吧\n","updated":"2020-09-08T03:23:20.891Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckgssh0xv00014wf0m33dxlu3","content":"<h1 id=\"这是关于我，有空再加吧\"><a href=\"#这是关于我，有空再加吧\" class=\"headerlink\" title=\"这是关于我，有空再加吧\"></a>这是关于我，有空再加吧</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"这是关于我，有空再加吧\"><a href=\"#这是关于我，有空再加吧\" class=\"headerlink\" title=\"这是关于我，有空再加吧\"></a>这是关于我，有空再加吧</h1>"}],"Post":[{"title":"C++ 复习1","_content":"\n#### 关于无符号与有符号数\n* 无符号不能为负数\n* 循环如果使用无符号计数，以>=为条件将导致死循环\n\n#### C++ 11的初始化方法\n```c++\nint a{0};\n```\n\n#### extern的使用\n* 对于希望分离成多个文件独立编译的变量，使用extern公开出去\n* 声明一个变量并extern出去，但注意不要声明+定义一起，否则失去了extern作用了\n* extern变更的声明可以在多个文件，但定义只能在一个文件\n\n#### 复合类型：引用与指针\n* 引用类型一旦初始化就与初始对象绑定在一起，不可以更换绑定。且必须在定义时赋值。\n* 引用类型不可以与值绑定\n* 指针可以不在声明时初始化，指针是一个对象\n* 指针赋值之间类型必须相同\n* C++ 11的标准提供了nullptr为指针初始化为空。 引用cstdlib标准库中，还可以用NULL为指针初始化\n* 任何非0的指针都为true.\n* void＊指针，可用于存放任意对象的地址，但不能直接操作指针所指的对象，可理解为操作内存空间\n\n#### 理解复合类型\n* 对于一个变量，要理解其类型，最简单的办法从右向左阅读变量的定义，离变量名最近的对变量有最直接的影响。\n```c++\nint i = 42;\nint *p;\nint *&r = p; //r是对指针p的一个引用类型变量\n\nr = &i; //给r赋值，就是给p的地址赋值，因此此时 p的值指向了i的地址\n*r = 0;//i的值也为0\n```\n\n* const 限定符， 声明了const后就不能改变其值，但可以使用非常量来初始化const值\n* const 在多文件中的使用：在一个文件中用extern声明同时定义，其他文件中仅extern声明即可。\n* const声明的任何类型都不可以改值！\n* const指针， 即指针指向的地址是不能改变的\n```c++\nint *errNumb = 0;\nint *const curErr = &errNumb;//curErr指针的指向的地址不能改变\nconst double pi = 3.14;\nconst double *const pip = &pi;// pip指向常量pi的常量指针\n```\n* 顶层const与底层const:　从变量名的左侧开始算，底层到高层。最右侧的为顶层const, 指针符左侧为底层const.\n* 拷贝的操作必须两对象都具有相同的底层const\n* 一般来说非常量可转换为常量。\n\n#### 常量表达式 constexpr\n具有以下两个条件的可称为常量表达式：\n1. 表达式左侧的变量需定义为常量\n2. 表达式右侧的值是不用到运行时就能确定的。\n\nC++ 11的标准规定，可以使用constexpr 让编译器验证是否为常量表达式，也可定义函数为constexpr 这样就可以在常量表达式中使用。\n```c++\nconstexpr int mf =20;\nconstexpr int limit = mf+1;\nconstexpr int sz = size(); //size()一定要用constexpr声明。\n```\n\n* constexpr 定义指针，表达此指针为常量指针，因此根据常量指针的特点，必须进行初始化。\n* 注意constexpr定义后的指针就为常量指针，即此const为指针对象的顶层const\n```c++\nconst int *p = nullptr;\nconstexpr int *q = nullptr;\n//p与q是非常不同的，p是一个指针，指向常量。 q是一个常量指针，其地址不能改。\n```\n\n#### 类型别名\n使用typedef 为类型起一个别名：\n```c++\ntypedef int ss;\n```\n\n* C++ 11 新标准可使用using语法替换typedef\n```c++\nusing ss = int;\n```\n* 特别注意当有const在最左侧声明时，带指针的类型别名解释不能直接替换后来翻译，如：\n```c++\ntypedef char *pstring; //类型别名为指向char的指针\nconst pstring a;//a是指向char的常量指针\n//const char* a;//a是指向const char的指针，与const pstring a表示不同！\n\n```\n\n#### Auto类型说明符 (C++11)\n\n不需要强制为某个变量指定类型的声明方式\n* 注意： auto一般会忽略掉顶层的const，当auto引用时！才会保留const\n* auto多变量声明类型必须一样\n```c++\nint i = 0;\nconst int ci = i;\n//以下错误，因为n和p的类型不同，n是整型指针，ci是整型常量指针。\nauto &n = i, *p = &ci;\n```\n\n#### decltype类型说明符（C++11）\n\n使用decltype可取出表达式或变量的类型，以此类型再声明变量。\n\n* 注意：与auto不同的是decltype的值与其内的变量或表达式密切相关，同时也可使用到顶层const和引用。\n* 注意：带括号的表达式或变量，使用decltype时，将必定！返回对应结果的引用类型。而且普通无多个括号时，只有表达式或变量是引用类型才为引用。\n```c++\ndecltype((i)) d; // 错误，d的类型最终为int &, 引用类型必须初始化才行\n```\n\n#### 关于结构体\nC++11新标准规定可以为结构体内的变量设置初始值\n\n#### 关于using的用法\n ```c++\n using std:cin;\n using namespace std;\n ```\n \n * 注意一般不要在头文件中使用using\n\n\n#### string\n* string相加的注意\n```c++\nstring s1 = \"H\"+\"s\"; //错误，无法确定为string类型\n```\n* string的size()返回的size_type，不确定具体类型，但一定是无符号的，所以比对时一定注意。\n\n#### for ： （C++ 11）\n类似于foreach，for 与： 结合取出对象。\n\n#### vector\n* 定义的方式：\n```c++\nvector<int> ivec;\nvector<int> ivec2(ivec);\nvector<int> ivec3 = ivec;\n//C++ 11\nvector<int> ivec4 = {5,6,7}\n\n//10个int类型的元素，且全部为-1\nvector<int> vec(10,-1);\n//10个int类型的元素，且全部为默认初始值\nvector<int> vec2(10);\n```\n* 区别初始化vector时，花号与普通括号内的值的意义。\n* curly braces还可以智能识别，如果其内的第一位与vector不符，且为数字，则此第一位可以表示为初始化的长度。第二位必须与类型相符。\n\n* 添加元素： push_back. 注意不可用下标添加元素\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\t// your code goes here\n\tvector<string> myVec;\n\tmyVec.push_back(\"a\");\n\tmyVec.push_back(\"b\");\n\tcout<< myVec[1] << endl;\n\tauto &v = myVec[1];\n\tv = \"c\";\n\tcout<< myVec[1]<<endl;\n\treturn 0;\n}\n```\n\n\n#### 迭代器的使用\n\nstring与vector都有迭代器。但返回的类型是未知的。因此经常使用auto来接收。\n\n```c++\n\t// your code goes here\n\tvector<vector<string>> myVec;\n\tvector<string> iVec;\n\tiVec.push_back(\"a\");\n\tmyVec.push_back(iVec);\n\t\n\tif(myVec.begin() != myVec.end()){\n\t\tcout<< \"非空vector\"<<endl;\n\t\tauto firstVec = myVec.begin();\n\t\tauto &v = (*firstVec)[0];\n\t\tcout<< \"第一个值：\"<< v;\n\t\tv = \"b\";\n\t\tcout<< \"改：第一个值：\"<< (*firstVec)[0];\n\t}\n```\n\n* C++中推荐尽量使用迭代器加!= 来做遍历。因为标准库的容器都定义了== !=。大部分没有定义<比较。\n```c++\n\t// your code goes here\n\tvector<int> myVec = {5,9,7,5,8,2};\n\tcout << myVec[1]<<endl;\n\tfor(auto it = myVec.begin(); it != myVec.end() ; ++it){\n\t\tcout<< *it << endl; \n\t}\n```\n* 迭代器的表示：\n除了用auto外，还可以使用：：iterator，或：：const_iterator表示常量vector或string。\n\n```c++\nvector<int> a;\na.push_back(6);\nvector<int>::iterator it = a.begin();\ncout<< *it << endl;\n```\n> c++ 11 中引入 cbegin和cend用于表示vector的常量迭代器，返回永远是const_iterator.\n\n* 访问迭代器\n使用C++的箭头， 将解引用与.运算符合在一起了。\n```c++\n// (*it).mem //访问 解it引用后的成员mem\n//it ->mem //与上面一样\n```\n> 特别注意，迭代器的循环不能添加元素，否则将破坏迭代器。\n\n* 迭代器之间的运算：\n+、- 一个数，表示移位置\n+=、-=也适用\n相减得到之间的距离：得到的类型为difference_type。为有符号类型。\n大小比较根据位置而定\n\n\n\n#### 数组的使用\n\n* 与vector区别，数组是定长的\n* 不存在存引用的数组\n```c++\nint arr[10];//定义含10个元素的数组\nint * parr[10];//含有10个整形指针的数组\n```\n* 显示初始化：\n```c++\nint a2[] = {0,2,1};// 自动设置维度为3\n```\n\n* 特殊情况的初始化：字符数组初始化必须加一个’\\0‘结尾字符\n```c++\nchar a3[] = \"c++\";//维度其实是4，因为会自动加一个结尾字符\n```\n* 重要：存对象的数组不需要由另一个数组拷贝，也不需要赋值！\n* 可以定义引用或指针数组来指向一个普通的数组：\n```c++\n\tint a[] = {1,5,3,6,8};\n\tint (*b)[5] = &a;\n\tint (&c)[5] = a;\n\tcout << a[0]<< endl;\n\tcout << *b[0]<<endl;\n\tcout << c[0]<<endl;\n```\n* 数组的size跟vector一样也是size_type\n\n* 指针与数组：\n```c++\nstring nums = {\"a\",\"b\",\"c\"};\nstring *p2 = nums;\n//string p2 = nums[0];//与上面等价\n```\n* 对数组使用decltype关键字返回的是数组还不是指针。使用auto返回的是指针！\n```c++\n\tint a[] = {1,5,3,6,8};\n\tauto b(a);//这是一个指针\n\tdecltype(a) c = {5,9,8,7};//这是一个数组\n```\n* 指针其实也是一个迭代器，拥有之前迭代器的操作。\n如用指针做迭代器输出：\n```c++\n\tfor(int *i = a; i != &a[5]; i++){\n\t\tcout << *i << endl;\n\t}\n```\n* C++ 11引入 begin和end函数用于取出数组的头尾指针位置。\n```c++\n\tfor(int *i = begin(a); i != end(a); i++){\n\t\tcout << *i << endl;\n\t}\n```\n> begin与end相减返回的类型为ptrdiff_t。与迭代器之差不同。但类型类似是符号数\n\n* 指针当成数组用：数组下标与vector和string不同，不是无符号类型！。可为负数。\n```\nint *p = &ia[2];\nint j = p[1];//与*(p+1)等价\nint k = p[-2];//返回ia[0]的元素\n```\n\n#### C风格字符串\n* C风格的字符串，操作的都是指针，而没有string对象的操作。\n* C++中的cstring就是string.h的C++版本。\n* 使用C风格字符串，必须保证字符数组以'\\0'结尾，否则就会发生严重错误！\n* 常用函数\n```c\nstrlen(p)\nstrcmp()//比较相等，相等返回0，大于为正值\nstrcat(p1,p2)//连接，p2加到p1,返回p1。必须保证p1能装得下p2\nstrcpy(p1,p2)//p2拷贝到p1，返回p1\n```\n> 使用C的字符串在估算数组长度时会充满风险，建议使用标准库string.\n\n#### 与旧代码兼容\n以下 C字符串意为： 以空字符结尾的字符数组 \n* 1. 允许使用C字符串初始化 string，或为其赋值\n* 2. string的加法运算，允许有一个C字符串\n* 3. string的复合赋值，右侧可以为一个C字符串\n此三个专为string标准库设计，反之如果是C字符则不行。但可以使用string.cstr()返回一个C字符串。如：\n```c++\nstring s(\"Hello\");\nchar * str = s;//错误，string不能给str赋值\nconst char *str = s.cstr();//正确，但如果一直要用此值，最好重新拷贝\n```\n\n*  以数组初始化vector\n```c++\nint a[] = {1,5,3,6,8};\nvector<int> ivec(begin(a),end(a));\ncout << ivec[0] << endl;\n```\n\n#### 多维数组\n本身C++是没有多维数组的，可以用一个指针嵌套的思想理解。从左往右的理解一个多维数组。\n如3,4的数组表示数组有三个元素，每个元素又是一个有四个元素的数组\n* 定义，二维数组可理解为行和列，平铺式的定义是以一行一行的定义来：\n```c++\n\tint a[3][4] = {\n\t\t{1,2,3,4},\n\t\t{5,6,7,8},\n\t\t{9,10,11,12}\n\t};\n\tint b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};//与a等价\n```\n* 遍历查值，除了用下标查找外，可以使用C++ 11的for\n```c++\nint b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};\n\tfor(auto &row:b){//注意必须使用引用，因为否则auto将自动转成指针，无法进行下一步\n\t\tfor(auto &i:row){\n\t\t\tcout << i <<endl;\n\t\t}\n\t}\n```\n\n* 注意括号的使用：\n```c++\nint *p[4];//一个有四个整型指针的数组\nint (*p)[4];//定义一个数组指针，指向四元素的数组\n```\n\n* 使用auto遍历：\n```c++\n\tfor(auto p = b;p != b+3;p++){\n\t\tfor(auto q = *p; q != (*p)+4; q++){\n\t\t\tcout << *q <<endl;\n\t\t}\n\t}\n\t//当然可以使用begin和end函数\n```\n* 使用类型别名来定义多维数组里的内部：\n```c++\nusing int_array = int[4];//c++11标准\n```\n\n#### 运算符组合使用\n注意++ 运算符优先级高于解引用优先级\n```c++\n\tint b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};\n\tauto p = begin(b[0]);\n\tcout << *p++ << endl; //1\n\tcout << *p << endl; //2\n\tcout << *++p << endl; //3\n//*p++;//p为迭代器时，返回迭代器的值，同时地址往前移一位\n```\n\n#### 位运算符\n```c++\n<< //左移运算符，将一个数的二进制向左移一定位数\n>> //右移运算符，将一个数的二进制向右移一定位数\n| //逻辑或，二进制相同位上的值，有一个为1则为1\n& //逻辑与，二进制相同位上的值，都为1则为1\n^ //逻辑异或，二进制相同位上的值，相同则为0，不同则为1\n```\n*　优先级： 算术运算符 >　移位运算符　＞条件运算符\n\n#### 函数\n\n* 函数的形参会自动忽略顶层const。\n* 尽量将不改动的对象形参设为常量形参。以阻止调用时出错。\n\n#### 内联函数\n\n* 使用Inline定义内联函数\n* 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.\n> 在使用内联函数时要留神：\n1.在内联函数内不允许使用循环语句和开关语句；\n2.内联函数的定义必须出现在内联函数第一次调用之前；\n3.类结构中所在的类说明内部定义的函数是内联函数。\nTip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.\n优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.\n缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。\n结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!\n\n#### 类成员\n* C++11 标准中，将默认值声明成一个类内初始值：\n```c++\n//类里定义\nstd::vector<Screen> screens{Screen(24, 80, '')};\n```\n\n* 返回值类型为引用与普通的区别\n```c++\n//如下如果改为返回Screen对象而非引用，将导致访问到的只是拷贝\nScreen &Screen::set(pos r)\n{\n\tcontents[r] = 10;\n\treturn *this;\n}\n```\n* 如果一个const成员函数以引用形式返回 * this, 则其返回类型是常量引用。因此如下代码无法执行\n```c++\n//假定display为返回const\nmyScreen.display(cout).set('s');\n```\n\n\n","source":"_posts/C++ 复习1.md","raw":"---\ntitle: C++ 复习1\ncategories:\n- CPlusPlus\ntags: \n- C++\n---\n\n#### 关于无符号与有符号数\n* 无符号不能为负数\n* 循环如果使用无符号计数，以>=为条件将导致死循环\n\n#### C++ 11的初始化方法\n```c++\nint a{0};\n```\n\n#### extern的使用\n* 对于希望分离成多个文件独立编译的变量，使用extern公开出去\n* 声明一个变量并extern出去，但注意不要声明+定义一起，否则失去了extern作用了\n* extern变更的声明可以在多个文件，但定义只能在一个文件\n\n#### 复合类型：引用与指针\n* 引用类型一旦初始化就与初始对象绑定在一起，不可以更换绑定。且必须在定义时赋值。\n* 引用类型不可以与值绑定\n* 指针可以不在声明时初始化，指针是一个对象\n* 指针赋值之间类型必须相同\n* C++ 11的标准提供了nullptr为指针初始化为空。 引用cstdlib标准库中，还可以用NULL为指针初始化\n* 任何非0的指针都为true.\n* void＊指针，可用于存放任意对象的地址，但不能直接操作指针所指的对象，可理解为操作内存空间\n\n#### 理解复合类型\n* 对于一个变量，要理解其类型，最简单的办法从右向左阅读变量的定义，离变量名最近的对变量有最直接的影响。\n```c++\nint i = 42;\nint *p;\nint *&r = p; //r是对指针p的一个引用类型变量\n\nr = &i; //给r赋值，就是给p的地址赋值，因此此时 p的值指向了i的地址\n*r = 0;//i的值也为0\n```\n\n* const 限定符， 声明了const后就不能改变其值，但可以使用非常量来初始化const值\n* const 在多文件中的使用：在一个文件中用extern声明同时定义，其他文件中仅extern声明即可。\n* const声明的任何类型都不可以改值！\n* const指针， 即指针指向的地址是不能改变的\n```c++\nint *errNumb = 0;\nint *const curErr = &errNumb;//curErr指针的指向的地址不能改变\nconst double pi = 3.14;\nconst double *const pip = &pi;// pip指向常量pi的常量指针\n```\n* 顶层const与底层const:　从变量名的左侧开始算，底层到高层。最右侧的为顶层const, 指针符左侧为底层const.\n* 拷贝的操作必须两对象都具有相同的底层const\n* 一般来说非常量可转换为常量。\n\n#### 常量表达式 constexpr\n具有以下两个条件的可称为常量表达式：\n1. 表达式左侧的变量需定义为常量\n2. 表达式右侧的值是不用到运行时就能确定的。\n\nC++ 11的标准规定，可以使用constexpr 让编译器验证是否为常量表达式，也可定义函数为constexpr 这样就可以在常量表达式中使用。\n```c++\nconstexpr int mf =20;\nconstexpr int limit = mf+1;\nconstexpr int sz = size(); //size()一定要用constexpr声明。\n```\n\n* constexpr 定义指针，表达此指针为常量指针，因此根据常量指针的特点，必须进行初始化。\n* 注意constexpr定义后的指针就为常量指针，即此const为指针对象的顶层const\n```c++\nconst int *p = nullptr;\nconstexpr int *q = nullptr;\n//p与q是非常不同的，p是一个指针，指向常量。 q是一个常量指针，其地址不能改。\n```\n\n#### 类型别名\n使用typedef 为类型起一个别名：\n```c++\ntypedef int ss;\n```\n\n* C++ 11 新标准可使用using语法替换typedef\n```c++\nusing ss = int;\n```\n* 特别注意当有const在最左侧声明时，带指针的类型别名解释不能直接替换后来翻译，如：\n```c++\ntypedef char *pstring; //类型别名为指向char的指针\nconst pstring a;//a是指向char的常量指针\n//const char* a;//a是指向const char的指针，与const pstring a表示不同！\n\n```\n\n#### Auto类型说明符 (C++11)\n\n不需要强制为某个变量指定类型的声明方式\n* 注意： auto一般会忽略掉顶层的const，当auto引用时！才会保留const\n* auto多变量声明类型必须一样\n```c++\nint i = 0;\nconst int ci = i;\n//以下错误，因为n和p的类型不同，n是整型指针，ci是整型常量指针。\nauto &n = i, *p = &ci;\n```\n\n#### decltype类型说明符（C++11）\n\n使用decltype可取出表达式或变量的类型，以此类型再声明变量。\n\n* 注意：与auto不同的是decltype的值与其内的变量或表达式密切相关，同时也可使用到顶层const和引用。\n* 注意：带括号的表达式或变量，使用decltype时，将必定！返回对应结果的引用类型。而且普通无多个括号时，只有表达式或变量是引用类型才为引用。\n```c++\ndecltype((i)) d; // 错误，d的类型最终为int &, 引用类型必须初始化才行\n```\n\n#### 关于结构体\nC++11新标准规定可以为结构体内的变量设置初始值\n\n#### 关于using的用法\n ```c++\n using std:cin;\n using namespace std;\n ```\n \n * 注意一般不要在头文件中使用using\n\n\n#### string\n* string相加的注意\n```c++\nstring s1 = \"H\"+\"s\"; //错误，无法确定为string类型\n```\n* string的size()返回的size_type，不确定具体类型，但一定是无符号的，所以比对时一定注意。\n\n#### for ： （C++ 11）\n类似于foreach，for 与： 结合取出对象。\n\n#### vector\n* 定义的方式：\n```c++\nvector<int> ivec;\nvector<int> ivec2(ivec);\nvector<int> ivec3 = ivec;\n//C++ 11\nvector<int> ivec4 = {5,6,7}\n\n//10个int类型的元素，且全部为-1\nvector<int> vec(10,-1);\n//10个int类型的元素，且全部为默认初始值\nvector<int> vec2(10);\n```\n* 区别初始化vector时，花号与普通括号内的值的意义。\n* curly braces还可以智能识别，如果其内的第一位与vector不符，且为数字，则此第一位可以表示为初始化的长度。第二位必须与类型相符。\n\n* 添加元素： push_back. 注意不可用下标添加元素\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\t// your code goes here\n\tvector<string> myVec;\n\tmyVec.push_back(\"a\");\n\tmyVec.push_back(\"b\");\n\tcout<< myVec[1] << endl;\n\tauto &v = myVec[1];\n\tv = \"c\";\n\tcout<< myVec[1]<<endl;\n\treturn 0;\n}\n```\n\n\n#### 迭代器的使用\n\nstring与vector都有迭代器。但返回的类型是未知的。因此经常使用auto来接收。\n\n```c++\n\t// your code goes here\n\tvector<vector<string>> myVec;\n\tvector<string> iVec;\n\tiVec.push_back(\"a\");\n\tmyVec.push_back(iVec);\n\t\n\tif(myVec.begin() != myVec.end()){\n\t\tcout<< \"非空vector\"<<endl;\n\t\tauto firstVec = myVec.begin();\n\t\tauto &v = (*firstVec)[0];\n\t\tcout<< \"第一个值：\"<< v;\n\t\tv = \"b\";\n\t\tcout<< \"改：第一个值：\"<< (*firstVec)[0];\n\t}\n```\n\n* C++中推荐尽量使用迭代器加!= 来做遍历。因为标准库的容器都定义了== !=。大部分没有定义<比较。\n```c++\n\t// your code goes here\n\tvector<int> myVec = {5,9,7,5,8,2};\n\tcout << myVec[1]<<endl;\n\tfor(auto it = myVec.begin(); it != myVec.end() ; ++it){\n\t\tcout<< *it << endl; \n\t}\n```\n* 迭代器的表示：\n除了用auto外，还可以使用：：iterator，或：：const_iterator表示常量vector或string。\n\n```c++\nvector<int> a;\na.push_back(6);\nvector<int>::iterator it = a.begin();\ncout<< *it << endl;\n```\n> c++ 11 中引入 cbegin和cend用于表示vector的常量迭代器，返回永远是const_iterator.\n\n* 访问迭代器\n使用C++的箭头， 将解引用与.运算符合在一起了。\n```c++\n// (*it).mem //访问 解it引用后的成员mem\n//it ->mem //与上面一样\n```\n> 特别注意，迭代器的循环不能添加元素，否则将破坏迭代器。\n\n* 迭代器之间的运算：\n+、- 一个数，表示移位置\n+=、-=也适用\n相减得到之间的距离：得到的类型为difference_type。为有符号类型。\n大小比较根据位置而定\n\n\n\n#### 数组的使用\n\n* 与vector区别，数组是定长的\n* 不存在存引用的数组\n```c++\nint arr[10];//定义含10个元素的数组\nint * parr[10];//含有10个整形指针的数组\n```\n* 显示初始化：\n```c++\nint a2[] = {0,2,1};// 自动设置维度为3\n```\n\n* 特殊情况的初始化：字符数组初始化必须加一个’\\0‘结尾字符\n```c++\nchar a3[] = \"c++\";//维度其实是4，因为会自动加一个结尾字符\n```\n* 重要：存对象的数组不需要由另一个数组拷贝，也不需要赋值！\n* 可以定义引用或指针数组来指向一个普通的数组：\n```c++\n\tint a[] = {1,5,3,6,8};\n\tint (*b)[5] = &a;\n\tint (&c)[5] = a;\n\tcout << a[0]<< endl;\n\tcout << *b[0]<<endl;\n\tcout << c[0]<<endl;\n```\n* 数组的size跟vector一样也是size_type\n\n* 指针与数组：\n```c++\nstring nums = {\"a\",\"b\",\"c\"};\nstring *p2 = nums;\n//string p2 = nums[0];//与上面等价\n```\n* 对数组使用decltype关键字返回的是数组还不是指针。使用auto返回的是指针！\n```c++\n\tint a[] = {1,5,3,6,8};\n\tauto b(a);//这是一个指针\n\tdecltype(a) c = {5,9,8,7};//这是一个数组\n```\n* 指针其实也是一个迭代器，拥有之前迭代器的操作。\n如用指针做迭代器输出：\n```c++\n\tfor(int *i = a; i != &a[5]; i++){\n\t\tcout << *i << endl;\n\t}\n```\n* C++ 11引入 begin和end函数用于取出数组的头尾指针位置。\n```c++\n\tfor(int *i = begin(a); i != end(a); i++){\n\t\tcout << *i << endl;\n\t}\n```\n> begin与end相减返回的类型为ptrdiff_t。与迭代器之差不同。但类型类似是符号数\n\n* 指针当成数组用：数组下标与vector和string不同，不是无符号类型！。可为负数。\n```\nint *p = &ia[2];\nint j = p[1];//与*(p+1)等价\nint k = p[-2];//返回ia[0]的元素\n```\n\n#### C风格字符串\n* C风格的字符串，操作的都是指针，而没有string对象的操作。\n* C++中的cstring就是string.h的C++版本。\n* 使用C风格字符串，必须保证字符数组以'\\0'结尾，否则就会发生严重错误！\n* 常用函数\n```c\nstrlen(p)\nstrcmp()//比较相等，相等返回0，大于为正值\nstrcat(p1,p2)//连接，p2加到p1,返回p1。必须保证p1能装得下p2\nstrcpy(p1,p2)//p2拷贝到p1，返回p1\n```\n> 使用C的字符串在估算数组长度时会充满风险，建议使用标准库string.\n\n#### 与旧代码兼容\n以下 C字符串意为： 以空字符结尾的字符数组 \n* 1. 允许使用C字符串初始化 string，或为其赋值\n* 2. string的加法运算，允许有一个C字符串\n* 3. string的复合赋值，右侧可以为一个C字符串\n此三个专为string标准库设计，反之如果是C字符则不行。但可以使用string.cstr()返回一个C字符串。如：\n```c++\nstring s(\"Hello\");\nchar * str = s;//错误，string不能给str赋值\nconst char *str = s.cstr();//正确，但如果一直要用此值，最好重新拷贝\n```\n\n*  以数组初始化vector\n```c++\nint a[] = {1,5,3,6,8};\nvector<int> ivec(begin(a),end(a));\ncout << ivec[0] << endl;\n```\n\n#### 多维数组\n本身C++是没有多维数组的，可以用一个指针嵌套的思想理解。从左往右的理解一个多维数组。\n如3,4的数组表示数组有三个元素，每个元素又是一个有四个元素的数组\n* 定义，二维数组可理解为行和列，平铺式的定义是以一行一行的定义来：\n```c++\n\tint a[3][4] = {\n\t\t{1,2,3,4},\n\t\t{5,6,7,8},\n\t\t{9,10,11,12}\n\t};\n\tint b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};//与a等价\n```\n* 遍历查值，除了用下标查找外，可以使用C++ 11的for\n```c++\nint b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};\n\tfor(auto &row:b){//注意必须使用引用，因为否则auto将自动转成指针，无法进行下一步\n\t\tfor(auto &i:row){\n\t\t\tcout << i <<endl;\n\t\t}\n\t}\n```\n\n* 注意括号的使用：\n```c++\nint *p[4];//一个有四个整型指针的数组\nint (*p)[4];//定义一个数组指针，指向四元素的数组\n```\n\n* 使用auto遍历：\n```c++\n\tfor(auto p = b;p != b+3;p++){\n\t\tfor(auto q = *p; q != (*p)+4; q++){\n\t\t\tcout << *q <<endl;\n\t\t}\n\t}\n\t//当然可以使用begin和end函数\n```\n* 使用类型别名来定义多维数组里的内部：\n```c++\nusing int_array = int[4];//c++11标准\n```\n\n#### 运算符组合使用\n注意++ 运算符优先级高于解引用优先级\n```c++\n\tint b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};\n\tauto p = begin(b[0]);\n\tcout << *p++ << endl; //1\n\tcout << *p << endl; //2\n\tcout << *++p << endl; //3\n//*p++;//p为迭代器时，返回迭代器的值，同时地址往前移一位\n```\n\n#### 位运算符\n```c++\n<< //左移运算符，将一个数的二进制向左移一定位数\n>> //右移运算符，将一个数的二进制向右移一定位数\n| //逻辑或，二进制相同位上的值，有一个为1则为1\n& //逻辑与，二进制相同位上的值，都为1则为1\n^ //逻辑异或，二进制相同位上的值，相同则为0，不同则为1\n```\n*　优先级： 算术运算符 >　移位运算符　＞条件运算符\n\n#### 函数\n\n* 函数的形参会自动忽略顶层const。\n* 尽量将不改动的对象形参设为常量形参。以阻止调用时出错。\n\n#### 内联函数\n\n* 使用Inline定义内联函数\n* 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.\n> 在使用内联函数时要留神：\n1.在内联函数内不允许使用循环语句和开关语句；\n2.内联函数的定义必须出现在内联函数第一次调用之前；\n3.类结构中所在的类说明内部定义的函数是内联函数。\nTip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.\n优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.\n缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。\n结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!\n\n#### 类成员\n* C++11 标准中，将默认值声明成一个类内初始值：\n```c++\n//类里定义\nstd::vector<Screen> screens{Screen(24, 80, '')};\n```\n\n* 返回值类型为引用与普通的区别\n```c++\n//如下如果改为返回Screen对象而非引用，将导致访问到的只是拷贝\nScreen &Screen::set(pos r)\n{\n\tcontents[r] = 10;\n\treturn *this;\n}\n```\n* 如果一个const成员函数以引用形式返回 * this, 则其返回类型是常量引用。因此如下代码无法执行\n```c++\n//假定display为返回const\nmyScreen.display(cout).set('s');\n```\n\n\n","slug":"C++ 复习1","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0xp00004wf0eis6qtyk","content":"<h4 id=\"关于无符号与有符号数\"><a href=\"#关于无符号与有符号数\" class=\"headerlink\" title=\"关于无符号与有符号数\"></a>关于无符号与有符号数</h4><ul>\n<li>无符号不能为负数</li>\n<li>循环如果使用无符号计数，以&gt;=为条件将导致死循环</li>\n</ul>\n<h4 id=\"C-11的初始化方法\"><a href=\"#C-11的初始化方法\" class=\"headerlink\" title=\"C++ 11的初始化方法\"></a>C++ 11的初始化方法</h4><pre><code class=\"c++\">int a{0};</code></pre>\n<h4 id=\"extern的使用\"><a href=\"#extern的使用\" class=\"headerlink\" title=\"extern的使用\"></a>extern的使用</h4><ul>\n<li>对于希望分离成多个文件独立编译的变量，使用extern公开出去</li>\n<li>声明一个变量并extern出去，但注意不要声明+定义一起，否则失去了extern作用了</li>\n<li>extern变更的声明可以在多个文件，但定义只能在一个文件</li>\n</ul>\n<h4 id=\"复合类型：引用与指针\"><a href=\"#复合类型：引用与指针\" class=\"headerlink\" title=\"复合类型：引用与指针\"></a>复合类型：引用与指针</h4><ul>\n<li>引用类型一旦初始化就与初始对象绑定在一起，不可以更换绑定。且必须在定义时赋值。</li>\n<li>引用类型不可以与值绑定</li>\n<li>指针可以不在声明时初始化，指针是一个对象</li>\n<li>指针赋值之间类型必须相同</li>\n<li>C++ 11的标准提供了nullptr为指针初始化为空。 引用cstdlib标准库中，还可以用NULL为指针初始化</li>\n<li>任何非0的指针都为true.</li>\n<li>void＊指针，可用于存放任意对象的地址，但不能直接操作指针所指的对象，可理解为操作内存空间</li>\n</ul>\n<h4 id=\"理解复合类型\"><a href=\"#理解复合类型\" class=\"headerlink\" title=\"理解复合类型\"></a>理解复合类型</h4><ul>\n<li>对于一个变量，要理解其类型，最简单的办法从右向左阅读变量的定义，离变量名最近的对变量有最直接的影响。<pre><code class=\"c++\">int i = 42;\nint *p;\nint *&amp;r = p; //r是对指针p的一个引用类型变量\n</code></pre>\n</li>\n</ul>\n<p>r = &i; //给r赋值，就是给p的地址赋值，因此此时 p的值指向了i的地址<br>*r = 0;//i的值也为0</p>\n<pre><code>\n* const 限定符， 声明了const后就不能改变其值，但可以使用非常量来初始化const值\n* const 在多文件中的使用：在一个文件中用extern声明同时定义，其他文件中仅extern声明即可。\n* const声明的任何类型都不可以改值！\n* const指针， 即指针指向的地址是不能改变的\n```c++\nint *errNumb = 0;\nint *const curErr = &amp;errNumb;//curErr指针的指向的地址不能改变\nconst double pi = 3.14;\nconst double *const pip = &amp;pi;// pip指向常量pi的常量指针</code></pre><ul>\n<li>顶层const与底层const:　从变量名的左侧开始算，底层到高层。最右侧的为顶层const, 指针符左侧为底层const.</li>\n<li>拷贝的操作必须两对象都具有相同的底层const</li>\n<li>一般来说非常量可转换为常量。</li>\n</ul>\n<h4 id=\"常量表达式-constexpr\"><a href=\"#常量表达式-constexpr\" class=\"headerlink\" title=\"常量表达式 constexpr\"></a>常量表达式 constexpr</h4><p>具有以下两个条件的可称为常量表达式：</p>\n<ol>\n<li>表达式左侧的变量需定义为常量</li>\n<li>表达式右侧的值是不用到运行时就能确定的。</li>\n</ol>\n<p>C++ 11的标准规定，可以使用constexpr 让编译器验证是否为常量表达式，也可定义函数为constexpr 这样就可以在常量表达式中使用。</p>\n<pre><code class=\"c++\">constexpr int mf =20;\nconstexpr int limit = mf+1;\nconstexpr int sz = size(); //size()一定要用constexpr声明。</code></pre>\n<ul>\n<li>constexpr 定义指针，表达此指针为常量指针，因此根据常量指针的特点，必须进行初始化。</li>\n<li>注意constexpr定义后的指针就为常量指针，即此const为指针对象的顶层const<pre><code class=\"c++\">const int *p = nullptr;\nconstexpr int *q = nullptr;\n//p与q是非常不同的，p是一个指针，指向常量。 q是一个常量指针，其地址不能改。</code></pre>\n</li>\n</ul>\n<h4 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h4><p>使用typedef 为类型起一个别名：</p>\n<pre><code class=\"c++\">typedef int ss;</code></pre>\n<ul>\n<li>C++ 11 新标准可使用using语法替换typedef<pre><code class=\"c++\">using ss = int;</code></pre>\n</li>\n<li>特别注意当有const在最左侧声明时，带指针的类型别名解释不能直接替换后来翻译，如：<pre><code class=\"c++\">typedef char *pstring; //类型别名为指向char的指针\nconst pstring a;//a是指向char的常量指针\n//const char* a;//a是指向const char的指针，与const pstring a表示不同！\n</code></pre>\n</li>\n</ul>\n<pre><code>\n#### Auto类型说明符 (C++11)\n\n不需要强制为某个变量指定类型的声明方式\n* 注意： auto一般会忽略掉顶层的const，当auto引用时！才会保留const\n* auto多变量声明类型必须一样\n```c++\nint i = 0;\nconst int ci = i;\n//以下错误，因为n和p的类型不同，n是整型指针，ci是整型常量指针。\nauto &amp;n = i, *p = &amp;ci;</code></pre><h4 id=\"decltype类型说明符（C-11）\"><a href=\"#decltype类型说明符（C-11）\" class=\"headerlink\" title=\"decltype类型说明符（C++11）\"></a>decltype类型说明符（C++11）</h4><p>使用decltype可取出表达式或变量的类型，以此类型再声明变量。</p>\n<ul>\n<li>注意：与auto不同的是decltype的值与其内的变量或表达式密切相关，同时也可使用到顶层const和引用。</li>\n<li>注意：带括号的表达式或变量，使用decltype时，将必定！返回对应结果的引用类型。而且普通无多个括号时，只有表达式或变量是引用类型才为引用。<pre><code class=\"c++\">decltype((i)) d; // 错误，d的类型最终为int &amp;, 引用类型必须初始化才行</code></pre>\n</li>\n</ul>\n<h4 id=\"关于结构体\"><a href=\"#关于结构体\" class=\"headerlink\" title=\"关于结构体\"></a>关于结构体</h4><p>C++11新标准规定可以为结构体内的变量设置初始值</p>\n<h4 id=\"关于using的用法\"><a href=\"#关于using的用法\" class=\"headerlink\" title=\"关于using的用法\"></a>关于using的用法</h4><pre><code class=\"c++\"> using std:cin;\n using namespace std;</code></pre>\n<ul>\n<li>注意一般不要在头文件中使用using</li>\n</ul>\n<h4 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h4><ul>\n<li>string相加的注意<pre><code class=\"c++\">string s1 = &quot;H&quot;+&quot;s&quot;; //错误，无法确定为string类型</code></pre>\n</li>\n<li>string的size()返回的size_type，不确定具体类型，但一定是无符号的，所以比对时一定注意。</li>\n</ul>\n<h4 id=\"for-：-（C-11）\"><a href=\"#for-：-（C-11）\" class=\"headerlink\" title=\"for ： （C++ 11）\"></a>for ： （C++ 11）</h4><p>类似于foreach，for 与： 结合取出对象。</p>\n<h4 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h4><ul>\n<li>定义的方式：<pre><code class=\"c++\">vector&lt;int&gt; ivec;\nvector&lt;int&gt; ivec2(ivec);\nvector&lt;int&gt; ivec3 = ivec;\n//C++ 11\nvector&lt;int&gt; ivec4 = {5,6,7}\n</code></pre>\n</li>\n</ul>\n<p>//10个int类型的元素，且全部为-1<br>vector<int> vec(10,-1);<br>//10个int类型的元素，且全部为默认初始值<br>vector<int> vec2(10);</p>\n<pre><code>* 区别初始化vector时，花号与普通括号内的值的意义。\n* curly braces还可以智能识别，如果其内的第一位与vector不符，且为数字，则此第一位可以表示为初始化的长度。第二位必须与类型相符。\n\n* 添加元素： push_back. 注意不可用下标添加元素\n```c++\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    // your code goes here\n    vector&lt;string&gt; myVec;\n    myVec.push_back(&quot;a&quot;);\n    myVec.push_back(&quot;b&quot;);\n    cout&lt;&lt; myVec[1] &lt;&lt; endl;\n    auto &amp;v = myVec[1];\n    v = &quot;c&quot;;\n    cout&lt;&lt; myVec[1]&lt;&lt;endl;\n    return 0;\n}</code></pre><h4 id=\"迭代器的使用\"><a href=\"#迭代器的使用\" class=\"headerlink\" title=\"迭代器的使用\"></a>迭代器的使用</h4><p>string与vector都有迭代器。但返回的类型是未知的。因此经常使用auto来接收。</p>\n<pre><code class=\"c++\">    // your code goes here\n    vector&lt;vector&lt;string&gt;&gt; myVec;\n    vector&lt;string&gt; iVec;\n    iVec.push_back(&quot;a&quot;);\n    myVec.push_back(iVec);\n\n    if(myVec.begin() != myVec.end()){\n        cout&lt;&lt; &quot;非空vector&quot;&lt;&lt;endl;\n        auto firstVec = myVec.begin();\n        auto &amp;v = (*firstVec)[0];\n        cout&lt;&lt; &quot;第一个值：&quot;&lt;&lt; v;\n        v = &quot;b&quot;;\n        cout&lt;&lt; &quot;改：第一个值：&quot;&lt;&lt; (*firstVec)[0];\n    }</code></pre>\n<ul>\n<li>C++中推荐尽量使用迭代器加!= 来做遍历。因为标准库的容器都定义了== !=。大部分没有定义&lt;比较。<pre><code class=\"c++\">  // your code goes here\n  vector&lt;int&gt; myVec = {5,9,7,5,8,2};\n  cout &lt;&lt; myVec[1]&lt;&lt;endl;\n  for(auto it = myVec.begin(); it != myVec.end() ; ++it){\n      cout&lt;&lt; *it &lt;&lt; endl; \n  }</code></pre>\n</li>\n<li>迭代器的表示：<br>除了用auto外，还可以使用：：iterator，或：：const_iterator表示常量vector或string。</li>\n</ul>\n<pre><code class=\"c++\">vector&lt;int&gt; a;\na.push_back(6);\nvector&lt;int&gt;::iterator it = a.begin();\ncout&lt;&lt; *it &lt;&lt; endl;</code></pre>\n<blockquote>\n<p>c++ 11 中引入 cbegin和cend用于表示vector的常量迭代器，返回永远是const_iterator.</p>\n</blockquote>\n<ul>\n<li><p>访问迭代器<br>使用C++的箭头， 将解引用与.运算符合在一起了。</p>\n<pre><code class=\"c++\">// (*it).mem //访问 解it引用后的成员mem\n//it -&gt;mem //与上面一样</code></pre>\n<blockquote>\n<p>特别注意，迭代器的循环不能添加元素，否则将破坏迭代器。</p>\n</blockquote>\n</li>\n<li><p>迭代器之间的运算：</p>\n</li>\n</ul>\n<p>+、- 一个数，表示移位置<br>+=、-=也适用<br>相减得到之间的距离：得到的类型为difference_type。为有符号类型。<br>大小比较根据位置而定</p>\n<h4 id=\"数组的使用\"><a href=\"#数组的使用\" class=\"headerlink\" title=\"数组的使用\"></a>数组的使用</h4><ul>\n<li><p>与vector区别，数组是定长的</p>\n</li>\n<li><p>不存在存引用的数组</p>\n<pre><code class=\"c++\">int arr[10];//定义含10个元素的数组\nint * parr[10];//含有10个整形指针的数组</code></pre>\n</li>\n<li><p>显示初始化：</p>\n<pre><code class=\"c++\">int a2[] = {0,2,1};// 自动设置维度为3</code></pre>\n</li>\n<li><p>特殊情况的初始化：字符数组初始化必须加一个’\\0‘结尾字符</p>\n<pre><code class=\"c++\">char a3[] = &quot;c++&quot;;//维度其实是4，因为会自动加一个结尾字符</code></pre>\n</li>\n<li><p>重要：存对象的数组不需要由另一个数组拷贝，也不需要赋值！</p>\n</li>\n<li><p>可以定义引用或指针数组来指向一个普通的数组：</p>\n<pre><code class=\"c++\">  int a[] = {1,5,3,6,8};\n  int (*b)[5] = &amp;a;\n  int (&amp;c)[5] = a;\n  cout &lt;&lt; a[0]&lt;&lt; endl;\n  cout &lt;&lt; *b[0]&lt;&lt;endl;\n  cout &lt;&lt; c[0]&lt;&lt;endl;</code></pre>\n</li>\n<li><p>数组的size跟vector一样也是size_type</p>\n</li>\n<li><p>指针与数组：</p>\n<pre><code class=\"c++\">string nums = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;};\nstring *p2 = nums;\n//string p2 = nums[0];//与上面等价</code></pre>\n</li>\n<li><p>对数组使用decltype关键字返回的是数组还不是指针。使用auto返回的是指针！</p>\n<pre><code class=\"c++\">  int a[] = {1,5,3,6,8};\n  auto b(a);//这是一个指针\n  decltype(a) c = {5,9,8,7};//这是一个数组</code></pre>\n</li>\n<li><p>指针其实也是一个迭代器，拥有之前迭代器的操作。<br>如用指针做迭代器输出：</p>\n<pre><code class=\"c++\">  for(int *i = a; i != &amp;a[5]; i++){\n      cout &lt;&lt; *i &lt;&lt; endl;\n  }</code></pre>\n</li>\n<li><p>C++ 11引入 begin和end函数用于取出数组的头尾指针位置。</p>\n<pre><code class=\"c++\">  for(int *i = begin(a); i != end(a); i++){\n      cout &lt;&lt; *i &lt;&lt; endl;\n  }</code></pre>\n<blockquote>\n<p>begin与end相减返回的类型为ptrdiff_t。与迭代器之差不同。但类型类似是符号数</p>\n</blockquote>\n</li>\n<li><p>指针当成数组用：数组下标与vector和string不同，不是无符号类型！。可为负数。</p>\n<pre><code>int *p = &amp;ia[2];\nint j = p[1];//与*(p+1)等价\nint k = p[-2];//返回ia[0]的元素</code></pre></li>\n</ul>\n<h4 id=\"C风格字符串\"><a href=\"#C风格字符串\" class=\"headerlink\" title=\"C风格字符串\"></a>C风格字符串</h4><ul>\n<li>C风格的字符串，操作的都是指针，而没有string对象的操作。</li>\n<li>C++中的cstring就是string.h的C++版本。</li>\n<li>使用C风格字符串，必须保证字符数组以’\\0’结尾，否则就会发生严重错误！</li>\n<li>常用函数<pre><code class=\"c\">strlen(p)\nstrcmp()//比较相等，相等返回0，大于为正值\nstrcat(p1,p2)//连接，p2加到p1,返回p1。必须保证p1能装得下p2\nstrcpy(p1,p2)//p2拷贝到p1，返回p1</code></pre>\n<blockquote>\n<p>使用C的字符串在估算数组长度时会充满风险，建议使用标准库string.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"与旧代码兼容\"><a href=\"#与旧代码兼容\" class=\"headerlink\" title=\"与旧代码兼容\"></a>与旧代码兼容</h4><p>以下 C字符串意为： 以空字符结尾的字符数组 </p>\n<ul>\n<li><ol>\n<li>允许使用C字符串初始化 string，或为其赋值</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>string的加法运算，允许有一个C字符串</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>string的复合赋值，右侧可以为一个C字符串<br>此三个专为string标准库设计，反之如果是C字符则不行。但可以使用string.cstr()返回一个C字符串。如：<pre><code class=\"c++\">string s(&quot;Hello&quot;);\nchar * str = s;//错误，string不能给str赋值\nconst char *str = s.cstr();//正确，但如果一直要用此值，最好重新拷贝</code></pre>\n</li>\n</ol>\n</li>\n<li><p>以数组初始化vector</p>\n<pre><code class=\"c++\">int a[] = {1,5,3,6,8};\nvector&lt;int&gt; ivec(begin(a),end(a));\ncout &lt;&lt; ivec[0] &lt;&lt; endl;</code></pre>\n</li>\n</ul>\n<h4 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h4><p>本身C++是没有多维数组的，可以用一个指针嵌套的思想理解。从左往右的理解一个多维数组。<br>如3,4的数组表示数组有三个元素，每个元素又是一个有四个元素的数组</p>\n<ul>\n<li><p>定义，二维数组可理解为行和列，平铺式的定义是以一行一行的定义来：</p>\n<pre><code class=\"c++\">  int a[3][4] = {\n      {1,2,3,4},\n      {5,6,7,8},\n      {9,10,11,12}\n  };\n  int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};//与a等价</code></pre>\n</li>\n<li><p>遍历查值，除了用下标查找外，可以使用C++ 11的for</p>\n<pre><code class=\"c++\">int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};\n  for(auto &amp;row:b){//注意必须使用引用，因为否则auto将自动转成指针，无法进行下一步\n      for(auto &amp;i:row){\n          cout &lt;&lt; i &lt;&lt;endl;\n      }\n  }</code></pre>\n</li>\n<li><p>注意括号的使用：</p>\n<pre><code class=\"c++\">int *p[4];//一个有四个整型指针的数组\nint (*p)[4];//定义一个数组指针，指向四元素的数组</code></pre>\n</li>\n<li><p>使用auto遍历：</p>\n<pre><code class=\"c++\">  for(auto p = b;p != b+3;p++){\n      for(auto q = *p; q != (*p)+4; q++){\n          cout &lt;&lt; *q &lt;&lt;endl;\n      }\n  }\n  //当然可以使用begin和end函数</code></pre>\n</li>\n<li><p>使用类型别名来定义多维数组里的内部：</p>\n<pre><code class=\"c++\">using int_array = int[4];//c++11标准</code></pre>\n</li>\n</ul>\n<h4 id=\"运算符组合使用\"><a href=\"#运算符组合使用\" class=\"headerlink\" title=\"运算符组合使用\"></a>运算符组合使用</h4><p>注意++ 运算符优先级高于解引用优先级</p>\n<pre><code class=\"c++\">    int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};\n    auto p = begin(b[0]);\n    cout &lt;&lt; *p++ &lt;&lt; endl; //1\n    cout &lt;&lt; *p &lt;&lt; endl; //2\n    cout &lt;&lt; *++p &lt;&lt; endl; //3\n//*p++;//p为迭代器时，返回迭代器的值，同时地址往前移一位</code></pre>\n<h4 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h4><pre><code class=\"c++\">&lt;&lt; //左移运算符，将一个数的二进制向左移一定位数\n&gt;&gt; //右移运算符，将一个数的二进制向右移一定位数\n| //逻辑或，二进制相同位上的值，有一个为1则为1\n&amp; //逻辑与，二进制相同位上的值，都为1则为1\n^ //逻辑异或，二进制相同位上的值，相同则为0，不同则为1</code></pre>\n<p>*　优先级： 算术运算符 &gt;　移位运算符　＞条件运算符</p>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><ul>\n<li>函数的形参会自动忽略顶层const。</li>\n<li>尽量将不改动的对象形参设为常量形参。以阻止调用时出错。</li>\n</ul>\n<h4 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h4><ul>\n<li>使用Inline定义内联函数</li>\n<li>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.<blockquote>\n<p>在使用内联函数时要留神：</p>\n</blockquote>\n</li>\n</ul>\n<p>1.在内联函数内不允许使用循环语句和开关语句；<br>2.内联函数的定义必须出现在内联函数第一次调用之前；<br>3.类结构中所在的类说明内部定义的函数是内联函数。<br>Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.<br>优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.<br>缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。<br>结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>\n<h4 id=\"类成员\"><a href=\"#类成员\" class=\"headerlink\" title=\"类成员\"></a>类成员</h4><ul>\n<li><p>C++11 标准中，将默认值声明成一个类内初始值：</p>\n<pre><code class=\"c++\">//类里定义\nstd::vector&lt;Screen&gt; screens{Screen(24, 80, &#39;&#39;)};</code></pre>\n</li>\n<li><p>返回值类型为引用与普通的区别</p>\n<pre><code class=\"c++\">//如下如果改为返回Screen对象而非引用，将导致访问到的只是拷贝\nScreen &amp;Screen::set(pos r)\n{\n  contents[r] = 10;\n  return *this;\n}</code></pre>\n</li>\n<li><p>如果一个const成员函数以引用形式返回 * this, 则其返回类型是常量引用。因此如下代码无法执行</p>\n<pre><code class=\"c++\">//假定display为返回const\nmyScreen.display(cout).set(&#39;s&#39;);</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"关于无符号与有符号数\"><a href=\"#关于无符号与有符号数\" class=\"headerlink\" title=\"关于无符号与有符号数\"></a>关于无符号与有符号数</h4><ul>\n<li>无符号不能为负数</li>\n<li>循环如果使用无符号计数，以&gt;=为条件将导致死循环</li>\n</ul>\n<h4 id=\"C-11的初始化方法\"><a href=\"#C-11的初始化方法\" class=\"headerlink\" title=\"C++ 11的初始化方法\"></a>C++ 11的初始化方法</h4><pre><code class=\"c++\">int a{0};</code></pre>\n<h4 id=\"extern的使用\"><a href=\"#extern的使用\" class=\"headerlink\" title=\"extern的使用\"></a>extern的使用</h4><ul>\n<li>对于希望分离成多个文件独立编译的变量，使用extern公开出去</li>\n<li>声明一个变量并extern出去，但注意不要声明+定义一起，否则失去了extern作用了</li>\n<li>extern变更的声明可以在多个文件，但定义只能在一个文件</li>\n</ul>\n<h4 id=\"复合类型：引用与指针\"><a href=\"#复合类型：引用与指针\" class=\"headerlink\" title=\"复合类型：引用与指针\"></a>复合类型：引用与指针</h4><ul>\n<li>引用类型一旦初始化就与初始对象绑定在一起，不可以更换绑定。且必须在定义时赋值。</li>\n<li>引用类型不可以与值绑定</li>\n<li>指针可以不在声明时初始化，指针是一个对象</li>\n<li>指针赋值之间类型必须相同</li>\n<li>C++ 11的标准提供了nullptr为指针初始化为空。 引用cstdlib标准库中，还可以用NULL为指针初始化</li>\n<li>任何非0的指针都为true.</li>\n<li>void＊指针，可用于存放任意对象的地址，但不能直接操作指针所指的对象，可理解为操作内存空间</li>\n</ul>\n<h4 id=\"理解复合类型\"><a href=\"#理解复合类型\" class=\"headerlink\" title=\"理解复合类型\"></a>理解复合类型</h4><ul>\n<li>对于一个变量，要理解其类型，最简单的办法从右向左阅读变量的定义，离变量名最近的对变量有最直接的影响。<pre><code class=\"c++\">int i = 42;\nint *p;\nint *&amp;r = p; //r是对指针p的一个引用类型变量\n</code></pre>\n</li>\n</ul>\n<p>r = &i; //给r赋值，就是给p的地址赋值，因此此时 p的值指向了i的地址<br>*r = 0;//i的值也为0</p>\n<pre><code>\n* const 限定符， 声明了const后就不能改变其值，但可以使用非常量来初始化const值\n* const 在多文件中的使用：在一个文件中用extern声明同时定义，其他文件中仅extern声明即可。\n* const声明的任何类型都不可以改值！\n* const指针， 即指针指向的地址是不能改变的\n```c++\nint *errNumb = 0;\nint *const curErr = &amp;errNumb;//curErr指针的指向的地址不能改变\nconst double pi = 3.14;\nconst double *const pip = &amp;pi;// pip指向常量pi的常量指针</code></pre><ul>\n<li>顶层const与底层const:　从变量名的左侧开始算，底层到高层。最右侧的为顶层const, 指针符左侧为底层const.</li>\n<li>拷贝的操作必须两对象都具有相同的底层const</li>\n<li>一般来说非常量可转换为常量。</li>\n</ul>\n<h4 id=\"常量表达式-constexpr\"><a href=\"#常量表达式-constexpr\" class=\"headerlink\" title=\"常量表达式 constexpr\"></a>常量表达式 constexpr</h4><p>具有以下两个条件的可称为常量表达式：</p>\n<ol>\n<li>表达式左侧的变量需定义为常量</li>\n<li>表达式右侧的值是不用到运行时就能确定的。</li>\n</ol>\n<p>C++ 11的标准规定，可以使用constexpr 让编译器验证是否为常量表达式，也可定义函数为constexpr 这样就可以在常量表达式中使用。</p>\n<pre><code class=\"c++\">constexpr int mf =20;\nconstexpr int limit = mf+1;\nconstexpr int sz = size(); //size()一定要用constexpr声明。</code></pre>\n<ul>\n<li>constexpr 定义指针，表达此指针为常量指针，因此根据常量指针的特点，必须进行初始化。</li>\n<li>注意constexpr定义后的指针就为常量指针，即此const为指针对象的顶层const<pre><code class=\"c++\">const int *p = nullptr;\nconstexpr int *q = nullptr;\n//p与q是非常不同的，p是一个指针，指向常量。 q是一个常量指针，其地址不能改。</code></pre>\n</li>\n</ul>\n<h4 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h4><p>使用typedef 为类型起一个别名：</p>\n<pre><code class=\"c++\">typedef int ss;</code></pre>\n<ul>\n<li>C++ 11 新标准可使用using语法替换typedef<pre><code class=\"c++\">using ss = int;</code></pre>\n</li>\n<li>特别注意当有const在最左侧声明时，带指针的类型别名解释不能直接替换后来翻译，如：<pre><code class=\"c++\">typedef char *pstring; //类型别名为指向char的指针\nconst pstring a;//a是指向char的常量指针\n//const char* a;//a是指向const char的指针，与const pstring a表示不同！\n</code></pre>\n</li>\n</ul>\n<pre><code>\n#### Auto类型说明符 (C++11)\n\n不需要强制为某个变量指定类型的声明方式\n* 注意： auto一般会忽略掉顶层的const，当auto引用时！才会保留const\n* auto多变量声明类型必须一样\n```c++\nint i = 0;\nconst int ci = i;\n//以下错误，因为n和p的类型不同，n是整型指针，ci是整型常量指针。\nauto &amp;n = i, *p = &amp;ci;</code></pre><h4 id=\"decltype类型说明符（C-11）\"><a href=\"#decltype类型说明符（C-11）\" class=\"headerlink\" title=\"decltype类型说明符（C++11）\"></a>decltype类型说明符（C++11）</h4><p>使用decltype可取出表达式或变量的类型，以此类型再声明变量。</p>\n<ul>\n<li>注意：与auto不同的是decltype的值与其内的变量或表达式密切相关，同时也可使用到顶层const和引用。</li>\n<li>注意：带括号的表达式或变量，使用decltype时，将必定！返回对应结果的引用类型。而且普通无多个括号时，只有表达式或变量是引用类型才为引用。<pre><code class=\"c++\">decltype((i)) d; // 错误，d的类型最终为int &amp;, 引用类型必须初始化才行</code></pre>\n</li>\n</ul>\n<h4 id=\"关于结构体\"><a href=\"#关于结构体\" class=\"headerlink\" title=\"关于结构体\"></a>关于结构体</h4><p>C++11新标准规定可以为结构体内的变量设置初始值</p>\n<h4 id=\"关于using的用法\"><a href=\"#关于using的用法\" class=\"headerlink\" title=\"关于using的用法\"></a>关于using的用法</h4><pre><code class=\"c++\"> using std:cin;\n using namespace std;</code></pre>\n<ul>\n<li>注意一般不要在头文件中使用using</li>\n</ul>\n<h4 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h4><ul>\n<li>string相加的注意<pre><code class=\"c++\">string s1 = &quot;H&quot;+&quot;s&quot;; //错误，无法确定为string类型</code></pre>\n</li>\n<li>string的size()返回的size_type，不确定具体类型，但一定是无符号的，所以比对时一定注意。</li>\n</ul>\n<h4 id=\"for-：-（C-11）\"><a href=\"#for-：-（C-11）\" class=\"headerlink\" title=\"for ： （C++ 11）\"></a>for ： （C++ 11）</h4><p>类似于foreach，for 与： 结合取出对象。</p>\n<h4 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h4><ul>\n<li>定义的方式：<pre><code class=\"c++\">vector&lt;int&gt; ivec;\nvector&lt;int&gt; ivec2(ivec);\nvector&lt;int&gt; ivec3 = ivec;\n//C++ 11\nvector&lt;int&gt; ivec4 = {5,6,7}\n</code></pre>\n</li>\n</ul>\n<p>//10个int类型的元素，且全部为-1<br>vector<int> vec(10,-1);<br>//10个int类型的元素，且全部为默认初始值<br>vector<int> vec2(10);</p>\n<pre><code>* 区别初始化vector时，花号与普通括号内的值的意义。\n* curly braces还可以智能识别，如果其内的第一位与vector不符，且为数字，则此第一位可以表示为初始化的长度。第二位必须与类型相符。\n\n* 添加元素： push_back. 注意不可用下标添加元素\n```c++\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    // your code goes here\n    vector&lt;string&gt; myVec;\n    myVec.push_back(&quot;a&quot;);\n    myVec.push_back(&quot;b&quot;);\n    cout&lt;&lt; myVec[1] &lt;&lt; endl;\n    auto &amp;v = myVec[1];\n    v = &quot;c&quot;;\n    cout&lt;&lt; myVec[1]&lt;&lt;endl;\n    return 0;\n}</code></pre><h4 id=\"迭代器的使用\"><a href=\"#迭代器的使用\" class=\"headerlink\" title=\"迭代器的使用\"></a>迭代器的使用</h4><p>string与vector都有迭代器。但返回的类型是未知的。因此经常使用auto来接收。</p>\n<pre><code class=\"c++\">    // your code goes here\n    vector&lt;vector&lt;string&gt;&gt; myVec;\n    vector&lt;string&gt; iVec;\n    iVec.push_back(&quot;a&quot;);\n    myVec.push_back(iVec);\n\n    if(myVec.begin() != myVec.end()){\n        cout&lt;&lt; &quot;非空vector&quot;&lt;&lt;endl;\n        auto firstVec = myVec.begin();\n        auto &amp;v = (*firstVec)[0];\n        cout&lt;&lt; &quot;第一个值：&quot;&lt;&lt; v;\n        v = &quot;b&quot;;\n        cout&lt;&lt; &quot;改：第一个值：&quot;&lt;&lt; (*firstVec)[0];\n    }</code></pre>\n<ul>\n<li>C++中推荐尽量使用迭代器加!= 来做遍历。因为标准库的容器都定义了== !=。大部分没有定义&lt;比较。<pre><code class=\"c++\">  // your code goes here\n  vector&lt;int&gt; myVec = {5,9,7,5,8,2};\n  cout &lt;&lt; myVec[1]&lt;&lt;endl;\n  for(auto it = myVec.begin(); it != myVec.end() ; ++it){\n      cout&lt;&lt; *it &lt;&lt; endl; \n  }</code></pre>\n</li>\n<li>迭代器的表示：<br>除了用auto外，还可以使用：：iterator，或：：const_iterator表示常量vector或string。</li>\n</ul>\n<pre><code class=\"c++\">vector&lt;int&gt; a;\na.push_back(6);\nvector&lt;int&gt;::iterator it = a.begin();\ncout&lt;&lt; *it &lt;&lt; endl;</code></pre>\n<blockquote>\n<p>c++ 11 中引入 cbegin和cend用于表示vector的常量迭代器，返回永远是const_iterator.</p>\n</blockquote>\n<ul>\n<li><p>访问迭代器<br>使用C++的箭头， 将解引用与.运算符合在一起了。</p>\n<pre><code class=\"c++\">// (*it).mem //访问 解it引用后的成员mem\n//it -&gt;mem //与上面一样</code></pre>\n<blockquote>\n<p>特别注意，迭代器的循环不能添加元素，否则将破坏迭代器。</p>\n</blockquote>\n</li>\n<li><p>迭代器之间的运算：</p>\n</li>\n</ul>\n<p>+、- 一个数，表示移位置<br>+=、-=也适用<br>相减得到之间的距离：得到的类型为difference_type。为有符号类型。<br>大小比较根据位置而定</p>\n<h4 id=\"数组的使用\"><a href=\"#数组的使用\" class=\"headerlink\" title=\"数组的使用\"></a>数组的使用</h4><ul>\n<li><p>与vector区别，数组是定长的</p>\n</li>\n<li><p>不存在存引用的数组</p>\n<pre><code class=\"c++\">int arr[10];//定义含10个元素的数组\nint * parr[10];//含有10个整形指针的数组</code></pre>\n</li>\n<li><p>显示初始化：</p>\n<pre><code class=\"c++\">int a2[] = {0,2,1};// 自动设置维度为3</code></pre>\n</li>\n<li><p>特殊情况的初始化：字符数组初始化必须加一个’\\0‘结尾字符</p>\n<pre><code class=\"c++\">char a3[] = &quot;c++&quot;;//维度其实是4，因为会自动加一个结尾字符</code></pre>\n</li>\n<li><p>重要：存对象的数组不需要由另一个数组拷贝，也不需要赋值！</p>\n</li>\n<li><p>可以定义引用或指针数组来指向一个普通的数组：</p>\n<pre><code class=\"c++\">  int a[] = {1,5,3,6,8};\n  int (*b)[5] = &amp;a;\n  int (&amp;c)[5] = a;\n  cout &lt;&lt; a[0]&lt;&lt; endl;\n  cout &lt;&lt; *b[0]&lt;&lt;endl;\n  cout &lt;&lt; c[0]&lt;&lt;endl;</code></pre>\n</li>\n<li><p>数组的size跟vector一样也是size_type</p>\n</li>\n<li><p>指针与数组：</p>\n<pre><code class=\"c++\">string nums = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;};\nstring *p2 = nums;\n//string p2 = nums[0];//与上面等价</code></pre>\n</li>\n<li><p>对数组使用decltype关键字返回的是数组还不是指针。使用auto返回的是指针！</p>\n<pre><code class=\"c++\">  int a[] = {1,5,3,6,8};\n  auto b(a);//这是一个指针\n  decltype(a) c = {5,9,8,7};//这是一个数组</code></pre>\n</li>\n<li><p>指针其实也是一个迭代器，拥有之前迭代器的操作。<br>如用指针做迭代器输出：</p>\n<pre><code class=\"c++\">  for(int *i = a; i != &amp;a[5]; i++){\n      cout &lt;&lt; *i &lt;&lt; endl;\n  }</code></pre>\n</li>\n<li><p>C++ 11引入 begin和end函数用于取出数组的头尾指针位置。</p>\n<pre><code class=\"c++\">  for(int *i = begin(a); i != end(a); i++){\n      cout &lt;&lt; *i &lt;&lt; endl;\n  }</code></pre>\n<blockquote>\n<p>begin与end相减返回的类型为ptrdiff_t。与迭代器之差不同。但类型类似是符号数</p>\n</blockquote>\n</li>\n<li><p>指针当成数组用：数组下标与vector和string不同，不是无符号类型！。可为负数。</p>\n<pre><code>int *p = &amp;ia[2];\nint j = p[1];//与*(p+1)等价\nint k = p[-2];//返回ia[0]的元素</code></pre></li>\n</ul>\n<h4 id=\"C风格字符串\"><a href=\"#C风格字符串\" class=\"headerlink\" title=\"C风格字符串\"></a>C风格字符串</h4><ul>\n<li>C风格的字符串，操作的都是指针，而没有string对象的操作。</li>\n<li>C++中的cstring就是string.h的C++版本。</li>\n<li>使用C风格字符串，必须保证字符数组以’\\0’结尾，否则就会发生严重错误！</li>\n<li>常用函数<pre><code class=\"c\">strlen(p)\nstrcmp()//比较相等，相等返回0，大于为正值\nstrcat(p1,p2)//连接，p2加到p1,返回p1。必须保证p1能装得下p2\nstrcpy(p1,p2)//p2拷贝到p1，返回p1</code></pre>\n<blockquote>\n<p>使用C的字符串在估算数组长度时会充满风险，建议使用标准库string.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"与旧代码兼容\"><a href=\"#与旧代码兼容\" class=\"headerlink\" title=\"与旧代码兼容\"></a>与旧代码兼容</h4><p>以下 C字符串意为： 以空字符结尾的字符数组 </p>\n<ul>\n<li><ol>\n<li>允许使用C字符串初始化 string，或为其赋值</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>string的加法运算，允许有一个C字符串</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>string的复合赋值，右侧可以为一个C字符串<br>此三个专为string标准库设计，反之如果是C字符则不行。但可以使用string.cstr()返回一个C字符串。如：<pre><code class=\"c++\">string s(&quot;Hello&quot;);\nchar * str = s;//错误，string不能给str赋值\nconst char *str = s.cstr();//正确，但如果一直要用此值，最好重新拷贝</code></pre>\n</li>\n</ol>\n</li>\n<li><p>以数组初始化vector</p>\n<pre><code class=\"c++\">int a[] = {1,5,3,6,8};\nvector&lt;int&gt; ivec(begin(a),end(a));\ncout &lt;&lt; ivec[0] &lt;&lt; endl;</code></pre>\n</li>\n</ul>\n<h4 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h4><p>本身C++是没有多维数组的，可以用一个指针嵌套的思想理解。从左往右的理解一个多维数组。<br>如3,4的数组表示数组有三个元素，每个元素又是一个有四个元素的数组</p>\n<ul>\n<li><p>定义，二维数组可理解为行和列，平铺式的定义是以一行一行的定义来：</p>\n<pre><code class=\"c++\">  int a[3][4] = {\n      {1,2,3,4},\n      {5,6,7,8},\n      {9,10,11,12}\n  };\n  int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};//与a等价</code></pre>\n</li>\n<li><p>遍历查值，除了用下标查找外，可以使用C++ 11的for</p>\n<pre><code class=\"c++\">int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};\n  for(auto &amp;row:b){//注意必须使用引用，因为否则auto将自动转成指针，无法进行下一步\n      for(auto &amp;i:row){\n          cout &lt;&lt; i &lt;&lt;endl;\n      }\n  }</code></pre>\n</li>\n<li><p>注意括号的使用：</p>\n<pre><code class=\"c++\">int *p[4];//一个有四个整型指针的数组\nint (*p)[4];//定义一个数组指针，指向四元素的数组</code></pre>\n</li>\n<li><p>使用auto遍历：</p>\n<pre><code class=\"c++\">  for(auto p = b;p != b+3;p++){\n      for(auto q = *p; q != (*p)+4; q++){\n          cout &lt;&lt; *q &lt;&lt;endl;\n      }\n  }\n  //当然可以使用begin和end函数</code></pre>\n</li>\n<li><p>使用类型别名来定义多维数组里的内部：</p>\n<pre><code class=\"c++\">using int_array = int[4];//c++11标准</code></pre>\n</li>\n</ul>\n<h4 id=\"运算符组合使用\"><a href=\"#运算符组合使用\" class=\"headerlink\" title=\"运算符组合使用\"></a>运算符组合使用</h4><p>注意++ 运算符优先级高于解引用优先级</p>\n<pre><code class=\"c++\">    int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};\n    auto p = begin(b[0]);\n    cout &lt;&lt; *p++ &lt;&lt; endl; //1\n    cout &lt;&lt; *p &lt;&lt; endl; //2\n    cout &lt;&lt; *++p &lt;&lt; endl; //3\n//*p++;//p为迭代器时，返回迭代器的值，同时地址往前移一位</code></pre>\n<h4 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h4><pre><code class=\"c++\">&lt;&lt; //左移运算符，将一个数的二进制向左移一定位数\n&gt;&gt; //右移运算符，将一个数的二进制向右移一定位数\n| //逻辑或，二进制相同位上的值，有一个为1则为1\n&amp; //逻辑与，二进制相同位上的值，都为1则为1\n^ //逻辑异或，二进制相同位上的值，相同则为0，不同则为1</code></pre>\n<p>*　优先级： 算术运算符 &gt;　移位运算符　＞条件运算符</p>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><ul>\n<li>函数的形参会自动忽略顶层const。</li>\n<li>尽量将不改动的对象形参设为常量形参。以阻止调用时出错。</li>\n</ul>\n<h4 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h4><ul>\n<li>使用Inline定义内联函数</li>\n<li>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.<blockquote>\n<p>在使用内联函数时要留神：</p>\n</blockquote>\n</li>\n</ul>\n<p>1.在内联函数内不允许使用循环语句和开关语句；<br>2.内联函数的定义必须出现在内联函数第一次调用之前；<br>3.类结构中所在的类说明内部定义的函数是内联函数。<br>Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.<br>优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.<br>缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。<br>结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>\n<h4 id=\"类成员\"><a href=\"#类成员\" class=\"headerlink\" title=\"类成员\"></a>类成员</h4><ul>\n<li><p>C++11 标准中，将默认值声明成一个类内初始值：</p>\n<pre><code class=\"c++\">//类里定义\nstd::vector&lt;Screen&gt; screens{Screen(24, 80, &#39;&#39;)};</code></pre>\n</li>\n<li><p>返回值类型为引用与普通的区别</p>\n<pre><code class=\"c++\">//如下如果改为返回Screen对象而非引用，将导致访问到的只是拷贝\nScreen &amp;Screen::set(pos r)\n{\n  contents[r] = 10;\n  return *this;\n}</code></pre>\n</li>\n<li><p>如果一个const成员函数以引用形式返回 * this, 则其返回类型是常量引用。因此如下代码无法执行</p>\n<pre><code class=\"c++\">//假定display为返回const\nmyScreen.display(cout).set(&#39;s&#39;);</code></pre>\n</li>\n</ul>\n"},{"title":"Addressable 研究","_content":"\n## 什么是Addressable？\n![什么](/img/1579072055300.png)\n\n## Addressable的实例函数\n\n![实例函数](/img/1579077588215.png)\n\n## 以label形式加载\n\n![以label加载](/img/1579078623846.png)\n\n## 模式选择\n\n![模式](/img/1579078890824.png)\n\nData Builders：在Addressable窗口菜单中能够选择的在编辑器下的数据构建模式，一般来说附带的这几个已经可以满足大部分要求，你也可以新建适合自己项目的模式。\nFast Mode：加载资源不通过资源包，直接使用AssetDatabase加载。\nVirtual Mode：会形成AssetBundle布局，但是不需要打包，加载资源通过ResourcesManager加载，并且可以在RM Profiler中查看包体布局。\nPacked Mode：需要额外步骤打包AssetBundle，运行时资源也是在AssetBundle中进行加载。\n\n## 迁移指南\n\n![从自己框架移植](/img/1579081015473.png)\n\n![从Resources移植](/img/1579081031342.png)\n\n\n## 使用注意项：\n1.每调用一次Addressables.Instantiate方法，会将该Asset的引用计数加一；而Addressables.ReleaseInstance会减少这个引用计数。如果你使用Object.Destroy释放了它，则原始资源会一直存在于内存中。所以应当避免使用Object.Destroy方法了~\n2.非使用 Addresables.Instantiate 方法实例化出来的对象，如使用Unity自带的Instantiate实例出来的对象，也可以使用Addressables.ReleaseInstance来释放，这并不会对计数有影响，只是单纯的释放。\n3.任何通过Addresables.Instantiate 方法实例化出来的对象，在切换场景的时候，如果没有标记为 DontDestroyOnLoad ,则会被自动调用Addressables.ReleaseInstance来释放掉。\n\n\n## 总结：\n* 1. 出包时将自动带上catalog.json在包内，出包的时候不用带 catalogxxx.json 和catalog.hash文件\n* 2. 可使用接口随时重加载catalog文件。如：\n\n``` csharp\n//注意： 一定要先清除所有resoucelocators\nAddressables.ClearResourceLocators();\n//重加载下载好的catalog文件\nawait Addressables.LoadContentCatalogAsync(Path.Combine(ResourceConfig.GetLocalBundlePath(), \"catalog.json\"),true).Task;\n```\n\n3. 因此 ： 流程可采用如下的方式：\n > 1. 将设置好assetbundle provider，这里仍用旧的方式，对资源加载时的路径进行跳转限制，优先找SD卡资源，再找包体资源。\n > 2. 出APK包，在 catalog打完包，在资源中不需要带，直接删除掉。资源+version.txt即可\n > 3. 出资源包时，带上新名字的catalog文件作为清单。\n > 4.下载模块完全用自己实现！ 先加载SD卡的catalog文件，没有，则默认用包内的。 如果有新的，再次调用加载catalog，这样读取就是最新的。","source":"_posts/Addressable 研究.md","raw":"---\ntitle: Addressable 研究\ncategories:\n- Unity学习\ntags: \n- Unity学习\n---\n\n## 什么是Addressable？\n![什么](/img/1579072055300.png)\n\n## Addressable的实例函数\n\n![实例函数](/img/1579077588215.png)\n\n## 以label形式加载\n\n![以label加载](/img/1579078623846.png)\n\n## 模式选择\n\n![模式](/img/1579078890824.png)\n\nData Builders：在Addressable窗口菜单中能够选择的在编辑器下的数据构建模式，一般来说附带的这几个已经可以满足大部分要求，你也可以新建适合自己项目的模式。\nFast Mode：加载资源不通过资源包，直接使用AssetDatabase加载。\nVirtual Mode：会形成AssetBundle布局，但是不需要打包，加载资源通过ResourcesManager加载，并且可以在RM Profiler中查看包体布局。\nPacked Mode：需要额外步骤打包AssetBundle，运行时资源也是在AssetBundle中进行加载。\n\n## 迁移指南\n\n![从自己框架移植](/img/1579081015473.png)\n\n![从Resources移植](/img/1579081031342.png)\n\n\n## 使用注意项：\n1.每调用一次Addressables.Instantiate方法，会将该Asset的引用计数加一；而Addressables.ReleaseInstance会减少这个引用计数。如果你使用Object.Destroy释放了它，则原始资源会一直存在于内存中。所以应当避免使用Object.Destroy方法了~\n2.非使用 Addresables.Instantiate 方法实例化出来的对象，如使用Unity自带的Instantiate实例出来的对象，也可以使用Addressables.ReleaseInstance来释放，这并不会对计数有影响，只是单纯的释放。\n3.任何通过Addresables.Instantiate 方法实例化出来的对象，在切换场景的时候，如果没有标记为 DontDestroyOnLoad ,则会被自动调用Addressables.ReleaseInstance来释放掉。\n\n\n## 总结：\n* 1. 出包时将自动带上catalog.json在包内，出包的时候不用带 catalogxxx.json 和catalog.hash文件\n* 2. 可使用接口随时重加载catalog文件。如：\n\n``` csharp\n//注意： 一定要先清除所有resoucelocators\nAddressables.ClearResourceLocators();\n//重加载下载好的catalog文件\nawait Addressables.LoadContentCatalogAsync(Path.Combine(ResourceConfig.GetLocalBundlePath(), \"catalog.json\"),true).Task;\n```\n\n3. 因此 ： 流程可采用如下的方式：\n > 1. 将设置好assetbundle provider，这里仍用旧的方式，对资源加载时的路径进行跳转限制，优先找SD卡资源，再找包体资源。\n > 2. 出APK包，在 catalog打完包，在资源中不需要带，直接删除掉。资源+version.txt即可\n > 3. 出资源包时，带上新名字的catalog文件作为清单。\n > 4.下载模块完全用自己实现！ 先加载SD卡的catalog文件，没有，则默认用包内的。 如果有新的，再次调用加载catalog，这样读取就是最新的。","slug":"Addressable 研究","published":1,"date":"2020-09-08T06:59:26.565Z","updated":"2020-09-08T06:59:26.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0xw00024wf0ah6k6x8b","content":"<h2 id=\"什么是Addressable？\"><a href=\"#什么是Addressable？\" class=\"headerlink\" title=\"什么是Addressable？\"></a>什么是Addressable？</h2><p><img src=\"/img/1579072055300.png\" alt=\"什么\"></p>\n<h2 id=\"Addressable的实例函数\"><a href=\"#Addressable的实例函数\" class=\"headerlink\" title=\"Addressable的实例函数\"></a>Addressable的实例函数</h2><p><img src=\"/img/1579077588215.png\" alt=\"实例函数\"></p>\n<h2 id=\"以label形式加载\"><a href=\"#以label形式加载\" class=\"headerlink\" title=\"以label形式加载\"></a>以label形式加载</h2><p><img src=\"/img/1579078623846.png\" alt=\"以label加载\"></p>\n<h2 id=\"模式选择\"><a href=\"#模式选择\" class=\"headerlink\" title=\"模式选择\"></a>模式选择</h2><p><img src=\"/img/1579078890824.png\" alt=\"模式\"></p>\n<p>Data Builders：在Addressable窗口菜单中能够选择的在编辑器下的数据构建模式，一般来说附带的这几个已经可以满足大部分要求，你也可以新建适合自己项目的模式。<br>Fast Mode：加载资源不通过资源包，直接使用AssetDatabase加载。<br>Virtual Mode：会形成AssetBundle布局，但是不需要打包，加载资源通过ResourcesManager加载，并且可以在RM Profiler中查看包体布局。<br>Packed Mode：需要额外步骤打包AssetBundle，运行时资源也是在AssetBundle中进行加载。</p>\n<h2 id=\"迁移指南\"><a href=\"#迁移指南\" class=\"headerlink\" title=\"迁移指南\"></a>迁移指南</h2><p><img src=\"/img/1579081015473.png\" alt=\"从自己框架移植\"></p>\n<p><img src=\"/img/1579081031342.png\" alt=\"从Resources移植\"></p>\n<h2 id=\"使用注意项：\"><a href=\"#使用注意项：\" class=\"headerlink\" title=\"使用注意项：\"></a>使用注意项：</h2><p>1.每调用一次Addressables.Instantiate方法，会将该Asset的引用计数加一；而Addressables.ReleaseInstance会减少这个引用计数。如果你使用Object.Destroy释放了它，则原始资源会一直存在于内存中。所以应当避免使用Object.Destroy方法了~<br>2.非使用 Addresables.Instantiate 方法实例化出来的对象，如使用Unity自带的Instantiate实例出来的对象，也可以使用Addressables.ReleaseInstance来释放，这并不会对计数有影响，只是单纯的释放。<br>3.任何通过Addresables.Instantiate 方法实例化出来的对象，在切换场景的时候，如果没有标记为 DontDestroyOnLoad ,则会被自动调用Addressables.ReleaseInstance来释放掉。</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ul>\n<li><ol>\n<li>出包时将自动带上catalog.json在包内，出包的时候不用带 catalogxxx.json 和catalog.hash文件</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>可使用接口随时重加载catalog文件。如：</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"csharp\">//注意： 一定要先清除所有resoucelocators\nAddressables.ClearResourceLocators();\n//重加载下载好的catalog文件\nawait Addressables.LoadContentCatalogAsync(Path.Combine(ResourceConfig.GetLocalBundlePath(), &quot;catalog.json&quot;),true).Task;</code></pre>\n<ol start=\"3\">\n<li>因此 ： 流程可采用如下的方式：<blockquote>\n<ol>\n<li>将设置好assetbundle provider，这里仍用旧的方式，对资源加载时的路径进行跳转限制，优先找SD卡资源，再找包体资源。</li>\n<li>出APK包，在 catalog打完包，在资源中不需要带，直接删除掉。资源+version.txt即可</li>\n<li>出资源包时，带上新名字的catalog文件作为清单。</li>\n<li>下载模块完全用自己实现！ 先加载SD卡的catalog文件，没有，则默认用包内的。 如果有新的，再次调用加载catalog，这样读取就是最新的。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Addressable？\"><a href=\"#什么是Addressable？\" class=\"headerlink\" title=\"什么是Addressable？\"></a>什么是Addressable？</h2><p><img src=\"/img/1579072055300.png\" alt=\"什么\"></p>\n<h2 id=\"Addressable的实例函数\"><a href=\"#Addressable的实例函数\" class=\"headerlink\" title=\"Addressable的实例函数\"></a>Addressable的实例函数</h2><p><img src=\"/img/1579077588215.png\" alt=\"实例函数\"></p>\n<h2 id=\"以label形式加载\"><a href=\"#以label形式加载\" class=\"headerlink\" title=\"以label形式加载\"></a>以label形式加载</h2><p><img src=\"/img/1579078623846.png\" alt=\"以label加载\"></p>\n<h2 id=\"模式选择\"><a href=\"#模式选择\" class=\"headerlink\" title=\"模式选择\"></a>模式选择</h2><p><img src=\"/img/1579078890824.png\" alt=\"模式\"></p>\n<p>Data Builders：在Addressable窗口菜单中能够选择的在编辑器下的数据构建模式，一般来说附带的这几个已经可以满足大部分要求，你也可以新建适合自己项目的模式。<br>Fast Mode：加载资源不通过资源包，直接使用AssetDatabase加载。<br>Virtual Mode：会形成AssetBundle布局，但是不需要打包，加载资源通过ResourcesManager加载，并且可以在RM Profiler中查看包体布局。<br>Packed Mode：需要额外步骤打包AssetBundle，运行时资源也是在AssetBundle中进行加载。</p>\n<h2 id=\"迁移指南\"><a href=\"#迁移指南\" class=\"headerlink\" title=\"迁移指南\"></a>迁移指南</h2><p><img src=\"/img/1579081015473.png\" alt=\"从自己框架移植\"></p>\n<p><img src=\"/img/1579081031342.png\" alt=\"从Resources移植\"></p>\n<h2 id=\"使用注意项：\"><a href=\"#使用注意项：\" class=\"headerlink\" title=\"使用注意项：\"></a>使用注意项：</h2><p>1.每调用一次Addressables.Instantiate方法，会将该Asset的引用计数加一；而Addressables.ReleaseInstance会减少这个引用计数。如果你使用Object.Destroy释放了它，则原始资源会一直存在于内存中。所以应当避免使用Object.Destroy方法了~<br>2.非使用 Addresables.Instantiate 方法实例化出来的对象，如使用Unity自带的Instantiate实例出来的对象，也可以使用Addressables.ReleaseInstance来释放，这并不会对计数有影响，只是单纯的释放。<br>3.任何通过Addresables.Instantiate 方法实例化出来的对象，在切换场景的时候，如果没有标记为 DontDestroyOnLoad ,则会被自动调用Addressables.ReleaseInstance来释放掉。</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ul>\n<li><ol>\n<li>出包时将自动带上catalog.json在包内，出包的时候不用带 catalogxxx.json 和catalog.hash文件</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>可使用接口随时重加载catalog文件。如：</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"csharp\">//注意： 一定要先清除所有resoucelocators\nAddressables.ClearResourceLocators();\n//重加载下载好的catalog文件\nawait Addressables.LoadContentCatalogAsync(Path.Combine(ResourceConfig.GetLocalBundlePath(), &quot;catalog.json&quot;),true).Task;</code></pre>\n<ol start=\"3\">\n<li>因此 ： 流程可采用如下的方式：<blockquote>\n<ol>\n<li>将设置好assetbundle provider，这里仍用旧的方式，对资源加载时的路径进行跳转限制，优先找SD卡资源，再找包体资源。</li>\n<li>出APK包，在 catalog打完包，在资源中不需要带，直接删除掉。资源+version.txt即可</li>\n<li>出资源包时，带上新名字的catalog文件作为清单。</li>\n<li>下载模块完全用自己实现！ 先加载SD卡的catalog文件，没有，则默认用包内的。 如果有新的，再次调用加载catalog，这样读取就是最新的。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n"},{"title":"Addressable打包流程","_content":"# 安卓打包流程\n\n## 1. [Python]  添加配置\n* 1.添加项目配置 vms/config/config.txt\n* 2.新建一个config文件到 vms/config/platform_{project}_{branch/version}.txt\n  \n >2的文件 将作为打包后项目带出去的platform.txt的模板\n > platform.txt在打包流程中 判断 branch是否以t开头，是则用1，否则用第一个字符设置为platformId\n \n\n ```python\n -------------------------------------------------\n   File Name：     ModifyJsonFileHandler\n   Author :       hujunhao\n   date：          2018/3/16 16:03\n   Description : 修改platform.txt文件\n-------------------------------------------------\n\"\"\"\nclass ModifyJsonFileHandler(BaseHandler):\n    def __init__(self):\n        super(ModifyJsonFileHandler, self).__init__(constants.H_MODIFY_JSON_FILE)\n        pass\n\n    def excute(self, args):\n        version = args[0]\n        publish_path = args[1]\n        plat_path = args[2]\n        to_path = args[3]\n\n        cur_date_time = datetime.datetime.now()\n        cur_date_time.strftime('%m%d%H%M')\n        publish_data = script.configMgr.load_file(publish_path)\n        ver_str = '%s_%s_%s_%s' % (\n            version, publish_data['appVersion'], publish_data['resVersion'], cur_date_time.strftime('%m%d%H%M'))\n\n        plat_data = script.configMgr.load_file(plat_path)\n        plat_data['verInfo'] = ver_str\n\n        # M by Yuk 2018-08-03\n        # 修复不同platformId被覆盖回默认platformId的bug\n        # platformId 取分支号\n        platformId = str(version[0])\n        if platformId == 't' or platformId == '0':\n            platformId = 1\n            pass\n        plat_data['platformId'] = platformId\n        \n        script.configMgr.save_file(plat_data, to_path)\n\n        return True\n\n    pass\n\n ```\n\n\n ## 2. [Python]  执行流程： B_PACK_RES  [Unity] :PackAllRes \n * 打包所有资源\n * 设置目录： res_ab: output\\testsg\\output\\res\\res_ab\n\n## 3.[Python] 执行流程：B_CREATE_PUBLISH [Unity]: UpdateVersionAndPublishFile\n* 创建项目内的publish.txt和xxx_version.txt\n  \n## 4.[Python] 执行流程：B_BUILD_PROJECT [Unity]: BuildProject\n* 生成安卓工程\n* 将调用Unity中对Manifest文件已经修改\n\n## 5.[Python] 执行流程：B_COMMIT_MOBILE \n* 将资源提交到SVN\n\n## 6.[Python] 执行流程：B_CREATE_ANDROID_APP \n* 生成安卓 apk。\n \n## 7.上传资源： [Python]: H_UPLOAD_CDN_COMPRESS\n * 上传本地生成的diff.txt中的文件到cdn\n * 内容示例如下：\n  ![diff文件内容](/img/1600238267260.png)\n \n## 8.打补丁包： [Python]：H_GENERATE_PATCH_CDN_COMPRESS\n * 输入参数: 起始版本，目标版本\n * 1. 获取两个版本的version文件\n * 2. 获取version中的catalogs, resources文件列表，以目标版本为准，起始版本中不同的记录到diff列表中\n * 3. 将diff列表中的文件遍历出，并压缩为 [start_version]_[target_version]patch.7z\n * 4.在目标版本的version文件中，添加压缩文件名到patchs字段\n * 5. 上传修改后的新的version文件\n * 结果如图：\n ![生成的364-384的补丁包](/img/1600238404872.png)\n\n\n# 加载流程\n## 1. 获取所有项目内版本号及version文件\n* GetLocalVersion 的System执行， 如图获取 resVersionInPack, resVersionInSD, appVersionInPack\n ![加载本地的版本号信息](/img/1600233059102.png)\n \n ## 2. 加载Addressable的Catelog\n * GetLocalVersion System结束时调用\n \n## 3. 加载服务端的md5文件，notice文件，server文件，version文件\n* GetServerList System执行\n* * Server的根地址： 包体内的plaform.txt指明的serverKey, mCenterUrl\n \n* md5文件: {mCenterUrl}static/md5/{mChannel}.json。 从其中获取如图内容\n![md5文件内容](/img/1600236947016.png)\n* notice文件： {mCenterUrl}static/notice/login/{mChannelKey}.json\n* server文件： {mCenterUrl}static/server/{mChannelKey}.json\n \n \n## 4. 判断是否需要强更？[非Editor]\n * DownloadApp System执行\n * 服务端给的APP版本号，如果比appVersionInPack要大，则强更，跳转到下载地址\n  \n  \n## 5. 更新资源文件 [非Editor] \n* DownloadUpdateFiles System执行\n* 服务端的res版本号，如果比(resVersionInPack与resVersionInSD中的最大者)大，则下载服务端的version文件\n\n* 服务端version文件： cdnUrl / Resources/[Android/iOS/Windows/Mac]/xxx_version.7z\n* 下载服务端版本文件并解压\n* 1.查找patches列表，如果存在 [resVersionInPack]_[服务端res_version]patch.7z 文件名，则进入补丁包快速下载流程\n* 2.未找到对应的patches记录，进入资源列表下载流程。\n  \n >A: 补丁包快速下载流程：\n > 1. 补丁包地址： cdnUrl / Resources/[Android/iOS/Windows/Mac]/[resVersionInPack]\\_[服务端res_version]patch.7z\n > 2. 解压补丁包到persistantData下，记录最新catalog名称，完成下载流程\n >B: 资源下载流程:\n> 对比得到 mCoreUpdateDic 必更资源列表，mAfterUpdateDic 随后（运行时）更新的资源列表\n> 结果： \n  1.mCoreUpdateDic与mAfterUpdateDic为空？ ： 将服务端的version文件复制到本地sd下\n  2.进行下载，并记录catelog文件名称，完成后，再次检测mCoreUpdateDic与mAfterUpdateDic，循环直到1成立\n  \n\n## 6. [再次]加载Addressable的Catelog\n * DownloadUpdateFiles System执行\n * 设置当前资源版本号为服务端\n \n## 7. 进入登录，执行LoginPreload, InitLua, EnterLogin进入游戏\n\n# 总体流程概述 \n![总体流程概述 ](/img/1600240709174.png)\n\n# CI后台系统\n\n## SVN资源目录结构\n![结构示例](/img/1600395139064.png)\n","source":"_posts/Addressable打包流程.md","raw":"---\ntitle: Addressable打包流程\ncategories:\n- 工作相关\ntags: \n- CI\n---\n# 安卓打包流程\n\n## 1. [Python]  添加配置\n* 1.添加项目配置 vms/config/config.txt\n* 2.新建一个config文件到 vms/config/platform_{project}_{branch/version}.txt\n  \n >2的文件 将作为打包后项目带出去的platform.txt的模板\n > platform.txt在打包流程中 判断 branch是否以t开头，是则用1，否则用第一个字符设置为platformId\n \n\n ```python\n -------------------------------------------------\n   File Name：     ModifyJsonFileHandler\n   Author :       hujunhao\n   date：          2018/3/16 16:03\n   Description : 修改platform.txt文件\n-------------------------------------------------\n\"\"\"\nclass ModifyJsonFileHandler(BaseHandler):\n    def __init__(self):\n        super(ModifyJsonFileHandler, self).__init__(constants.H_MODIFY_JSON_FILE)\n        pass\n\n    def excute(self, args):\n        version = args[0]\n        publish_path = args[1]\n        plat_path = args[2]\n        to_path = args[3]\n\n        cur_date_time = datetime.datetime.now()\n        cur_date_time.strftime('%m%d%H%M')\n        publish_data = script.configMgr.load_file(publish_path)\n        ver_str = '%s_%s_%s_%s' % (\n            version, publish_data['appVersion'], publish_data['resVersion'], cur_date_time.strftime('%m%d%H%M'))\n\n        plat_data = script.configMgr.load_file(plat_path)\n        plat_data['verInfo'] = ver_str\n\n        # M by Yuk 2018-08-03\n        # 修复不同platformId被覆盖回默认platformId的bug\n        # platformId 取分支号\n        platformId = str(version[0])\n        if platformId == 't' or platformId == '0':\n            platformId = 1\n            pass\n        plat_data['platformId'] = platformId\n        \n        script.configMgr.save_file(plat_data, to_path)\n\n        return True\n\n    pass\n\n ```\n\n\n ## 2. [Python]  执行流程： B_PACK_RES  [Unity] :PackAllRes \n * 打包所有资源\n * 设置目录： res_ab: output\\testsg\\output\\res\\res_ab\n\n## 3.[Python] 执行流程：B_CREATE_PUBLISH [Unity]: UpdateVersionAndPublishFile\n* 创建项目内的publish.txt和xxx_version.txt\n  \n## 4.[Python] 执行流程：B_BUILD_PROJECT [Unity]: BuildProject\n* 生成安卓工程\n* 将调用Unity中对Manifest文件已经修改\n\n## 5.[Python] 执行流程：B_COMMIT_MOBILE \n* 将资源提交到SVN\n\n## 6.[Python] 执行流程：B_CREATE_ANDROID_APP \n* 生成安卓 apk。\n \n## 7.上传资源： [Python]: H_UPLOAD_CDN_COMPRESS\n * 上传本地生成的diff.txt中的文件到cdn\n * 内容示例如下：\n  ![diff文件内容](/img/1600238267260.png)\n \n## 8.打补丁包： [Python]：H_GENERATE_PATCH_CDN_COMPRESS\n * 输入参数: 起始版本，目标版本\n * 1. 获取两个版本的version文件\n * 2. 获取version中的catalogs, resources文件列表，以目标版本为准，起始版本中不同的记录到diff列表中\n * 3. 将diff列表中的文件遍历出，并压缩为 [start_version]_[target_version]patch.7z\n * 4.在目标版本的version文件中，添加压缩文件名到patchs字段\n * 5. 上传修改后的新的version文件\n * 结果如图：\n ![生成的364-384的补丁包](/img/1600238404872.png)\n\n\n# 加载流程\n## 1. 获取所有项目内版本号及version文件\n* GetLocalVersion 的System执行， 如图获取 resVersionInPack, resVersionInSD, appVersionInPack\n ![加载本地的版本号信息](/img/1600233059102.png)\n \n ## 2. 加载Addressable的Catelog\n * GetLocalVersion System结束时调用\n \n## 3. 加载服务端的md5文件，notice文件，server文件，version文件\n* GetServerList System执行\n* * Server的根地址： 包体内的plaform.txt指明的serverKey, mCenterUrl\n \n* md5文件: {mCenterUrl}static/md5/{mChannel}.json。 从其中获取如图内容\n![md5文件内容](/img/1600236947016.png)\n* notice文件： {mCenterUrl}static/notice/login/{mChannelKey}.json\n* server文件： {mCenterUrl}static/server/{mChannelKey}.json\n \n \n## 4. 判断是否需要强更？[非Editor]\n * DownloadApp System执行\n * 服务端给的APP版本号，如果比appVersionInPack要大，则强更，跳转到下载地址\n  \n  \n## 5. 更新资源文件 [非Editor] \n* DownloadUpdateFiles System执行\n* 服务端的res版本号，如果比(resVersionInPack与resVersionInSD中的最大者)大，则下载服务端的version文件\n\n* 服务端version文件： cdnUrl / Resources/[Android/iOS/Windows/Mac]/xxx_version.7z\n* 下载服务端版本文件并解压\n* 1.查找patches列表，如果存在 [resVersionInPack]_[服务端res_version]patch.7z 文件名，则进入补丁包快速下载流程\n* 2.未找到对应的patches记录，进入资源列表下载流程。\n  \n >A: 补丁包快速下载流程：\n > 1. 补丁包地址： cdnUrl / Resources/[Android/iOS/Windows/Mac]/[resVersionInPack]\\_[服务端res_version]patch.7z\n > 2. 解压补丁包到persistantData下，记录最新catalog名称，完成下载流程\n >B: 资源下载流程:\n> 对比得到 mCoreUpdateDic 必更资源列表，mAfterUpdateDic 随后（运行时）更新的资源列表\n> 结果： \n  1.mCoreUpdateDic与mAfterUpdateDic为空？ ： 将服务端的version文件复制到本地sd下\n  2.进行下载，并记录catelog文件名称，完成后，再次检测mCoreUpdateDic与mAfterUpdateDic，循环直到1成立\n  \n\n## 6. [再次]加载Addressable的Catelog\n * DownloadUpdateFiles System执行\n * 设置当前资源版本号为服务端\n \n## 7. 进入登录，执行LoginPreload, InitLua, EnterLogin进入游戏\n\n# 总体流程概述 \n![总体流程概述 ](/img/1600240709174.png)\n\n# CI后台系统\n\n## SVN资源目录结构\n![结构示例](/img/1600395139064.png)\n","slug":"Addressable打包流程","published":1,"date":"2020-09-22T13:20:32.651Z","updated":"2020-09-22T13:20:32.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0y300054wf03r9j1wi1","content":"<h1 id=\"安卓打包流程\"><a href=\"#安卓打包流程\" class=\"headerlink\" title=\"安卓打包流程\"></a>安卓打包流程</h1><h2 id=\"1-Python-添加配置\"><a href=\"#1-Python-添加配置\" class=\"headerlink\" title=\"1. [Python]  添加配置\"></a>1. [Python]  添加配置</h2><ul>\n<li><p>1.添加项目配置 vms/config/config.txt</p>\n</li>\n<li><p>2.新建一个config文件到 vms/config/platform_{project}_{branch/version}.txt</p>\n<blockquote>\n<p>2的文件 将作为打包后项目带出去的platform.txt的模板<br>platform.txt在打包流程中 判断 branch是否以t开头，是则用1，否则用第一个字符设置为platformId</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"python\"> -------------------------------------------------\n   File Name：     ModifyJsonFileHandler\n   Author :       hujunhao\n   date：          2018/3/16 16:03\n   Description : 修改platform.txt文件\n-------------------------------------------------\n&quot;&quot;&quot;\nclass ModifyJsonFileHandler(BaseHandler):\n    def __init__(self):\n        super(ModifyJsonFileHandler, self).__init__(constants.H_MODIFY_JSON_FILE)\n        pass\n\n    def excute(self, args):\n        version = args[0]\n        publish_path = args[1]\n        plat_path = args[2]\n        to_path = args[3]\n\n        cur_date_time = datetime.datetime.now()\n        cur_date_time.strftime(&#39;%m%d%H%M&#39;)\n        publish_data = script.configMgr.load_file(publish_path)\n        ver_str = &#39;%s_%s_%s_%s&#39; % (\n            version, publish_data[&#39;appVersion&#39;], publish_data[&#39;resVersion&#39;], cur_date_time.strftime(&#39;%m%d%H%M&#39;))\n\n        plat_data = script.configMgr.load_file(plat_path)\n        plat_data[&#39;verInfo&#39;] = ver_str\n\n        # M by Yuk 2018-08-03\n        # 修复不同platformId被覆盖回默认platformId的bug\n        # platformId 取分支号\n        platformId = str(version[0])\n        if platformId == &#39;t&#39; or platformId == &#39;0&#39;:\n            platformId = 1\n            pass\n        plat_data[&#39;platformId&#39;] = platformId\n\n        script.configMgr.save_file(plat_data, to_path)\n\n        return True\n\n    pass\n</code></pre>\n<h2 id=\"2-Python-执行流程：-B-PACK-RES-Unity-PackAllRes\"><a href=\"#2-Python-执行流程：-B-PACK-RES-Unity-PackAllRes\" class=\"headerlink\" title=\"2. [Python]  执行流程： B_PACK_RES  [Unity] :PackAllRes\"></a>2. [Python]  执行流程： B_PACK_RES  [Unity] :PackAllRes</h2><ul>\n<li>打包所有资源</li>\n<li>设置目录： res_ab: output\\testsg\\output\\res\\res_ab</li>\n</ul>\n<h2 id=\"3-Python-执行流程：B-CREATE-PUBLISH-Unity-UpdateVersionAndPublishFile\"><a href=\"#3-Python-执行流程：B-CREATE-PUBLISH-Unity-UpdateVersionAndPublishFile\" class=\"headerlink\" title=\"3.[Python] 执行流程：B_CREATE_PUBLISH [Unity]: UpdateVersionAndPublishFile\"></a>3.[Python] 执行流程：B_CREATE_PUBLISH [Unity]: UpdateVersionAndPublishFile</h2><ul>\n<li>创建项目内的publish.txt和xxx_version.txt</li>\n</ul>\n<h2 id=\"4-Python-执行流程：B-BUILD-PROJECT-Unity-BuildProject\"><a href=\"#4-Python-执行流程：B-BUILD-PROJECT-Unity-BuildProject\" class=\"headerlink\" title=\"4.[Python] 执行流程：B_BUILD_PROJECT [Unity]: BuildProject\"></a>4.[Python] 执行流程：B_BUILD_PROJECT [Unity]: BuildProject</h2><ul>\n<li>生成安卓工程</li>\n<li>将调用Unity中对Manifest文件已经修改</li>\n</ul>\n<h2 id=\"5-Python-执行流程：B-COMMIT-MOBILE\"><a href=\"#5-Python-执行流程：B-COMMIT-MOBILE\" class=\"headerlink\" title=\"5.[Python] 执行流程：B_COMMIT_MOBILE\"></a>5.[Python] 执行流程：B_COMMIT_MOBILE</h2><ul>\n<li>将资源提交到SVN</li>\n</ul>\n<h2 id=\"6-Python-执行流程：B-CREATE-ANDROID-APP\"><a href=\"#6-Python-执行流程：B-CREATE-ANDROID-APP\" class=\"headerlink\" title=\"6.[Python] 执行流程：B_CREATE_ANDROID_APP\"></a>6.[Python] 执行流程：B_CREATE_ANDROID_APP</h2><ul>\n<li>生成安卓 apk。</li>\n</ul>\n<h2 id=\"7-上传资源：-Python-H-UPLOAD-CDN-COMPRESS\"><a href=\"#7-上传资源：-Python-H-UPLOAD-CDN-COMPRESS\" class=\"headerlink\" title=\"7.上传资源： [Python]: H_UPLOAD_CDN_COMPRESS\"></a>7.上传资源： [Python]: H_UPLOAD_CDN_COMPRESS</h2><ul>\n<li>上传本地生成的diff.txt中的文件到cdn</li>\n<li>内容示例如下：<br><img src=\"/img/1600238267260.png\" alt=\"diff文件内容\"></li>\n</ul>\n<h2 id=\"8-打补丁包：-Python-：H-GENERATE-PATCH-CDN-COMPRESS\"><a href=\"#8-打补丁包：-Python-：H-GENERATE-PATCH-CDN-COMPRESS\" class=\"headerlink\" title=\"8.打补丁包： [Python]：H_GENERATE_PATCH_CDN_COMPRESS\"></a>8.打补丁包： [Python]：H_GENERATE_PATCH_CDN_COMPRESS</h2><ul>\n<li>输入参数: 起始版本，目标版本</li>\n<li><ol>\n<li>获取两个版本的version文件</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>获取version中的catalogs, resources文件列表，以目标版本为准，起始版本中不同的记录到diff列表中</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>将diff列表中的文件遍历出，并压缩为 [start_version]_[target_version]patch.7z</li>\n</ol>\n</li>\n<li>4.在目标版本的version文件中，添加压缩文件名到patchs字段</li>\n<li><ol start=\"5\">\n<li>上传修改后的新的version文件</li>\n</ol>\n</li>\n<li>结果如图：<br><img src=\"/img/1600238404872.png\" alt=\"生成的364-384的补丁包\"></li>\n</ul>\n<h1 id=\"加载流程\"><a href=\"#加载流程\" class=\"headerlink\" title=\"加载流程\"></a>加载流程</h1><h2 id=\"1-获取所有项目内版本号及version文件\"><a href=\"#1-获取所有项目内版本号及version文件\" class=\"headerlink\" title=\"1. 获取所有项目内版本号及version文件\"></a>1. 获取所有项目内版本号及version文件</h2><ul>\n<li><p>GetLocalVersion 的System执行， 如图获取 resVersionInPack, resVersionInSD, appVersionInPack<br><img src=\"/img/1600233059102.png\" alt=\"加载本地的版本号信息\"></p>\n<h2 id=\"2-加载Addressable的Catelog\"><a href=\"#2-加载Addressable的Catelog\" class=\"headerlink\" title=\"2. 加载Addressable的Catelog\"></a>2. 加载Addressable的Catelog</h2><ul>\n<li>GetLocalVersion System结束时调用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-加载服务端的md5文件，notice文件，server文件，version文件\"><a href=\"#3-加载服务端的md5文件，notice文件，server文件，version文件\" class=\"headerlink\" title=\"3. 加载服务端的md5文件，notice文件，server文件，version文件\"></a>3. 加载服务端的md5文件，notice文件，server文件，version文件</h2><ul>\n<li><p>GetServerList System执行</p>\n</li>\n<li><ul>\n<li>Server的根地址： 包体内的plaform.txt指明的serverKey, mCenterUrl</li>\n</ul>\n</li>\n<li><p>md5文件: {mCenterUrl}static/md5/{mChannel}.json。 从其中获取如图内容<br><img src=\"/img/1600236947016.png\" alt=\"md5文件内容\"></p>\n</li>\n<li><p>notice文件： {mCenterUrl}static/notice/login/{mChannelKey}.json</p>\n</li>\n<li><p>server文件： {mCenterUrl}static/server/{mChannelKey}.json</p>\n</li>\n</ul>\n<h2 id=\"4-判断是否需要强更？-非Editor\"><a href=\"#4-判断是否需要强更？-非Editor\" class=\"headerlink\" title=\"4. 判断是否需要强更？[非Editor]\"></a>4. 判断是否需要强更？[非Editor]</h2><ul>\n<li>DownloadApp System执行</li>\n<li>服务端给的APP版本号，如果比appVersionInPack要大，则强更，跳转到下载地址</li>\n</ul>\n<h2 id=\"5-更新资源文件-非Editor\"><a href=\"#5-更新资源文件-非Editor\" class=\"headerlink\" title=\"5. 更新资源文件 [非Editor]\"></a>5. 更新资源文件 [非Editor]</h2><ul>\n<li><p>DownloadUpdateFiles System执行</p>\n</li>\n<li><p>服务端的res版本号，如果比(resVersionInPack与resVersionInSD中的最大者)大，则下载服务端的version文件</p>\n</li>\n<li><p>服务端version文件： cdnUrl / Resources/[Android/iOS/Windows/Mac]/xxx_version.7z</p>\n</li>\n<li><p>下载服务端版本文件并解压</p>\n</li>\n<li><p>1.查找patches列表，如果存在 [resVersionInPack]_[服务端res_version]patch.7z 文件名，则进入补丁包快速下载流程</p>\n</li>\n<li><p>2.未找到对应的patches记录，进入资源列表下载流程。</p>\n<blockquote>\n<p>A: 补丁包快速下载流程：</p>\n<ol>\n<li>补丁包地址： cdnUrl / Resources/[Android/iOS/Windows/Mac]/[resVersionInPack]_[服务端res_version]patch.7z</li>\n<li>解压补丁包到persistantData下，记录最新catalog名称，完成下载流程<br>B: 资源下载流程:<br>对比得到 mCoreUpdateDic 必更资源列表，mAfterUpdateDic 随后（运行时）更新的资源列表<br>结果： </li>\n<li>mCoreUpdateDic与mAfterUpdateDic为空？ ： 将服务端的version文件复制到本地sd下</li>\n<li>进行下载，并记录catelog文件名称，完成后，再次检测mCoreUpdateDic与mAfterUpdateDic，循环直到1成立</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"6-再次-加载Addressable的Catelog\"><a href=\"#6-再次-加载Addressable的Catelog\" class=\"headerlink\" title=\"6. [再次]加载Addressable的Catelog\"></a>6. [再次]加载Addressable的Catelog</h2><ul>\n<li>DownloadUpdateFiles System执行</li>\n<li>设置当前资源版本号为服务端</li>\n</ul>\n<h2 id=\"7-进入登录，执行LoginPreload-InitLua-EnterLogin进入游戏\"><a href=\"#7-进入登录，执行LoginPreload-InitLua-EnterLogin进入游戏\" class=\"headerlink\" title=\"7. 进入登录，执行LoginPreload, InitLua, EnterLogin进入游戏\"></a>7. 进入登录，执行LoginPreload, InitLua, EnterLogin进入游戏</h2><h1 id=\"总体流程概述\"><a href=\"#总体流程概述\" class=\"headerlink\" title=\"总体流程概述\"></a>总体流程概述</h1><p><img src=\"/img/1600240709174.png\" alt=\"总体流程概述 \"></p>\n<h1 id=\"CI后台系统\"><a href=\"#CI后台系统\" class=\"headerlink\" title=\"CI后台系统\"></a>CI后台系统</h1><h2 id=\"SVN资源目录结构\"><a href=\"#SVN资源目录结构\" class=\"headerlink\" title=\"SVN资源目录结构\"></a>SVN资源目录结构</h2><p><img src=\"/img/1600395139064.png\" alt=\"结构示例\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"安卓打包流程\"><a href=\"#安卓打包流程\" class=\"headerlink\" title=\"安卓打包流程\"></a>安卓打包流程</h1><h2 id=\"1-Python-添加配置\"><a href=\"#1-Python-添加配置\" class=\"headerlink\" title=\"1. [Python]  添加配置\"></a>1. [Python]  添加配置</h2><ul>\n<li><p>1.添加项目配置 vms/config/config.txt</p>\n</li>\n<li><p>2.新建一个config文件到 vms/config/platform_{project}_{branch/version}.txt</p>\n<blockquote>\n<p>2的文件 将作为打包后项目带出去的platform.txt的模板<br>platform.txt在打包流程中 判断 branch是否以t开头，是则用1，否则用第一个字符设置为platformId</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"python\"> -------------------------------------------------\n   File Name：     ModifyJsonFileHandler\n   Author :       hujunhao\n   date：          2018/3/16 16:03\n   Description : 修改platform.txt文件\n-------------------------------------------------\n&quot;&quot;&quot;\nclass ModifyJsonFileHandler(BaseHandler):\n    def __init__(self):\n        super(ModifyJsonFileHandler, self).__init__(constants.H_MODIFY_JSON_FILE)\n        pass\n\n    def excute(self, args):\n        version = args[0]\n        publish_path = args[1]\n        plat_path = args[2]\n        to_path = args[3]\n\n        cur_date_time = datetime.datetime.now()\n        cur_date_time.strftime(&#39;%m%d%H%M&#39;)\n        publish_data = script.configMgr.load_file(publish_path)\n        ver_str = &#39;%s_%s_%s_%s&#39; % (\n            version, publish_data[&#39;appVersion&#39;], publish_data[&#39;resVersion&#39;], cur_date_time.strftime(&#39;%m%d%H%M&#39;))\n\n        plat_data = script.configMgr.load_file(plat_path)\n        plat_data[&#39;verInfo&#39;] = ver_str\n\n        # M by Yuk 2018-08-03\n        # 修复不同platformId被覆盖回默认platformId的bug\n        # platformId 取分支号\n        platformId = str(version[0])\n        if platformId == &#39;t&#39; or platformId == &#39;0&#39;:\n            platformId = 1\n            pass\n        plat_data[&#39;platformId&#39;] = platformId\n\n        script.configMgr.save_file(plat_data, to_path)\n\n        return True\n\n    pass\n</code></pre>\n<h2 id=\"2-Python-执行流程：-B-PACK-RES-Unity-PackAllRes\"><a href=\"#2-Python-执行流程：-B-PACK-RES-Unity-PackAllRes\" class=\"headerlink\" title=\"2. [Python]  执行流程： B_PACK_RES  [Unity] :PackAllRes\"></a>2. [Python]  执行流程： B_PACK_RES  [Unity] :PackAllRes</h2><ul>\n<li>打包所有资源</li>\n<li>设置目录： res_ab: output\\testsg\\output\\res\\res_ab</li>\n</ul>\n<h2 id=\"3-Python-执行流程：B-CREATE-PUBLISH-Unity-UpdateVersionAndPublishFile\"><a href=\"#3-Python-执行流程：B-CREATE-PUBLISH-Unity-UpdateVersionAndPublishFile\" class=\"headerlink\" title=\"3.[Python] 执行流程：B_CREATE_PUBLISH [Unity]: UpdateVersionAndPublishFile\"></a>3.[Python] 执行流程：B_CREATE_PUBLISH [Unity]: UpdateVersionAndPublishFile</h2><ul>\n<li>创建项目内的publish.txt和xxx_version.txt</li>\n</ul>\n<h2 id=\"4-Python-执行流程：B-BUILD-PROJECT-Unity-BuildProject\"><a href=\"#4-Python-执行流程：B-BUILD-PROJECT-Unity-BuildProject\" class=\"headerlink\" title=\"4.[Python] 执行流程：B_BUILD_PROJECT [Unity]: BuildProject\"></a>4.[Python] 执行流程：B_BUILD_PROJECT [Unity]: BuildProject</h2><ul>\n<li>生成安卓工程</li>\n<li>将调用Unity中对Manifest文件已经修改</li>\n</ul>\n<h2 id=\"5-Python-执行流程：B-COMMIT-MOBILE\"><a href=\"#5-Python-执行流程：B-COMMIT-MOBILE\" class=\"headerlink\" title=\"5.[Python] 执行流程：B_COMMIT_MOBILE\"></a>5.[Python] 执行流程：B_COMMIT_MOBILE</h2><ul>\n<li>将资源提交到SVN</li>\n</ul>\n<h2 id=\"6-Python-执行流程：B-CREATE-ANDROID-APP\"><a href=\"#6-Python-执行流程：B-CREATE-ANDROID-APP\" class=\"headerlink\" title=\"6.[Python] 执行流程：B_CREATE_ANDROID_APP\"></a>6.[Python] 执行流程：B_CREATE_ANDROID_APP</h2><ul>\n<li>生成安卓 apk。</li>\n</ul>\n<h2 id=\"7-上传资源：-Python-H-UPLOAD-CDN-COMPRESS\"><a href=\"#7-上传资源：-Python-H-UPLOAD-CDN-COMPRESS\" class=\"headerlink\" title=\"7.上传资源： [Python]: H_UPLOAD_CDN_COMPRESS\"></a>7.上传资源： [Python]: H_UPLOAD_CDN_COMPRESS</h2><ul>\n<li>上传本地生成的diff.txt中的文件到cdn</li>\n<li>内容示例如下：<br><img src=\"/img/1600238267260.png\" alt=\"diff文件内容\"></li>\n</ul>\n<h2 id=\"8-打补丁包：-Python-：H-GENERATE-PATCH-CDN-COMPRESS\"><a href=\"#8-打补丁包：-Python-：H-GENERATE-PATCH-CDN-COMPRESS\" class=\"headerlink\" title=\"8.打补丁包： [Python]：H_GENERATE_PATCH_CDN_COMPRESS\"></a>8.打补丁包： [Python]：H_GENERATE_PATCH_CDN_COMPRESS</h2><ul>\n<li>输入参数: 起始版本，目标版本</li>\n<li><ol>\n<li>获取两个版本的version文件</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>获取version中的catalogs, resources文件列表，以目标版本为准，起始版本中不同的记录到diff列表中</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>将diff列表中的文件遍历出，并压缩为 [start_version]_[target_version]patch.7z</li>\n</ol>\n</li>\n<li>4.在目标版本的version文件中，添加压缩文件名到patchs字段</li>\n<li><ol start=\"5\">\n<li>上传修改后的新的version文件</li>\n</ol>\n</li>\n<li>结果如图：<br><img src=\"/img/1600238404872.png\" alt=\"生成的364-384的补丁包\"></li>\n</ul>\n<h1 id=\"加载流程\"><a href=\"#加载流程\" class=\"headerlink\" title=\"加载流程\"></a>加载流程</h1><h2 id=\"1-获取所有项目内版本号及version文件\"><a href=\"#1-获取所有项目内版本号及version文件\" class=\"headerlink\" title=\"1. 获取所有项目内版本号及version文件\"></a>1. 获取所有项目内版本号及version文件</h2><ul>\n<li><p>GetLocalVersion 的System执行， 如图获取 resVersionInPack, resVersionInSD, appVersionInPack<br><img src=\"/img/1600233059102.png\" alt=\"加载本地的版本号信息\"></p>\n<h2 id=\"2-加载Addressable的Catelog\"><a href=\"#2-加载Addressable的Catelog\" class=\"headerlink\" title=\"2. 加载Addressable的Catelog\"></a>2. 加载Addressable的Catelog</h2><ul>\n<li>GetLocalVersion System结束时调用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-加载服务端的md5文件，notice文件，server文件，version文件\"><a href=\"#3-加载服务端的md5文件，notice文件，server文件，version文件\" class=\"headerlink\" title=\"3. 加载服务端的md5文件，notice文件，server文件，version文件\"></a>3. 加载服务端的md5文件，notice文件，server文件，version文件</h2><ul>\n<li><p>GetServerList System执行</p>\n</li>\n<li><ul>\n<li>Server的根地址： 包体内的plaform.txt指明的serverKey, mCenterUrl</li>\n</ul>\n</li>\n<li><p>md5文件: {mCenterUrl}static/md5/{mChannel}.json。 从其中获取如图内容<br><img src=\"/img/1600236947016.png\" alt=\"md5文件内容\"></p>\n</li>\n<li><p>notice文件： {mCenterUrl}static/notice/login/{mChannelKey}.json</p>\n</li>\n<li><p>server文件： {mCenterUrl}static/server/{mChannelKey}.json</p>\n</li>\n</ul>\n<h2 id=\"4-判断是否需要强更？-非Editor\"><a href=\"#4-判断是否需要强更？-非Editor\" class=\"headerlink\" title=\"4. 判断是否需要强更？[非Editor]\"></a>4. 判断是否需要强更？[非Editor]</h2><ul>\n<li>DownloadApp System执行</li>\n<li>服务端给的APP版本号，如果比appVersionInPack要大，则强更，跳转到下载地址</li>\n</ul>\n<h2 id=\"5-更新资源文件-非Editor\"><a href=\"#5-更新资源文件-非Editor\" class=\"headerlink\" title=\"5. 更新资源文件 [非Editor]\"></a>5. 更新资源文件 [非Editor]</h2><ul>\n<li><p>DownloadUpdateFiles System执行</p>\n</li>\n<li><p>服务端的res版本号，如果比(resVersionInPack与resVersionInSD中的最大者)大，则下载服务端的version文件</p>\n</li>\n<li><p>服务端version文件： cdnUrl / Resources/[Android/iOS/Windows/Mac]/xxx_version.7z</p>\n</li>\n<li><p>下载服务端版本文件并解压</p>\n</li>\n<li><p>1.查找patches列表，如果存在 [resVersionInPack]_[服务端res_version]patch.7z 文件名，则进入补丁包快速下载流程</p>\n</li>\n<li><p>2.未找到对应的patches记录，进入资源列表下载流程。</p>\n<blockquote>\n<p>A: 补丁包快速下载流程：</p>\n<ol>\n<li>补丁包地址： cdnUrl / Resources/[Android/iOS/Windows/Mac]/[resVersionInPack]_[服务端res_version]patch.7z</li>\n<li>解压补丁包到persistantData下，记录最新catalog名称，完成下载流程<br>B: 资源下载流程:<br>对比得到 mCoreUpdateDic 必更资源列表，mAfterUpdateDic 随后（运行时）更新的资源列表<br>结果： </li>\n<li>mCoreUpdateDic与mAfterUpdateDic为空？ ： 将服务端的version文件复制到本地sd下</li>\n<li>进行下载，并记录catelog文件名称，完成后，再次检测mCoreUpdateDic与mAfterUpdateDic，循环直到1成立</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"6-再次-加载Addressable的Catelog\"><a href=\"#6-再次-加载Addressable的Catelog\" class=\"headerlink\" title=\"6. [再次]加载Addressable的Catelog\"></a>6. [再次]加载Addressable的Catelog</h2><ul>\n<li>DownloadUpdateFiles System执行</li>\n<li>设置当前资源版本号为服务端</li>\n</ul>\n<h2 id=\"7-进入登录，执行LoginPreload-InitLua-EnterLogin进入游戏\"><a href=\"#7-进入登录，执行LoginPreload-InitLua-EnterLogin进入游戏\" class=\"headerlink\" title=\"7. 进入登录，执行LoginPreload, InitLua, EnterLogin进入游戏\"></a>7. 进入登录，执行LoginPreload, InitLua, EnterLogin进入游戏</h2><h1 id=\"总体流程概述\"><a href=\"#总体流程概述\" class=\"headerlink\" title=\"总体流程概述\"></a>总体流程概述</h1><p><img src=\"/img/1600240709174.png\" alt=\"总体流程概述 \"></p>\n<h1 id=\"CI后台系统\"><a href=\"#CI后台系统\" class=\"headerlink\" title=\"CI后台系统\"></a>CI后台系统</h1><h2 id=\"SVN资源目录结构\"><a href=\"#SVN资源目录结构\" class=\"headerlink\" title=\"SVN资源目录结构\"></a>SVN资源目录结构</h2><p><img src=\"/img/1600395139064.png\" alt=\"结构示例\"></p>\n"},{"title":"DOTS-事件","_content":"\n### 方式一、使用NativeQueue循环检测\n* 1. 获取JOB可写的多线程NativeQueue对象\n```c#\nNativeQueue<PipePassedEvent>.ParallelWriter eventQueueParallel = eventQueue.AsParallelWriter();\n```\n\n* 2. 发出事件\n```c#\neventQueueParallel.Enqueue(new PipePassedEvent());\n```\n\n* 3. 事件机\n```c#\nwhile (eventQueue.TryDequeue(out PipePassedEvent evnt))\n        {\n            //Debug.Log(\"Get EVENT!!\");\n            OnPipePassed?.Invoke(this, EventArgs.Empty);\n        }\n```\n\n4.接收事件\n```c#\nWorld.DefaultGameObjectInjectionWorld.GetOrCreateSystem<PipeMoveSystem_Done>().OnPipePassed += TestingDOTSEvents_OnPipePassed;\n```\n\n\n### 方式二、使用EntityCommandBuffer\n\n* 1. 获取CommandBuffer的System\n* 2. 从System中创建一个commandbuffer, 并拿其Concurrent\n* 3. 利用2的concurrent就可以在job中创建一个entity.\n* 4.使用Entities.WithoutBurst().ForEach执行触发事件，并在触发完后一定将entity删除掉。\n\n```c#\n EntityCommandBuffer entityCommandBuffer = endSimulationEntityCommandBufferSystem.CreateCommandBuffer();\n        EntityCommandBuffer.Concurrent entityCommandBufferConcurrent = entityCommandBuffer.ToConcurrent();\n        EntityArchetype eventEntityArchetype = EntityManager.CreateArchetype(typeof(EventComponent));\n\n        double ElapsedTime = Time.ElapsedTime;\n\n        JobHandle jobHandle = Entities.ForEach((int entityInQueryIndex, ref Translation translation, ref Pipe pipe) => {\n            float xBefore = translation.Value.x;\n            translation.Value += moveDir * moveSpeed * deltaTime;\n            float xAfter = translation.Value.x;\n\n            if (pipe.isBottom && xBefore > 0 && xAfter <= 0) {\n                // Passed the Player\n                Entity eventEntity = entityCommandBufferConcurrent.CreateEntity(entityInQueryIndex, eventEntityArchetype);\n                entityCommandBufferConcurrent.SetComponent(entityInQueryIndex, eventEntity, new EventComponent {\n                    ElapsedTime = ElapsedTime\n                });\n            }\n        }).Schedule(inputDeps);\n\n        endSimulationEntityCommandBufferSystem.AddJobHandleForProducer(jobHandle);\n\n        EntityCommandBuffer captureEventsEntityCommandBuffer = endSimulationEntityCommandBufferSystem.CreateCommandBuffer();\n\n        Entities.WithoutBurst().ForEach((Entity entity, ref EventComponent eventComponent) => {\n            Debug.Log(eventComponent.ElapsedTime + \" ### \" + ElapsedTime);\n            OnPipePassed?.Invoke(this, EventArgs.Empty);\n            captureEventsEntityCommandBuffer.DestroyEntity(entity);\n        }).Run();\n```\n\n>  不用EndSimulationEntityCommandBufferSystem 也可以直接定义EntityCommandBuffer。只要在 job complete时，手动dispose()即可。\n```c#\nentityCommandBuffer.Playback(EntityManager);\n        entityCommandBuffer.Dispose();\n```","source":"_posts/DOTS-事件.md","raw":"---\ntitle: DOTS-事件\ncategories:\n- Unity\n---\n\n### 方式一、使用NativeQueue循环检测\n* 1. 获取JOB可写的多线程NativeQueue对象\n```c#\nNativeQueue<PipePassedEvent>.ParallelWriter eventQueueParallel = eventQueue.AsParallelWriter();\n```\n\n* 2. 发出事件\n```c#\neventQueueParallel.Enqueue(new PipePassedEvent());\n```\n\n* 3. 事件机\n```c#\nwhile (eventQueue.TryDequeue(out PipePassedEvent evnt))\n        {\n            //Debug.Log(\"Get EVENT!!\");\n            OnPipePassed?.Invoke(this, EventArgs.Empty);\n        }\n```\n\n4.接收事件\n```c#\nWorld.DefaultGameObjectInjectionWorld.GetOrCreateSystem<PipeMoveSystem_Done>().OnPipePassed += TestingDOTSEvents_OnPipePassed;\n```\n\n\n### 方式二、使用EntityCommandBuffer\n\n* 1. 获取CommandBuffer的System\n* 2. 从System中创建一个commandbuffer, 并拿其Concurrent\n* 3. 利用2的concurrent就可以在job中创建一个entity.\n* 4.使用Entities.WithoutBurst().ForEach执行触发事件，并在触发完后一定将entity删除掉。\n\n```c#\n EntityCommandBuffer entityCommandBuffer = endSimulationEntityCommandBufferSystem.CreateCommandBuffer();\n        EntityCommandBuffer.Concurrent entityCommandBufferConcurrent = entityCommandBuffer.ToConcurrent();\n        EntityArchetype eventEntityArchetype = EntityManager.CreateArchetype(typeof(EventComponent));\n\n        double ElapsedTime = Time.ElapsedTime;\n\n        JobHandle jobHandle = Entities.ForEach((int entityInQueryIndex, ref Translation translation, ref Pipe pipe) => {\n            float xBefore = translation.Value.x;\n            translation.Value += moveDir * moveSpeed * deltaTime;\n            float xAfter = translation.Value.x;\n\n            if (pipe.isBottom && xBefore > 0 && xAfter <= 0) {\n                // Passed the Player\n                Entity eventEntity = entityCommandBufferConcurrent.CreateEntity(entityInQueryIndex, eventEntityArchetype);\n                entityCommandBufferConcurrent.SetComponent(entityInQueryIndex, eventEntity, new EventComponent {\n                    ElapsedTime = ElapsedTime\n                });\n            }\n        }).Schedule(inputDeps);\n\n        endSimulationEntityCommandBufferSystem.AddJobHandleForProducer(jobHandle);\n\n        EntityCommandBuffer captureEventsEntityCommandBuffer = endSimulationEntityCommandBufferSystem.CreateCommandBuffer();\n\n        Entities.WithoutBurst().ForEach((Entity entity, ref EventComponent eventComponent) => {\n            Debug.Log(eventComponent.ElapsedTime + \" ### \" + ElapsedTime);\n            OnPipePassed?.Invoke(this, EventArgs.Empty);\n            captureEventsEntityCommandBuffer.DestroyEntity(entity);\n        }).Run();\n```\n\n>  不用EndSimulationEntityCommandBufferSystem 也可以直接定义EntityCommandBuffer。只要在 job complete时，手动dispose()即可。\n```c#\nentityCommandBuffer.Playback(EntityManager);\n        entityCommandBuffer.Dispose();\n```","slug":"DOTS-事件","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0y600064wf0ahaa3swg","content":"<h3 id=\"方式一、使用NativeQueue循环检测\"><a href=\"#方式一、使用NativeQueue循环检测\" class=\"headerlink\" title=\"方式一、使用NativeQueue循环检测\"></a>方式一、使用NativeQueue循环检测</h3><ul>\n<li><ol>\n<li>获取JOB可写的多线程NativeQueue对象<pre><code class=\"c#\">NativeQueue&lt;PipePassedEvent&gt;.ParallelWriter eventQueueParallel = eventQueue.AsParallelWriter();</code></pre>\n</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>发出事件<pre><code class=\"c#\">eventQueueParallel.Enqueue(new PipePassedEvent());</code></pre>\n</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>事件机<pre><code class=\"c#\">while (eventQueue.TryDequeue(out PipePassedEvent evnt))\n   {\n       //Debug.Log(&quot;Get EVENT!!&quot;);\n       OnPipePassed?.Invoke(this, EventArgs.Empty);\n   }</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<p>4.接收事件</p>\n<pre><code class=\"c#\">World.DefaultGameObjectInjectionWorld.GetOrCreateSystem&lt;PipeMoveSystem_Done&gt;().OnPipePassed += TestingDOTSEvents_OnPipePassed;</code></pre>\n<h3 id=\"方式二、使用EntityCommandBuffer\"><a href=\"#方式二、使用EntityCommandBuffer\" class=\"headerlink\" title=\"方式二、使用EntityCommandBuffer\"></a>方式二、使用EntityCommandBuffer</h3><ul>\n<li><ol>\n<li>获取CommandBuffer的System</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>从System中创建一个commandbuffer, 并拿其Concurrent</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>利用2的concurrent就可以在job中创建一个entity.</li>\n</ol>\n</li>\n<li>4.使用Entities.WithoutBurst().ForEach执行触发事件，并在触发完后一定将entity删除掉。</li>\n</ul>\n<pre><code class=\"c#\"> EntityCommandBuffer entityCommandBuffer = endSimulationEntityCommandBufferSystem.CreateCommandBuffer();\n        EntityCommandBuffer.Concurrent entityCommandBufferConcurrent = entityCommandBuffer.ToConcurrent();\n        EntityArchetype eventEntityArchetype = EntityManager.CreateArchetype(typeof(EventComponent));\n\n        double ElapsedTime = Time.ElapsedTime;\n\n        JobHandle jobHandle = Entities.ForEach((int entityInQueryIndex, ref Translation translation, ref Pipe pipe) =&gt; {\n            float xBefore = translation.Value.x;\n            translation.Value += moveDir * moveSpeed * deltaTime;\n            float xAfter = translation.Value.x;\n\n            if (pipe.isBottom &amp;&amp; xBefore &gt; 0 &amp;&amp; xAfter &lt;= 0) {\n                // Passed the Player\n                Entity eventEntity = entityCommandBufferConcurrent.CreateEntity(entityInQueryIndex, eventEntityArchetype);\n                entityCommandBufferConcurrent.SetComponent(entityInQueryIndex, eventEntity, new EventComponent {\n                    ElapsedTime = ElapsedTime\n                });\n            }\n        }).Schedule(inputDeps);\n\n        endSimulationEntityCommandBufferSystem.AddJobHandleForProducer(jobHandle);\n\n        EntityCommandBuffer captureEventsEntityCommandBuffer = endSimulationEntityCommandBufferSystem.CreateCommandBuffer();\n\n        Entities.WithoutBurst().ForEach((Entity entity, ref EventComponent eventComponent) =&gt; {\n            Debug.Log(eventComponent.ElapsedTime + &quot; ### &quot; + ElapsedTime);\n            OnPipePassed?.Invoke(this, EventArgs.Empty);\n            captureEventsEntityCommandBuffer.DestroyEntity(entity);\n        }).Run();</code></pre>\n<blockquote>\n<p> 不用EndSimulationEntityCommandBufferSystem 也可以直接定义EntityCommandBuffer。只要在 job complete时，手动dispose()即可。</p>\n</blockquote>\n<pre><code class=\"c#\">entityCommandBuffer.Playback(EntityManager);\n        entityCommandBuffer.Dispose();</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"方式一、使用NativeQueue循环检测\"><a href=\"#方式一、使用NativeQueue循环检测\" class=\"headerlink\" title=\"方式一、使用NativeQueue循环检测\"></a>方式一、使用NativeQueue循环检测</h3><ul>\n<li><ol>\n<li>获取JOB可写的多线程NativeQueue对象<pre><code class=\"c#\">NativeQueue&lt;PipePassedEvent&gt;.ParallelWriter eventQueueParallel = eventQueue.AsParallelWriter();</code></pre>\n</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>发出事件<pre><code class=\"c#\">eventQueueParallel.Enqueue(new PipePassedEvent());</code></pre>\n</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>事件机<pre><code class=\"c#\">while (eventQueue.TryDequeue(out PipePassedEvent evnt))\n   {\n       //Debug.Log(&quot;Get EVENT!!&quot;);\n       OnPipePassed?.Invoke(this, EventArgs.Empty);\n   }</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<p>4.接收事件</p>\n<pre><code class=\"c#\">World.DefaultGameObjectInjectionWorld.GetOrCreateSystem&lt;PipeMoveSystem_Done&gt;().OnPipePassed += TestingDOTSEvents_OnPipePassed;</code></pre>\n<h3 id=\"方式二、使用EntityCommandBuffer\"><a href=\"#方式二、使用EntityCommandBuffer\" class=\"headerlink\" title=\"方式二、使用EntityCommandBuffer\"></a>方式二、使用EntityCommandBuffer</h3><ul>\n<li><ol>\n<li>获取CommandBuffer的System</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>从System中创建一个commandbuffer, 并拿其Concurrent</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>利用2的concurrent就可以在job中创建一个entity.</li>\n</ol>\n</li>\n<li>4.使用Entities.WithoutBurst().ForEach执行触发事件，并在触发完后一定将entity删除掉。</li>\n</ul>\n<pre><code class=\"c#\"> EntityCommandBuffer entityCommandBuffer = endSimulationEntityCommandBufferSystem.CreateCommandBuffer();\n        EntityCommandBuffer.Concurrent entityCommandBufferConcurrent = entityCommandBuffer.ToConcurrent();\n        EntityArchetype eventEntityArchetype = EntityManager.CreateArchetype(typeof(EventComponent));\n\n        double ElapsedTime = Time.ElapsedTime;\n\n        JobHandle jobHandle = Entities.ForEach((int entityInQueryIndex, ref Translation translation, ref Pipe pipe) =&gt; {\n            float xBefore = translation.Value.x;\n            translation.Value += moveDir * moveSpeed * deltaTime;\n            float xAfter = translation.Value.x;\n\n            if (pipe.isBottom &amp;&amp; xBefore &gt; 0 &amp;&amp; xAfter &lt;= 0) {\n                // Passed the Player\n                Entity eventEntity = entityCommandBufferConcurrent.CreateEntity(entityInQueryIndex, eventEntityArchetype);\n                entityCommandBufferConcurrent.SetComponent(entityInQueryIndex, eventEntity, new EventComponent {\n                    ElapsedTime = ElapsedTime\n                });\n            }\n        }).Schedule(inputDeps);\n\n        endSimulationEntityCommandBufferSystem.AddJobHandleForProducer(jobHandle);\n\n        EntityCommandBuffer captureEventsEntityCommandBuffer = endSimulationEntityCommandBufferSystem.CreateCommandBuffer();\n\n        Entities.WithoutBurst().ForEach((Entity entity, ref EventComponent eventComponent) =&gt; {\n            Debug.Log(eventComponent.ElapsedTime + &quot; ### &quot; + ElapsedTime);\n            OnPipePassed?.Invoke(this, EventArgs.Empty);\n            captureEventsEntityCommandBuffer.DestroyEntity(entity);\n        }).Run();</code></pre>\n<blockquote>\n<p> 不用EndSimulationEntityCommandBufferSystem 也可以直接定义EntityCommandBuffer。只要在 job complete时，手动dispose()即可。</p>\n</blockquote>\n<pre><code class=\"c#\">entityCommandBuffer.Playback(EntityManager);\n        entityCommandBuffer.Dispose();</code></pre>\n"},{"title":"Centos 部署 Django","_content":"\n### 1. 下载必要库\n\n```\nyum -y groupinstall \"Development tools\"\n```\n\n### 2. 下载最新SQLITE\n\n到SQLite官网的下载页面：https://www.sqlite.org/download.html  这里是最新的版本，我们就安装它吧。\n\n```\nwget https://www.sqlite.org/2017/sqlite-autoconf-3160200.tar.gz\ntar zxvf sqlite-autoconf-3160200.tar.gz\ncd sqlite-autoconf-3160200\n\n./configure\nmake\nsudo make install\n```\n\n以默认方式安装后，会把编译好的二进制文件安装到 /usr/local/lib， 把头文件sqlite3.h sqlite3ext.h安装到/usr/local/include。\n\n用这两条命令确认一下已成功安装到这里：\n\n```\nls -l /usr/local/lib/*sqlite*\nls -l /usr/local/include/*sqlite*\n```\n\n### 3.Python 安装\n\n```\nwget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tgz\ntar -zxvf Python-3.6.6.tgz\n```\n\n进入解压好的目录\n```\n\nsudo LD_RUN_PATH=/usr/local/lib ./configure --enable-optimizations\nsudo LD_RUN_PATH=/usr/local/lib make altinstall\n\n```\n\n建立软链接\n\n```\nln -s /usr/local/python3/bin/python3.6 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3.6 /usr/bin/pip3\n```\n\n看Python3和pip3安装情况\n```\npython3\n\npip3 -V\n```\n\n卸载：\n\n```\nwhereis python\nrm -rf ....\n```\n\n### 4. virtualenv安装\n\n```\npip3 install virtualenv\n```\n\n建立链接\n```\nln -s /usr/local/python3/bin/virtualenv /usr/bin/virtualenv\n```\n \n 创建虚拟环境\n \n ```\n mkdir -p /data/env\n mkdir -p /data/wwwroot\n\nvirtualenv --python=/usr/bin/python3 pyweb\n ```\n\n进入虚拟环境\n\n```\ncd /data/env/pyweb/bin\nsource activate\n```\n\n退出虚拟环境\n\n```\ndeactivate\n```\n\n### 5.虚拟环境下安装django, uwsgi\n\n```\npip3 install django （如果用于生产的话，则需要指定安装和你项目相同的版本）\npip3 install uwsgi\n\nln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi\n```\n\n### 6. Django下创建项目和app\n\n```\ndjango-admin.py startproject mysite\n\ncd mysite\n\npython3 manage.py startapp blog\n```\n\n\n\n### 参考文章\nhttps://www.cnblogs.com/djangocn/p/9538551.html\nhttps://stackoverflow.com/questions/55674176/django-cant-find-new-sqlite-version-sqlite-3-8-3-or-later-is-required-found\nhttps://blog.csdn.net/yohjob/article/details/90760862","source":"_posts/Centos 部署 Django.md","raw":"---\ntitle: Centos 部署 Django\ncategories:\n- Python\ntags: \n- Python\n- Note\n- Django\n---\n\n### 1. 下载必要库\n\n```\nyum -y groupinstall \"Development tools\"\n```\n\n### 2. 下载最新SQLITE\n\n到SQLite官网的下载页面：https://www.sqlite.org/download.html  这里是最新的版本，我们就安装它吧。\n\n```\nwget https://www.sqlite.org/2017/sqlite-autoconf-3160200.tar.gz\ntar zxvf sqlite-autoconf-3160200.tar.gz\ncd sqlite-autoconf-3160200\n\n./configure\nmake\nsudo make install\n```\n\n以默认方式安装后，会把编译好的二进制文件安装到 /usr/local/lib， 把头文件sqlite3.h sqlite3ext.h安装到/usr/local/include。\n\n用这两条命令确认一下已成功安装到这里：\n\n```\nls -l /usr/local/lib/*sqlite*\nls -l /usr/local/include/*sqlite*\n```\n\n### 3.Python 安装\n\n```\nwget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tgz\ntar -zxvf Python-3.6.6.tgz\n```\n\n进入解压好的目录\n```\n\nsudo LD_RUN_PATH=/usr/local/lib ./configure --enable-optimizations\nsudo LD_RUN_PATH=/usr/local/lib make altinstall\n\n```\n\n建立软链接\n\n```\nln -s /usr/local/python3/bin/python3.6 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3.6 /usr/bin/pip3\n```\n\n看Python3和pip3安装情况\n```\npython3\n\npip3 -V\n```\n\n卸载：\n\n```\nwhereis python\nrm -rf ....\n```\n\n### 4. virtualenv安装\n\n```\npip3 install virtualenv\n```\n\n建立链接\n```\nln -s /usr/local/python3/bin/virtualenv /usr/bin/virtualenv\n```\n \n 创建虚拟环境\n \n ```\n mkdir -p /data/env\n mkdir -p /data/wwwroot\n\nvirtualenv --python=/usr/bin/python3 pyweb\n ```\n\n进入虚拟环境\n\n```\ncd /data/env/pyweb/bin\nsource activate\n```\n\n退出虚拟环境\n\n```\ndeactivate\n```\n\n### 5.虚拟环境下安装django, uwsgi\n\n```\npip3 install django （如果用于生产的话，则需要指定安装和你项目相同的版本）\npip3 install uwsgi\n\nln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi\n```\n\n### 6. Django下创建项目和app\n\n```\ndjango-admin.py startproject mysite\n\ncd mysite\n\npython3 manage.py startapp blog\n```\n\n\n\n### 参考文章\nhttps://www.cnblogs.com/djangocn/p/9538551.html\nhttps://stackoverflow.com/questions/55674176/django-cant-find-new-sqlite-version-sqlite-3-8-3-or-later-is-required-found\nhttps://blog.csdn.net/yohjob/article/details/90760862","slug":"Centos 部署 Django","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0y700074wf08sstmtpq","content":"<h3 id=\"1-下载必要库\"><a href=\"#1-下载必要库\" class=\"headerlink\" title=\"1. 下载必要库\"></a>1. 下载必要库</h3><pre><code>yum -y groupinstall &quot;Development tools&quot;</code></pre><h3 id=\"2-下载最新SQLITE\"><a href=\"#2-下载最新SQLITE\" class=\"headerlink\" title=\"2. 下载最新SQLITE\"></a>2. 下载最新SQLITE</h3><p>到SQLite官网的下载页面：<a href=\"https://www.sqlite.org/download.html\">https://www.sqlite.org/download.html</a>  这里是最新的版本，我们就安装它吧。</p>\n<pre><code>wget https://www.sqlite.org/2017/sqlite-autoconf-3160200.tar.gz\ntar zxvf sqlite-autoconf-3160200.tar.gz\ncd sqlite-autoconf-3160200\n\n./configure\nmake\nsudo make install</code></pre><p>以默认方式安装后，会把编译好的二进制文件安装到 /usr/local/lib， 把头文件sqlite3.h sqlite3ext.h安装到/usr/local/include。</p>\n<p>用这两条命令确认一下已成功安装到这里：</p>\n<pre><code>ls -l /usr/local/lib/*sqlite*\nls -l /usr/local/include/*sqlite*</code></pre><h3 id=\"3-Python-安装\"><a href=\"#3-Python-安装\" class=\"headerlink\" title=\"3.Python 安装\"></a>3.Python 安装</h3><pre><code>wget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tgz\ntar -zxvf Python-3.6.6.tgz</code></pre><p>进入解压好的目录</p>\n<pre><code>\nsudo LD_RUN_PATH=/usr/local/lib ./configure --enable-optimizations\nsudo LD_RUN_PATH=/usr/local/lib make altinstall\n</code></pre><p>建立软链接</p>\n<pre><code>ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3.6 /usr/bin/pip3</code></pre><p>看Python3和pip3安装情况</p>\n<pre><code>python3\n\npip3 -V</code></pre><p>卸载：</p>\n<pre><code>whereis python\nrm -rf ....</code></pre><h3 id=\"4-virtualenv安装\"><a href=\"#4-virtualenv安装\" class=\"headerlink\" title=\"4. virtualenv安装\"></a>4. virtualenv安装</h3><pre><code>pip3 install virtualenv</code></pre><p>建立链接</p>\n<pre><code>ln -s /usr/local/python3/bin/virtualenv /usr/bin/virtualenv</code></pre><p> 创建虚拟环境</p>\n<pre><code> mkdir -p /data/env\n mkdir -p /data/wwwroot\n\nvirtualenv --python=/usr/bin/python3 pyweb</code></pre><p>进入虚拟环境</p>\n<pre><code>cd /data/env/pyweb/bin\nsource activate</code></pre><p>退出虚拟环境</p>\n<pre><code>deactivate</code></pre><h3 id=\"5-虚拟环境下安装django-uwsgi\"><a href=\"#5-虚拟环境下安装django-uwsgi\" class=\"headerlink\" title=\"5.虚拟环境下安装django, uwsgi\"></a>5.虚拟环境下安装django, uwsgi</h3><pre><code>pip3 install django （如果用于生产的话，则需要指定安装和你项目相同的版本）\npip3 install uwsgi\n\nln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</code></pre><h3 id=\"6-Django下创建项目和app\"><a href=\"#6-Django下创建项目和app\" class=\"headerlink\" title=\"6. Django下创建项目和app\"></a>6. Django下创建项目和app</h3><pre><code>django-admin.py startproject mysite\n\ncd mysite\n\npython3 manage.py startapp blog</code></pre><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://www.cnblogs.com/djangocn/p/9538551.html\">https://www.cnblogs.com/djangocn/p/9538551.html</a><br><a href=\"https://stackoverflow.com/questions/55674176/django-cant-find-new-sqlite-version-sqlite-3-8-3-or-later-is-required-found\">https://stackoverflow.com/questions/55674176/django-cant-find-new-sqlite-version-sqlite-3-8-3-or-later-is-required-found</a><br><a href=\"https://blog.csdn.net/yohjob/article/details/90760862\">https://blog.csdn.net/yohjob/article/details/90760862</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-下载必要库\"><a href=\"#1-下载必要库\" class=\"headerlink\" title=\"1. 下载必要库\"></a>1. 下载必要库</h3><pre><code>yum -y groupinstall &quot;Development tools&quot;</code></pre><h3 id=\"2-下载最新SQLITE\"><a href=\"#2-下载最新SQLITE\" class=\"headerlink\" title=\"2. 下载最新SQLITE\"></a>2. 下载最新SQLITE</h3><p>到SQLite官网的下载页面：<a href=\"https://www.sqlite.org/download.html\">https://www.sqlite.org/download.html</a>  这里是最新的版本，我们就安装它吧。</p>\n<pre><code>wget https://www.sqlite.org/2017/sqlite-autoconf-3160200.tar.gz\ntar zxvf sqlite-autoconf-3160200.tar.gz\ncd sqlite-autoconf-3160200\n\n./configure\nmake\nsudo make install</code></pre><p>以默认方式安装后，会把编译好的二进制文件安装到 /usr/local/lib， 把头文件sqlite3.h sqlite3ext.h安装到/usr/local/include。</p>\n<p>用这两条命令确认一下已成功安装到这里：</p>\n<pre><code>ls -l /usr/local/lib/*sqlite*\nls -l /usr/local/include/*sqlite*</code></pre><h3 id=\"3-Python-安装\"><a href=\"#3-Python-安装\" class=\"headerlink\" title=\"3.Python 安装\"></a>3.Python 安装</h3><pre><code>wget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tgz\ntar -zxvf Python-3.6.6.tgz</code></pre><p>进入解压好的目录</p>\n<pre><code>\nsudo LD_RUN_PATH=/usr/local/lib ./configure --enable-optimizations\nsudo LD_RUN_PATH=/usr/local/lib make altinstall\n</code></pre><p>建立软链接</p>\n<pre><code>ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3.6 /usr/bin/pip3</code></pre><p>看Python3和pip3安装情况</p>\n<pre><code>python3\n\npip3 -V</code></pre><p>卸载：</p>\n<pre><code>whereis python\nrm -rf ....</code></pre><h3 id=\"4-virtualenv安装\"><a href=\"#4-virtualenv安装\" class=\"headerlink\" title=\"4. virtualenv安装\"></a>4. virtualenv安装</h3><pre><code>pip3 install virtualenv</code></pre><p>建立链接</p>\n<pre><code>ln -s /usr/local/python3/bin/virtualenv /usr/bin/virtualenv</code></pre><p> 创建虚拟环境</p>\n<pre><code> mkdir -p /data/env\n mkdir -p /data/wwwroot\n\nvirtualenv --python=/usr/bin/python3 pyweb</code></pre><p>进入虚拟环境</p>\n<pre><code>cd /data/env/pyweb/bin\nsource activate</code></pre><p>退出虚拟环境</p>\n<pre><code>deactivate</code></pre><h3 id=\"5-虚拟环境下安装django-uwsgi\"><a href=\"#5-虚拟环境下安装django-uwsgi\" class=\"headerlink\" title=\"5.虚拟环境下安装django, uwsgi\"></a>5.虚拟环境下安装django, uwsgi</h3><pre><code>pip3 install django （如果用于生产的话，则需要指定安装和你项目相同的版本）\npip3 install uwsgi\n\nln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</code></pre><h3 id=\"6-Django下创建项目和app\"><a href=\"#6-Django下创建项目和app\" class=\"headerlink\" title=\"6. Django下创建项目和app\"></a>6. Django下创建项目和app</h3><pre><code>django-admin.py startproject mysite\n\ncd mysite\n\npython3 manage.py startapp blog</code></pre><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://www.cnblogs.com/djangocn/p/9538551.html\">https://www.cnblogs.com/djangocn/p/9538551.html</a><br><a href=\"https://stackoverflow.com/questions/55674176/django-cant-find-new-sqlite-version-sqlite-3-8-3-or-later-is-required-found\">https://stackoverflow.com/questions/55674176/django-cant-find-new-sqlite-version-sqlite-3-8-3-or-later-is-required-found</a><br><a href=\"https://blog.csdn.net/yohjob/article/details/90760862\">https://blog.csdn.net/yohjob/article/details/90760862</a></p>\n"},{"title":"C与C++开源项目学习","_content":"\n来自www.codesheep.cn 作者推荐\n\n#### CJson\n实现在一个C语言的JSON解析器\nhttps://sourceforge.net/projects/cjson\n\n#### TinyHttpd\n实现一个C语言简单的HTTP服务器\nhttps://github.com/ezlippi/tinyhttpd\n\n#### MyTinySTL\n实现了一个STL库\nhttps://github.com/alinshans/mytinystl\n\n#### OATPP\n纯C++的高性能无依赖的WEB框架\nhttps://github.com/oatpp/oatpp\n\n#### Redis\n\nhttps://redis.io\n\n#### nginx\n超轻量级静态服务器","source":"_posts/C与C++开源项目学习.md","raw":"---\ntitle: C与C++开源项目学习\ncategories:\n- CPlusPlus\ntags: \n- C++\n---\n\n来自www.codesheep.cn 作者推荐\n\n#### CJson\n实现在一个C语言的JSON解析器\nhttps://sourceforge.net/projects/cjson\n\n#### TinyHttpd\n实现一个C语言简单的HTTP服务器\nhttps://github.com/ezlippi/tinyhttpd\n\n#### MyTinySTL\n实现了一个STL库\nhttps://github.com/alinshans/mytinystl\n\n#### OATPP\n纯C++的高性能无依赖的WEB框架\nhttps://github.com/oatpp/oatpp\n\n#### Redis\n\nhttps://redis.io\n\n#### nginx\n超轻量级静态服务器","slug":"C与C++开源项目学习","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0yb000b4wf0f4f8l9e9","content":"<p>来自<a href=\"http://www.codesheep.cn\">www.codesheep.cn</a> 作者推荐</p>\n<h4 id=\"CJson\"><a href=\"#CJson\" class=\"headerlink\" title=\"CJson\"></a>CJson</h4><p>实现在一个C语言的JSON解析器<br><a href=\"https://sourceforge.net/projects/cjson\">https://sourceforge.net/projects/cjson</a></p>\n<h4 id=\"TinyHttpd\"><a href=\"#TinyHttpd\" class=\"headerlink\" title=\"TinyHttpd\"></a>TinyHttpd</h4><p>实现一个C语言简单的HTTP服务器<br><a href=\"https://github.com/ezlippi/tinyhttpd\">https://github.com/ezlippi/tinyhttpd</a></p>\n<h4 id=\"MyTinySTL\"><a href=\"#MyTinySTL\" class=\"headerlink\" title=\"MyTinySTL\"></a>MyTinySTL</h4><p>实现了一个STL库<br><a href=\"https://github.com/alinshans/mytinystl\">https://github.com/alinshans/mytinystl</a></p>\n<h4 id=\"OATPP\"><a href=\"#OATPP\" class=\"headerlink\" title=\"OATPP\"></a>OATPP</h4><p>纯C++的高性能无依赖的WEB框架<br><a href=\"https://github.com/oatpp/oatpp\">https://github.com/oatpp/oatpp</a></p>\n<h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><p><a href=\"https://redis.io\">https://redis.io</a></p>\n<h4 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h4><p>超轻量级静态服务器</p>\n","site":{"data":{}},"excerpt":"","more":"<p>来自<a href=\"http://www.codesheep.cn\">www.codesheep.cn</a> 作者推荐</p>\n<h4 id=\"CJson\"><a href=\"#CJson\" class=\"headerlink\" title=\"CJson\"></a>CJson</h4><p>实现在一个C语言的JSON解析器<br><a href=\"https://sourceforge.net/projects/cjson\">https://sourceforge.net/projects/cjson</a></p>\n<h4 id=\"TinyHttpd\"><a href=\"#TinyHttpd\" class=\"headerlink\" title=\"TinyHttpd\"></a>TinyHttpd</h4><p>实现一个C语言简单的HTTP服务器<br><a href=\"https://github.com/ezlippi/tinyhttpd\">https://github.com/ezlippi/tinyhttpd</a></p>\n<h4 id=\"MyTinySTL\"><a href=\"#MyTinySTL\" class=\"headerlink\" title=\"MyTinySTL\"></a>MyTinySTL</h4><p>实现了一个STL库<br><a href=\"https://github.com/alinshans/mytinystl\">https://github.com/alinshans/mytinystl</a></p>\n<h4 id=\"OATPP\"><a href=\"#OATPP\" class=\"headerlink\" title=\"OATPP\"></a>OATPP</h4><p>纯C++的高性能无依赖的WEB框架<br><a href=\"https://github.com/oatpp/oatpp\">https://github.com/oatpp/oatpp</a></p>\n<h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><p><a href=\"https://redis.io\">https://redis.io</a></p>\n<h4 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h4><p>超轻量级静态服务器</p>\n"},{"title":"Conda 常用操作","_content":"\n\n### Conda介绍\n\n> Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件。\n\n### 下载&安装\n> conda官网：https://conda.io/miniconda.html\n\nlinux或mac ox版本：\n\n```\nwget -c https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nchmod 777 Miniconda3-latest-Linux-x86_64.sh #给执行权限\nbash Miniconda3-latest-Linux-x86_64.sh #运行\n```\n\n> 当命令行前面出现(base)的时候说明现在已经在conda的环境中了。这时候输入conda list 命令就有反应了\n\n\n###  添加频道\n\n官方频道\n \n```\nconda config --add channels bioconda\nconda config --add channels conda-forge\n```\n\n 清华镜像\n  \n``` \nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda\n```\n\n其他：\n\n``` \nconda config --add channels genomedk\n```\n\n显示安装的频道\n\n``` \n conda config --set show_channel_urls yes \n ``` \n \n查看已经添加的channels\n\n``` \nconda config --get channels\n``` \n\n已添加的channel在哪里查看\n\n``` \nvim ~/.condarc\n``` \n\n### 创建环境\n\n如创建一个python2.7环境且名为mysite\n\n``` \nconda create -n mysite python=2.7\n``` \n\n### 激活、退出环境\n\n激活：\nwindows环境下不用加conda前缀，mac及旧版本下可能需要使用source activate\n\n```\nconda activate mysite\n```\n\n退出：\n同激活\n\n``` \nconda deactivate mysite\n```\n\n### 删除环境\n\n``` \nconda remove -n mysite --all\n```\n\n### 重命名环境\n\n把一个原来叫做py2的环境重新命名成python2：\n\n``` \nconda create -n python2 --clone py2\nconda remove -n py2 --all\n```\n\n\n\n\n","source":"_posts/Conda 常用操作.md","raw":"---\ntitle: Conda 常用操作\ncategories:\n- Python\ntags: \n- Python\n- Note\n- Django\n- Conda\n---\n\n\n### Conda介绍\n\n> Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件。\n\n### 下载&安装\n> conda官网：https://conda.io/miniconda.html\n\nlinux或mac ox版本：\n\n```\nwget -c https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nchmod 777 Miniconda3-latest-Linux-x86_64.sh #给执行权限\nbash Miniconda3-latest-Linux-x86_64.sh #运行\n```\n\n> 当命令行前面出现(base)的时候说明现在已经在conda的环境中了。这时候输入conda list 命令就有反应了\n\n\n###  添加频道\n\n官方频道\n \n```\nconda config --add channels bioconda\nconda config --add channels conda-forge\n```\n\n 清华镜像\n  \n``` \nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda\n```\n\n其他：\n\n``` \nconda config --add channels genomedk\n```\n\n显示安装的频道\n\n``` \n conda config --set show_channel_urls yes \n ``` \n \n查看已经添加的channels\n\n``` \nconda config --get channels\n``` \n\n已添加的channel在哪里查看\n\n``` \nvim ~/.condarc\n``` \n\n### 创建环境\n\n如创建一个python2.7环境且名为mysite\n\n``` \nconda create -n mysite python=2.7\n``` \n\n### 激活、退出环境\n\n激活：\nwindows环境下不用加conda前缀，mac及旧版本下可能需要使用source activate\n\n```\nconda activate mysite\n```\n\n退出：\n同激活\n\n``` \nconda deactivate mysite\n```\n\n### 删除环境\n\n``` \nconda remove -n mysite --all\n```\n\n### 重命名环境\n\n把一个原来叫做py2的环境重新命名成python2：\n\n``` \nconda create -n python2 --clone py2\nconda remove -n py2 --all\n```\n\n\n\n\n","slug":"Conda 常用操作","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0yd000c4wf0wwyj2onu","content":"<h3 id=\"Conda介绍\"><a href=\"#Conda介绍\" class=\"headerlink\" title=\"Conda介绍\"></a>Conda介绍</h3><blockquote>\n<p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件。</p>\n</blockquote>\n<h3 id=\"下载-amp-安装\"><a href=\"#下载-amp-安装\" class=\"headerlink\" title=\"下载&amp;安装\"></a>下载&amp;安装</h3><blockquote>\n<p>conda官网：<a href=\"https://conda.io/miniconda.html\">https://conda.io/miniconda.html</a></p>\n</blockquote>\n<p>linux或mac ox版本：</p>\n<pre><code>wget -c https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nchmod 777 Miniconda3-latest-Linux-x86_64.sh #给执行权限\nbash Miniconda3-latest-Linux-x86_64.sh #运行</code></pre><blockquote>\n<p>当命令行前面出现(base)的时候说明现在已经在conda的环境中了。这时候输入conda list 命令就有反应了</p>\n</blockquote>\n<h3 id=\"添加频道\"><a href=\"#添加频道\" class=\"headerlink\" title=\"添加频道\"></a>添加频道</h3><p>官方频道</p>\n<pre><code>conda config --add channels bioconda\nconda config --add channels conda-forge</code></pre><p> 清华镜像</p>\n<pre><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda</code></pre><p>其他：</p>\n<pre><code>conda config --add channels genomedk</code></pre><p>显示安装的频道</p>\n<pre><code> conda config --set show_channel_urls yes </code></pre><p>查看已经添加的channels</p>\n<pre><code>conda config --get channels</code></pre><p>已添加的channel在哪里查看</p>\n<pre><code>vim ~/.condarc</code></pre><h3 id=\"创建环境\"><a href=\"#创建环境\" class=\"headerlink\" title=\"创建环境\"></a>创建环境</h3><p>如创建一个python2.7环境且名为mysite</p>\n<pre><code>conda create -n mysite python=2.7</code></pre><h3 id=\"激活、退出环境\"><a href=\"#激活、退出环境\" class=\"headerlink\" title=\"激活、退出环境\"></a>激活、退出环境</h3><p>激活：<br>windows环境下不用加conda前缀，mac及旧版本下可能需要使用source activate</p>\n<pre><code>conda activate mysite</code></pre><p>退出：<br>同激活</p>\n<pre><code>conda deactivate mysite</code></pre><h3 id=\"删除环境\"><a href=\"#删除环境\" class=\"headerlink\" title=\"删除环境\"></a>删除环境</h3><pre><code>conda remove -n mysite --all</code></pre><h3 id=\"重命名环境\"><a href=\"#重命名环境\" class=\"headerlink\" title=\"重命名环境\"></a>重命名环境</h3><p>把一个原来叫做py2的环境重新命名成python2：</p>\n<pre><code>conda create -n python2 --clone py2\nconda remove -n py2 --all</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Conda介绍\"><a href=\"#Conda介绍\" class=\"headerlink\" title=\"Conda介绍\"></a>Conda介绍</h3><blockquote>\n<p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件。</p>\n</blockquote>\n<h3 id=\"下载-amp-安装\"><a href=\"#下载-amp-安装\" class=\"headerlink\" title=\"下载&amp;安装\"></a>下载&amp;安装</h3><blockquote>\n<p>conda官网：<a href=\"https://conda.io/miniconda.html\">https://conda.io/miniconda.html</a></p>\n</blockquote>\n<p>linux或mac ox版本：</p>\n<pre><code>wget -c https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nchmod 777 Miniconda3-latest-Linux-x86_64.sh #给执行权限\nbash Miniconda3-latest-Linux-x86_64.sh #运行</code></pre><blockquote>\n<p>当命令行前面出现(base)的时候说明现在已经在conda的环境中了。这时候输入conda list 命令就有反应了</p>\n</blockquote>\n<h3 id=\"添加频道\"><a href=\"#添加频道\" class=\"headerlink\" title=\"添加频道\"></a>添加频道</h3><p>官方频道</p>\n<pre><code>conda config --add channels bioconda\nconda config --add channels conda-forge</code></pre><p> 清华镜像</p>\n<pre><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda</code></pre><p>其他：</p>\n<pre><code>conda config --add channels genomedk</code></pre><p>显示安装的频道</p>\n<pre><code> conda config --set show_channel_urls yes </code></pre><p>查看已经添加的channels</p>\n<pre><code>conda config --get channels</code></pre><p>已添加的channel在哪里查看</p>\n<pre><code>vim ~/.condarc</code></pre><h3 id=\"创建环境\"><a href=\"#创建环境\" class=\"headerlink\" title=\"创建环境\"></a>创建环境</h3><p>如创建一个python2.7环境且名为mysite</p>\n<pre><code>conda create -n mysite python=2.7</code></pre><h3 id=\"激活、退出环境\"><a href=\"#激活、退出环境\" class=\"headerlink\" title=\"激活、退出环境\"></a>激活、退出环境</h3><p>激活：<br>windows环境下不用加conda前缀，mac及旧版本下可能需要使用source activate</p>\n<pre><code>conda activate mysite</code></pre><p>退出：<br>同激活</p>\n<pre><code>conda deactivate mysite</code></pre><h3 id=\"删除环境\"><a href=\"#删除环境\" class=\"headerlink\" title=\"删除环境\"></a>删除环境</h3><pre><code>conda remove -n mysite --all</code></pre><h3 id=\"重命名环境\"><a href=\"#重命名环境\" class=\"headerlink\" title=\"重命名环境\"></a>重命名环境</h3><p>把一个原来叫做py2的环境重新命名成python2：</p>\n<pre><code>conda create -n python2 --clone py2\nconda remove -n py2 --all</code></pre>"},{"title":"网络游戏同步方案","_content":"\n![enter description here](/img/1583548259212.png)\n\n![enter description here](/img/1583549163720.png)\n\n![enter description here](/img/1583549878874.png)\n\n![enter description here](/img/1583550030862.png)","source":"_posts/DrawCall优化.md","raw":"---\ntitle: 网络游戏同步方案\ncategories:\n- Unity\ntags: \n---\n\n![enter description here](/img/1583548259212.png)\n\n![enter description here](/img/1583549163720.png)\n\n![enter description here](/img/1583549878874.png)\n\n![enter description here](/img/1583550030862.png)","slug":"DrawCall优化","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0yh000h4wf08p5pism9","content":"<p><img src=\"/img/1583548259212.png\" alt=\"enter description here\"></p>\n<p><img src=\"/img/1583549163720.png\" alt=\"enter description here\"></p>\n<p><img src=\"/img/1583549878874.png\" alt=\"enter description here\"></p>\n<p><img src=\"/img/1583550030862.png\" alt=\"enter description here\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/img/1583548259212.png\" alt=\"enter description here\"></p>\n<p><img src=\"/img/1583549163720.png\" alt=\"enter description here\"></p>\n<p><img src=\"/img/1583549878874.png\" alt=\"enter description here\"></p>\n<p><img src=\"/img/1583550030862.png\" alt=\"enter description here\"></p>\n"},{"title":"Django 实例 Web Application","_content":"\n## Preparing\n\n > Python\n > Django\n > Html\n > css\n > Javascript\n > Databases\n > HeroKu\n > Materialize  \n > Beautiful suite\n > Web scraping\n\n\n## Starters!\n\n+ 创建conda环境\n\n```\nconda create --name codedaddies python=3\n```\n\n+ 安装django\n\n```\npip install django\n```\n\n+ 创建工程（指定目录下）\n\n```\ndjango-admin startproject codedaddies_list\n```\n\n+ 创建APP\n\n```\npython manage.py startapp my_app\n```\n\n+ 数据库构建\n\n```\npython manage.py makemigrations\npython manage.py migrate\n```\n\n+ Templates文件夹\n> 配置在settings中，加入以下：\nTEMPLATE_DIR = os.path.join(BASE_DIR, \"templates\")\n> 底部加入:\nSTATICFILES_DIR = (os.path.join(BASE_DIR, 'static'),)\n\n> TEMPLATES块中设置DIRS\n> 'DIRS': [TEMPLATE_DIR],\n\n注：需要在pycharm中设置templates标志\n\n+ 启用admin\n```\npython manage.py createsuperuser\n```\n\n\n## First Page\n\n+ APP中新建urls.py\n在文件中配置路径表：\n\n```\nfrom . import views\n\n\nurlpatterns = [\n    path('', views.home, name='home'),\n]\n```\n\n+ 创建视图（与上面的Home匹配）\n在views.py\n\n```\ndef home(request):\n    return render(request, 'base.html')\n```\n\n+ 创建数据表\n\nmodels.py中\n\n```\nclass Search(models.Model):\n    search = models.CharField(max_length=500)\n    created = models.DateTimeField(auto_now=True)\n\n```\n记得执行migrate操作\n\n+ 添加admin管理\n\n```\nfrom .models import Search\n\n# Register your models here.\nadmin.site.register(Search)\n```\n\n","source":"_posts/Django 实例 Web Application.md","raw":"---\ntitle: Django 实例 Web Application\ncategories:\n- Python\ntags: \n- Python\n- Note\n- Django\n- 实例\n---\n\n## Preparing\n\n > Python\n > Django\n > Html\n > css\n > Javascript\n > Databases\n > HeroKu\n > Materialize  \n > Beautiful suite\n > Web scraping\n\n\n## Starters!\n\n+ 创建conda环境\n\n```\nconda create --name codedaddies python=3\n```\n\n+ 安装django\n\n```\npip install django\n```\n\n+ 创建工程（指定目录下）\n\n```\ndjango-admin startproject codedaddies_list\n```\n\n+ 创建APP\n\n```\npython manage.py startapp my_app\n```\n\n+ 数据库构建\n\n```\npython manage.py makemigrations\npython manage.py migrate\n```\n\n+ Templates文件夹\n> 配置在settings中，加入以下：\nTEMPLATE_DIR = os.path.join(BASE_DIR, \"templates\")\n> 底部加入:\nSTATICFILES_DIR = (os.path.join(BASE_DIR, 'static'),)\n\n> TEMPLATES块中设置DIRS\n> 'DIRS': [TEMPLATE_DIR],\n\n注：需要在pycharm中设置templates标志\n\n+ 启用admin\n```\npython manage.py createsuperuser\n```\n\n\n## First Page\n\n+ APP中新建urls.py\n在文件中配置路径表：\n\n```\nfrom . import views\n\n\nurlpatterns = [\n    path('', views.home, name='home'),\n]\n```\n\n+ 创建视图（与上面的Home匹配）\n在views.py\n\n```\ndef home(request):\n    return render(request, 'base.html')\n```\n\n+ 创建数据表\n\nmodels.py中\n\n```\nclass Search(models.Model):\n    search = models.CharField(max_length=500)\n    created = models.DateTimeField(auto_now=True)\n\n```\n记得执行migrate操作\n\n+ 添加admin管理\n\n```\nfrom .models import Search\n\n# Register your models here.\nadmin.site.register(Search)\n```\n\n","slug":"Django 实例 Web Application","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0yj000j4wf0z5hyfxk8","content":"<h2 id=\"Preparing\"><a href=\"#Preparing\" class=\"headerlink\" title=\"Preparing\"></a>Preparing</h2><blockquote>\n<p>Python<br>Django<br>Html<br>css<br>Javascript<br>Databases<br>HeroKu<br>Materialize<br>Beautiful suite<br>Web scraping</p>\n</blockquote>\n<h2 id=\"Starters\"><a href=\"#Starters\" class=\"headerlink\" title=\"Starters!\"></a>Starters!</h2><ul>\n<li>创建conda环境</li>\n</ul>\n<pre><code>conda create --name codedaddies python=3</code></pre><ul>\n<li>安装django</li>\n</ul>\n<pre><code>pip install django</code></pre><ul>\n<li>创建工程（指定目录下）</li>\n</ul>\n<pre><code>django-admin startproject codedaddies_list</code></pre><ul>\n<li>创建APP</li>\n</ul>\n<pre><code>python manage.py startapp my_app</code></pre><ul>\n<li>数据库构建</li>\n</ul>\n<pre><code>python manage.py makemigrations\npython manage.py migrate</code></pre><ul>\n<li>Templates文件夹<blockquote>\n<p>配置在settings中，加入以下：<br>TEMPLATE_DIR = os.path.join(BASE_DIR, “templates”)<br>底部加入:<br>STATICFILES_DIR = (os.path.join(BASE_DIR, ‘static’),)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>TEMPLATES块中设置DIRS<br>‘DIRS’: [TEMPLATE_DIR],</p>\n</blockquote>\n<p>注：需要在pycharm中设置templates标志</p>\n<ul>\n<li>启用admin<pre><code>python manage.py createsuperuser</code></pre></li>\n</ul>\n<h2 id=\"First-Page\"><a href=\"#First-Page\" class=\"headerlink\" title=\"First Page\"></a>First Page</h2><ul>\n<li>APP中新建urls.py<br>在文件中配置路径表：</li>\n</ul>\n<pre><code>from . import views\n\n\nurlpatterns = [\n    path(&#39;&#39;, views.home, name=&#39;home&#39;),\n]</code></pre><ul>\n<li>创建视图（与上面的Home匹配）<br>在views.py</li>\n</ul>\n<pre><code>def home(request):\n    return render(request, &#39;base.html&#39;)</code></pre><ul>\n<li>创建数据表</li>\n</ul>\n<p>models.py中</p>\n<pre><code>class Search(models.Model):\n    search = models.CharField(max_length=500)\n    created = models.DateTimeField(auto_now=True)\n</code></pre><p>记得执行migrate操作</p>\n<ul>\n<li>添加admin管理</li>\n</ul>\n<pre><code>from .models import Search\n\n# Register your models here.\nadmin.site.register(Search)</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Preparing\"><a href=\"#Preparing\" class=\"headerlink\" title=\"Preparing\"></a>Preparing</h2><blockquote>\n<p>Python<br>Django<br>Html<br>css<br>Javascript<br>Databases<br>HeroKu<br>Materialize<br>Beautiful suite<br>Web scraping</p>\n</blockquote>\n<h2 id=\"Starters\"><a href=\"#Starters\" class=\"headerlink\" title=\"Starters!\"></a>Starters!</h2><ul>\n<li>创建conda环境</li>\n</ul>\n<pre><code>conda create --name codedaddies python=3</code></pre><ul>\n<li>安装django</li>\n</ul>\n<pre><code>pip install django</code></pre><ul>\n<li>创建工程（指定目录下）</li>\n</ul>\n<pre><code>django-admin startproject codedaddies_list</code></pre><ul>\n<li>创建APP</li>\n</ul>\n<pre><code>python manage.py startapp my_app</code></pre><ul>\n<li>数据库构建</li>\n</ul>\n<pre><code>python manage.py makemigrations\npython manage.py migrate</code></pre><ul>\n<li>Templates文件夹<blockquote>\n<p>配置在settings中，加入以下：<br>TEMPLATE_DIR = os.path.join(BASE_DIR, “templates”)<br>底部加入:<br>STATICFILES_DIR = (os.path.join(BASE_DIR, ‘static’),)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>TEMPLATES块中设置DIRS<br>‘DIRS’: [TEMPLATE_DIR],</p>\n</blockquote>\n<p>注：需要在pycharm中设置templates标志</p>\n<ul>\n<li>启用admin<pre><code>python manage.py createsuperuser</code></pre></li>\n</ul>\n<h2 id=\"First-Page\"><a href=\"#First-Page\" class=\"headerlink\" title=\"First Page\"></a>First Page</h2><ul>\n<li>APP中新建urls.py<br>在文件中配置路径表：</li>\n</ul>\n<pre><code>from . import views\n\n\nurlpatterns = [\n    path(&#39;&#39;, views.home, name=&#39;home&#39;),\n]</code></pre><ul>\n<li>创建视图（与上面的Home匹配）<br>在views.py</li>\n</ul>\n<pre><code>def home(request):\n    return render(request, &#39;base.html&#39;)</code></pre><ul>\n<li>创建数据表</li>\n</ul>\n<p>models.py中</p>\n<pre><code>class Search(models.Model):\n    search = models.CharField(max_length=500)\n    created = models.DateTimeField(auto_now=True)\n</code></pre><p>记得执行migrate操作</p>\n<ul>\n<li>添加admin管理</li>\n</ul>\n<pre><code>from .models import Search\n\n# Register your models here.\nadmin.site.register(Search)</code></pre>"},{"title":"Django  初步构建","_content":"\n### Generic View\n>　简化写法，可选的有generic.IndexView和generic.DetailView\n>　DetailView 默认使用  \\<app name\\>/\\<model name\\>_detail.html.为模板， 可使用template重定向。自动生成model小写名字_list 为名的对象\n>　ListView 默认使用  \\<app name\\>/\\<model name\\>_list.html 为模板，可使用template重定向。 自动生成model小写名字的context对象\n\n","source":"_posts/Django  初步构建.md","raw":"---\ntitle: Django  初步构建\ncategories:\n- Python\ntags: \n- Python\n- Note\n- Django\n---\n\n### Generic View\n>　简化写法，可选的有generic.IndexView和generic.DetailView\n>　DetailView 默认使用  \\<app name\\>/\\<model name\\>_detail.html.为模板， 可使用template重定向。自动生成model小写名字_list 为名的对象\n>　ListView 默认使用  \\<app name\\>/\\<model name\\>_list.html 为模板，可使用template重定向。 自动生成model小写名字的context对象\n\n","slug":"Django  初步构建","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0yl000n4wf0w84mkneg","content":"<h3 id=\"Generic-View\"><a href=\"#Generic-View\" class=\"headerlink\" title=\"Generic View\"></a>Generic View</h3><blockquote>\n<p>　简化写法，可选的有generic.IndexView和generic.DetailView<br>　DetailView 默认使用  &lt;app name&gt;/&lt;model name&gt;_detail.html.为模板， 可使用template重定向。自动生成model小写名字_list 为名的对象<br>　ListView 默认使用  &lt;app name&gt;/&lt;model name&gt;_list.html 为模板，可使用template重定向。 自动生成model小写名字的context对象</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Generic-View\"><a href=\"#Generic-View\" class=\"headerlink\" title=\"Generic View\"></a>Generic View</h3><blockquote>\n<p>　简化写法，可选的有generic.IndexView和generic.DetailView<br>　DetailView 默认使用  &lt;app name&gt;/&lt;model name&gt;_detail.html.为模板， 可使用template重定向。自动生成model小写名字_list 为名的对象<br>　ListView 默认使用  &lt;app name&gt;/&lt;model name&gt;_list.html 为模板，可使用template重定向。 自动生成model小写名字的context对象</p>\n</blockquote>\n"},{"title":"Django  初始测试","_content":"\n### 使用models.py 创建数据库\n\n> 注意事项：\n>1、makemigrations 和 migrate 工作原理分别是什么：\nmakemigrations：根据检测到的模型创建新的迁移。迁移的作用，更多的是将数据库的操作，以文件的形式记录下来，方便以后检查、调用、重做等等。\nmigrate：使数据库状态与当前模型集和迁移集同步。说白了，就是将对数据库的更改，主要是数据表设计的更改，在数据库中真实执行。例如，新建、修改、删除数据表，新增、修改、删除某数据表内的字段等等。\n2、如果不想使用 Django 的 makemigrations 和 migrate 功能，但是不小心执行了这两个命令会发生什么，\n首先在该app下建立 migrations目录，并记录下你所有的关于modes.py的改动，比如0001_initial.py，\n接着执行migrate的话，这时候会作用到数据库文件，产生对应的表\n3、官方解释：\n运行 python manage.py makemigrations 为模型的改变生成迁移文件。\n运行 python manage.py migrate 来应用数据库迁移。\n参考： https://blog.csdn.net/weixin_43507484/article/details/87950788\n\n> 1. 先执行一下迁移\n\n\n> 2. 编辑app里的models.py\n如：\n\n```\nfrom django.db import models\n\n\nclass Question(models.Model):\n    question_text = models.CharField(max_length=200)\n    pub_date = models.DateTimeField('date published')\n\n\nclass Choice(models.Model):\n    question = models.ForeignKey(Question, on_delete=models.CASCADE)\n    choice_text = models.CharField(max_length=200)\n    votes = models.IntegerField(default=0)\n```\n\n> 3. 激活模型\n\n```\n#mysite/settings.py\nINSTALLED_APPS = [\n    'polls.apps.PollsConfig',\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]\n```\n\n> 4. 执行生成数据库\n\n\n```\npython manage.py makemigrations polls\n```\n\n输出迁移过程中可能执行的sql\n\n```\npython manage.py sqlmigrate polls 0001\n```\n\n最后，正式执行迁移\n\n```\npython manage.py migrate\n```\n\n\n\n### 使用API\n\n进入项目的Python控制台\n\n```\npython manage.py shell\n\nfrom polls.models import Choice, Question  # Import the model classes we just wrote.\nQuestion.objects.all()\n```\n\n给模型添加__str__()函数，这样默认输出将会改变\n\n```\nfrom django.db import models\n\nclass Question(models.Model):\n    # ...\n    def __str__(self):\n        return self.question_text\n\nclass Choice(models.Model):\n    # ...\n    def __str__(self):\n        return self.choice_text\n```\n\n\n\n### 使用管理员账号\n\n```\npython manage.py createsuperuser\n```\n\n此时进入xxxx/admin网址，登录就可看到数据库资源\n\n```\npython manage.py runserver\n```\n\n加入我们的项目\n\n```\nfrom django.contrib import admin\n\nfrom .models import Question\n\nadmin.site.register(Question)\n```\n\n无需重启，直接刷新就可以看到项目在主界面\n\n\n","source":"_posts/Django  初始测试.md","raw":"---\ntitle: Django  初始测试\ncategories:\n- Python\ntags: \n- Python\n- Note\n- Django\n---\n\n### 使用models.py 创建数据库\n\n> 注意事项：\n>1、makemigrations 和 migrate 工作原理分别是什么：\nmakemigrations：根据检测到的模型创建新的迁移。迁移的作用，更多的是将数据库的操作，以文件的形式记录下来，方便以后检查、调用、重做等等。\nmigrate：使数据库状态与当前模型集和迁移集同步。说白了，就是将对数据库的更改，主要是数据表设计的更改，在数据库中真实执行。例如，新建、修改、删除数据表，新增、修改、删除某数据表内的字段等等。\n2、如果不想使用 Django 的 makemigrations 和 migrate 功能，但是不小心执行了这两个命令会发生什么，\n首先在该app下建立 migrations目录，并记录下你所有的关于modes.py的改动，比如0001_initial.py，\n接着执行migrate的话，这时候会作用到数据库文件，产生对应的表\n3、官方解释：\n运行 python manage.py makemigrations 为模型的改变生成迁移文件。\n运行 python manage.py migrate 来应用数据库迁移。\n参考： https://blog.csdn.net/weixin_43507484/article/details/87950788\n\n> 1. 先执行一下迁移\n\n\n> 2. 编辑app里的models.py\n如：\n\n```\nfrom django.db import models\n\n\nclass Question(models.Model):\n    question_text = models.CharField(max_length=200)\n    pub_date = models.DateTimeField('date published')\n\n\nclass Choice(models.Model):\n    question = models.ForeignKey(Question, on_delete=models.CASCADE)\n    choice_text = models.CharField(max_length=200)\n    votes = models.IntegerField(default=0)\n```\n\n> 3. 激活模型\n\n```\n#mysite/settings.py\nINSTALLED_APPS = [\n    'polls.apps.PollsConfig',\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]\n```\n\n> 4. 执行生成数据库\n\n\n```\npython manage.py makemigrations polls\n```\n\n输出迁移过程中可能执行的sql\n\n```\npython manage.py sqlmigrate polls 0001\n```\n\n最后，正式执行迁移\n\n```\npython manage.py migrate\n```\n\n\n\n### 使用API\n\n进入项目的Python控制台\n\n```\npython manage.py shell\n\nfrom polls.models import Choice, Question  # Import the model classes we just wrote.\nQuestion.objects.all()\n```\n\n给模型添加__str__()函数，这样默认输出将会改变\n\n```\nfrom django.db import models\n\nclass Question(models.Model):\n    # ...\n    def __str__(self):\n        return self.question_text\n\nclass Choice(models.Model):\n    # ...\n    def __str__(self):\n        return self.choice_text\n```\n\n\n\n### 使用管理员账号\n\n```\npython manage.py createsuperuser\n```\n\n此时进入xxxx/admin网址，登录就可看到数据库资源\n\n```\npython manage.py runserver\n```\n\n加入我们的项目\n\n```\nfrom django.contrib import admin\n\nfrom .models import Question\n\nadmin.site.register(Question)\n```\n\n无需重启，直接刷新就可以看到项目在主界面\n\n\n","slug":"Django  初始测试","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0yn000q4wf0d0oidbxm","content":"<h3 id=\"使用models-py-创建数据库\"><a href=\"#使用models-py-创建数据库\" class=\"headerlink\" title=\"使用models.py 创建数据库\"></a>使用models.py 创建数据库</h3><blockquote>\n<p>注意事项：<br>1、makemigrations 和 migrate 工作原理分别是什么：<br>makemigrations：根据检测到的模型创建新的迁移。迁移的作用，更多的是将数据库的操作，以文件的形式记录下来，方便以后检查、调用、重做等等。<br>migrate：使数据库状态与当前模型集和迁移集同步。说白了，就是将对数据库的更改，主要是数据表设计的更改，在数据库中真实执行。例如，新建、修改、删除数据表，新增、修改、删除某数据表内的字段等等。<br>2、如果不想使用 Django 的 makemigrations 和 migrate 功能，但是不小心执行了这两个命令会发生什么，<br>首先在该app下建立 migrations目录，并记录下你所有的关于modes.py的改动，比如0001_initial.py，<br>接着执行migrate的话，这时候会作用到数据库文件，产生对应的表<br>3、官方解释：<br>运行 python manage.py makemigrations 为模型的改变生成迁移文件。<br>运行 python manage.py migrate 来应用数据库迁移。<br>参考： <a href=\"https://blog.csdn.net/weixin_43507484/article/details/87950788\">https://blog.csdn.net/weixin_43507484/article/details/87950788</a></p>\n</blockquote>\n<blockquote>\n<ol>\n<li>先执行一下迁移</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>编辑app里的models.py<br>如：</li>\n</ol>\n</blockquote>\n<pre><code>from django.db import models\n\n\nclass Question(models.Model):\n    question_text = models.CharField(max_length=200)\n    pub_date = models.DateTimeField(&#39;date published&#39;)\n\n\nclass Choice(models.Model):\n    question = models.ForeignKey(Question, on_delete=models.CASCADE)\n    choice_text = models.CharField(max_length=200)\n    votes = models.IntegerField(default=0)</code></pre><blockquote>\n<ol start=\"3\">\n<li>激活模型</li>\n</ol>\n</blockquote>\n<pre><code>#mysite/settings.py\nINSTALLED_APPS = [\n    &#39;polls.apps.PollsConfig&#39;,\n    &#39;django.contrib.admin&#39;,\n    &#39;django.contrib.auth&#39;,\n    &#39;django.contrib.contenttypes&#39;,\n    &#39;django.contrib.sessions&#39;,\n    &#39;django.contrib.messages&#39;,\n    &#39;django.contrib.staticfiles&#39;,\n]</code></pre><blockquote>\n<ol start=\"4\">\n<li>执行生成数据库</li>\n</ol>\n</blockquote>\n<pre><code>python manage.py makemigrations polls</code></pre><p>输出迁移过程中可能执行的sql</p>\n<pre><code>python manage.py sqlmigrate polls 0001</code></pre><p>最后，正式执行迁移</p>\n<pre><code>python manage.py migrate</code></pre><h3 id=\"使用API\"><a href=\"#使用API\" class=\"headerlink\" title=\"使用API\"></a>使用API</h3><p>进入项目的Python控制台</p>\n<pre><code>python manage.py shell\n\nfrom polls.models import Choice, Question  # Import the model classes we just wrote.\nQuestion.objects.all()</code></pre><p>给模型添加<strong>str</strong>()函数，这样默认输出将会改变</p>\n<pre><code>from django.db import models\n\nclass Question(models.Model):\n    # ...\n    def __str__(self):\n        return self.question_text\n\nclass Choice(models.Model):\n    # ...\n    def __str__(self):\n        return self.choice_text</code></pre><h3 id=\"使用管理员账号\"><a href=\"#使用管理员账号\" class=\"headerlink\" title=\"使用管理员账号\"></a>使用管理员账号</h3><pre><code>python manage.py createsuperuser</code></pre><p>此时进入xxxx/admin网址，登录就可看到数据库资源</p>\n<pre><code>python manage.py runserver</code></pre><p>加入我们的项目</p>\n<pre><code>from django.contrib import admin\n\nfrom .models import Question\n\nadmin.site.register(Question)</code></pre><p>无需重启，直接刷新就可以看到项目在主界面</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"使用models-py-创建数据库\"><a href=\"#使用models-py-创建数据库\" class=\"headerlink\" title=\"使用models.py 创建数据库\"></a>使用models.py 创建数据库</h3><blockquote>\n<p>注意事项：<br>1、makemigrations 和 migrate 工作原理分别是什么：<br>makemigrations：根据检测到的模型创建新的迁移。迁移的作用，更多的是将数据库的操作，以文件的形式记录下来，方便以后检查、调用、重做等等。<br>migrate：使数据库状态与当前模型集和迁移集同步。说白了，就是将对数据库的更改，主要是数据表设计的更改，在数据库中真实执行。例如，新建、修改、删除数据表，新增、修改、删除某数据表内的字段等等。<br>2、如果不想使用 Django 的 makemigrations 和 migrate 功能，但是不小心执行了这两个命令会发生什么，<br>首先在该app下建立 migrations目录，并记录下你所有的关于modes.py的改动，比如0001_initial.py，<br>接着执行migrate的话，这时候会作用到数据库文件，产生对应的表<br>3、官方解释：<br>运行 python manage.py makemigrations 为模型的改变生成迁移文件。<br>运行 python manage.py migrate 来应用数据库迁移。<br>参考： <a href=\"https://blog.csdn.net/weixin_43507484/article/details/87950788\">https://blog.csdn.net/weixin_43507484/article/details/87950788</a></p>\n</blockquote>\n<blockquote>\n<ol>\n<li>先执行一下迁移</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>编辑app里的models.py<br>如：</li>\n</ol>\n</blockquote>\n<pre><code>from django.db import models\n\n\nclass Question(models.Model):\n    question_text = models.CharField(max_length=200)\n    pub_date = models.DateTimeField(&#39;date published&#39;)\n\n\nclass Choice(models.Model):\n    question = models.ForeignKey(Question, on_delete=models.CASCADE)\n    choice_text = models.CharField(max_length=200)\n    votes = models.IntegerField(default=0)</code></pre><blockquote>\n<ol start=\"3\">\n<li>激活模型</li>\n</ol>\n</blockquote>\n<pre><code>#mysite/settings.py\nINSTALLED_APPS = [\n    &#39;polls.apps.PollsConfig&#39;,\n    &#39;django.contrib.admin&#39;,\n    &#39;django.contrib.auth&#39;,\n    &#39;django.contrib.contenttypes&#39;,\n    &#39;django.contrib.sessions&#39;,\n    &#39;django.contrib.messages&#39;,\n    &#39;django.contrib.staticfiles&#39;,\n]</code></pre><blockquote>\n<ol start=\"4\">\n<li>执行生成数据库</li>\n</ol>\n</blockquote>\n<pre><code>python manage.py makemigrations polls</code></pre><p>输出迁移过程中可能执行的sql</p>\n<pre><code>python manage.py sqlmigrate polls 0001</code></pre><p>最后，正式执行迁移</p>\n<pre><code>python manage.py migrate</code></pre><h3 id=\"使用API\"><a href=\"#使用API\" class=\"headerlink\" title=\"使用API\"></a>使用API</h3><p>进入项目的Python控制台</p>\n<pre><code>python manage.py shell\n\nfrom polls.models import Choice, Question  # Import the model classes we just wrote.\nQuestion.objects.all()</code></pre><p>给模型添加<strong>str</strong>()函数，这样默认输出将会改变</p>\n<pre><code>from django.db import models\n\nclass Question(models.Model):\n    # ...\n    def __str__(self):\n        return self.question_text\n\nclass Choice(models.Model):\n    # ...\n    def __str__(self):\n        return self.choice_text</code></pre><h3 id=\"使用管理员账号\"><a href=\"#使用管理员账号\" class=\"headerlink\" title=\"使用管理员账号\"></a>使用管理员账号</h3><pre><code>python manage.py createsuperuser</code></pre><p>此时进入xxxx/admin网址，登录就可看到数据库资源</p>\n<pre><code>python manage.py runserver</code></pre><p>加入我们的项目</p>\n<pre><code>from django.contrib import admin\n\nfrom .models import Question\n\nadmin.site.register(Question)</code></pre><p>无需重启，直接刷新就可以看到项目在主界面</p>\n"},{"title":"GEA-P1","_content":"\n## (1.2)What is Game?\n\n>In his excellent book, A Theory\nof Fun for Game Design **a game to be an interactive experience that provides the player with an increasingly challenging sequence of patterns which he or she learns and eventually masters**.\n\n>游戏： 一个交互性的经历提供一个玩家学习或将要学习的技能的挑战集合（持续提升的）\n\n* soft real-time game & hard real-time game\n  soft 意味着deadline不影响玩家，hard往往造成严重的后果。\n  \n\n## (1.4) Game genres\n\n### FPS\n\n>first-person shooters aim to provide their players with the illusion of being\nimmersed in a detailed, hyperrealistic world\n\n>First-person shooters typically focus on technologies such as:\n>* efficient rendering of large 3D virtual worlds;\n>* a responsive camera control/aiming mechanic;\n>* high-fidelity animations of the player’s virtual arms and weapons;\n>* a wide range of powerful handheld weaponry;\n>* a forgiving player character motion and collision model, which often\ngives these games a “floaty” feel;\n>* high-fidelity animations and artificial intelligence for the non-player\ncharacters (NPCs)—the player’s enemies and allies; and\n>* small-scale online multiplayer capabilities (typically supporting up to\n64 simultaneous players), and the ubiquitous “death match” gameplay\nmode.\n\n> 高效渲染3D虚拟世界\n> 有响应式的相机控制与射击目标指向机制\n> 高质量的玩家手臂和武器控制\n> 丰富的装备选择\n> 丰富的人物动画库和碰撞模型\n> 非玩家（NPC）的高质量动作和人工智能\n> 小型的多人同屏（<64）和频繁的角色死亡重生的游戏机制\n\n### Platformers and Other Third-Person Games\n\n> Technologies specifically:\n> * moving platforms, ladders, ropes, trellises and other interesting locomotion modes;\n> * puzzle-like environmental elements;\n> * a third-person “follow camera” which stays focused on the player character and whose rotation is typically controlled by the human player via\nthe right joypad stick (on a console) or the mouse (on a PC—note that\nwhile there are a number of popular third-person shooters on a PC, the\nplatformer genre exists almost exclusively on consoles); and\n> * a complex camera collision system for ensuring that the view point never\n“clips” through background geometry or dynamic foreground objects\n\n> 移动平台，楼梯等模块\n> 场景的混淆视听的组件\n> 第三人称使用的相机跟随\n> 复杂的相机机制以显示当前游戏所需的空间\n\n### Fighting Games\n\n> Efforts on:\n> * a rich set of fighting animations;\n>*  accurate hit detection;\n>* a user input system capable of detecting complex button and joystick\n>combinations; and\n>*  crowds, but otherwise relatively static backgrounds\n\n> State-of-the-art fighting games:\n>*  high-definition character graphics, including realistic skin shaders with\nsubsurface scattering and sweat effects;\n>* high-fidelity character animations; and\n>*  physics-based cloth and hair simulations for the characters.\n\n> 丰富的对战性的动画集\n> 精准的碰撞检测\n> 连招所用的组合键设计\n> 观众相关的人群背景设计\n\n> 高质量的人物画面及皮肤shader支持\n> 高质量的动画\n> 头发衣服的模拟\n\n\n### Racing Games\n>Some of the technological properties of a typical racing game include the\nfollowing techniques:\n>* Various “tricks” are used when rendering distant background elements,\nsuch as employing two-dimensional cards for trees, hills and mountains.\n>* The track is often broken down into relatively simple two-dimensional\nregions called “sectors.” These data structures are used to optimize\nrendering and visibility determination, to aid in artificial intelligence\nand path finding for non-human-controlled vehicles, and to solve many\nother technical problems.\n>*The camera typically follows behind the vehicle for a third-person perspective, or is sometimes situated inside the cockpit first-person style.\n>*When the track involves tunnels and other “tight” spaces, a good deal\nof effort is often put into ensuring that the camera does not collide with\nbackground geometry\n\n>  背景元素的各种2D的以假乱真的方法\n>  赛道的设计，使用2维的Sectors的数据结构，用于优化渲染和视觉效果，也可辅助设计AI的寻路等\n>  相机的视角以塞车后方的第三方人称或驾驶室的第一人称角色\n\n### Real-Time Strategy(RTS)\n\n> Include the following techniques:\n>* Each unit is relatively low-res, so that the game can support large numbers of them on-screen at once.\n>* Height-field terrain is usually the canvas upon which the game is designed and played.\n>* The player is often allowed to build new structures on the terrain in\naddition to deploying his or her forces.\n>* User interaction is typically via single-click and area-based selection of\nunits, plus menus or toolbars containing commands, equipment, unit\ntypes, building types, etc.\n\n> 每一个单元都占有相对少的资源，以便支持更多单元的同屏\n> 高地的地型常用于场景中\n> 玩家可自己支配自己的势力在地图，如创建一些建筑等\n> 交互模式传统上来说是用单击或区域选择\n\n\n### Massively Multiplayer Online Games (MMO)\n\n>* An MMO is defined as any game that supports huge numbers of\nsimultaneous players (from thousands to hundreds of thousands), usually all\nplaying in one very large, persistent virtual world (i.e., a world whose internal\nstate persists for very long periods of time, far beyond that of any one player’s\ngameplay session). \n>* Hence, perhaps the most important\nrole of the central server is to handle the billing and micro-transactions which\nserve as the game developer’s primary source of revenue.\n> MMO：支持超多在线在在一个虚拟世界中游玩的游戏\n> 分类有MMORPG,MMORTS, MMOFPS\n> 核心在于服务器的强大。\n\n### Player-Authored Content\n> 以玩家为主的游戏模式，代表性如我的世界，Little Big Planet2\n\n\n### Other Genres\n\n> sports\n> RPG\n> God games, e.g. Populous \n> Social simulation games , e.g. SimCity\n> puzzle game , e.g.Tetris\n> non-electronic games\n> web-based game\n\n## (1.5) Game Engine Survey\n\n### The Quake Family of Engines\n1992 Written by Id Software. \n\nQuake , Quake II source code is freely available!\n\n### The Unreal Family of Engines\n\nMajor competitor to Quake from 1998 written by Epic Games, Inc.\n2004 UE2. \n> Unreal is an incredibly powerful prototyping\ntool and commercial game development platform, and it can be used to build\nvirtually any 3D first-person or third-person game (not to mention games in\nother genres as well).\n\n> Epic now offers full access to Unreal Engine 4, source code and\nall, for a low monthly subscription fee plus a cut of your game’s profits if it\nships. This makes UE4 a viable choice for small independent game studios.\n\nhttps://github.com/EpicGames/UnrealEngine\n\n### The Half-Life Source Engine\n\n> Source is a high-quality engine, rivaling Unreal Engine 4 in terms of graphics capabilities and tool set.\n\nhttps://www.moddb.com/games/half-life-source\n\n### DICE's Frostbite\n寒霜\n\n >DICE's efforts to create a game engine for Battlefield Bad Company in 2006! Frostbite boasts a powerful unified asset creation tool called\nFrostEd, a powerful tools pipeline known as Backend Services, and a powerful\nruntime game engine. \n>https://www.ea.com/frostbite/engine\n\n### CryEngine\n\n>Crytek originally developed their powerful game engine known as CryENGINE as a tech demo for Nvidia.\n\n\n### Sony's PhyreEngine\n\n\n>In an effort to make developing games for Sony’s PlayStation 3 platform more\naccessible, Sony introduced PhyreEngine at the Game Developer’s Conference (GDC) in 2008.\n>It is available free of charge to any licensed Sony developer as part of the PlayStation SDK\n\n>为了针对sony ps3平台更好的开发游戏，2008年在GDC大会上推出\n\n### Microsoft’s XNA Game Studio\n\n> VS. C# and CLR.\n\n### Unity\n\n### 2D Game Engines for Non-programmers\n\n>These toolkits emphasize ease of use and allow users to employ a graphical user\ninterface to create a game rather than requiring the use of a programming\nlanguage. \n\n>使用图形化界面去创建游戏而不是编程的方式\n> 此类引擎：\n> Multimedia Fusion 2\n> Game Salad Creator\n> Scratch\n\n\n### C4 Engine\n\n>http://terathon.com/index.html\n\n\n### Proprietary In-House Engines\n>Many companies build and maintain proprietary in-house game engines. \n>专属著作权的内部引擎！\n\n\n### Open Source Engines\n\n> https://en.wikipedia.org/wiki/List_of_game_engines\n> OGRE\n> Panda3D\n> Yake <-OGRE\n> Crystal Space \n> Torque and Irrlicht","source":"_posts/GEA-P1.md","raw":"---\ntitle: GEA-P1 \ncategories:\n- IT阅读\ntags: \n- Game\n---\n\n## (1.2)What is Game?\n\n>In his excellent book, A Theory\nof Fun for Game Design **a game to be an interactive experience that provides the player with an increasingly challenging sequence of patterns which he or she learns and eventually masters**.\n\n>游戏： 一个交互性的经历提供一个玩家学习或将要学习的技能的挑战集合（持续提升的）\n\n* soft real-time game & hard real-time game\n  soft 意味着deadline不影响玩家，hard往往造成严重的后果。\n  \n\n## (1.4) Game genres\n\n### FPS\n\n>first-person shooters aim to provide their players with the illusion of being\nimmersed in a detailed, hyperrealistic world\n\n>First-person shooters typically focus on technologies such as:\n>* efficient rendering of large 3D virtual worlds;\n>* a responsive camera control/aiming mechanic;\n>* high-fidelity animations of the player’s virtual arms and weapons;\n>* a wide range of powerful handheld weaponry;\n>* a forgiving player character motion and collision model, which often\ngives these games a “floaty” feel;\n>* high-fidelity animations and artificial intelligence for the non-player\ncharacters (NPCs)—the player’s enemies and allies; and\n>* small-scale online multiplayer capabilities (typically supporting up to\n64 simultaneous players), and the ubiquitous “death match” gameplay\nmode.\n\n> 高效渲染3D虚拟世界\n> 有响应式的相机控制与射击目标指向机制\n> 高质量的玩家手臂和武器控制\n> 丰富的装备选择\n> 丰富的人物动画库和碰撞模型\n> 非玩家（NPC）的高质量动作和人工智能\n> 小型的多人同屏（<64）和频繁的角色死亡重生的游戏机制\n\n### Platformers and Other Third-Person Games\n\n> Technologies specifically:\n> * moving platforms, ladders, ropes, trellises and other interesting locomotion modes;\n> * puzzle-like environmental elements;\n> * a third-person “follow camera” which stays focused on the player character and whose rotation is typically controlled by the human player via\nthe right joypad stick (on a console) or the mouse (on a PC—note that\nwhile there are a number of popular third-person shooters on a PC, the\nplatformer genre exists almost exclusively on consoles); and\n> * a complex camera collision system for ensuring that the view point never\n“clips” through background geometry or dynamic foreground objects\n\n> 移动平台，楼梯等模块\n> 场景的混淆视听的组件\n> 第三人称使用的相机跟随\n> 复杂的相机机制以显示当前游戏所需的空间\n\n### Fighting Games\n\n> Efforts on:\n> * a rich set of fighting animations;\n>*  accurate hit detection;\n>* a user input system capable of detecting complex button and joystick\n>combinations; and\n>*  crowds, but otherwise relatively static backgrounds\n\n> State-of-the-art fighting games:\n>*  high-definition character graphics, including realistic skin shaders with\nsubsurface scattering and sweat effects;\n>* high-fidelity character animations; and\n>*  physics-based cloth and hair simulations for the characters.\n\n> 丰富的对战性的动画集\n> 精准的碰撞检测\n> 连招所用的组合键设计\n> 观众相关的人群背景设计\n\n> 高质量的人物画面及皮肤shader支持\n> 高质量的动画\n> 头发衣服的模拟\n\n\n### Racing Games\n>Some of the technological properties of a typical racing game include the\nfollowing techniques:\n>* Various “tricks” are used when rendering distant background elements,\nsuch as employing two-dimensional cards for trees, hills and mountains.\n>* The track is often broken down into relatively simple two-dimensional\nregions called “sectors.” These data structures are used to optimize\nrendering and visibility determination, to aid in artificial intelligence\nand path finding for non-human-controlled vehicles, and to solve many\nother technical problems.\n>*The camera typically follows behind the vehicle for a third-person perspective, or is sometimes situated inside the cockpit first-person style.\n>*When the track involves tunnels and other “tight” spaces, a good deal\nof effort is often put into ensuring that the camera does not collide with\nbackground geometry\n\n>  背景元素的各种2D的以假乱真的方法\n>  赛道的设计，使用2维的Sectors的数据结构，用于优化渲染和视觉效果，也可辅助设计AI的寻路等\n>  相机的视角以塞车后方的第三方人称或驾驶室的第一人称角色\n\n### Real-Time Strategy(RTS)\n\n> Include the following techniques:\n>* Each unit is relatively low-res, so that the game can support large numbers of them on-screen at once.\n>* Height-field terrain is usually the canvas upon which the game is designed and played.\n>* The player is often allowed to build new structures on the terrain in\naddition to deploying his or her forces.\n>* User interaction is typically via single-click and area-based selection of\nunits, plus menus or toolbars containing commands, equipment, unit\ntypes, building types, etc.\n\n> 每一个单元都占有相对少的资源，以便支持更多单元的同屏\n> 高地的地型常用于场景中\n> 玩家可自己支配自己的势力在地图，如创建一些建筑等\n> 交互模式传统上来说是用单击或区域选择\n\n\n### Massively Multiplayer Online Games (MMO)\n\n>* An MMO is defined as any game that supports huge numbers of\nsimultaneous players (from thousands to hundreds of thousands), usually all\nplaying in one very large, persistent virtual world (i.e., a world whose internal\nstate persists for very long periods of time, far beyond that of any one player’s\ngameplay session). \n>* Hence, perhaps the most important\nrole of the central server is to handle the billing and micro-transactions which\nserve as the game developer’s primary source of revenue.\n> MMO：支持超多在线在在一个虚拟世界中游玩的游戏\n> 分类有MMORPG,MMORTS, MMOFPS\n> 核心在于服务器的强大。\n\n### Player-Authored Content\n> 以玩家为主的游戏模式，代表性如我的世界，Little Big Planet2\n\n\n### Other Genres\n\n> sports\n> RPG\n> God games, e.g. Populous \n> Social simulation games , e.g. SimCity\n> puzzle game , e.g.Tetris\n> non-electronic games\n> web-based game\n\n## (1.5) Game Engine Survey\n\n### The Quake Family of Engines\n1992 Written by Id Software. \n\nQuake , Quake II source code is freely available!\n\n### The Unreal Family of Engines\n\nMajor competitor to Quake from 1998 written by Epic Games, Inc.\n2004 UE2. \n> Unreal is an incredibly powerful prototyping\ntool and commercial game development platform, and it can be used to build\nvirtually any 3D first-person or third-person game (not to mention games in\nother genres as well).\n\n> Epic now offers full access to Unreal Engine 4, source code and\nall, for a low monthly subscription fee plus a cut of your game’s profits if it\nships. This makes UE4 a viable choice for small independent game studios.\n\nhttps://github.com/EpicGames/UnrealEngine\n\n### The Half-Life Source Engine\n\n> Source is a high-quality engine, rivaling Unreal Engine 4 in terms of graphics capabilities and tool set.\n\nhttps://www.moddb.com/games/half-life-source\n\n### DICE's Frostbite\n寒霜\n\n >DICE's efforts to create a game engine for Battlefield Bad Company in 2006! Frostbite boasts a powerful unified asset creation tool called\nFrostEd, a powerful tools pipeline known as Backend Services, and a powerful\nruntime game engine. \n>https://www.ea.com/frostbite/engine\n\n### CryEngine\n\n>Crytek originally developed their powerful game engine known as CryENGINE as a tech demo for Nvidia.\n\n\n### Sony's PhyreEngine\n\n\n>In an effort to make developing games for Sony’s PlayStation 3 platform more\naccessible, Sony introduced PhyreEngine at the Game Developer’s Conference (GDC) in 2008.\n>It is available free of charge to any licensed Sony developer as part of the PlayStation SDK\n\n>为了针对sony ps3平台更好的开发游戏，2008年在GDC大会上推出\n\n### Microsoft’s XNA Game Studio\n\n> VS. C# and CLR.\n\n### Unity\n\n### 2D Game Engines for Non-programmers\n\n>These toolkits emphasize ease of use and allow users to employ a graphical user\ninterface to create a game rather than requiring the use of a programming\nlanguage. \n\n>使用图形化界面去创建游戏而不是编程的方式\n> 此类引擎：\n> Multimedia Fusion 2\n> Game Salad Creator\n> Scratch\n\n\n### C4 Engine\n\n>http://terathon.com/index.html\n\n\n### Proprietary In-House Engines\n>Many companies build and maintain proprietary in-house game engines. \n>专属著作权的内部引擎！\n\n\n### Open Source Engines\n\n> https://en.wikipedia.org/wiki/List_of_game_engines\n> OGRE\n> Panda3D\n> Yake <-OGRE\n> Crystal Space \n> Torque and Irrlicht","slug":"GEA-P1","published":1,"date":"2020-09-09T02:46:51.345Z","updated":"2020-09-09T02:46:51.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0yp000u4wf0dp0syxvj","content":"<h2 id=\"1-2-What-is-Game\"><a href=\"#1-2-What-is-Game\" class=\"headerlink\" title=\"(1.2)What is Game?\"></a>(1.2)What is Game?</h2><blockquote>\n<p>In his excellent book, A Theory<br>of Fun for Game Design <strong>a game to be an interactive experience that provides the player with an increasingly challenging sequence of patterns which he or she learns and eventually masters</strong>.</p>\n</blockquote>\n<blockquote>\n<p>游戏： 一个交互性的经历提供一个玩家学习或将要学习的技能的挑战集合（持续提升的）</p>\n</blockquote>\n<ul>\n<li>soft real-time game &amp; hard real-time game<br>soft 意味着deadline不影响玩家，hard往往造成严重的后果。</li>\n</ul>\n<h2 id=\"1-4-Game-genres\"><a href=\"#1-4-Game-genres\" class=\"headerlink\" title=\"(1.4) Game genres\"></a>(1.4) Game genres</h2><h3 id=\"FPS\"><a href=\"#FPS\" class=\"headerlink\" title=\"FPS\"></a>FPS</h3><blockquote>\n<p>first-person shooters aim to provide their players with the illusion of being<br>immersed in a detailed, hyperrealistic world</p>\n</blockquote>\n<blockquote>\n<p>First-person shooters typically focus on technologies such as:</p>\n<ul>\n<li>efficient rendering of large 3D virtual worlds;</li>\n<li>a responsive camera control/aiming mechanic;</li>\n<li>high-fidelity animations of the player’s virtual arms and weapons;</li>\n<li>a wide range of powerful handheld weaponry;</li>\n<li>a forgiving player character motion and collision model, which often<br>gives these games a “floaty” feel;</li>\n<li>high-fidelity animations and artificial intelligence for the non-player<br>characters (NPCs)—the player’s enemies and allies; and</li>\n<li>small-scale online multiplayer capabilities (typically supporting up to<br>64 simultaneous players), and the ubiquitous “death match” gameplay<br>mode.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>高效渲染3D虚拟世界<br>有响应式的相机控制与射击目标指向机制<br>高质量的玩家手臂和武器控制<br>丰富的装备选择<br>丰富的人物动画库和碰撞模型<br>非玩家（NPC）的高质量动作和人工智能<br>小型的多人同屏（&lt;64）和频繁的角色死亡重生的游戏机制</p>\n</blockquote>\n<h3 id=\"Platformers-and-Other-Third-Person-Games\"><a href=\"#Platformers-and-Other-Third-Person-Games\" class=\"headerlink\" title=\"Platformers and Other Third-Person Games\"></a>Platformers and Other Third-Person Games</h3><blockquote>\n<p>Technologies specifically:</p>\n<ul>\n<li>moving platforms, ladders, ropes, trellises and other interesting locomotion modes;</li>\n<li>puzzle-like environmental elements;</li>\n<li>a third-person “follow camera” which stays focused on the player character and whose rotation is typically controlled by the human player via<br>the right joypad stick (on a console) or the mouse (on a PC—note that<br>while there are a number of popular third-person shooters on a PC, the<br>platformer genre exists almost exclusively on consoles); and</li>\n<li>a complex camera collision system for ensuring that the view point never<br>“clips” through background geometry or dynamic foreground objects</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>移动平台，楼梯等模块<br>场景的混淆视听的组件<br>第三人称使用的相机跟随<br>复杂的相机机制以显示当前游戏所需的空间</p>\n</blockquote>\n<h3 id=\"Fighting-Games\"><a href=\"#Fighting-Games\" class=\"headerlink\" title=\"Fighting Games\"></a>Fighting Games</h3><blockquote>\n<p>Efforts on:</p>\n<ul>\n<li>a rich set of fighting animations;</li>\n<li>accurate hit detection;</li>\n<li>a user input system capable of detecting complex button and joystick<br>combinations; and</li>\n<li>crowds, but otherwise relatively static backgrounds</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>State-of-the-art fighting games:</p>\n<ul>\n<li>high-definition character graphics, including realistic skin shaders with<br>subsurface scattering and sweat effects;</li>\n<li>high-fidelity character animations; and</li>\n<li>physics-based cloth and hair simulations for the characters.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>丰富的对战性的动画集<br>精准的碰撞检测<br>连招所用的组合键设计<br>观众相关的人群背景设计</p>\n</blockquote>\n<blockquote>\n<p>高质量的人物画面及皮肤shader支持<br>高质量的动画<br>头发衣服的模拟</p>\n</blockquote>\n<h3 id=\"Racing-Games\"><a href=\"#Racing-Games\" class=\"headerlink\" title=\"Racing Games\"></a>Racing Games</h3><blockquote>\n<p>Some of the technological properties of a typical racing game include the<br>following techniques:</p>\n<ul>\n<li>Various “tricks” are used when rendering distant background elements,<br>such as employing two-dimensional cards for trees, hills and mountains.</li>\n<li>The track is often broken down into relatively simple two-dimensional<br>regions called “sectors.” These data structures are used to optimize<br>rendering and visibility determination, to aid in artificial intelligence<br>and path finding for non-human-controlled vehicles, and to solve many<br>other technical problems.</li>\n<li>The camera typically follows behind the vehicle for a third-person perspective, or is sometimes situated inside the cockpit first-person style.</li>\n<li>When the track involves tunnels and other “tight” spaces, a good deal<br>of effort is often put into ensuring that the camera does not collide with<br>background geometry</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> 背景元素的各种2D的以假乱真的方法<br> 赛道的设计，使用2维的Sectors的数据结构，用于优化渲染和视觉效果，也可辅助设计AI的寻路等<br> 相机的视角以塞车后方的第三方人称或驾驶室的第一人称角色</p>\n</blockquote>\n<h3 id=\"Real-Time-Strategy-RTS\"><a href=\"#Real-Time-Strategy-RTS\" class=\"headerlink\" title=\"Real-Time Strategy(RTS)\"></a>Real-Time Strategy(RTS)</h3><blockquote>\n<p>Include the following techniques:</p>\n<ul>\n<li>Each unit is relatively low-res, so that the game can support large numbers of them on-screen at once.</li>\n<li>Height-field terrain is usually the canvas upon which the game is designed and played.</li>\n<li>The player is often allowed to build new structures on the terrain in<br>addition to deploying his or her forces.</li>\n<li>User interaction is typically via single-click and area-based selection of<br>units, plus menus or toolbars containing commands, equipment, unit<br>types, building types, etc.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>每一个单元都占有相对少的资源，以便支持更多单元的同屏<br>高地的地型常用于场景中<br>玩家可自己支配自己的势力在地图，如创建一些建筑等<br>交互模式传统上来说是用单击或区域选择</p>\n</blockquote>\n<h3 id=\"Massively-Multiplayer-Online-Games-MMO\"><a href=\"#Massively-Multiplayer-Online-Games-MMO\" class=\"headerlink\" title=\"Massively Multiplayer Online Games (MMO)\"></a>Massively Multiplayer Online Games (MMO)</h3><blockquote>\n<ul>\n<li>An MMO is defined as any game that supports huge numbers of<br>simultaneous players (from thousands to hundreds of thousands), usually all<br>playing in one very large, persistent virtual world (i.e., a world whose internal<br>state persists for very long periods of time, far beyond that of any one player’s<br>gameplay session). </li>\n<li>Hence, perhaps the most important<br>role of the central server is to handle the billing and micro-transactions which<br>serve as the game developer’s primary source of revenue.<br>MMO：支持超多在线在在一个虚拟世界中游玩的游戏<br>分类有MMORPG,MMORTS, MMOFPS<br>核心在于服务器的强大。</li>\n</ul>\n</blockquote>\n<h3 id=\"Player-Authored-Content\"><a href=\"#Player-Authored-Content\" class=\"headerlink\" title=\"Player-Authored Content\"></a>Player-Authored Content</h3><blockquote>\n<p>以玩家为主的游戏模式，代表性如我的世界，Little Big Planet2</p>\n</blockquote>\n<h3 id=\"Other-Genres\"><a href=\"#Other-Genres\" class=\"headerlink\" title=\"Other Genres\"></a>Other Genres</h3><blockquote>\n<p>sports<br>RPG<br>God games, e.g. Populous<br>Social simulation games , e.g. SimCity<br>puzzle game , e.g.Tetris<br>non-electronic games<br>web-based game</p>\n</blockquote>\n<h2 id=\"1-5-Game-Engine-Survey\"><a href=\"#1-5-Game-Engine-Survey\" class=\"headerlink\" title=\"(1.5) Game Engine Survey\"></a>(1.5) Game Engine Survey</h2><h3 id=\"The-Quake-Family-of-Engines\"><a href=\"#The-Quake-Family-of-Engines\" class=\"headerlink\" title=\"The Quake Family of Engines\"></a>The Quake Family of Engines</h3><p>1992 Written by Id Software. </p>\n<p>Quake , Quake II source code is freely available!</p>\n<h3 id=\"The-Unreal-Family-of-Engines\"><a href=\"#The-Unreal-Family-of-Engines\" class=\"headerlink\" title=\"The Unreal Family of Engines\"></a>The Unreal Family of Engines</h3><p>Major competitor to Quake from 1998 written by Epic Games, Inc.<br>2004 UE2. </p>\n<blockquote>\n<p>Unreal is an incredibly powerful prototyping<br>tool and commercial game development platform, and it can be used to build<br>virtually any 3D first-person or third-person game (not to mention games in<br>other genres as well).</p>\n</blockquote>\n<blockquote>\n<p>Epic now offers full access to Unreal Engine 4, source code and<br>all, for a low monthly subscription fee plus a cut of your game’s profits if it<br>ships. This makes UE4 a viable choice for small independent game studios.</p>\n</blockquote>\n<p><a href=\"https://github.com/EpicGames/UnrealEngine\">https://github.com/EpicGames/UnrealEngine</a></p>\n<h3 id=\"The-Half-Life-Source-Engine\"><a href=\"#The-Half-Life-Source-Engine\" class=\"headerlink\" title=\"The Half-Life Source Engine\"></a>The Half-Life Source Engine</h3><blockquote>\n<p>Source is a high-quality engine, rivaling Unreal Engine 4 in terms of graphics capabilities and tool set.</p>\n</blockquote>\n<p><a href=\"https://www.moddb.com/games/half-life-source\">https://www.moddb.com/games/half-life-source</a></p>\n<h3 id=\"DICE’s-Frostbite\"><a href=\"#DICE’s-Frostbite\" class=\"headerlink\" title=\"DICE’s Frostbite\"></a>DICE’s Frostbite</h3><p>寒霜</p>\n<blockquote>\n<p>DICE’s efforts to create a game engine for Battlefield Bad Company in 2006! Frostbite boasts a powerful unified asset creation tool called<br>FrostEd, a powerful tools pipeline known as Backend Services, and a powerful<br>runtime game engine.<br><a href=\"https://www.ea.com/frostbite/engine\">https://www.ea.com/frostbite/engine</a></p>\n</blockquote>\n<h3 id=\"CryEngine\"><a href=\"#CryEngine\" class=\"headerlink\" title=\"CryEngine\"></a>CryEngine</h3><blockquote>\n<p>Crytek originally developed their powerful game engine known as CryENGINE as a tech demo for Nvidia.</p>\n</blockquote>\n<h3 id=\"Sony’s-PhyreEngine\"><a href=\"#Sony’s-PhyreEngine\" class=\"headerlink\" title=\"Sony’s PhyreEngine\"></a>Sony’s PhyreEngine</h3><blockquote>\n<p>In an effort to make developing games for Sony’s PlayStation 3 platform more<br>accessible, Sony introduced PhyreEngine at the Game Developer’s Conference (GDC) in 2008.<br>It is available free of charge to any licensed Sony developer as part of the PlayStation SDK</p>\n</blockquote>\n<blockquote>\n<p>为了针对sony ps3平台更好的开发游戏，2008年在GDC大会上推出</p>\n</blockquote>\n<h3 id=\"Microsoft’s-XNA-Game-Studio\"><a href=\"#Microsoft’s-XNA-Game-Studio\" class=\"headerlink\" title=\"Microsoft’s XNA Game Studio\"></a>Microsoft’s XNA Game Studio</h3><blockquote>\n<p>VS. C# and CLR.</p>\n</blockquote>\n<h3 id=\"Unity\"><a href=\"#Unity\" class=\"headerlink\" title=\"Unity\"></a>Unity</h3><h3 id=\"2D-Game-Engines-for-Non-programmers\"><a href=\"#2D-Game-Engines-for-Non-programmers\" class=\"headerlink\" title=\"2D Game Engines for Non-programmers\"></a>2D Game Engines for Non-programmers</h3><blockquote>\n<p>These toolkits emphasize ease of use and allow users to employ a graphical user<br>interface to create a game rather than requiring the use of a programming<br>language. </p>\n</blockquote>\n<blockquote>\n<p>使用图形化界面去创建游戏而不是编程的方式<br>此类引擎：<br>Multimedia Fusion 2<br>Game Salad Creator<br>Scratch</p>\n</blockquote>\n<h3 id=\"C4-Engine\"><a href=\"#C4-Engine\" class=\"headerlink\" title=\"C4 Engine\"></a>C4 Engine</h3><blockquote>\n<p><a href=\"http://terathon.com/index.html\">http://terathon.com/index.html</a></p>\n</blockquote>\n<h3 id=\"Proprietary-In-House-Engines\"><a href=\"#Proprietary-In-House-Engines\" class=\"headerlink\" title=\"Proprietary In-House Engines\"></a>Proprietary In-House Engines</h3><blockquote>\n<p>Many companies build and maintain proprietary in-house game engines.<br>专属著作权的内部引擎！</p>\n</blockquote>\n<h3 id=\"Open-Source-Engines\"><a href=\"#Open-Source-Engines\" class=\"headerlink\" title=\"Open Source Engines\"></a>Open Source Engines</h3><blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/List_of_game_engines\">https://en.wikipedia.org/wiki/List_of_game_engines</a><br>OGRE<br>Panda3D<br>Yake &lt;-OGRE<br>Crystal Space<br>Torque and Irrlicht</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-2-What-is-Game\"><a href=\"#1-2-What-is-Game\" class=\"headerlink\" title=\"(1.2)What is Game?\"></a>(1.2)What is Game?</h2><blockquote>\n<p>In his excellent book, A Theory<br>of Fun for Game Design <strong>a game to be an interactive experience that provides the player with an increasingly challenging sequence of patterns which he or she learns and eventually masters</strong>.</p>\n</blockquote>\n<blockquote>\n<p>游戏： 一个交互性的经历提供一个玩家学习或将要学习的技能的挑战集合（持续提升的）</p>\n</blockquote>\n<ul>\n<li>soft real-time game &amp; hard real-time game<br>soft 意味着deadline不影响玩家，hard往往造成严重的后果。</li>\n</ul>\n<h2 id=\"1-4-Game-genres\"><a href=\"#1-4-Game-genres\" class=\"headerlink\" title=\"(1.4) Game genres\"></a>(1.4) Game genres</h2><h3 id=\"FPS\"><a href=\"#FPS\" class=\"headerlink\" title=\"FPS\"></a>FPS</h3><blockquote>\n<p>first-person shooters aim to provide their players with the illusion of being<br>immersed in a detailed, hyperrealistic world</p>\n</blockquote>\n<blockquote>\n<p>First-person shooters typically focus on technologies such as:</p>\n<ul>\n<li>efficient rendering of large 3D virtual worlds;</li>\n<li>a responsive camera control/aiming mechanic;</li>\n<li>high-fidelity animations of the player’s virtual arms and weapons;</li>\n<li>a wide range of powerful handheld weaponry;</li>\n<li>a forgiving player character motion and collision model, which often<br>gives these games a “floaty” feel;</li>\n<li>high-fidelity animations and artificial intelligence for the non-player<br>characters (NPCs)—the player’s enemies and allies; and</li>\n<li>small-scale online multiplayer capabilities (typically supporting up to<br>64 simultaneous players), and the ubiquitous “death match” gameplay<br>mode.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>高效渲染3D虚拟世界<br>有响应式的相机控制与射击目标指向机制<br>高质量的玩家手臂和武器控制<br>丰富的装备选择<br>丰富的人物动画库和碰撞模型<br>非玩家（NPC）的高质量动作和人工智能<br>小型的多人同屏（&lt;64）和频繁的角色死亡重生的游戏机制</p>\n</blockquote>\n<h3 id=\"Platformers-and-Other-Third-Person-Games\"><a href=\"#Platformers-and-Other-Third-Person-Games\" class=\"headerlink\" title=\"Platformers and Other Third-Person Games\"></a>Platformers and Other Third-Person Games</h3><blockquote>\n<p>Technologies specifically:</p>\n<ul>\n<li>moving platforms, ladders, ropes, trellises and other interesting locomotion modes;</li>\n<li>puzzle-like environmental elements;</li>\n<li>a third-person “follow camera” which stays focused on the player character and whose rotation is typically controlled by the human player via<br>the right joypad stick (on a console) or the mouse (on a PC—note that<br>while there are a number of popular third-person shooters on a PC, the<br>platformer genre exists almost exclusively on consoles); and</li>\n<li>a complex camera collision system for ensuring that the view point never<br>“clips” through background geometry or dynamic foreground objects</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>移动平台，楼梯等模块<br>场景的混淆视听的组件<br>第三人称使用的相机跟随<br>复杂的相机机制以显示当前游戏所需的空间</p>\n</blockquote>\n<h3 id=\"Fighting-Games\"><a href=\"#Fighting-Games\" class=\"headerlink\" title=\"Fighting Games\"></a>Fighting Games</h3><blockquote>\n<p>Efforts on:</p>\n<ul>\n<li>a rich set of fighting animations;</li>\n<li>accurate hit detection;</li>\n<li>a user input system capable of detecting complex button and joystick<br>combinations; and</li>\n<li>crowds, but otherwise relatively static backgrounds</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>State-of-the-art fighting games:</p>\n<ul>\n<li>high-definition character graphics, including realistic skin shaders with<br>subsurface scattering and sweat effects;</li>\n<li>high-fidelity character animations; and</li>\n<li>physics-based cloth and hair simulations for the characters.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>丰富的对战性的动画集<br>精准的碰撞检测<br>连招所用的组合键设计<br>观众相关的人群背景设计</p>\n</blockquote>\n<blockquote>\n<p>高质量的人物画面及皮肤shader支持<br>高质量的动画<br>头发衣服的模拟</p>\n</blockquote>\n<h3 id=\"Racing-Games\"><a href=\"#Racing-Games\" class=\"headerlink\" title=\"Racing Games\"></a>Racing Games</h3><blockquote>\n<p>Some of the technological properties of a typical racing game include the<br>following techniques:</p>\n<ul>\n<li>Various “tricks” are used when rendering distant background elements,<br>such as employing two-dimensional cards for trees, hills and mountains.</li>\n<li>The track is often broken down into relatively simple two-dimensional<br>regions called “sectors.” These data structures are used to optimize<br>rendering and visibility determination, to aid in artificial intelligence<br>and path finding for non-human-controlled vehicles, and to solve many<br>other technical problems.</li>\n<li>The camera typically follows behind the vehicle for a third-person perspective, or is sometimes situated inside the cockpit first-person style.</li>\n<li>When the track involves tunnels and other “tight” spaces, a good deal<br>of effort is often put into ensuring that the camera does not collide with<br>background geometry</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> 背景元素的各种2D的以假乱真的方法<br> 赛道的设计，使用2维的Sectors的数据结构，用于优化渲染和视觉效果，也可辅助设计AI的寻路等<br> 相机的视角以塞车后方的第三方人称或驾驶室的第一人称角色</p>\n</blockquote>\n<h3 id=\"Real-Time-Strategy-RTS\"><a href=\"#Real-Time-Strategy-RTS\" class=\"headerlink\" title=\"Real-Time Strategy(RTS)\"></a>Real-Time Strategy(RTS)</h3><blockquote>\n<p>Include the following techniques:</p>\n<ul>\n<li>Each unit is relatively low-res, so that the game can support large numbers of them on-screen at once.</li>\n<li>Height-field terrain is usually the canvas upon which the game is designed and played.</li>\n<li>The player is often allowed to build new structures on the terrain in<br>addition to deploying his or her forces.</li>\n<li>User interaction is typically via single-click and area-based selection of<br>units, plus menus or toolbars containing commands, equipment, unit<br>types, building types, etc.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>每一个单元都占有相对少的资源，以便支持更多单元的同屏<br>高地的地型常用于场景中<br>玩家可自己支配自己的势力在地图，如创建一些建筑等<br>交互模式传统上来说是用单击或区域选择</p>\n</blockquote>\n<h3 id=\"Massively-Multiplayer-Online-Games-MMO\"><a href=\"#Massively-Multiplayer-Online-Games-MMO\" class=\"headerlink\" title=\"Massively Multiplayer Online Games (MMO)\"></a>Massively Multiplayer Online Games (MMO)</h3><blockquote>\n<ul>\n<li>An MMO is defined as any game that supports huge numbers of<br>simultaneous players (from thousands to hundreds of thousands), usually all<br>playing in one very large, persistent virtual world (i.e., a world whose internal<br>state persists for very long periods of time, far beyond that of any one player’s<br>gameplay session). </li>\n<li>Hence, perhaps the most important<br>role of the central server is to handle the billing and micro-transactions which<br>serve as the game developer’s primary source of revenue.<br>MMO：支持超多在线在在一个虚拟世界中游玩的游戏<br>分类有MMORPG,MMORTS, MMOFPS<br>核心在于服务器的强大。</li>\n</ul>\n</blockquote>\n<h3 id=\"Player-Authored-Content\"><a href=\"#Player-Authored-Content\" class=\"headerlink\" title=\"Player-Authored Content\"></a>Player-Authored Content</h3><blockquote>\n<p>以玩家为主的游戏模式，代表性如我的世界，Little Big Planet2</p>\n</blockquote>\n<h3 id=\"Other-Genres\"><a href=\"#Other-Genres\" class=\"headerlink\" title=\"Other Genres\"></a>Other Genres</h3><blockquote>\n<p>sports<br>RPG<br>God games, e.g. Populous<br>Social simulation games , e.g. SimCity<br>puzzle game , e.g.Tetris<br>non-electronic games<br>web-based game</p>\n</blockquote>\n<h2 id=\"1-5-Game-Engine-Survey\"><a href=\"#1-5-Game-Engine-Survey\" class=\"headerlink\" title=\"(1.5) Game Engine Survey\"></a>(1.5) Game Engine Survey</h2><h3 id=\"The-Quake-Family-of-Engines\"><a href=\"#The-Quake-Family-of-Engines\" class=\"headerlink\" title=\"The Quake Family of Engines\"></a>The Quake Family of Engines</h3><p>1992 Written by Id Software. </p>\n<p>Quake , Quake II source code is freely available!</p>\n<h3 id=\"The-Unreal-Family-of-Engines\"><a href=\"#The-Unreal-Family-of-Engines\" class=\"headerlink\" title=\"The Unreal Family of Engines\"></a>The Unreal Family of Engines</h3><p>Major competitor to Quake from 1998 written by Epic Games, Inc.<br>2004 UE2. </p>\n<blockquote>\n<p>Unreal is an incredibly powerful prototyping<br>tool and commercial game development platform, and it can be used to build<br>virtually any 3D first-person or third-person game (not to mention games in<br>other genres as well).</p>\n</blockquote>\n<blockquote>\n<p>Epic now offers full access to Unreal Engine 4, source code and<br>all, for a low monthly subscription fee plus a cut of your game’s profits if it<br>ships. This makes UE4 a viable choice for small independent game studios.</p>\n</blockquote>\n<p><a href=\"https://github.com/EpicGames/UnrealEngine\">https://github.com/EpicGames/UnrealEngine</a></p>\n<h3 id=\"The-Half-Life-Source-Engine\"><a href=\"#The-Half-Life-Source-Engine\" class=\"headerlink\" title=\"The Half-Life Source Engine\"></a>The Half-Life Source Engine</h3><blockquote>\n<p>Source is a high-quality engine, rivaling Unreal Engine 4 in terms of graphics capabilities and tool set.</p>\n</blockquote>\n<p><a href=\"https://www.moddb.com/games/half-life-source\">https://www.moddb.com/games/half-life-source</a></p>\n<h3 id=\"DICE’s-Frostbite\"><a href=\"#DICE’s-Frostbite\" class=\"headerlink\" title=\"DICE’s Frostbite\"></a>DICE’s Frostbite</h3><p>寒霜</p>\n<blockquote>\n<p>DICE’s efforts to create a game engine for Battlefield Bad Company in 2006! Frostbite boasts a powerful unified asset creation tool called<br>FrostEd, a powerful tools pipeline known as Backend Services, and a powerful<br>runtime game engine.<br><a href=\"https://www.ea.com/frostbite/engine\">https://www.ea.com/frostbite/engine</a></p>\n</blockquote>\n<h3 id=\"CryEngine\"><a href=\"#CryEngine\" class=\"headerlink\" title=\"CryEngine\"></a>CryEngine</h3><blockquote>\n<p>Crytek originally developed their powerful game engine known as CryENGINE as a tech demo for Nvidia.</p>\n</blockquote>\n<h3 id=\"Sony’s-PhyreEngine\"><a href=\"#Sony’s-PhyreEngine\" class=\"headerlink\" title=\"Sony’s PhyreEngine\"></a>Sony’s PhyreEngine</h3><blockquote>\n<p>In an effort to make developing games for Sony’s PlayStation 3 platform more<br>accessible, Sony introduced PhyreEngine at the Game Developer’s Conference (GDC) in 2008.<br>It is available free of charge to any licensed Sony developer as part of the PlayStation SDK</p>\n</blockquote>\n<blockquote>\n<p>为了针对sony ps3平台更好的开发游戏，2008年在GDC大会上推出</p>\n</blockquote>\n<h3 id=\"Microsoft’s-XNA-Game-Studio\"><a href=\"#Microsoft’s-XNA-Game-Studio\" class=\"headerlink\" title=\"Microsoft’s XNA Game Studio\"></a>Microsoft’s XNA Game Studio</h3><blockquote>\n<p>VS. C# and CLR.</p>\n</blockquote>\n<h3 id=\"Unity\"><a href=\"#Unity\" class=\"headerlink\" title=\"Unity\"></a>Unity</h3><h3 id=\"2D-Game-Engines-for-Non-programmers\"><a href=\"#2D-Game-Engines-for-Non-programmers\" class=\"headerlink\" title=\"2D Game Engines for Non-programmers\"></a>2D Game Engines for Non-programmers</h3><blockquote>\n<p>These toolkits emphasize ease of use and allow users to employ a graphical user<br>interface to create a game rather than requiring the use of a programming<br>language. </p>\n</blockquote>\n<blockquote>\n<p>使用图形化界面去创建游戏而不是编程的方式<br>此类引擎：<br>Multimedia Fusion 2<br>Game Salad Creator<br>Scratch</p>\n</blockquote>\n<h3 id=\"C4-Engine\"><a href=\"#C4-Engine\" class=\"headerlink\" title=\"C4 Engine\"></a>C4 Engine</h3><blockquote>\n<p><a href=\"http://terathon.com/index.html\">http://terathon.com/index.html</a></p>\n</blockquote>\n<h3 id=\"Proprietary-In-House-Engines\"><a href=\"#Proprietary-In-House-Engines\" class=\"headerlink\" title=\"Proprietary In-House Engines\"></a>Proprietary In-House Engines</h3><blockquote>\n<p>Many companies build and maintain proprietary in-house game engines.<br>专属著作权的内部引擎！</p>\n</blockquote>\n<h3 id=\"Open-Source-Engines\"><a href=\"#Open-Source-Engines\" class=\"headerlink\" title=\"Open Source Engines\"></a>Open Source Engines</h3><blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/List_of_game_engines\">https://en.wikipedia.org/wiki/List_of_game_engines</a><br>OGRE<br>Panda3D<br>Yake &lt;-OGRE<br>Crystal Space<br>Torque and Irrlicht</p>\n</blockquote>\n"},{"title":"ECS框架的思考","_content":"\n# 对比ECSGameEngine框架的问题：\n1.Archetype加入的优势 ？\n2.Component与Entity不使用类概念的好处？\n\n\n\n# 开发模式的变更（对比ECSGameEngine）：\n1.System与数据对象之间无组合关系\n* Unity ECS\n读取所有数据方式都一样\n* A: 在Awake时通过GetComponentGroup 注册需要的component\n* B: 处理时使用group.ToComponentDataArray拿到Entity. 再从Entity取出Component数据\n\n* ECSGameEngine：\n读取其他数据：需要访问其他的System或某个manager来获取。\n* A: 新建一个Entity对象，将Component数据预先存到对象里\n* B: 此System需要某个Entity时，在awake时将Entity实例加入进去，访问其下Component拿数据\n\n>ECSGameEngine框架，Component，Entity与System有组合关系，如果有共享Entity数据，这时要么System间相互访问，要么借助另一个公共类将Entity存起来。\n>Unity的ECS，Entity是直属于EntityManager<- World层的。Entity与System没有任何关联。 Component 对应存储在Archetype中，并有entity的标签（id），System会通过componen类型找到对应的Entity，再从entity获取数据内容。\n\n2.内存优化\n\n* Unity ECS\n同类的Component 存在Archetype中，Archetype存储着一堆chunk，一个chunk 16KB.\n\n* ECSGameEngine\n所有都为类，都将占用堆内存，第一次实例时内存将会有一个峰值，多次进出将重复利用内存。\n\n3.应用层差别\n\n* Unity ECS:\n\t*A: ECS.TypeManager.RegisterType(\"MyComponentData\", {value=0}) --装载时即指定此Component数据（适合全局）\n\t*B: 在拥有Entity时，ECS.EntityManager:SetComponentData(entity, \"MyComponentData\", {value=123}) --通过设置entity里的数据设置（适合局部修改）\n    LUA: Inject方式\n    *A：使用Inject函数将Component名字注入\n    *B：在SystemUpdate中接收处理，使用注入的别名+数组索引号取出对象\n\t\n* ECSGameEngine:  \n\t* A： 定义一个类，继承自EntityComponent\n\t* B:  找到一个Entity来挂载或定义一个新的Entity类，继承自Entity\n\t* C:  System需要添加些entity，再通过此entity拿到component\n\n4.LUA层的实践过程\n\n* 创建ArcheType的过程\n* 1. 入口：EntityManager - CreateArchetype(types)。 \n    > 调用ComponentTypeInArcheType，创建一个Entity类型的type放在其第一位。\n    > 原types数组内容往后面放入当cachedArcheTypes中，设置长度+1\n* 2. 处理者： ArcheTypeManager。 cachedArcheTypes和长度，传入GetExistingArchetype() 看是否可拿到ArcheType对象。\n* 3. 只有当2不同拿到对象时，才执行此步！ 处理者：ArcheTypeManager。 \n将cacheArcheTypes和长度传入GetOrCreateArchetype()执行拿到ArcheType对象\n\n* 4. 入口：ArchetypeManager - CreateArchetypeInternal() \n    > 创建新的table，设置chunk大小，types，及把当前type设为PrevArchetype\n    > 处理者：EntityGroupManager- AddArchetypeIfMatching \n\n* 5. 入口：EntityGroupManager - AddArchetypeIfMatching(type) \n    > 取出lastGroupData，默认从ComponentSystem-GetComponentGroup创建\n    > 将type与ComponentGroup所属的archetype对应起来 \n    > IndexInArchetype存储上对应的类型\n\n* System中拿数据的过程\n* 1. 入口：ComponentSystem - GetComponentGroup({}) \n    System的Awake回调函数中添加GetComponentGroup，注册指定的archetype名，并得到group对象\n    \n    \n* 2. [在另一个地方创建好此Archetype的Entity后] 使用此group对象的ToComponentDataArray({})，获取到所有含些component数据。\n","source":"_posts/ECS框架的思考.md","raw":"---\ntitle: ECS框架的思考\ncategories:\n- Unity\n---\n\n# 对比ECSGameEngine框架的问题：\n1.Archetype加入的优势 ？\n2.Component与Entity不使用类概念的好处？\n\n\n\n# 开发模式的变更（对比ECSGameEngine）：\n1.System与数据对象之间无组合关系\n* Unity ECS\n读取所有数据方式都一样\n* A: 在Awake时通过GetComponentGroup 注册需要的component\n* B: 处理时使用group.ToComponentDataArray拿到Entity. 再从Entity取出Component数据\n\n* ECSGameEngine：\n读取其他数据：需要访问其他的System或某个manager来获取。\n* A: 新建一个Entity对象，将Component数据预先存到对象里\n* B: 此System需要某个Entity时，在awake时将Entity实例加入进去，访问其下Component拿数据\n\n>ECSGameEngine框架，Component，Entity与System有组合关系，如果有共享Entity数据，这时要么System间相互访问，要么借助另一个公共类将Entity存起来。\n>Unity的ECS，Entity是直属于EntityManager<- World层的。Entity与System没有任何关联。 Component 对应存储在Archetype中，并有entity的标签（id），System会通过componen类型找到对应的Entity，再从entity获取数据内容。\n\n2.内存优化\n\n* Unity ECS\n同类的Component 存在Archetype中，Archetype存储着一堆chunk，一个chunk 16KB.\n\n* ECSGameEngine\n所有都为类，都将占用堆内存，第一次实例时内存将会有一个峰值，多次进出将重复利用内存。\n\n3.应用层差别\n\n* Unity ECS:\n\t*A: ECS.TypeManager.RegisterType(\"MyComponentData\", {value=0}) --装载时即指定此Component数据（适合全局）\n\t*B: 在拥有Entity时，ECS.EntityManager:SetComponentData(entity, \"MyComponentData\", {value=123}) --通过设置entity里的数据设置（适合局部修改）\n    LUA: Inject方式\n    *A：使用Inject函数将Component名字注入\n    *B：在SystemUpdate中接收处理，使用注入的别名+数组索引号取出对象\n\t\n* ECSGameEngine:  \n\t* A： 定义一个类，继承自EntityComponent\n\t* B:  找到一个Entity来挂载或定义一个新的Entity类，继承自Entity\n\t* C:  System需要添加些entity，再通过此entity拿到component\n\n4.LUA层的实践过程\n\n* 创建ArcheType的过程\n* 1. 入口：EntityManager - CreateArchetype(types)。 \n    > 调用ComponentTypeInArcheType，创建一个Entity类型的type放在其第一位。\n    > 原types数组内容往后面放入当cachedArcheTypes中，设置长度+1\n* 2. 处理者： ArcheTypeManager。 cachedArcheTypes和长度，传入GetExistingArchetype() 看是否可拿到ArcheType对象。\n* 3. 只有当2不同拿到对象时，才执行此步！ 处理者：ArcheTypeManager。 \n将cacheArcheTypes和长度传入GetOrCreateArchetype()执行拿到ArcheType对象\n\n* 4. 入口：ArchetypeManager - CreateArchetypeInternal() \n    > 创建新的table，设置chunk大小，types，及把当前type设为PrevArchetype\n    > 处理者：EntityGroupManager- AddArchetypeIfMatching \n\n* 5. 入口：EntityGroupManager - AddArchetypeIfMatching(type) \n    > 取出lastGroupData，默认从ComponentSystem-GetComponentGroup创建\n    > 将type与ComponentGroup所属的archetype对应起来 \n    > IndexInArchetype存储上对应的类型\n\n* System中拿数据的过程\n* 1. 入口：ComponentSystem - GetComponentGroup({}) \n    System的Awake回调函数中添加GetComponentGroup，注册指定的archetype名，并得到group对象\n    \n    \n* 2. [在另一个地方创建好此Archetype的Entity后] 使用此group对象的ToComponentDataArray({})，获取到所有含些component数据。\n","slug":"ECS框架的思考","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0yr000v4wf0x6eva7yt","content":"<h1 id=\"对比ECSGameEngine框架的问题：\"><a href=\"#对比ECSGameEngine框架的问题：\" class=\"headerlink\" title=\"对比ECSGameEngine框架的问题：\"></a>对比ECSGameEngine框架的问题：</h1><p>1.Archetype加入的优势 ？<br>2.Component与Entity不使用类概念的好处？</p>\n<h1 id=\"开发模式的变更（对比ECSGameEngine）：\"><a href=\"#开发模式的变更（对比ECSGameEngine）：\" class=\"headerlink\" title=\"开发模式的变更（对比ECSGameEngine）：\"></a>开发模式的变更（对比ECSGameEngine）：</h1><p>1.System与数据对象之间无组合关系</p>\n<ul>\n<li><p>Unity ECS<br>读取所有数据方式都一样</p>\n</li>\n<li><p>A: 在Awake时通过GetComponentGroup 注册需要的component</p>\n</li>\n<li><p>B: 处理时使用group.ToComponentDataArray拿到Entity. 再从Entity取出Component数据</p>\n</li>\n<li><p>ECSGameEngine：<br>读取其他数据：需要访问其他的System或某个manager来获取。</p>\n</li>\n<li><p>A: 新建一个Entity对象，将Component数据预先存到对象里</p>\n</li>\n<li><p>B: 此System需要某个Entity时，在awake时将Entity实例加入进去，访问其下Component拿数据</p>\n</li>\n</ul>\n<blockquote>\n<p>ECSGameEngine框架，Component，Entity与System有组合关系，如果有共享Entity数据，这时要么System间相互访问，要么借助另一个公共类将Entity存起来。<br>Unity的ECS，Entity是直属于EntityManager&lt;- World层的。Entity与System没有任何关联。 Component 对应存储在Archetype中，并有entity的标签（id），System会通过componen类型找到对应的Entity，再从entity获取数据内容。</p>\n</blockquote>\n<p>2.内存优化</p>\n<ul>\n<li><p>Unity ECS<br>同类的Component 存在Archetype中，Archetype存储着一堆chunk，一个chunk 16KB.</p>\n</li>\n<li><p>ECSGameEngine<br>所有都为类，都将占用堆内存，第一次实例时内存将会有一个峰值，多次进出将重复利用内存。</p>\n</li>\n</ul>\n<p>3.应用层差别</p>\n<ul>\n<li><p>Unity ECS:<br>  *A: ECS.TypeManager.RegisterType(“MyComponentData”, {value=0}) –装载时即指定此Component数据（适合全局）<br>  *B: 在拥有Entity时，ECS.EntityManager:SetComponentData(entity, “MyComponentData”, {value=123}) –通过设置entity里的数据设置（适合局部修改）<br>  LUA: Inject方式<br>  *A：使用Inject函数将Component名字注入<br>  *B：在SystemUpdate中接收处理，使用注入的别名+数组索引号取出对象</p>\n</li>\n<li><p>ECSGameEngine:  </p>\n<ul>\n<li>A： 定义一个类，继承自EntityComponent</li>\n<li>B:  找到一个Entity来挂载或定义一个新的Entity类，继承自Entity</li>\n<li>C:  System需要添加些entity，再通过此entity拿到component</li>\n</ul>\n</li>\n</ul>\n<p>4.LUA层的实践过程</p>\n<ul>\n<li><p>创建ArcheType的过程</p>\n</li>\n<li><ol>\n<li>入口：EntityManager - CreateArchetype(types)。 <blockquote>\n<p>调用ComponentTypeInArcheType，创建一个Entity类型的type放在其第一位。<br>原types数组内容往后面放入当cachedArcheTypes中，设置长度+1</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>处理者： ArcheTypeManager。 cachedArcheTypes和长度，传入GetExistingArchetype() 看是否可拿到ArcheType对象。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>只有当2不同拿到对象时，才执行此步！ 处理者：ArcheTypeManager。<br>将cacheArcheTypes和长度传入GetOrCreateArchetype()执行拿到ArcheType对象</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>入口：ArchetypeManager - CreateArchetypeInternal() <blockquote>\n<p>创建新的table，设置chunk大小，types，及把当前type设为PrevArchetype<br>处理者：EntityGroupManager- AddArchetypeIfMatching </p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>入口：EntityGroupManager - AddArchetypeIfMatching(type) <blockquote>\n<p>取出lastGroupData，默认从ComponentSystem-GetComponentGroup创建<br>将type与ComponentGroup所属的archetype对应起来<br>IndexInArchetype存储上对应的类型</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>System中拿数据的过程</p>\n</li>\n<li><ol>\n<li>入口：ComponentSystem - GetComponentGroup({})<br>System的Awake回调函数中添加GetComponentGroup，注册指定的archetype名，并得到group对象</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><ol start=\"2\">\n<li>[在另一个地方创建好此Archetype的Entity后] 使用此group对象的ToComponentDataArray({})，获取到所有含些component数据。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"对比ECSGameEngine框架的问题：\"><a href=\"#对比ECSGameEngine框架的问题：\" class=\"headerlink\" title=\"对比ECSGameEngine框架的问题：\"></a>对比ECSGameEngine框架的问题：</h1><p>1.Archetype加入的优势 ？<br>2.Component与Entity不使用类概念的好处？</p>\n<h1 id=\"开发模式的变更（对比ECSGameEngine）：\"><a href=\"#开发模式的变更（对比ECSGameEngine）：\" class=\"headerlink\" title=\"开发模式的变更（对比ECSGameEngine）：\"></a>开发模式的变更（对比ECSGameEngine）：</h1><p>1.System与数据对象之间无组合关系</p>\n<ul>\n<li><p>Unity ECS<br>读取所有数据方式都一样</p>\n</li>\n<li><p>A: 在Awake时通过GetComponentGroup 注册需要的component</p>\n</li>\n<li><p>B: 处理时使用group.ToComponentDataArray拿到Entity. 再从Entity取出Component数据</p>\n</li>\n<li><p>ECSGameEngine：<br>读取其他数据：需要访问其他的System或某个manager来获取。</p>\n</li>\n<li><p>A: 新建一个Entity对象，将Component数据预先存到对象里</p>\n</li>\n<li><p>B: 此System需要某个Entity时，在awake时将Entity实例加入进去，访问其下Component拿数据</p>\n</li>\n</ul>\n<blockquote>\n<p>ECSGameEngine框架，Component，Entity与System有组合关系，如果有共享Entity数据，这时要么System间相互访问，要么借助另一个公共类将Entity存起来。<br>Unity的ECS，Entity是直属于EntityManager&lt;- World层的。Entity与System没有任何关联。 Component 对应存储在Archetype中，并有entity的标签（id），System会通过componen类型找到对应的Entity，再从entity获取数据内容。</p>\n</blockquote>\n<p>2.内存优化</p>\n<ul>\n<li><p>Unity ECS<br>同类的Component 存在Archetype中，Archetype存储着一堆chunk，一个chunk 16KB.</p>\n</li>\n<li><p>ECSGameEngine<br>所有都为类，都将占用堆内存，第一次实例时内存将会有一个峰值，多次进出将重复利用内存。</p>\n</li>\n</ul>\n<p>3.应用层差别</p>\n<ul>\n<li><p>Unity ECS:<br>  *A: ECS.TypeManager.RegisterType(“MyComponentData”, {value=0}) –装载时即指定此Component数据（适合全局）<br>  *B: 在拥有Entity时，ECS.EntityManager:SetComponentData(entity, “MyComponentData”, {value=123}) –通过设置entity里的数据设置（适合局部修改）<br>  LUA: Inject方式<br>  *A：使用Inject函数将Component名字注入<br>  *B：在SystemUpdate中接收处理，使用注入的别名+数组索引号取出对象</p>\n</li>\n<li><p>ECSGameEngine:  </p>\n<ul>\n<li>A： 定义一个类，继承自EntityComponent</li>\n<li>B:  找到一个Entity来挂载或定义一个新的Entity类，继承自Entity</li>\n<li>C:  System需要添加些entity，再通过此entity拿到component</li>\n</ul>\n</li>\n</ul>\n<p>4.LUA层的实践过程</p>\n<ul>\n<li><p>创建ArcheType的过程</p>\n</li>\n<li><ol>\n<li>入口：EntityManager - CreateArchetype(types)。 <blockquote>\n<p>调用ComponentTypeInArcheType，创建一个Entity类型的type放在其第一位。<br>原types数组内容往后面放入当cachedArcheTypes中，设置长度+1</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>处理者： ArcheTypeManager。 cachedArcheTypes和长度，传入GetExistingArchetype() 看是否可拿到ArcheType对象。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>只有当2不同拿到对象时，才执行此步！ 处理者：ArcheTypeManager。<br>将cacheArcheTypes和长度传入GetOrCreateArchetype()执行拿到ArcheType对象</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>入口：ArchetypeManager - CreateArchetypeInternal() <blockquote>\n<p>创建新的table，设置chunk大小，types，及把当前type设为PrevArchetype<br>处理者：EntityGroupManager- AddArchetypeIfMatching </p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>入口：EntityGroupManager - AddArchetypeIfMatching(type) <blockquote>\n<p>取出lastGroupData，默认从ComponentSystem-GetComponentGroup创建<br>将type与ComponentGroup所属的archetype对应起来<br>IndexInArchetype存储上对应的类型</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>System中拿数据的过程</p>\n</li>\n<li><ol>\n<li>入口：ComponentSystem - GetComponentGroup({})<br>System的Awake回调函数中添加GetComponentGroup，注册指定的archetype名，并得到group对象</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><ol start=\"2\">\n<li>[在另一个地方创建好此Archetype的Entity后] 使用此group对象的ToComponentDataArray({})，获取到所有含些component数据。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"DOTS-研究学习","_content":"\n### 1. What is DOTS?\n\nDATA-ORIENTED TECH STACK\n多线程式数据导向型技术堆栈\n\n 核心-高性能\n充分利用多核处理器，多线程，让游戏运行速度更快。\n组成部分如下：\n* C# 任务系统， Job System，用于高效运行多线程代码\n* 实体组件系统，ECS， 默认编写的高性能代码的框架结构\n* Burst编译器，用于生成高度优化的本地代码\n\nJob System 与ECS是独立的，两者结合实际才能发挥最大优势。\n\n### 2. Job System\n\n* 在Job System之前，unity 仅在内部支持多线程，外部都必须运行在主线程上\n* C#虽然支持多线程，但在unity中只处理数据，如网络消息，下载等等，且在线程中调用Unity的API是不行的。\n* 有了Job System,可以充分利用多核CPU，比如在多线程中修改Transform等\n* 例：MMO游戏判断碰撞，大量同步角色坐标，大量血条飘字等较为适合\n* 不必过于担心线程安全，加锁的问题\n* 配合Burst更佳\n\n2.1 HPC# -High Performance C#\n\n介绍：\n* IL2Cpp虽然将IL转成C++，但实际还是模拟了.NET的垃圾回收，效率并非等同C++\n* 使用NativeArray代替T[]，数据类型包括了值类型和其他类型指针\n* NativeArray可以在C#层分配 C++中的对象，主动释放而不进行C#的垃圾回收。\n\nBurst性能对比：\n* .Net Code 比C++慢2倍\n* Mono比.NET Code慢3倍\n* IL2CPP与.NET Code相当\n* Burst将比C++运行更快。\n\nhttp://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-3-CSharp-Unity-Burst/\n\n2.2 代码使用\n\n* 数据类型只能是值类型和其他类型的指针\n* 不能使用引用类型，如T[]数组就不能在job中使用，应用HPC#的NativeArray代替\n\n![enter description here](/img/1584498872491.png)\n\n> IJob与IJobParallelFor\n> IJob是一个一个的开线程任务，顺序执行的，所以正确性有保证\n> 如果想让线程真正并行，则应使用JobParallelFor。这样并行后的数据就不会有前后依赖关系。\n> 使用ReadOnly标记的数据，只读后让Job不为其加锁。\n> 默认的数据是Read/Write的，这样在改变数据后，Job一定会等它。\n> 加解锁unity已经做好了，不需要自己实现逻辑。\n> \n![enter description here](/img/1584499275880.png)\n\n### 3.Burst编译器\n\n3.1 原理\n* 以开源LLVM为基础的后端编译技术\n* 原理的5个步骤：源代码》前端》优化器》后端 》机器码\n* LLVM定义抽象语言IR，前端负责将源代码（C#）翻译成IR，优化器优化，后端将IR生成目标语言（机器码）。\n* IR的存在，所以LLVM支持众多语言\n* LLVM对C#的GC支持不好，目前burst只支持值类型。\n\n3.2 内存别名\n* 之前的编译器无法知道运行时两个指针指向同一个地址的情况，编译出的代码必然要占用额外寄存器多次拷贝，无法优化。\n* NativeArray的API禁止限制了内存别名，不存在两个指针指向同一地址的情况。所以它更加高效。\n\n\n3.3 Unity.Mathmatcis数学库\n* 更高效的数据库，提供矢量类型float3,float4. 直接映射到SIMD寄存器\n* Math类中也提供了直接映射 到硬件SIMD寄存器。\n* SIMD可以一次性计算完毕。\n* 旧Math类是不支持SIMD寄存器的。\n*\n\n3.4 启动BurstCompile\n* 添加标签即可：\n* Struct必须实现IJob接口\n![enter description here](/img/1584499995727.png)\n\n\n### 4. ECS\n\n4.1 组合模式：\n需要什么功能加什么组件\n\n4.2 传统脚本的问题：\n* 耦合度过高\n* 引用类型\n* 挂脚本过重，产生 0.01s耗时\n* 热更支持不好\n\n4.3 Entity  实体\nA entity is a key.\n* 非常轻量级，一个ID用Int保存。\n* 根据需要绑定组件\n* 对Cache友好，将相同的组件排列在一起，遍历更快。\n\n4.4 Component 组件\n数据层，只有数据\n* 实现IcomponentData接口的结构体，不能写方法，没有任何行为\n* 注意使用新的数学库代替一些变量。\n\n> ArcheType原型\n> 组件命中率高得益于Archetype\n> unity规定每个archetype为16K，不够再开，保证连续性\n\n![enter description here](/img/1584500576606.png)\n\n> 共享组件\n> 区别IcomponentData于，IsharedComponentData共享组件。是为了避免结构体存储的数据完全相同，从而占用多份内存\n> 典型的例子：场景中很多相同mesh和材质的物体。\n> 必须实现IEquatable接口！\n\n![共享组件](/img/1584501076960.png)\n![enter description here](/img/1584501108996.png)\n\n4.5 System系统\nA system is a data tranform.\n* 只与Component关联，不关心entity\n* 在Update中可以统一更新自己关心的组件\n\n![enter description here](/img/1584500759081.png)\n\n4.6 World世界\nWorlds ars for isolation\n* 包含EntityManager, ComponentSystem, ArcheTypes.\n* ECS默认提供了一个World，也可自己创建\n* 世界之间不互通，可以同时并行\n\n### 5. ECS + Job + Burst让性能飞起来\n\n5.1 JobComponentSystem \n\n* 使用继承于ComponentSystem的JobComponentSystem\n* JobComponentSystem的Update效率更高，复杂运算将由Job完成\n*  标识ReadOnly让Job的数据并行\n*  如果Job数据变更，此Job就不能与其他访问此数据的JOB并行\n\n5.2 JCS与CS混合\n\n* JCS中的实体有任何 结构数据变更修改都带来硬性同步点\n* JCS必须保证后面执行的CS拿到的数据准确性，实体增删改都会带来同步点，导致线程卡顿。\n\n\n5.3 ECS渲染\n\n* ECS自身不包含渲染，但游戏中的渲染与实体是紧密绑定的\n* 原理大致是ECS在Job中先准备渲染的数据，通过GPU Instancing一次渲染，中间不产生gameobject.\n* GPU instancing不带裁剪，且需要每帧在Update中调用刷新。建议使用CommandBuffer来渲染Gpu instancing，如果在有变化时再刷新。\n\nhttps://www.xuanyusong.com/archives/4683\n\n* 使用BatchRendererGroup代替Graphics.DrawMeshInstanced和CommandBuffer.DrawMeshInstanced\n* BRG强制需要镜头裁剪的JOB方法，自己实现\n* BRG需要提供每个渲染物体的包围盒区载用于job中判断是否不在视野。\n* BRG内部会调自动Graphics.DrawMeshInstanced且没有1023的数量限制。\n\n![enter description here](/img/1584502302892.png)\n\n![enter description here](/img/1584502316800.png)\n\n\n### 6.实践\n\n6.1  装Entites, Burst, Hybrid Render, Dots Editor\n\n>报错了？The type or namespace name 'CompilerServices' does not exist in the namespace 'Unity.Burst' (are you missing an assembly reference?)\n>选择安装preview下的最高版本，如burst会默认安装非preview的版本\n\n6.2 实例1 创建entity\n\n```csharp\nusing UnityEngine;\nusing Unity.Transforms;\nusing Unity.Entities;\nusing Unity.Rendering;\nusing Unity.Mathematics;\npublic class Spawner : MonoBehaviour\n{\n    [SerializeField] private Mesh unitMesh;\n    [SerializeField] private Material unitMat;\n\n    private EntityManager unitManager;\n    private EntityArchetype entityArcheType;\n    // Start is called before the first frame update\n    void Start()\n    {\n        InitEntityManager();\n        CreateArcheType();\n        CreateEntity();\n    }\n\n    void InitEntityManager()\n    {\n        unitManager = World.DefaultGameObjectInjectionWorld.EntityManager;\n    }\n\n    void CreateEntity()\n    {\n        Entity hero = unitManager.CreateEntity(entityArcheType);\n        unitManager.AddComponentData(hero, new Translation(){\n            Value = new float3(1, 1, 1)\n        });\n\n        unitManager.AddComponentData(hero, new Scale()\n        {\n            Value = 1.0f\n        });\n\n        unitManager.AddSharedComponentData(hero, new RenderMesh()\n        {\n            mesh = unitMesh,\n            material = unitMat\n        });\n        \n    }\n\n    void CreateArcheType()\n    {\n        var translationType = ComponentType.ReadWrite<Translation>();\n        var scaleType = ComponentType.ReadWrite<Scale>();\n        var rotationType = ComponentType.ReadWrite<Rotation>();\n        var renderType = ComponentType.ReadWrite<RenderMesh>();\n        var renderBoundsType = ComponentType.ReadWrite<RenderBounds>();\n        var localToWorldType = ComponentType.ReadWrite<LocalToWorld>();\n        entityArcheType = unitManager.CreateArchetype(translationType, scaleType, rotationType, renderType, renderBoundsType, localToWorldType);\n    }\n}\n```\n\n> 注意： RenderBounds 如果不加，会导致不显示。。\n\n6.2 实例2 自定义system\n\nSystem定义后，将自动执行update函数。\n\n```csharp\nusing Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\npublic class MoveSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        Entities.ForEach((ref Translation trans, ref MoveBySpeedData moveSpeed, ref WaveData waveData) =>\n        {\n            float zPos = waveData.amplitude * math.sin((float)Time.ElapsedTime * moveSpeed.Value\n                + trans.Value.x * waveData.xOffset + trans.Value.y * waveData.yOffset);\n            trans.Value = new float3(trans.Value.x, trans.Value.y, zPos);\n        });\n    }\n}\n\n```\n\n6.3 实例3 加入JOB与Burst\n\n在实例2的基础上加上Job和Burst\n\n```csharp\n\nusing Unity.Burst;\nusing Unity.Collections;\nusing Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\npublic class MoveSystem : JobComponentSystem\n{\n    [BurstCompile]\n    private struct MoveJob : IJobChunk\n    {\n        public double ElapsedTime;\n\n        public ArchetypeChunkComponentType<Translation> TranslationType;\n        [ReadOnly] public ArchetypeChunkComponentType<MoveBySpeedData> MoveBySpeedDataType;\n        [ReadOnly] public ArchetypeChunkComponentType<WaveData> WaveDataType;\n        public uint LastSystemVersion;\n        public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)\n        {\n\n            var chunkTrans = chunk.GetNativeArray(TranslationType);\n            var chunkSpeedDatas = chunk.GetNativeArray(MoveBySpeedDataType);\n            var chunkWaveDatas = chunk.GetNativeArray(WaveDataType);\n\n            for (var i = 0; i < chunk.Count; i++)\n            {\n                var moveSpeed = chunkSpeedDatas[i];\n                var waveData = chunkWaveDatas[i];\n                var trans = chunkTrans[i];\n                float zPos = waveData.amplitude * math.sin((float)ElapsedTime * moveSpeed.Value\n               + trans.Value.x * waveData.xOffset + trans.Value.y * waveData.yOffset);\n\n                // Rotate something about its up vector at the speed given by RotationSpeed.\n                chunkTrans[i] = new Translation\n                {\n                    Value = new float3(trans.Value.x, trans.Value.y, zPos)\n                };\n            }\n        }\n    }\n    EntityQuery m_Group;\n    protected override void OnCreate()\n    {\n        m_Group = GetEntityQuery(ComponentType.ReadOnly<MoveBySpeedData>(),\n                               ComponentType.ReadOnly<WaveData>());\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        var job = new MoveJob()\n        {\n            TranslationType = GetArchetypeChunkComponentType<Translation>(false),\n            MoveBySpeedDataType = GetArchetypeChunkComponentType<MoveBySpeedData>(true),\n            WaveDataType = GetArchetypeChunkComponentType<WaveData>(true),\n            ElapsedTime = Time.ElapsedTime\n        };\n        return job.Schedule(m_Group, inputDeps);\n    }\n}\n\n```\n\n### 7. 使用Conversion\n流程明细：\n```c#\n// ??? <- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? <- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update() <-- 你的 Convert 方法在这时运行\nGameObjectAfterConversionGroup.Update()\n// ??? <- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()\n```\n\n7.1 ConversionToEntity\n* 为GameObject添加ConversionToEntity将自动转换为ECS的entity. \n* 添加ConversionToEntity(Stop)将保持为原gameobject\n\n7.2 ConversionMode\n* Convert And Destroy模式：如果没有conversion system处理的组件，在Conversion world 被带入的东西在world销毁时也同时销毁。\n* Convert and inject 模式： 此模式下，相比上一个组件都会保留。\n> Convert and inject模式是用于当你需要在 conversion 的结果上面回溯原有对象的情况下才有用, 而 Hybrid Renderer 显然无需回溯。\n\n7.3 IConvertGameObjectToEntity\n* 继承此接口，在方法Convert里自由控制conversion的过程\n> Unity 内置了另一种名为ConvertGameObjectToEntitySystem 的 conversion system. 该 system 会迭代 conversion world 中所有的GameObject, 接着使用GetComponents 并判断是否实现IConvertGameObjectToEntity 接口, 然后再调用该接口的.Convert 方法\n\n7.4 LinkedEntityGroup\n* 为原层次结构做关联的组件。同时也是一个dynmaic buffer。 \n* 调用Instantiate方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的LinkedEntityGroup. 注意实例化并不一定和ECS中的Prefab component 直接关联.\n* 调用DestroyEntity时也会同时销毁 LinkedEntityGroup中的所有 entity. 类似在编辑器中删除GameObject\n* 调用 entityManager.SetEnabled 加上的 Disabledcomponent 会告知 ECS 的查询系统忽略它们, 而 LinkedEntityGroup 中的 entity 也会受到同样的影响. 有点类似禁用GameObject 时同时会禁用整个层级树.\n\n> 当有子物体Disable状态时，此子物体自身不会生成linkedentitygroup的子结构,但可以手动在此disable上添加\n\n> 注意如果buffer 中的 entity 也有LinkedEntityGroup, 系统不会递归地执行instantiation/destroy/disabled 过程.\n这些过程在具体执行当中也有一些细微不同.Instantiate和SetEnabled只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity 必须要把自己包括在内才能正常工作. 然而DestroyEntity则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.\n要注意LinkedEntityGroup 和 Parent并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.\n\n* 为gameobject添加\n```c#\npublic class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n```\n\n> 在 entities-0.5.1版本里, TypeManager.cs 源码中可看到, 任何没有[InternalBufferCapacity] 的buffer 类型都会默认 128/size 的容量. LinkedEntityGroup里面装的是 entity, 因此其容量是 128/8 = 16 .\n每个 Entity 关联的LinkedEntityGroup(或者其他未指定 capacity 的buffer) 将占据 128 bytes. 这是 chunk 容积变小的原因.\n层级中超过16个子对象并不是什么好事, 一旦超过这个数量, 这些 linked entities 不得不从排列良好的 chunk 内存中挪到堆内存中. 可能 Unity 认为 16 是一个不太可能达到的值, 而 8 又太过于常见.\n除非显式调用, LinkedEntityGroup仅仅在 prefab 的 conversion 过程中被自动创建, 因此你只需要注意你的 prefab 里面嵌套的 GameObject 数量\n在运行时, 所有嵌套 prefab 和 prefab variant 工作流并不受影响, 系统内部只把它们看过一个单独的 prefab. 你无法把嵌套 prefab 从父 prefab 中拿出来, 并期望LinkedEntityGroup正常工作.\n最后, 16个entities 一个 chunk ，  1MB 大概包含 60 个 chunk. 如上例, 你能在 1MB 存储大约 2700 个转换后的GameObject , 这样看来或许45 的 chunk 容量也不用太担心了(当然具体情况具体分析).\n\n7.5 创建额外的entity\n使用如下方式：\n```c#\n  Entity additional1 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional1, $\"{this.name}_Add1\");\n        Entity additional2 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional2, $\"{this.name}_Add2\");\n```\n\n> 注意：此方式创建的entity将不在linkedentitygroup内，且是完全空的entity\n","source":"_posts/ECS-研究学习.md","raw":"---\ntitle: DOTS-研究学习\ncategories:\n- Unity\n---\n\n### 1. What is DOTS?\n\nDATA-ORIENTED TECH STACK\n多线程式数据导向型技术堆栈\n\n 核心-高性能\n充分利用多核处理器，多线程，让游戏运行速度更快。\n组成部分如下：\n* C# 任务系统， Job System，用于高效运行多线程代码\n* 实体组件系统，ECS， 默认编写的高性能代码的框架结构\n* Burst编译器，用于生成高度优化的本地代码\n\nJob System 与ECS是独立的，两者结合实际才能发挥最大优势。\n\n### 2. Job System\n\n* 在Job System之前，unity 仅在内部支持多线程，外部都必须运行在主线程上\n* C#虽然支持多线程，但在unity中只处理数据，如网络消息，下载等等，且在线程中调用Unity的API是不行的。\n* 有了Job System,可以充分利用多核CPU，比如在多线程中修改Transform等\n* 例：MMO游戏判断碰撞，大量同步角色坐标，大量血条飘字等较为适合\n* 不必过于担心线程安全，加锁的问题\n* 配合Burst更佳\n\n2.1 HPC# -High Performance C#\n\n介绍：\n* IL2Cpp虽然将IL转成C++，但实际还是模拟了.NET的垃圾回收，效率并非等同C++\n* 使用NativeArray代替T[]，数据类型包括了值类型和其他类型指针\n* NativeArray可以在C#层分配 C++中的对象，主动释放而不进行C#的垃圾回收。\n\nBurst性能对比：\n* .Net Code 比C++慢2倍\n* Mono比.NET Code慢3倍\n* IL2CPP与.NET Code相当\n* Burst将比C++运行更快。\n\nhttp://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-3-CSharp-Unity-Burst/\n\n2.2 代码使用\n\n* 数据类型只能是值类型和其他类型的指针\n* 不能使用引用类型，如T[]数组就不能在job中使用，应用HPC#的NativeArray代替\n\n![enter description here](/img/1584498872491.png)\n\n> IJob与IJobParallelFor\n> IJob是一个一个的开线程任务，顺序执行的，所以正确性有保证\n> 如果想让线程真正并行，则应使用JobParallelFor。这样并行后的数据就不会有前后依赖关系。\n> 使用ReadOnly标记的数据，只读后让Job不为其加锁。\n> 默认的数据是Read/Write的，这样在改变数据后，Job一定会等它。\n> 加解锁unity已经做好了，不需要自己实现逻辑。\n> \n![enter description here](/img/1584499275880.png)\n\n### 3.Burst编译器\n\n3.1 原理\n* 以开源LLVM为基础的后端编译技术\n* 原理的5个步骤：源代码》前端》优化器》后端 》机器码\n* LLVM定义抽象语言IR，前端负责将源代码（C#）翻译成IR，优化器优化，后端将IR生成目标语言（机器码）。\n* IR的存在，所以LLVM支持众多语言\n* LLVM对C#的GC支持不好，目前burst只支持值类型。\n\n3.2 内存别名\n* 之前的编译器无法知道运行时两个指针指向同一个地址的情况，编译出的代码必然要占用额外寄存器多次拷贝，无法优化。\n* NativeArray的API禁止限制了内存别名，不存在两个指针指向同一地址的情况。所以它更加高效。\n\n\n3.3 Unity.Mathmatcis数学库\n* 更高效的数据库，提供矢量类型float3,float4. 直接映射到SIMD寄存器\n* Math类中也提供了直接映射 到硬件SIMD寄存器。\n* SIMD可以一次性计算完毕。\n* 旧Math类是不支持SIMD寄存器的。\n*\n\n3.4 启动BurstCompile\n* 添加标签即可：\n* Struct必须实现IJob接口\n![enter description here](/img/1584499995727.png)\n\n\n### 4. ECS\n\n4.1 组合模式：\n需要什么功能加什么组件\n\n4.2 传统脚本的问题：\n* 耦合度过高\n* 引用类型\n* 挂脚本过重，产生 0.01s耗时\n* 热更支持不好\n\n4.3 Entity  实体\nA entity is a key.\n* 非常轻量级，一个ID用Int保存。\n* 根据需要绑定组件\n* 对Cache友好，将相同的组件排列在一起，遍历更快。\n\n4.4 Component 组件\n数据层，只有数据\n* 实现IcomponentData接口的结构体，不能写方法，没有任何行为\n* 注意使用新的数学库代替一些变量。\n\n> ArcheType原型\n> 组件命中率高得益于Archetype\n> unity规定每个archetype为16K，不够再开，保证连续性\n\n![enter description here](/img/1584500576606.png)\n\n> 共享组件\n> 区别IcomponentData于，IsharedComponentData共享组件。是为了避免结构体存储的数据完全相同，从而占用多份内存\n> 典型的例子：场景中很多相同mesh和材质的物体。\n> 必须实现IEquatable接口！\n\n![共享组件](/img/1584501076960.png)\n![enter description here](/img/1584501108996.png)\n\n4.5 System系统\nA system is a data tranform.\n* 只与Component关联，不关心entity\n* 在Update中可以统一更新自己关心的组件\n\n![enter description here](/img/1584500759081.png)\n\n4.6 World世界\nWorlds ars for isolation\n* 包含EntityManager, ComponentSystem, ArcheTypes.\n* ECS默认提供了一个World，也可自己创建\n* 世界之间不互通，可以同时并行\n\n### 5. ECS + Job + Burst让性能飞起来\n\n5.1 JobComponentSystem \n\n* 使用继承于ComponentSystem的JobComponentSystem\n* JobComponentSystem的Update效率更高，复杂运算将由Job完成\n*  标识ReadOnly让Job的数据并行\n*  如果Job数据变更，此Job就不能与其他访问此数据的JOB并行\n\n5.2 JCS与CS混合\n\n* JCS中的实体有任何 结构数据变更修改都带来硬性同步点\n* JCS必须保证后面执行的CS拿到的数据准确性，实体增删改都会带来同步点，导致线程卡顿。\n\n\n5.3 ECS渲染\n\n* ECS自身不包含渲染，但游戏中的渲染与实体是紧密绑定的\n* 原理大致是ECS在Job中先准备渲染的数据，通过GPU Instancing一次渲染，中间不产生gameobject.\n* GPU instancing不带裁剪，且需要每帧在Update中调用刷新。建议使用CommandBuffer来渲染Gpu instancing，如果在有变化时再刷新。\n\nhttps://www.xuanyusong.com/archives/4683\n\n* 使用BatchRendererGroup代替Graphics.DrawMeshInstanced和CommandBuffer.DrawMeshInstanced\n* BRG强制需要镜头裁剪的JOB方法，自己实现\n* BRG需要提供每个渲染物体的包围盒区载用于job中判断是否不在视野。\n* BRG内部会调自动Graphics.DrawMeshInstanced且没有1023的数量限制。\n\n![enter description here](/img/1584502302892.png)\n\n![enter description here](/img/1584502316800.png)\n\n\n### 6.实践\n\n6.1  装Entites, Burst, Hybrid Render, Dots Editor\n\n>报错了？The type or namespace name 'CompilerServices' does not exist in the namespace 'Unity.Burst' (are you missing an assembly reference?)\n>选择安装preview下的最高版本，如burst会默认安装非preview的版本\n\n6.2 实例1 创建entity\n\n```csharp\nusing UnityEngine;\nusing Unity.Transforms;\nusing Unity.Entities;\nusing Unity.Rendering;\nusing Unity.Mathematics;\npublic class Spawner : MonoBehaviour\n{\n    [SerializeField] private Mesh unitMesh;\n    [SerializeField] private Material unitMat;\n\n    private EntityManager unitManager;\n    private EntityArchetype entityArcheType;\n    // Start is called before the first frame update\n    void Start()\n    {\n        InitEntityManager();\n        CreateArcheType();\n        CreateEntity();\n    }\n\n    void InitEntityManager()\n    {\n        unitManager = World.DefaultGameObjectInjectionWorld.EntityManager;\n    }\n\n    void CreateEntity()\n    {\n        Entity hero = unitManager.CreateEntity(entityArcheType);\n        unitManager.AddComponentData(hero, new Translation(){\n            Value = new float3(1, 1, 1)\n        });\n\n        unitManager.AddComponentData(hero, new Scale()\n        {\n            Value = 1.0f\n        });\n\n        unitManager.AddSharedComponentData(hero, new RenderMesh()\n        {\n            mesh = unitMesh,\n            material = unitMat\n        });\n        \n    }\n\n    void CreateArcheType()\n    {\n        var translationType = ComponentType.ReadWrite<Translation>();\n        var scaleType = ComponentType.ReadWrite<Scale>();\n        var rotationType = ComponentType.ReadWrite<Rotation>();\n        var renderType = ComponentType.ReadWrite<RenderMesh>();\n        var renderBoundsType = ComponentType.ReadWrite<RenderBounds>();\n        var localToWorldType = ComponentType.ReadWrite<LocalToWorld>();\n        entityArcheType = unitManager.CreateArchetype(translationType, scaleType, rotationType, renderType, renderBoundsType, localToWorldType);\n    }\n}\n```\n\n> 注意： RenderBounds 如果不加，会导致不显示。。\n\n6.2 实例2 自定义system\n\nSystem定义后，将自动执行update函数。\n\n```csharp\nusing Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\npublic class MoveSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        Entities.ForEach((ref Translation trans, ref MoveBySpeedData moveSpeed, ref WaveData waveData) =>\n        {\n            float zPos = waveData.amplitude * math.sin((float)Time.ElapsedTime * moveSpeed.Value\n                + trans.Value.x * waveData.xOffset + trans.Value.y * waveData.yOffset);\n            trans.Value = new float3(trans.Value.x, trans.Value.y, zPos);\n        });\n    }\n}\n\n```\n\n6.3 实例3 加入JOB与Burst\n\n在实例2的基础上加上Job和Burst\n\n```csharp\n\nusing Unity.Burst;\nusing Unity.Collections;\nusing Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\npublic class MoveSystem : JobComponentSystem\n{\n    [BurstCompile]\n    private struct MoveJob : IJobChunk\n    {\n        public double ElapsedTime;\n\n        public ArchetypeChunkComponentType<Translation> TranslationType;\n        [ReadOnly] public ArchetypeChunkComponentType<MoveBySpeedData> MoveBySpeedDataType;\n        [ReadOnly] public ArchetypeChunkComponentType<WaveData> WaveDataType;\n        public uint LastSystemVersion;\n        public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)\n        {\n\n            var chunkTrans = chunk.GetNativeArray(TranslationType);\n            var chunkSpeedDatas = chunk.GetNativeArray(MoveBySpeedDataType);\n            var chunkWaveDatas = chunk.GetNativeArray(WaveDataType);\n\n            for (var i = 0; i < chunk.Count; i++)\n            {\n                var moveSpeed = chunkSpeedDatas[i];\n                var waveData = chunkWaveDatas[i];\n                var trans = chunkTrans[i];\n                float zPos = waveData.amplitude * math.sin((float)ElapsedTime * moveSpeed.Value\n               + trans.Value.x * waveData.xOffset + trans.Value.y * waveData.yOffset);\n\n                // Rotate something about its up vector at the speed given by RotationSpeed.\n                chunkTrans[i] = new Translation\n                {\n                    Value = new float3(trans.Value.x, trans.Value.y, zPos)\n                };\n            }\n        }\n    }\n    EntityQuery m_Group;\n    protected override void OnCreate()\n    {\n        m_Group = GetEntityQuery(ComponentType.ReadOnly<MoveBySpeedData>(),\n                               ComponentType.ReadOnly<WaveData>());\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        var job = new MoveJob()\n        {\n            TranslationType = GetArchetypeChunkComponentType<Translation>(false),\n            MoveBySpeedDataType = GetArchetypeChunkComponentType<MoveBySpeedData>(true),\n            WaveDataType = GetArchetypeChunkComponentType<WaveData>(true),\n            ElapsedTime = Time.ElapsedTime\n        };\n        return job.Schedule(m_Group, inputDeps);\n    }\n}\n\n```\n\n### 7. 使用Conversion\n流程明细：\n```c#\n// ??? <- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? <- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update() <-- 你的 Convert 方法在这时运行\nGameObjectAfterConversionGroup.Update()\n// ??? <- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()\n```\n\n7.1 ConversionToEntity\n* 为GameObject添加ConversionToEntity将自动转换为ECS的entity. \n* 添加ConversionToEntity(Stop)将保持为原gameobject\n\n7.2 ConversionMode\n* Convert And Destroy模式：如果没有conversion system处理的组件，在Conversion world 被带入的东西在world销毁时也同时销毁。\n* Convert and inject 模式： 此模式下，相比上一个组件都会保留。\n> Convert and inject模式是用于当你需要在 conversion 的结果上面回溯原有对象的情况下才有用, 而 Hybrid Renderer 显然无需回溯。\n\n7.3 IConvertGameObjectToEntity\n* 继承此接口，在方法Convert里自由控制conversion的过程\n> Unity 内置了另一种名为ConvertGameObjectToEntitySystem 的 conversion system. 该 system 会迭代 conversion world 中所有的GameObject, 接着使用GetComponents 并判断是否实现IConvertGameObjectToEntity 接口, 然后再调用该接口的.Convert 方法\n\n7.4 LinkedEntityGroup\n* 为原层次结构做关联的组件。同时也是一个dynmaic buffer。 \n* 调用Instantiate方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的LinkedEntityGroup. 注意实例化并不一定和ECS中的Prefab component 直接关联.\n* 调用DestroyEntity时也会同时销毁 LinkedEntityGroup中的所有 entity. 类似在编辑器中删除GameObject\n* 调用 entityManager.SetEnabled 加上的 Disabledcomponent 会告知 ECS 的查询系统忽略它们, 而 LinkedEntityGroup 中的 entity 也会受到同样的影响. 有点类似禁用GameObject 时同时会禁用整个层级树.\n\n> 当有子物体Disable状态时，此子物体自身不会生成linkedentitygroup的子结构,但可以手动在此disable上添加\n\n> 注意如果buffer 中的 entity 也有LinkedEntityGroup, 系统不会递归地执行instantiation/destroy/disabled 过程.\n这些过程在具体执行当中也有一些细微不同.Instantiate和SetEnabled只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity 必须要把自己包括在内才能正常工作. 然而DestroyEntity则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.\n要注意LinkedEntityGroup 和 Parent并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.\n\n* 为gameobject添加\n```c#\npublic class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n    {\n        conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n    }\n}\n```\n\n> 在 entities-0.5.1版本里, TypeManager.cs 源码中可看到, 任何没有[InternalBufferCapacity] 的buffer 类型都会默认 128/size 的容量. LinkedEntityGroup里面装的是 entity, 因此其容量是 128/8 = 16 .\n每个 Entity 关联的LinkedEntityGroup(或者其他未指定 capacity 的buffer) 将占据 128 bytes. 这是 chunk 容积变小的原因.\n层级中超过16个子对象并不是什么好事, 一旦超过这个数量, 这些 linked entities 不得不从排列良好的 chunk 内存中挪到堆内存中. 可能 Unity 认为 16 是一个不太可能达到的值, 而 8 又太过于常见.\n除非显式调用, LinkedEntityGroup仅仅在 prefab 的 conversion 过程中被自动创建, 因此你只需要注意你的 prefab 里面嵌套的 GameObject 数量\n在运行时, 所有嵌套 prefab 和 prefab variant 工作流并不受影响, 系统内部只把它们看过一个单独的 prefab. 你无法把嵌套 prefab 从父 prefab 中拿出来, 并期望LinkedEntityGroup正常工作.\n最后, 16个entities 一个 chunk ，  1MB 大概包含 60 个 chunk. 如上例, 你能在 1MB 存储大约 2700 个转换后的GameObject , 这样看来或许45 的 chunk 容量也不用太担心了(当然具体情况具体分析).\n\n7.5 创建额外的entity\n使用如下方式：\n```c#\n  Entity additional1 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional1, $\"{this.name}_Add1\");\n        Entity additional2 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional2, $\"{this.name}_Add2\");\n```\n\n> 注意：此方式创建的entity将不在linkedentitygroup内，且是完全空的entity\n","slug":"ECS-研究学习","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0ys000x4wf00cnw4n0y","content":"<h3 id=\"1-What-is-DOTS\"><a href=\"#1-What-is-DOTS\" class=\"headerlink\" title=\"1. What is DOTS?\"></a>1. What is DOTS?</h3><p>DATA-ORIENTED TECH STACK<br>多线程式数据导向型技术堆栈</p>\n<p> 核心-高性能<br>充分利用多核处理器，多线程，让游戏运行速度更快。<br>组成部分如下：</p>\n<ul>\n<li>C# 任务系统， Job System，用于高效运行多线程代码</li>\n<li>实体组件系统，ECS， 默认编写的高性能代码的框架结构</li>\n<li>Burst编译器，用于生成高度优化的本地代码</li>\n</ul>\n<p>Job System 与ECS是独立的，两者结合实际才能发挥最大优势。</p>\n<h3 id=\"2-Job-System\"><a href=\"#2-Job-System\" class=\"headerlink\" title=\"2. Job System\"></a>2. Job System</h3><ul>\n<li>在Job System之前，unity 仅在内部支持多线程，外部都必须运行在主线程上</li>\n<li>C#虽然支持多线程，但在unity中只处理数据，如网络消息，下载等等，且在线程中调用Unity的API是不行的。</li>\n<li>有了Job System,可以充分利用多核CPU，比如在多线程中修改Transform等</li>\n<li>例：MMO游戏判断碰撞，大量同步角色坐标，大量血条飘字等较为适合</li>\n<li>不必过于担心线程安全，加锁的问题</li>\n<li>配合Burst更佳</li>\n</ul>\n<p>2.1 HPC# -High Performance C#</p>\n<p>介绍：</p>\n<ul>\n<li>IL2Cpp虽然将IL转成C++，但实际还是模拟了.NET的垃圾回收，效率并非等同C++</li>\n<li>使用NativeArray代替T[]，数据类型包括了值类型和其他类型指针</li>\n<li>NativeArray可以在C#层分配 C++中的对象，主动释放而不进行C#的垃圾回收。</li>\n</ul>\n<p>Burst性能对比：</p>\n<ul>\n<li>.Net Code 比C++慢2倍</li>\n<li>Mono比.NET Code慢3倍</li>\n<li>IL2CPP与.NET Code相当</li>\n<li>Burst将比C++运行更快。</li>\n</ul>\n<p><a href=\"http://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-3-CSharp-Unity-Burst/\">http://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-3-CSharp-Unity-Burst/</a></p>\n<p>2.2 代码使用</p>\n<ul>\n<li>数据类型只能是值类型和其他类型的指针</li>\n<li>不能使用引用类型，如T[]数组就不能在job中使用，应用HPC#的NativeArray代替</li>\n</ul>\n<p><img src=\"/img/1584498872491.png\" alt=\"enter description here\"></p>\n<blockquote>\n<p>IJob与IJobParallelFor<br>IJob是一个一个的开线程任务，顺序执行的，所以正确性有保证<br>如果想让线程真正并行，则应使用JobParallelFor。这样并行后的数据就不会有前后依赖关系。<br>使用ReadOnly标记的数据，只读后让Job不为其加锁。<br>默认的数据是Read/Write的，这样在改变数据后，Job一定会等它。<br>加解锁unity已经做好了，不需要自己实现逻辑。</p>\n</blockquote>\n<p><img src=\"/img/1584499275880.png\" alt=\"enter description here\"></p>\n<h3 id=\"3-Burst编译器\"><a href=\"#3-Burst编译器\" class=\"headerlink\" title=\"3.Burst编译器\"></a>3.Burst编译器</h3><p>3.1 原理</p>\n<ul>\n<li>以开源LLVM为基础的后端编译技术</li>\n<li>原理的5个步骤：源代码》前端》优化器》后端 》机器码</li>\n<li>LLVM定义抽象语言IR，前端负责将源代码（C#）翻译成IR，优化器优化，后端将IR生成目标语言（机器码）。</li>\n<li>IR的存在，所以LLVM支持众多语言</li>\n<li>LLVM对C#的GC支持不好，目前burst只支持值类型。</li>\n</ul>\n<p>3.2 内存别名</p>\n<ul>\n<li>之前的编译器无法知道运行时两个指针指向同一个地址的情况，编译出的代码必然要占用额外寄存器多次拷贝，无法优化。</li>\n<li>NativeArray的API禁止限制了内存别名，不存在两个指针指向同一地址的情况。所以它更加高效。</li>\n</ul>\n<p>3.3 Unity.Mathmatcis数学库</p>\n<ul>\n<li>更高效的数据库，提供矢量类型float3,float4. 直接映射到SIMD寄存器</li>\n<li>Math类中也提供了直接映射 到硬件SIMD寄存器。</li>\n<li>SIMD可以一次性计算完毕。</li>\n<li>旧Math类是不支持SIMD寄存器的。</li>\n<li></li>\n</ul>\n<p>3.4 启动BurstCompile</p>\n<ul>\n<li>添加标签即可：</li>\n<li>Struct必须实现IJob接口<br><img src=\"/img/1584499995727.png\" alt=\"enter description here\"></li>\n</ul>\n<h3 id=\"4-ECS\"><a href=\"#4-ECS\" class=\"headerlink\" title=\"4. ECS\"></a>4. ECS</h3><p>4.1 组合模式：<br>需要什么功能加什么组件</p>\n<p>4.2 传统脚本的问题：</p>\n<ul>\n<li>耦合度过高</li>\n<li>引用类型</li>\n<li>挂脚本过重，产生 0.01s耗时</li>\n<li>热更支持不好</li>\n</ul>\n<p>4.3 Entity  实体<br>A entity is a key.</p>\n<ul>\n<li>非常轻量级，一个ID用Int保存。</li>\n<li>根据需要绑定组件</li>\n<li>对Cache友好，将相同的组件排列在一起，遍历更快。</li>\n</ul>\n<p>4.4 Component 组件<br>数据层，只有数据</p>\n<ul>\n<li>实现IcomponentData接口的结构体，不能写方法，没有任何行为</li>\n<li>注意使用新的数学库代替一些变量。</li>\n</ul>\n<blockquote>\n<p>ArcheType原型<br>组件命中率高得益于Archetype<br>unity规定每个archetype为16K，不够再开，保证连续性</p>\n</blockquote>\n<p><img src=\"/img/1584500576606.png\" alt=\"enter description here\"></p>\n<blockquote>\n<p>共享组件<br>区别IcomponentData于，IsharedComponentData共享组件。是为了避免结构体存储的数据完全相同，从而占用多份内存<br>典型的例子：场景中很多相同mesh和材质的物体。<br>必须实现IEquatable接口！</p>\n</blockquote>\n<p><img src=\"/img/1584501076960.png\" alt=\"共享组件\"><br><img src=\"/img/1584501108996.png\" alt=\"enter description here\"></p>\n<p>4.5 System系统<br>A system is a data tranform.</p>\n<ul>\n<li>只与Component关联，不关心entity</li>\n<li>在Update中可以统一更新自己关心的组件</li>\n</ul>\n<p><img src=\"/img/1584500759081.png\" alt=\"enter description here\"></p>\n<p>4.6 World世界<br>Worlds ars for isolation</p>\n<ul>\n<li>包含EntityManager, ComponentSystem, ArcheTypes.</li>\n<li>ECS默认提供了一个World，也可自己创建</li>\n<li>世界之间不互通，可以同时并行</li>\n</ul>\n<h3 id=\"5-ECS-Job-Burst让性能飞起来\"><a href=\"#5-ECS-Job-Burst让性能飞起来\" class=\"headerlink\" title=\"5. ECS + Job + Burst让性能飞起来\"></a>5. ECS + Job + Burst让性能飞起来</h3><p>5.1 JobComponentSystem </p>\n<ul>\n<li>使用继承于ComponentSystem的JobComponentSystem</li>\n<li>JobComponentSystem的Update效率更高，复杂运算将由Job完成</li>\n<li>标识ReadOnly让Job的数据并行</li>\n<li>如果Job数据变更，此Job就不能与其他访问此数据的JOB并行</li>\n</ul>\n<p>5.2 JCS与CS混合</p>\n<ul>\n<li>JCS中的实体有任何 结构数据变更修改都带来硬性同步点</li>\n<li>JCS必须保证后面执行的CS拿到的数据准确性，实体增删改都会带来同步点，导致线程卡顿。</li>\n</ul>\n<p>5.3 ECS渲染</p>\n<ul>\n<li>ECS自身不包含渲染，但游戏中的渲染与实体是紧密绑定的</li>\n<li>原理大致是ECS在Job中先准备渲染的数据，通过GPU Instancing一次渲染，中间不产生gameobject.</li>\n<li>GPU instancing不带裁剪，且需要每帧在Update中调用刷新。建议使用CommandBuffer来渲染Gpu instancing，如果在有变化时再刷新。</li>\n</ul>\n<p><a href=\"https://www.xuanyusong.com/archives/4683\">https://www.xuanyusong.com/archives/4683</a></p>\n<ul>\n<li>使用BatchRendererGroup代替Graphics.DrawMeshInstanced和CommandBuffer.DrawMeshInstanced</li>\n<li>BRG强制需要镜头裁剪的JOB方法，自己实现</li>\n<li>BRG需要提供每个渲染物体的包围盒区载用于job中判断是否不在视野。</li>\n<li>BRG内部会调自动Graphics.DrawMeshInstanced且没有1023的数量限制。</li>\n</ul>\n<p><img src=\"/img/1584502302892.png\" alt=\"enter description here\"></p>\n<p><img src=\"/img/1584502316800.png\" alt=\"enter description here\"></p>\n<h3 id=\"6-实践\"><a href=\"#6-实践\" class=\"headerlink\" title=\"6.实践\"></a>6.实践</h3><p>6.1  装Entites, Burst, Hybrid Render, Dots Editor</p>\n<blockquote>\n<p>报错了？The type or namespace name ‘CompilerServices’ does not exist in the namespace ‘Unity.Burst’ (are you missing an assembly reference?)<br>选择安装preview下的最高版本，如burst会默认安装非preview的版本</p>\n</blockquote>\n<p>6.2 实例1 创建entity</p>\n<pre><code class=\"csharp\">using UnityEngine;\nusing Unity.Transforms;\nusing Unity.Entities;\nusing Unity.Rendering;\nusing Unity.Mathematics;\npublic class Spawner : MonoBehaviour\n{\n    [SerializeField] private Mesh unitMesh;\n    [SerializeField] private Material unitMat;\n\n    private EntityManager unitManager;\n    private EntityArchetype entityArcheType;\n    // Start is called before the first frame update\n    void Start()\n    {\n        InitEntityManager();\n        CreateArcheType();\n        CreateEntity();\n    }\n\n    void InitEntityManager()\n    {\n        unitManager = World.DefaultGameObjectInjectionWorld.EntityManager;\n    }\n\n    void CreateEntity()\n    {\n        Entity hero = unitManager.CreateEntity(entityArcheType);\n        unitManager.AddComponentData(hero, new Translation(){\n            Value = new float3(1, 1, 1)\n        });\n\n        unitManager.AddComponentData(hero, new Scale()\n        {\n            Value = 1.0f\n        });\n\n        unitManager.AddSharedComponentData(hero, new RenderMesh()\n        {\n            mesh = unitMesh,\n            material = unitMat\n        });\n\n    }\n\n    void CreateArcheType()\n    {\n        var translationType = ComponentType.ReadWrite&lt;Translation&gt;();\n        var scaleType = ComponentType.ReadWrite&lt;Scale&gt;();\n        var rotationType = ComponentType.ReadWrite&lt;Rotation&gt;();\n        var renderType = ComponentType.ReadWrite&lt;RenderMesh&gt;();\n        var renderBoundsType = ComponentType.ReadWrite&lt;RenderBounds&gt;();\n        var localToWorldType = ComponentType.ReadWrite&lt;LocalToWorld&gt;();\n        entityArcheType = unitManager.CreateArchetype(translationType, scaleType, rotationType, renderType, renderBoundsType, localToWorldType);\n    }\n}</code></pre>\n<blockquote>\n<p>注意： RenderBounds 如果不加，会导致不显示。。</p>\n</blockquote>\n<p>6.2 实例2 自定义system</p>\n<p>System定义后，将自动执行update函数。</p>\n<pre><code class=\"csharp\">using Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\npublic class MoveSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        Entities.ForEach((ref Translation trans, ref MoveBySpeedData moveSpeed, ref WaveData waveData) =&gt;\n        {\n            float zPos = waveData.amplitude * math.sin((float)Time.ElapsedTime * moveSpeed.Value\n                + trans.Value.x * waveData.xOffset + trans.Value.y * waveData.yOffset);\n            trans.Value = new float3(trans.Value.x, trans.Value.y, zPos);\n        });\n    }\n}\n</code></pre>\n<p>6.3 实例3 加入JOB与Burst</p>\n<p>在实例2的基础上加上Job和Burst</p>\n<pre><code class=\"csharp\">\nusing Unity.Burst;\nusing Unity.Collections;\nusing Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\npublic class MoveSystem : JobComponentSystem\n{\n    [BurstCompile]\n    private struct MoveJob : IJobChunk\n    {\n        public double ElapsedTime;\n\n        public ArchetypeChunkComponentType&lt;Translation&gt; TranslationType;\n        [ReadOnly] public ArchetypeChunkComponentType&lt;MoveBySpeedData&gt; MoveBySpeedDataType;\n        [ReadOnly] public ArchetypeChunkComponentType&lt;WaveData&gt; WaveDataType;\n        public uint LastSystemVersion;\n        public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)\n        {\n\n            var chunkTrans = chunk.GetNativeArray(TranslationType);\n            var chunkSpeedDatas = chunk.GetNativeArray(MoveBySpeedDataType);\n            var chunkWaveDatas = chunk.GetNativeArray(WaveDataType);\n\n            for (var i = 0; i &lt; chunk.Count; i++)\n            {\n                var moveSpeed = chunkSpeedDatas[i];\n                var waveData = chunkWaveDatas[i];\n                var trans = chunkTrans[i];\n                float zPos = waveData.amplitude * math.sin((float)ElapsedTime * moveSpeed.Value\n               + trans.Value.x * waveData.xOffset + trans.Value.y * waveData.yOffset);\n\n                // Rotate something about its up vector at the speed given by RotationSpeed.\n                chunkTrans[i] = new Translation\n                {\n                    Value = new float3(trans.Value.x, trans.Value.y, zPos)\n                };\n            }\n        }\n    }\n    EntityQuery m_Group;\n    protected override void OnCreate()\n    {\n        m_Group = GetEntityQuery(ComponentType.ReadOnly&lt;MoveBySpeedData&gt;(),\n                               ComponentType.ReadOnly&lt;WaveData&gt;());\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        var job = new MoveJob()\n        {\n            TranslationType = GetArchetypeChunkComponentType&lt;Translation&gt;(false),\n            MoveBySpeedDataType = GetArchetypeChunkComponentType&lt;MoveBySpeedData&gt;(true),\n            WaveDataType = GetArchetypeChunkComponentType&lt;WaveData&gt;(true),\n            ElapsedTime = Time.ElapsedTime\n        };\n        return job.Schedule(m_Group, inputDeps);\n    }\n}\n</code></pre>\n<h3 id=\"7-使用Conversion\"><a href=\"#7-使用Conversion\" class=\"headerlink\" title=\"7. 使用Conversion\"></a>7. 使用Conversion</h3><p>流程明细：</p>\n<pre><code class=\"c#\">// ??? &lt;- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? &lt;- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update() &lt;-- 你的 Convert 方法在这时运行\nGameObjectAfterConversionGroup.Update()\n// ??? &lt;- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()</code></pre>\n<p>7.1 ConversionToEntity</p>\n<ul>\n<li>为GameObject添加ConversionToEntity将自动转换为ECS的entity. </li>\n<li>添加ConversionToEntity(Stop)将保持为原gameobject</li>\n</ul>\n<p>7.2 ConversionMode</p>\n<ul>\n<li>Convert And Destroy模式：如果没有conversion system处理的组件，在Conversion world 被带入的东西在world销毁时也同时销毁。</li>\n<li>Convert and inject 模式： 此模式下，相比上一个组件都会保留。<blockquote>\n<p>Convert and inject模式是用于当你需要在 conversion 的结果上面回溯原有对象的情况下才有用, 而 Hybrid Renderer 显然无需回溯。</p>\n</blockquote>\n</li>\n</ul>\n<p>7.3 IConvertGameObjectToEntity</p>\n<ul>\n<li>继承此接口，在方法Convert里自由控制conversion的过程<blockquote>\n<p>Unity 内置了另一种名为ConvertGameObjectToEntitySystem 的 conversion system. 该 system 会迭代 conversion world 中所有的GameObject, 接着使用GetComponents 并判断是否实现IConvertGameObjectToEntity 接口, 然后再调用该接口的.Convert 方法</p>\n</blockquote>\n</li>\n</ul>\n<p>7.4 LinkedEntityGroup</p>\n<ul>\n<li>为原层次结构做关联的组件。同时也是一个dynmaic buffer。 </li>\n<li>调用Instantiate方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的LinkedEntityGroup. 注意实例化并不一定和ECS中的Prefab component 直接关联.</li>\n<li>调用DestroyEntity时也会同时销毁 LinkedEntityGroup中的所有 entity. 类似在编辑器中删除GameObject</li>\n<li>调用 entityManager.SetEnabled 加上的 Disabledcomponent 会告知 ECS 的查询系统忽略它们, 而 LinkedEntityGroup 中的 entity 也会受到同样的影响. 有点类似禁用GameObject 时同时会禁用整个层级树.</li>\n</ul>\n<blockquote>\n<p>当有子物体Disable状态时，此子物体自身不会生成linkedentitygroup的子结构,但可以手动在此disable上添加</p>\n</blockquote>\n<blockquote>\n<p>注意如果buffer 中的 entity 也有LinkedEntityGroup, 系统不会递归地执行instantiation/destroy/disabled 过程.<br>这些过程在具体执行当中也有一些细微不同.Instantiate和SetEnabled只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity 必须要把自己包括在内才能正常工作. 然而DestroyEntity则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.<br>要注意LinkedEntityGroup 和 Parent并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.</p>\n</blockquote>\n<ul>\n<li>为gameobject添加<pre><code class=\"c#\">public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n  public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n  {\n      conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n  }\n}</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>在 entities-0.5.1版本里, TypeManager.cs 源码中可看到, 任何没有[InternalBufferCapacity] 的buffer 类型都会默认 128/size 的容量. LinkedEntityGroup里面装的是 entity, 因此其容量是 128/8 = 16 .<br>每个 Entity 关联的LinkedEntityGroup(或者其他未指定 capacity 的buffer) 将占据 128 bytes. 这是 chunk 容积变小的原因.<br>层级中超过16个子对象并不是什么好事, 一旦超过这个数量, 这些 linked entities 不得不从排列良好的 chunk 内存中挪到堆内存中. 可能 Unity 认为 16 是一个不太可能达到的值, 而 8 又太过于常见.<br>除非显式调用, LinkedEntityGroup仅仅在 prefab 的 conversion 过程中被自动创建, 因此你只需要注意你的 prefab 里面嵌套的 GameObject 数量<br>在运行时, 所有嵌套 prefab 和 prefab variant 工作流并不受影响, 系统内部只把它们看过一个单独的 prefab. 你无法把嵌套 prefab 从父 prefab 中拿出来, 并期望LinkedEntityGroup正常工作.<br>最后, 16个entities 一个 chunk ，  1MB 大概包含 60 个 chunk. 如上例, 你能在 1MB 存储大约 2700 个转换后的GameObject , 这样看来或许45 的 chunk 容量也不用太担心了(当然具体情况具体分析).</p>\n</blockquote>\n<p>7.5 创建额外的entity<br>使用如下方式：</p>\n<pre><code class=\"c#\">  Entity additional1 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional1, $&quot;{this.name}_Add1&quot;);\n        Entity additional2 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional2, $&quot;{this.name}_Add2&quot;);</code></pre>\n<blockquote>\n<p>注意：此方式创建的entity将不在linkedentitygroup内，且是完全空的entity</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-What-is-DOTS\"><a href=\"#1-What-is-DOTS\" class=\"headerlink\" title=\"1. What is DOTS?\"></a>1. What is DOTS?</h3><p>DATA-ORIENTED TECH STACK<br>多线程式数据导向型技术堆栈</p>\n<p> 核心-高性能<br>充分利用多核处理器，多线程，让游戏运行速度更快。<br>组成部分如下：</p>\n<ul>\n<li>C# 任务系统， Job System，用于高效运行多线程代码</li>\n<li>实体组件系统，ECS， 默认编写的高性能代码的框架结构</li>\n<li>Burst编译器，用于生成高度优化的本地代码</li>\n</ul>\n<p>Job System 与ECS是独立的，两者结合实际才能发挥最大优势。</p>\n<h3 id=\"2-Job-System\"><a href=\"#2-Job-System\" class=\"headerlink\" title=\"2. Job System\"></a>2. Job System</h3><ul>\n<li>在Job System之前，unity 仅在内部支持多线程，外部都必须运行在主线程上</li>\n<li>C#虽然支持多线程，但在unity中只处理数据，如网络消息，下载等等，且在线程中调用Unity的API是不行的。</li>\n<li>有了Job System,可以充分利用多核CPU，比如在多线程中修改Transform等</li>\n<li>例：MMO游戏判断碰撞，大量同步角色坐标，大量血条飘字等较为适合</li>\n<li>不必过于担心线程安全，加锁的问题</li>\n<li>配合Burst更佳</li>\n</ul>\n<p>2.1 HPC# -High Performance C#</p>\n<p>介绍：</p>\n<ul>\n<li>IL2Cpp虽然将IL转成C++，但实际还是模拟了.NET的垃圾回收，效率并非等同C++</li>\n<li>使用NativeArray代替T[]，数据类型包括了值类型和其他类型指针</li>\n<li>NativeArray可以在C#层分配 C++中的对象，主动释放而不进行C#的垃圾回收。</li>\n</ul>\n<p>Burst性能对比：</p>\n<ul>\n<li>.Net Code 比C++慢2倍</li>\n<li>Mono比.NET Code慢3倍</li>\n<li>IL2CPP与.NET Code相当</li>\n<li>Burst将比C++运行更快。</li>\n</ul>\n<p><a href=\"http://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-3-CSharp-Unity-Burst/\">http://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-3-CSharp-Unity-Burst/</a></p>\n<p>2.2 代码使用</p>\n<ul>\n<li>数据类型只能是值类型和其他类型的指针</li>\n<li>不能使用引用类型，如T[]数组就不能在job中使用，应用HPC#的NativeArray代替</li>\n</ul>\n<p><img src=\"/img/1584498872491.png\" alt=\"enter description here\"></p>\n<blockquote>\n<p>IJob与IJobParallelFor<br>IJob是一个一个的开线程任务，顺序执行的，所以正确性有保证<br>如果想让线程真正并行，则应使用JobParallelFor。这样并行后的数据就不会有前后依赖关系。<br>使用ReadOnly标记的数据，只读后让Job不为其加锁。<br>默认的数据是Read/Write的，这样在改变数据后，Job一定会等它。<br>加解锁unity已经做好了，不需要自己实现逻辑。</p>\n</blockquote>\n<p><img src=\"/img/1584499275880.png\" alt=\"enter description here\"></p>\n<h3 id=\"3-Burst编译器\"><a href=\"#3-Burst编译器\" class=\"headerlink\" title=\"3.Burst编译器\"></a>3.Burst编译器</h3><p>3.1 原理</p>\n<ul>\n<li>以开源LLVM为基础的后端编译技术</li>\n<li>原理的5个步骤：源代码》前端》优化器》后端 》机器码</li>\n<li>LLVM定义抽象语言IR，前端负责将源代码（C#）翻译成IR，优化器优化，后端将IR生成目标语言（机器码）。</li>\n<li>IR的存在，所以LLVM支持众多语言</li>\n<li>LLVM对C#的GC支持不好，目前burst只支持值类型。</li>\n</ul>\n<p>3.2 内存别名</p>\n<ul>\n<li>之前的编译器无法知道运行时两个指针指向同一个地址的情况，编译出的代码必然要占用额外寄存器多次拷贝，无法优化。</li>\n<li>NativeArray的API禁止限制了内存别名，不存在两个指针指向同一地址的情况。所以它更加高效。</li>\n</ul>\n<p>3.3 Unity.Mathmatcis数学库</p>\n<ul>\n<li>更高效的数据库，提供矢量类型float3,float4. 直接映射到SIMD寄存器</li>\n<li>Math类中也提供了直接映射 到硬件SIMD寄存器。</li>\n<li>SIMD可以一次性计算完毕。</li>\n<li>旧Math类是不支持SIMD寄存器的。</li>\n<li></li>\n</ul>\n<p>3.4 启动BurstCompile</p>\n<ul>\n<li>添加标签即可：</li>\n<li>Struct必须实现IJob接口<br><img src=\"/img/1584499995727.png\" alt=\"enter description here\"></li>\n</ul>\n<h3 id=\"4-ECS\"><a href=\"#4-ECS\" class=\"headerlink\" title=\"4. ECS\"></a>4. ECS</h3><p>4.1 组合模式：<br>需要什么功能加什么组件</p>\n<p>4.2 传统脚本的问题：</p>\n<ul>\n<li>耦合度过高</li>\n<li>引用类型</li>\n<li>挂脚本过重，产生 0.01s耗时</li>\n<li>热更支持不好</li>\n</ul>\n<p>4.3 Entity  实体<br>A entity is a key.</p>\n<ul>\n<li>非常轻量级，一个ID用Int保存。</li>\n<li>根据需要绑定组件</li>\n<li>对Cache友好，将相同的组件排列在一起，遍历更快。</li>\n</ul>\n<p>4.4 Component 组件<br>数据层，只有数据</p>\n<ul>\n<li>实现IcomponentData接口的结构体，不能写方法，没有任何行为</li>\n<li>注意使用新的数学库代替一些变量。</li>\n</ul>\n<blockquote>\n<p>ArcheType原型<br>组件命中率高得益于Archetype<br>unity规定每个archetype为16K，不够再开，保证连续性</p>\n</blockquote>\n<p><img src=\"/img/1584500576606.png\" alt=\"enter description here\"></p>\n<blockquote>\n<p>共享组件<br>区别IcomponentData于，IsharedComponentData共享组件。是为了避免结构体存储的数据完全相同，从而占用多份内存<br>典型的例子：场景中很多相同mesh和材质的物体。<br>必须实现IEquatable接口！</p>\n</blockquote>\n<p><img src=\"/img/1584501076960.png\" alt=\"共享组件\"><br><img src=\"/img/1584501108996.png\" alt=\"enter description here\"></p>\n<p>4.5 System系统<br>A system is a data tranform.</p>\n<ul>\n<li>只与Component关联，不关心entity</li>\n<li>在Update中可以统一更新自己关心的组件</li>\n</ul>\n<p><img src=\"/img/1584500759081.png\" alt=\"enter description here\"></p>\n<p>4.6 World世界<br>Worlds ars for isolation</p>\n<ul>\n<li>包含EntityManager, ComponentSystem, ArcheTypes.</li>\n<li>ECS默认提供了一个World，也可自己创建</li>\n<li>世界之间不互通，可以同时并行</li>\n</ul>\n<h3 id=\"5-ECS-Job-Burst让性能飞起来\"><a href=\"#5-ECS-Job-Burst让性能飞起来\" class=\"headerlink\" title=\"5. ECS + Job + Burst让性能飞起来\"></a>5. ECS + Job + Burst让性能飞起来</h3><p>5.1 JobComponentSystem </p>\n<ul>\n<li>使用继承于ComponentSystem的JobComponentSystem</li>\n<li>JobComponentSystem的Update效率更高，复杂运算将由Job完成</li>\n<li>标识ReadOnly让Job的数据并行</li>\n<li>如果Job数据变更，此Job就不能与其他访问此数据的JOB并行</li>\n</ul>\n<p>5.2 JCS与CS混合</p>\n<ul>\n<li>JCS中的实体有任何 结构数据变更修改都带来硬性同步点</li>\n<li>JCS必须保证后面执行的CS拿到的数据准确性，实体增删改都会带来同步点，导致线程卡顿。</li>\n</ul>\n<p>5.3 ECS渲染</p>\n<ul>\n<li>ECS自身不包含渲染，但游戏中的渲染与实体是紧密绑定的</li>\n<li>原理大致是ECS在Job中先准备渲染的数据，通过GPU Instancing一次渲染，中间不产生gameobject.</li>\n<li>GPU instancing不带裁剪，且需要每帧在Update中调用刷新。建议使用CommandBuffer来渲染Gpu instancing，如果在有变化时再刷新。</li>\n</ul>\n<p><a href=\"https://www.xuanyusong.com/archives/4683\">https://www.xuanyusong.com/archives/4683</a></p>\n<ul>\n<li>使用BatchRendererGroup代替Graphics.DrawMeshInstanced和CommandBuffer.DrawMeshInstanced</li>\n<li>BRG强制需要镜头裁剪的JOB方法，自己实现</li>\n<li>BRG需要提供每个渲染物体的包围盒区载用于job中判断是否不在视野。</li>\n<li>BRG内部会调自动Graphics.DrawMeshInstanced且没有1023的数量限制。</li>\n</ul>\n<p><img src=\"/img/1584502302892.png\" alt=\"enter description here\"></p>\n<p><img src=\"/img/1584502316800.png\" alt=\"enter description here\"></p>\n<h3 id=\"6-实践\"><a href=\"#6-实践\" class=\"headerlink\" title=\"6.实践\"></a>6.实践</h3><p>6.1  装Entites, Burst, Hybrid Render, Dots Editor</p>\n<blockquote>\n<p>报错了？The type or namespace name ‘CompilerServices’ does not exist in the namespace ‘Unity.Burst’ (are you missing an assembly reference?)<br>选择安装preview下的最高版本，如burst会默认安装非preview的版本</p>\n</blockquote>\n<p>6.2 实例1 创建entity</p>\n<pre><code class=\"csharp\">using UnityEngine;\nusing Unity.Transforms;\nusing Unity.Entities;\nusing Unity.Rendering;\nusing Unity.Mathematics;\npublic class Spawner : MonoBehaviour\n{\n    [SerializeField] private Mesh unitMesh;\n    [SerializeField] private Material unitMat;\n\n    private EntityManager unitManager;\n    private EntityArchetype entityArcheType;\n    // Start is called before the first frame update\n    void Start()\n    {\n        InitEntityManager();\n        CreateArcheType();\n        CreateEntity();\n    }\n\n    void InitEntityManager()\n    {\n        unitManager = World.DefaultGameObjectInjectionWorld.EntityManager;\n    }\n\n    void CreateEntity()\n    {\n        Entity hero = unitManager.CreateEntity(entityArcheType);\n        unitManager.AddComponentData(hero, new Translation(){\n            Value = new float3(1, 1, 1)\n        });\n\n        unitManager.AddComponentData(hero, new Scale()\n        {\n            Value = 1.0f\n        });\n\n        unitManager.AddSharedComponentData(hero, new RenderMesh()\n        {\n            mesh = unitMesh,\n            material = unitMat\n        });\n\n    }\n\n    void CreateArcheType()\n    {\n        var translationType = ComponentType.ReadWrite&lt;Translation&gt;();\n        var scaleType = ComponentType.ReadWrite&lt;Scale&gt;();\n        var rotationType = ComponentType.ReadWrite&lt;Rotation&gt;();\n        var renderType = ComponentType.ReadWrite&lt;RenderMesh&gt;();\n        var renderBoundsType = ComponentType.ReadWrite&lt;RenderBounds&gt;();\n        var localToWorldType = ComponentType.ReadWrite&lt;LocalToWorld&gt;();\n        entityArcheType = unitManager.CreateArchetype(translationType, scaleType, rotationType, renderType, renderBoundsType, localToWorldType);\n    }\n}</code></pre>\n<blockquote>\n<p>注意： RenderBounds 如果不加，会导致不显示。。</p>\n</blockquote>\n<p>6.2 实例2 自定义system</p>\n<p>System定义后，将自动执行update函数。</p>\n<pre><code class=\"csharp\">using Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\npublic class MoveSystem : ComponentSystem\n{\n    protected override void OnUpdate()\n    {\n        Entities.ForEach((ref Translation trans, ref MoveBySpeedData moveSpeed, ref WaveData waveData) =&gt;\n        {\n            float zPos = waveData.amplitude * math.sin((float)Time.ElapsedTime * moveSpeed.Value\n                + trans.Value.x * waveData.xOffset + trans.Value.y * waveData.yOffset);\n            trans.Value = new float3(trans.Value.x, trans.Value.y, zPos);\n        });\n    }\n}\n</code></pre>\n<p>6.3 实例3 加入JOB与Burst</p>\n<p>在实例2的基础上加上Job和Burst</p>\n<pre><code class=\"csharp\">\nusing Unity.Burst;\nusing Unity.Collections;\nusing Unity.Entities;\nusing Unity.Jobs;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\npublic class MoveSystem : JobComponentSystem\n{\n    [BurstCompile]\n    private struct MoveJob : IJobChunk\n    {\n        public double ElapsedTime;\n\n        public ArchetypeChunkComponentType&lt;Translation&gt; TranslationType;\n        [ReadOnly] public ArchetypeChunkComponentType&lt;MoveBySpeedData&gt; MoveBySpeedDataType;\n        [ReadOnly] public ArchetypeChunkComponentType&lt;WaveData&gt; WaveDataType;\n        public uint LastSystemVersion;\n        public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)\n        {\n\n            var chunkTrans = chunk.GetNativeArray(TranslationType);\n            var chunkSpeedDatas = chunk.GetNativeArray(MoveBySpeedDataType);\n            var chunkWaveDatas = chunk.GetNativeArray(WaveDataType);\n\n            for (var i = 0; i &lt; chunk.Count; i++)\n            {\n                var moveSpeed = chunkSpeedDatas[i];\n                var waveData = chunkWaveDatas[i];\n                var trans = chunkTrans[i];\n                float zPos = waveData.amplitude * math.sin((float)ElapsedTime * moveSpeed.Value\n               + trans.Value.x * waveData.xOffset + trans.Value.y * waveData.yOffset);\n\n                // Rotate something about its up vector at the speed given by RotationSpeed.\n                chunkTrans[i] = new Translation\n                {\n                    Value = new float3(trans.Value.x, trans.Value.y, zPos)\n                };\n            }\n        }\n    }\n    EntityQuery m_Group;\n    protected override void OnCreate()\n    {\n        m_Group = GetEntityQuery(ComponentType.ReadOnly&lt;MoveBySpeedData&gt;(),\n                               ComponentType.ReadOnly&lt;WaveData&gt;());\n    }\n\n    protected override JobHandle OnUpdate(JobHandle inputDeps)\n    {\n        var job = new MoveJob()\n        {\n            TranslationType = GetArchetypeChunkComponentType&lt;Translation&gt;(false),\n            MoveBySpeedDataType = GetArchetypeChunkComponentType&lt;MoveBySpeedData&gt;(true),\n            WaveDataType = GetArchetypeChunkComponentType&lt;WaveData&gt;(true),\n            ElapsedTime = Time.ElapsedTime\n        };\n        return job.Schedule(m_Group, inputDeps);\n    }\n}\n</code></pre>\n<h3 id=\"7-使用Conversion\"><a href=\"#7-使用Conversion\" class=\"headerlink\" title=\"7. 使用Conversion\"></a>7. 使用Conversion</h3><p>流程明细：</p>\n<pre><code class=\"c#\">// ??? &lt;- IDeclareReferencedPrefabs 调用.\nGameObjectDeclareReferencedObjectsGroup.Update()\n// ??? &lt;- discovery 阶段结束, 无法再声明更多 asset.\nGameObjectBeforeConversionGroup.Update()\nGameObjectConversionGroup.Update() &lt;-- 你的 Convert 方法在这时运行\nGameObjectAfterConversionGroup.Update()\n// ??? &lt;- LinkedEntityGroup + Prefab 都已就绪.\nGameObjectExportGroup.Update()</code></pre>\n<p>7.1 ConversionToEntity</p>\n<ul>\n<li>为GameObject添加ConversionToEntity将自动转换为ECS的entity. </li>\n<li>添加ConversionToEntity(Stop)将保持为原gameobject</li>\n</ul>\n<p>7.2 ConversionMode</p>\n<ul>\n<li>Convert And Destroy模式：如果没有conversion system处理的组件，在Conversion world 被带入的东西在world销毁时也同时销毁。</li>\n<li>Convert and inject 模式： 此模式下，相比上一个组件都会保留。<blockquote>\n<p>Convert and inject模式是用于当你需要在 conversion 的结果上面回溯原有对象的情况下才有用, 而 Hybrid Renderer 显然无需回溯。</p>\n</blockquote>\n</li>\n</ul>\n<p>7.3 IConvertGameObjectToEntity</p>\n<ul>\n<li>继承此接口，在方法Convert里自由控制conversion的过程<blockquote>\n<p>Unity 内置了另一种名为ConvertGameObjectToEntitySystem 的 conversion system. 该 system 会迭代 conversion world 中所有的GameObject, 接着使用GetComponents 并判断是否实现IConvertGameObjectToEntity 接口, 然后再调用该接口的.Convert 方法</p>\n</blockquote>\n</li>\n</ul>\n<p>7.4 LinkedEntityGroup</p>\n<ul>\n<li>为原层次结构做关联的组件。同时也是一个dynmaic buffer。 </li>\n<li>调用Instantiate方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的LinkedEntityGroup. 注意实例化并不一定和ECS中的Prefab component 直接关联.</li>\n<li>调用DestroyEntity时也会同时销毁 LinkedEntityGroup中的所有 entity. 类似在编辑器中删除GameObject</li>\n<li>调用 entityManager.SetEnabled 加上的 Disabledcomponent 会告知 ECS 的查询系统忽略它们, 而 LinkedEntityGroup 中的 entity 也会受到同样的影响. 有点类似禁用GameObject 时同时会禁用整个层级树.</li>\n</ul>\n<blockquote>\n<p>当有子物体Disable状态时，此子物体自身不会生成linkedentitygroup的子结构,但可以手动在此disable上添加</p>\n</blockquote>\n<blockquote>\n<p>注意如果buffer 中的 entity 也有LinkedEntityGroup, 系统不会递归地执行instantiation/destroy/disabled 过程.<br>这些过程在具体执行当中也有一些细微不同.Instantiate和SetEnabled只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity 必须要把自己包括在内才能正常工作. 然而DestroyEntity则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.<br>要注意LinkedEntityGroup 和 Parent并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.</p>\n</blockquote>\n<ul>\n<li>为gameobject添加<pre><code class=\"c#\">public class CubeConvert : MonoBehaviour, IConvertGameObjectToEntity\n{\n  public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)\n  {\n      conversionSystem.DeclareLinkedEntityGroup(this.gameObject);\n  }\n}</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>在 entities-0.5.1版本里, TypeManager.cs 源码中可看到, 任何没有[InternalBufferCapacity] 的buffer 类型都会默认 128/size 的容量. LinkedEntityGroup里面装的是 entity, 因此其容量是 128/8 = 16 .<br>每个 Entity 关联的LinkedEntityGroup(或者其他未指定 capacity 的buffer) 将占据 128 bytes. 这是 chunk 容积变小的原因.<br>层级中超过16个子对象并不是什么好事, 一旦超过这个数量, 这些 linked entities 不得不从排列良好的 chunk 内存中挪到堆内存中. 可能 Unity 认为 16 是一个不太可能达到的值, 而 8 又太过于常见.<br>除非显式调用, LinkedEntityGroup仅仅在 prefab 的 conversion 过程中被自动创建, 因此你只需要注意你的 prefab 里面嵌套的 GameObject 数量<br>在运行时, 所有嵌套 prefab 和 prefab variant 工作流并不受影响, 系统内部只把它们看过一个单独的 prefab. 你无法把嵌套 prefab 从父 prefab 中拿出来, 并期望LinkedEntityGroup正常工作.<br>最后, 16个entities 一个 chunk ，  1MB 大概包含 60 个 chunk. 如上例, 你能在 1MB 存储大约 2700 个转换后的GameObject , 这样看来或许45 的 chunk 容量也不用太担心了(当然具体情况具体分析).</p>\n</blockquote>\n<p>7.5 创建额外的entity<br>使用如下方式：</p>\n<pre><code class=\"c#\">  Entity additional1 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional1, $&quot;{this.name}_Add1&quot;);\n        Entity additional2 = conversionSystem.CreateAdditionalEntity(this.gameObject);\n        dstManager.SetName(additional2, $&quot;{this.name}_Add2&quot;);</code></pre>\n<blockquote>\n<p>注意：此方式创建的entity将不在linkedentitygroup内，且是完全空的entity</p>\n</blockquote>\n"},{"title":"Effective C++学习记录","_content":"\n#### 条款1: 习惯C++\nC++ 领域的四大块：\n* 1.C： 基础，语句，数组，指针等等\n* 2.Object-Oriented C: 继承，多态，封装\n* 3.Template C++: 泛型编程\n* 4. STL： 一种特殊的Template程序库，容器，迭代器，算法，对象等等规约\n\n#### 条款2：尽量以const, enum, inline替换 #define\n宁用编译器替换预处理器。\n* 1.使用声明式与定义式：如\n```c++\n//头文件\nclass GamePlayer{\nprivate:\n\tstatic const int NumTurns = 5;//声明时候指定数值\n}\n//实现文件\nconst int GamePlayer::NumTurns;//无需再次定义了\n```\n* 2.使用enum当int数组用\n```c++\nclass GamePlayer{\nprivate:\n\tenum{NumTurns =5};\n\tint scores[NumTurns];\n}\n```\n* 3.对于函数宏定义，使用Inline替代\n ```c++\n //替换以下define语句。\n //#define CALL_WITH_MAX(a,b) f(a>b?a:b);\n template<typename T>\n inline void callWithMax(const T&a,const T&b)\n {\n \tf(a>b?a:b);\n }\n ```\n\n","source":"_posts/Effective C++学习记录.md","raw":"---\ntitle: Effective C++学习记录\ncategories:\n- CPlusPlus\ntags: \n- C++\n---\n\n#### 条款1: 习惯C++\nC++ 领域的四大块：\n* 1.C： 基础，语句，数组，指针等等\n* 2.Object-Oriented C: 继承，多态，封装\n* 3.Template C++: 泛型编程\n* 4. STL： 一种特殊的Template程序库，容器，迭代器，算法，对象等等规约\n\n#### 条款2：尽量以const, enum, inline替换 #define\n宁用编译器替换预处理器。\n* 1.使用声明式与定义式：如\n```c++\n//头文件\nclass GamePlayer{\nprivate:\n\tstatic const int NumTurns = 5;//声明时候指定数值\n}\n//实现文件\nconst int GamePlayer::NumTurns;//无需再次定义了\n```\n* 2.使用enum当int数组用\n```c++\nclass GamePlayer{\nprivate:\n\tenum{NumTurns =5};\n\tint scores[NumTurns];\n}\n```\n* 3.对于函数宏定义，使用Inline替代\n ```c++\n //替换以下define语句。\n //#define CALL_WITH_MAX(a,b) f(a>b?a:b);\n template<typename T>\n inline void callWithMax(const T&a,const T&b)\n {\n \tf(a>b?a:b);\n }\n ```\n\n","slug":"Effective C++学习记录","published":1,"date":"2020-09-08T03:23:20.714Z","updated":"2020-09-08T03:23:20.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0zb00104wf0pr2rgtr9","content":"<h4 id=\"条款1-习惯C\"><a href=\"#条款1-习惯C\" class=\"headerlink\" title=\"条款1: 习惯C++\"></a>条款1: 习惯C++</h4><p>C++ 领域的四大块：</p>\n<ul>\n<li>1.C： 基础，语句，数组，指针等等</li>\n<li>2.Object-Oriented C: 继承，多态，封装</li>\n<li>3.Template C++: 泛型编程</li>\n<li><ol start=\"4\">\n<li>STL： 一种特殊的Template程序库，容器，迭代器，算法，对象等等规约</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"条款2：尽量以const-enum-inline替换-define\"><a href=\"#条款2：尽量以const-enum-inline替换-define\" class=\"headerlink\" title=\"条款2：尽量以const, enum, inline替换 #define\"></a>条款2：尽量以const, enum, inline替换 #define</h4><p>宁用编译器替换预处理器。</p>\n<ul>\n<li>1.使用声明式与定义式：如<pre><code class=\"c++\">//头文件\nclass GamePlayer{\nprivate:\n  static const int NumTurns = 5;//声明时候指定数值\n}\n//实现文件\nconst int GamePlayer::NumTurns;//无需再次定义了</code></pre>\n</li>\n<li>2.使用enum当int数组用<pre><code class=\"c++\">class GamePlayer{\nprivate:\n  enum{NumTurns =5};\n  int scores[NumTurns];\n}</code></pre>\n</li>\n<li>3.对于函数宏定义，使用Inline替代<pre><code class=\"c++\">//替换以下define语句。\n//#define CALL_WITH_MAX(a,b) f(a&gt;b?a:b);\ntemplate&lt;typename T&gt;\ninline void callWithMax(const T&amp;a,const T&amp;b)\n{\n   f(a&gt;b?a:b);\n}</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"条款1-习惯C\"><a href=\"#条款1-习惯C\" class=\"headerlink\" title=\"条款1: 习惯C++\"></a>条款1: 习惯C++</h4><p>C++ 领域的四大块：</p>\n<ul>\n<li>1.C： 基础，语句，数组，指针等等</li>\n<li>2.Object-Oriented C: 继承，多态，封装</li>\n<li>3.Template C++: 泛型编程</li>\n<li><ol start=\"4\">\n<li>STL： 一种特殊的Template程序库，容器，迭代器，算法，对象等等规约</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"条款2：尽量以const-enum-inline替换-define\"><a href=\"#条款2：尽量以const-enum-inline替换-define\" class=\"headerlink\" title=\"条款2：尽量以const, enum, inline替换 #define\"></a>条款2：尽量以const, enum, inline替换 #define</h4><p>宁用编译器替换预处理器。</p>\n<ul>\n<li>1.使用声明式与定义式：如<pre><code class=\"c++\">//头文件\nclass GamePlayer{\nprivate:\n  static const int NumTurns = 5;//声明时候指定数值\n}\n//实现文件\nconst int GamePlayer::NumTurns;//无需再次定义了</code></pre>\n</li>\n<li>2.使用enum当int数组用<pre><code class=\"c++\">class GamePlayer{\nprivate:\n  enum{NumTurns =5};\n  int scores[NumTurns];\n}</code></pre>\n</li>\n<li>3.对于函数宏定义，使用Inline替代<pre><code class=\"c++\">//替换以下define语句。\n//#define CALL_WITH_MAX(a,b) f(a&gt;b?a:b);\ntemplate&lt;typename T&gt;\ninline void callWithMax(const T&amp;a,const T&amp;b)\n{\n   f(a&gt;b?a:b);\n}</code></pre>\n</li>\n</ul>\n"},{"title":"GEA-P3","_content":"# 3 引擎基础\n\n## (3.1) C++ Review and Best Practive\n\nimperative languages: C\nobject-oriented languages: C# , Java\nscripting languages: python lua,perl\nfunctional languages: Lisp, scheme, F# \n\n### Multiple Inheritance(MI)\nMost C++ software developers avoid multiple inheritance completely or\nonly permit it in a limited form. \n> 多继承容易让结构混乱，提升技术难度，引发deadly diamond问题（当父类们存在相同函数时，子类不知道实现哪个？）\n> 实际应用中，多继承应继承自无父的类对象\n> Most C++ software developers avoid multiple inheritance completely or\nonly permit it in a limited form. A common rule of thumb is to allow only\nsimple, parentless classes to be multiply inherited into an otherwise strictly\nsingle-inheritance hierarchy. Such classes are sometimes called mix-in classes\nbecause they can be used to introduce new functionality at arbitrary points in\na class tree. \n\n![Deadly diamond](./img/1575255814499.png)\n![Mix-in class](/img/1575255482902.png)\n\n### Composition and Aggregation\n\n组合和聚合\nhas-a, uses-a\n\n### Coding Standards\n\n代码规范\n> 1.Some standards make the code more readable, understandable and maintainable.\n>2. Other conventions help to prevent programmers from shooting themselves in the foot. For example, a coding standard might encourage the\nprogrammer to use only a smaller, more testable and less error-prone\nsubset of the whole language. The C++ language is rife with possibilities for abuse, so this kind of coding standard is particularly important\nwhen using C++.\n\n> Interfaces are king. 接口保持干净，整洁\n> Good names encourage understanding and avoid confusion.  命名要求规范\n> Don’t clutter the global namespace. C++中避免互包等混乱\n> Follow C++ best practices. Books like the Effective C++ series by Scott Meyers [31,32], Meyers’ Effective STL [33] and Large-Scale C++ Software Design3.1. C++ Review and Best Practices 105\nby John Lakos [27] provide excellent guidelines that will help keep you\nout of trouble.   关注最好的代码\n> Be consistent.  坚定规范要求\n> Make errors stick out. 让错误更易在代码中查觉。\n\n","source":"_posts/GEA-P3.md","raw":"---\ntitle: GEA-P3\ncategories:\n- IT阅读\ntags: \n- Game\n---\n# 3 引擎基础\n\n## (3.1) C++ Review and Best Practive\n\nimperative languages: C\nobject-oriented languages: C# , Java\nscripting languages: python lua,perl\nfunctional languages: Lisp, scheme, F# \n\n### Multiple Inheritance(MI)\nMost C++ software developers avoid multiple inheritance completely or\nonly permit it in a limited form. \n> 多继承容易让结构混乱，提升技术难度，引发deadly diamond问题（当父类们存在相同函数时，子类不知道实现哪个？）\n> 实际应用中，多继承应继承自无父的类对象\n> Most C++ software developers avoid multiple inheritance completely or\nonly permit it in a limited form. A common rule of thumb is to allow only\nsimple, parentless classes to be multiply inherited into an otherwise strictly\nsingle-inheritance hierarchy. Such classes are sometimes called mix-in classes\nbecause they can be used to introduce new functionality at arbitrary points in\na class tree. \n\n![Deadly diamond](./img/1575255814499.png)\n![Mix-in class](/img/1575255482902.png)\n\n### Composition and Aggregation\n\n组合和聚合\nhas-a, uses-a\n\n### Coding Standards\n\n代码规范\n> 1.Some standards make the code more readable, understandable and maintainable.\n>2. Other conventions help to prevent programmers from shooting themselves in the foot. For example, a coding standard might encourage the\nprogrammer to use only a smaller, more testable and less error-prone\nsubset of the whole language. The C++ language is rife with possibilities for abuse, so this kind of coding standard is particularly important\nwhen using C++.\n\n> Interfaces are king. 接口保持干净，整洁\n> Good names encourage understanding and avoid confusion.  命名要求规范\n> Don’t clutter the global namespace. C++中避免互包等混乱\n> Follow C++ best practices. Books like the Effective C++ series by Scott Meyers [31,32], Meyers’ Effective STL [33] and Large-Scale C++ Software Design3.1. C++ Review and Best Practices 105\nby John Lakos [27] provide excellent guidelines that will help keep you\nout of trouble.   关注最好的代码\n> Be consistent.  坚定规范要求\n> Make errors stick out. 让错误更易在代码中查觉。\n\n","slug":"GEA-P3","published":1,"date":"2020-10-15T12:46:56.197Z","updated":"2020-10-15T12:46:56.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0zd00114wf0x6hff7w4","content":"<h1 id=\"3-引擎基础\"><a href=\"#3-引擎基础\" class=\"headerlink\" title=\"3 引擎基础\"></a>3 引擎基础</h1><h2 id=\"3-1-C-Review-and-Best-Practive\"><a href=\"#3-1-C-Review-and-Best-Practive\" class=\"headerlink\" title=\"(3.1) C++ Review and Best Practive\"></a>(3.1) C++ Review and Best Practive</h2><p>imperative languages: C<br>object-oriented languages: C# , Java<br>scripting languages: python lua,perl<br>functional languages: Lisp, scheme, F# </p>\n<h3 id=\"Multiple-Inheritance-MI\"><a href=\"#Multiple-Inheritance-MI\" class=\"headerlink\" title=\"Multiple Inheritance(MI)\"></a>Multiple Inheritance(MI)</h3><p>Most C++ software developers avoid multiple inheritance completely or<br>only permit it in a limited form. </p>\n<blockquote>\n<p>多继承容易让结构混乱，提升技术难度，引发deadly diamond问题（当父类们存在相同函数时，子类不知道实现哪个？）<br>实际应用中，多继承应继承自无父的类对象<br>Most C++ software developers avoid multiple inheritance completely or<br>only permit it in a limited form. A common rule of thumb is to allow only<br>simple, parentless classes to be multiply inherited into an otherwise strictly<br>single-inheritance hierarchy. Such classes are sometimes called mix-in classes<br>because they can be used to introduce new functionality at arbitrary points in<br>a class tree. </p>\n</blockquote>\n<p><img src=\"./img/1575255814499.png\" alt=\"Deadly diamond\"><br><img src=\"/img/1575255482902.png\" alt=\"Mix-in class\"></p>\n<h3 id=\"Composition-and-Aggregation\"><a href=\"#Composition-and-Aggregation\" class=\"headerlink\" title=\"Composition and Aggregation\"></a>Composition and Aggregation</h3><p>组合和聚合<br>has-a, uses-a</p>\n<h3 id=\"Coding-Standards\"><a href=\"#Coding-Standards\" class=\"headerlink\" title=\"Coding Standards\"></a>Coding Standards</h3><p>代码规范</p>\n<blockquote>\n<p>1.Some standards make the code more readable, understandable and maintainable.<br>2. Other conventions help to prevent programmers from shooting themselves in the foot. For example, a coding standard might encourage the<br>programmer to use only a smaller, more testable and less error-prone<br>subset of the whole language. The C++ language is rife with possibilities for abuse, so this kind of coding standard is particularly important<br>when using C++.</p>\n</blockquote>\n<blockquote>\n<p>Interfaces are king. 接口保持干净，整洁<br>Good names encourage understanding and avoid confusion.  命名要求规范<br>Don’t clutter the global namespace. C++中避免互包等混乱<br>Follow C++ best practices. Books like the Effective C++ series by Scott Meyers [31,32], Meyers’ Effective STL [33] and Large-Scale C++ Software Design3.1. C++ Review and Best Practices 105<br>by John Lakos [27] provide excellent guidelines that will help keep you<br>out of trouble.   关注最好的代码<br>Be consistent.  坚定规范要求<br>Make errors stick out. 让错误更易在代码中查觉。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"3-引擎基础\"><a href=\"#3-引擎基础\" class=\"headerlink\" title=\"3 引擎基础\"></a>3 引擎基础</h1><h2 id=\"3-1-C-Review-and-Best-Practive\"><a href=\"#3-1-C-Review-and-Best-Practive\" class=\"headerlink\" title=\"(3.1) C++ Review and Best Practive\"></a>(3.1) C++ Review and Best Practive</h2><p>imperative languages: C<br>object-oriented languages: C# , Java<br>scripting languages: python lua,perl<br>functional languages: Lisp, scheme, F# </p>\n<h3 id=\"Multiple-Inheritance-MI\"><a href=\"#Multiple-Inheritance-MI\" class=\"headerlink\" title=\"Multiple Inheritance(MI)\"></a>Multiple Inheritance(MI)</h3><p>Most C++ software developers avoid multiple inheritance completely or<br>only permit it in a limited form. </p>\n<blockquote>\n<p>多继承容易让结构混乱，提升技术难度，引发deadly diamond问题（当父类们存在相同函数时，子类不知道实现哪个？）<br>实际应用中，多继承应继承自无父的类对象<br>Most C++ software developers avoid multiple inheritance completely or<br>only permit it in a limited form. A common rule of thumb is to allow only<br>simple, parentless classes to be multiply inherited into an otherwise strictly<br>single-inheritance hierarchy. Such classes are sometimes called mix-in classes<br>because they can be used to introduce new functionality at arbitrary points in<br>a class tree. </p>\n</blockquote>\n<p><img src=\"./img/1575255814499.png\" alt=\"Deadly diamond\"><br><img src=\"/img/1575255482902.png\" alt=\"Mix-in class\"></p>\n<h3 id=\"Composition-and-Aggregation\"><a href=\"#Composition-and-Aggregation\" class=\"headerlink\" title=\"Composition and Aggregation\"></a>Composition and Aggregation</h3><p>组合和聚合<br>has-a, uses-a</p>\n<h3 id=\"Coding-Standards\"><a href=\"#Coding-Standards\" class=\"headerlink\" title=\"Coding Standards\"></a>Coding Standards</h3><p>代码规范</p>\n<blockquote>\n<p>1.Some standards make the code more readable, understandable and maintainable.<br>2. Other conventions help to prevent programmers from shooting themselves in the foot. For example, a coding standard might encourage the<br>programmer to use only a smaller, more testable and less error-prone<br>subset of the whole language. The C++ language is rife with possibilities for abuse, so this kind of coding standard is particularly important<br>when using C++.</p>\n</blockquote>\n<blockquote>\n<p>Interfaces are king. 接口保持干净，整洁<br>Good names encourage understanding and avoid confusion.  命名要求规范<br>Don’t clutter the global namespace. C++中避免互包等混乱<br>Follow C++ best practices. Books like the Effective C++ series by Scott Meyers [31,32], Meyers’ Effective STL [33] and Large-Scale C++ Software Design3.1. C++ Review and Best Practices 105<br>by John Lakos [27] provide excellent guidelines that will help keep you<br>out of trouble.   关注最好的代码<br>Be consistent.  坚定规范要求<br>Make errors stick out. 让错误更易在代码中查觉。</p>\n</blockquote>\n"},{"title":"GEA-P2","_content":"# 1 介绍\n\n## (1.6) Runtime Engine Architecture\n\n![Runtime Engine Architecture](/img/1574738644796.png)\n\n>自底向上的顺序大概为：\n>硬件层 \n>驱动层\n> 系统层 \n>ＳＤＫ层\n＞平台独立层\n> 核心库\n>资源库 \n>　渲染，调试，物理检测，游戏平台基础\n＞游戏级渲染，各上层动画机制，相机机制，ＡＩ机制\n＞游戏逻辑层\n\n### 操作系统层\n\n分为PC与主机（游戏）系统，PC系统如windows 提供了一种线程的机制为分享硬件资源，而主机游戏一般来说则可占用所有的硬件资源，但这两者的差距在逐渐减少。\n\n>Operating systems like Microsoft\nWindows employ a time-sliced approach to sharing the hardware with multiple running programs, known as preemptive multitasking. \n>On a console, the game typically\n“owns” the entire machine.\n>So the gap between console and PC development is\ngradually closing (for better or for worse).\n\n###  3rd Party SDKS\n\n> DirectX Opengl\n> Havok, PhysX ODE etc.. 实现增强物理效果的SDK\n> Boost++ C++标准库之一\n> STL C++标准库之一\n> Kynapse 游戏AI开发的中间件\n> Granny, Havok Animation，处理动画骨骼等\n> Euphoria， 小型的游戏开发套件：https://sourceforge.net/projects/euphoriasdk/\n\n#### 数据结构与算法\n\nC++ 库\n1. STL : strings, data structures, stream-based I/O  \n2. STLport :portable and optimized of STL\n3. Boost :Powerful data structures and algorithms library\n4. Loki :Powerful generic programming template library\n\n\n#### 图形\n\n>硬件图形库\n> Glide  早期的3D图形SDK，针对Voodoo显卡。\n> OpenGL widely used!\n> DirectX Microsoft's 3D graphics SDK\n> libgcm   更底层的接口针对PS3的图形硬件，OpenGL更高效处理的选择。\n> Edge Naughty Dog 和Sony提供的PS3平台的库\n\n#### 物理与碰撞\n\n> Havok industrial-strength physics and collision engine.\n> PhysX  NVIDIA\n> Open Dynamics Engine.  open source\n\n#### 角色动画\n\n> Granny:\n> In my opinion, the Granny SDK\nhas the best-designed and most logical animation API of any I’ve seen,\ncommercial or proprietary, especially its excellent handling of time\n\n> Havok Animation\n>  The line between physics and animation is becoming\nincreasingly blurred as characters become more and more realistic.\n\n> Edge  PS3 from Sony\n\n#### 生物力学角色模型 Biomechanical Character Models\n\n>Endorphin and Euphoria. These are animation packages that produce\ncharacter motion using advanced biomechanical models of realistic human movement.\n> Endorphin, is a Maya plug-in that permits animators to\nrun full biomechanical simulations on characters and export the resulting animations as if they had been hand animated\n>Euphoria, is a real-time version of Endorphin intended\nto produce physically and biomechanically accurate character motion at runtime under the influence of unpredictable forces.\n\n> Endorphin， MAYA插件，执行动作的角色将运行一个完整的生物力学模拟同时导出动画。\n> Euphoria,  在一些不可预测的因素影响下，将动作更精细的模拟表现出来。\nhttps://space.bilibili.com/430600560/channel/detail?cid=75669\n\n\n### Platform Independence Layer\n\n>the platform independence layer ensures consistent\nbehavior across all hardware platforms.\n\n\n### Rendering Engine\n> The rendering engine is one of the largest and most complex components of\nany game engine.\n\n#### Low-Level Renderer\n![Low-Level Renderer](/img/1574756479212.png)\n\n> Graphics Device Interface\n> DirectX, OpenGL\n\n> The low-level renderer usually provides a viewport abstraction with an associated camera-to-world matrix and 3D projection parameters, such as field of view and the location of the near and far clip planes.\n\n>  底层的渲染提供一个显示区域，关联到相机-世界和投影的参数。\n\n#### Scene Graph / Culling Optimizations\n\n> For very small game worlds, a simple frustum cull (i.e., removing objects\nthat the camera cannot “see”) is probably all that is required. For larger game\nworlds, a more advanced spatial subdivision data structure might be used to\nimprove rendering efficiency by allowing the potentially visible set (PVS) of\nobjects to be determined very quickly. \n\n> potentially visible set (PVS)\n\n> 理想状态下，底层渲染应该完全不关心spatial subdivision或scene graph的使用类型。 \n>OGRE open source rendering engine (http://www.ogre3d.org) is a great example of this principle in action. OGRE provides a plug-and-play scene graph\narchitecture. Game developers can either select from a number of preimplemented scene graph designs, or they can provide a custom scene graph implementation.\n\n### Front End\n![Front End](/img/1574759871996.png)\n\n> HUD, Heads-up Display\n> 在顶层显示\n> FMV, Full-Motion Video 动作完整的视频回放\nThis system is responsible for playing full-screen movies that have been recorded earlier.\n> IGC, in-game cinematics system.  游戏内的视频，一般当玩家不可操作时显示\n\n\n### Profiling and Debugging Tools\n>常用\n• Intel’s VTune,\n• IBM’s Quantify and Purify (part of the PurifyPlus tool suite), and\n• Compuware’s Bounds Checker.\n\n>However, most game engines also incorporate a suite of custom profiling\nand debugging tools. For example, they might include one or more of the\nfollowing:\n>* a mechanism for manually instrumenting the code, so that specific sections of code can be timed;\n>* a facility for displaying the profiling statistics on-screen while the game\nis running;\n>* a facility for dumping performance stats to a text file or to an Excel\nspreadsheet;\n>* a facility for determining how much memory is being used by the engine, and by each subsystem, including various on-screen displays;\n>* the ability to dump memory usage, high water mark and leakage stats\nwhen the game terminates and/or during gameplay;\n>* tools that allow debug print statements to be peppered throughout the\ncode, along with an ability to turn on or off different categories of debug\noutput and control the level of verbosity of the output; and\n>* the ability to record game events and then play them back. This is tough\nto get right, but when done properly it can be a very valuable tool for\ntracking down bugs.\n\n### Collisions & Physics\n\nCollision and physics are usually quite tightly coupled. \n>* Havok is the gold standard in the industry today. It is feature-rich and\nperforms well across the boards.\n>* PhysX by NVIDIA is another excellent collision and dynamics engine.\nIt was integrated into Unreal Engine 4 and is also available for free as\na stand-alone product for PC game development. PhysX was originally\ndesigned as the interface to Ageia’s new physics accelerator chip. The\nSDK is now owned and distributed by NVIDIA, and the company has\nadapted PhysX to run on its latest GPUs.\n\n>Open source physics and collision engines are also available. Perhaps the best-known of these is the Open Dynamics Engine (ODE)\n>I-Collide, V-Collide and RAPID are other popular non-commercial collision detection engines. 开发于University of North Carolina\n>http://www.ode.org\n\n\n### Animations\n>类型：\n>* sprite/texture animation,\n>* rigid body hierarchy animation, \n>* skeletal animation, 骨骼动画，\n>* vertex animation， 顶点动画\n>* morph targets.， 拉伸变形目标\n\n![enter description here](/img/1574826629863.png)\n![enter description here](/img/1574826985515.png)\n\n### Human Interface Devices (HID)\n\ninput from the player , 玩家的输入设备\n> keyboard, mouse\n> joypad\n> other specialized game controllers, like steering wheels, fishing rods,\ndance pads, the Wiimote, etc.  方向盘，鱼竿，跳舞板，手柄控制器等\n\n>The HID engine component is sometimes architected to divorce the lowlevel details of the game controller(s) on a particular hardware platform from the high-level game controls.\n>It sometimes also includes a system for detecting\nchords (multiple buttons pressed together), sequences (buttons pressed in sequence within a certain time limit) and gestures (sequences of inputs from the\nbuttons, sticks, accelerometers, etc.).\n> HID engine 组件通常设计为划分出低等级的游戏控制器到高级游戏操作。\n> 通常也会考虑检测组合按钮等情况\n\n### Audio\n\nAudio engines vary greatly in sophistication.\n> For DirectX platforms (PC, Xbox 360, Xbox One), Microsoft provides an excellent audio tool\nsuite called XACT, supported at runtime by their feature-rich XAudio2 andX3DAudio APIs. \n\n>Electronic Arts has developed an advanced, high-powered\naudio engine internally called SoundR!OT\n\n>In conjunction with first-party studios like Naughty Dog, Sony Computer Entertainment America (SCEA) provides a powerful 3D audio engine called Scream\n\n### Online Multiplayer/Networking\n\n> That said, it is usually better to design multiplayer features from day one, if you\nhave that luxury.\n尽早设置多人在线的模式\n\n> 从多人在线转单机版，往往较为简单\n>The Quake engine is well known\nfor its client-on-top-of-server mode, in which a single executable, running on a\nsingle PC, acts both as the client and the server in single-player campaigns.\n\n### Gameplay Foundation Systems\n\n> 用于连接low-level engine systems 与 gameplay code。为了上层游戏逻辑可以更方便使用。\n\n![enter description here](/img/1574912330296.png)\n\n### Game Worlds and Object Models\n\n> 游戏内的对象：\n>* static background geometry, like buildings, roads, terrain (often a special case), etc.;\n>* dynamic rigid bodies, such as rocks, soda cans, chairs, etc.;\n>* player characters (PC);\n>* non-player characters (NPC);\n>* weapons;\n>* projectiles;\n>* vehicles;\n>* lights (which may be present in the dynamic scene at runtime, or only\nused for static lighting offline);\n>* cameras;\n\n\n### Scripting System & Event\n\n> Many game engines employ a scripting language in order to make development of game-specific gameplay rules and content easier and more rapid.\n\n### Artificial Intellience Foundations\n\n游戏的人工智能模块，一些游戏引擎已经在引入这一模块到引擎，虽然这并不是引擎模块考虑的。\nKynogon \n>A company called Kynogon developed a middleware SDK named Kynapse, which provided much of the low-level technology required to build commercially viable game AI.  This SDK provides low-level AI building blocks such as nav mesh generation, path finding, static and dynamic object avoidance, identification of vulnerabilities within a play space (e.g., an open window from which an ambush could come) and a well-defined interface between AI and animation. \n\n### Game-Specific Subsystems\n\n 顶端的游戏开发层\n> Practically speaking, this line is never perfectly distinct. At least\nsome game-specific knowledge invariably seeps down through the gameplay\nfoundations layer and sometimes even extends into the core of the engine\nitself.\n\n\n## (1.7) Tools and the asset pipeline\n\n游戏数据层的组成：\n如图：粗黑箭头， 表示源数据是怎样从工具中生成出\n\t\t细线箭头，表示不同数据资源之间的引用关系\n![enter description here](/img/1574995793894.png)\n\n### Digital Content Creation Tools\n\n游戏资源从3D mesh到图片bitmaps再到音频之类的，都需要设计师用工具制作，而这些工具被称为DCC（Digital Content Creation）\n\n> Maya,3d Max\n> SoundForge\n> Photoshop\n。。。\n\n>That said, tools must be relatively **easy to use**, and they absolutely must be reliable, if a game team is going to be able to develop a highly polished product in a timely manner.\n>工具的使用需要按项目所需来决定，关键在于好用，不一定要非常完美的工具。\n\n\n### The Asset Conditioning Pipeline\n\n往往DCC生成的文件并不能直接在游戏开发中使用，原因有下：\n1. DCC导出的数据，存在许多游戏开发不需要的，比如maya中会存储directed acyclic graph的场景结点，和复杂的联结的网络结构。\n\n2. DCC文件格式加载读取很慢，而且通常格式是各个DCC专属的\n\n>Once data has been exported from the DCC app, it often must be further\nprocessed before being sent to the game engine. And if a game studio is shipping its game on more than one platform, the intermediate files might be processed differently for each target platform. \nDCC应用一般需要生成给游戏引擎用的文件。\n\n>The pipeline from DCC app to game engine is sometimes called the asset\nconditioning pipeline (ACP). Every game engine has this in some form.\n这种途径：从DCC应用到游戏引擎通常被称为: ACP\n\n#### 3D Model/Mesh Data\n\n>A mesh is a complex shape composed of triangles and vertices. A mesh typically has one or more materials applied to it in order to define\nvisual surface properties\n> MESH：由三角面和点组成的复杂的形状\n\n> In this book, I will use the term “mesh” to refer to a single renderable shape,\nand “model” to refer to a composite object that may contain multiple meshes,\nplus animation data and other metadata for use by the game.\n\n>Brush Geometry\n>Brush geometry is defined as a collection of convex hulls, each of which is defined by multiple planes.Brushes are typically created and edited directly in the game world editor. This is essentially an “old school” approach to creating\nrenderable geometry, but it is still used in some engines.\n> 笔刷型的图形，每个都由多个平面组成，通常是凹凸面的一种实现工具。\n> Pros:\n• fast and easy to create;\n• accessible to game designers—often used to “block out” a game level for\nprototyping purposes;\n• can serve both as collision volumes and as renderable geometry.\n>Cons:\n• low-resolution;\n• difficult to create complex shapes;\n• cannot support articulated objects or animated characters.\n\n\n#### Skeletal Animation Data\n\nA skeletal mesh is a special kind of mesh that is bound to a skeletal hierarchy for\nthe purposes of articulated animation. \n>Each vertex of a skeletal mesh contains a list of indices indicating to which\njoint(s) in the skeleton it is bound. A vertex usually also includes a set of joint\nweights, specifying the amount of influence each joint has on the vertex.\n>骨骼mesh，包含骨骼连接点信息，通常还会有点的权重和数量影响的数据\n\n>In order to render a skeletal mesh, the game engine requires three distinct\nkinds of data:\n>1. the mesh itself,\n>2. the skeletal hierarchy (joint names, parent-child relationships and the\nbase pose the skeleton was in when it was originally bound to the mesh),\nand58 1. Introduction\n>3. one or more animation clips, which specify how the joints should move\nover time.\n\n> Mesh与skeleton通常由DCC导出在一个文件里，当然，当有多个mesh对应一个骨骼时，骨骼通常需要单独导出，另外动画文件一般也是单独导出。有些引擎会让这三者在一个大文件里。\n\n>An unoptimized skeletal animation is defined by a stream of 4 × 3 matrix\nsamples, taken at a frequency of at least 30 frames per second, for each of the\njoints in a skeleton (of which there can be 500 or more for a realistic humanoid\ncharacter).\n因此动画文件一般需要使用高强度的压缩方式来存储。\n\n#### Audio Data\n\nAudio clips are usually exported from Sound Forge or some other audio production tool in a variety of formats and at a number of different data sampling rates.\n\n#### Particle Systems Data\n\nModern games make use of complex particle effects. These are authored by\nartists who specialize in the creation of visual effects. Third-party tools, such\nas Houdini, permit film-quality effects to be authored\n\n\n### The World Editor\n\nThe game world is where everything in a game engine comes together. To my\nknowledge, there are no commercially available game world editors\n>* Some variant of the Radiant game editor is used by most game engines\nbased on Quake technology.\n>* The Half-Life 2 Source engine provides a world editor called Hammer.\n>* UnrealEd is the Unreal Engine’s world editor. This powerful tool also\nserves as the asset manager for all data types that the engine can consume.\n\n### The Resource Database\n\nEvery asset also carries with it a great deal of metadata. metadata with the following information:\n• A unique id that identifies the animation clip at runtime.\n• The name and directory path of the source Maya (.ma or .mb) file.\n• The frame range—on which frame the animation begins and ends.\n• Whether or not the animation is intended to loop.\n• The animator’s choice of compression technique and level. (Some assets\ncan be highly compressed without noticeably degrading their quality,\nwhile others require less or no compression in order to look right ingame.)\n\n### Some Approaches to Tool Architecture\n\nAs an interesting and unique example, Unreal’s world editor and asset\nmanager, UnrealEd, is built right into the runtime game engine.It permits the tools to\nhave total access to the full range of data structures used by the engine and\navoids a common problem of having to have two representations of every\ndata structure—one for the runtime engine and one for the tools.\n>  运行时编辑和访问游戏所有数据为开发带来便利和加速\n\n![一些游戏的工具架构](/img/1575083811284.png)\n![一些运行时可编辑的架构](/img/1575083796324.png)\n\n####  Web-Based User Interfaces\n网页基础的页面显示。这里主要指工具。\n>At Naughty Dog, we use a number of web-based\nUIs. Naughty Dog’s localization tool serves as the front-end portal into our\nlocalization database. Tasker is the web-based interface used by all Naughty\nDog employees to create, manage, schedule, communicate and collaborate on\ngame development tasks during production. A web-based interface known\nas Connector also serves as our window into the various streams of debugging\ninformation that are emitted by the game engine at runtime.\n\n\n\n","source":"_posts/GEA-P2.md","raw":"---\ntitle: GEA-P2\ncategories:\n- IT阅读\ntags: \n- Game\n---\n# 1 介绍\n\n## (1.6) Runtime Engine Architecture\n\n![Runtime Engine Architecture](/img/1574738644796.png)\n\n>自底向上的顺序大概为：\n>硬件层 \n>驱动层\n> 系统层 \n>ＳＤＫ层\n＞平台独立层\n> 核心库\n>资源库 \n>　渲染，调试，物理检测，游戏平台基础\n＞游戏级渲染，各上层动画机制，相机机制，ＡＩ机制\n＞游戏逻辑层\n\n### 操作系统层\n\n分为PC与主机（游戏）系统，PC系统如windows 提供了一种线程的机制为分享硬件资源，而主机游戏一般来说则可占用所有的硬件资源，但这两者的差距在逐渐减少。\n\n>Operating systems like Microsoft\nWindows employ a time-sliced approach to sharing the hardware with multiple running programs, known as preemptive multitasking. \n>On a console, the game typically\n“owns” the entire machine.\n>So the gap between console and PC development is\ngradually closing (for better or for worse).\n\n###  3rd Party SDKS\n\n> DirectX Opengl\n> Havok, PhysX ODE etc.. 实现增强物理效果的SDK\n> Boost++ C++标准库之一\n> STL C++标准库之一\n> Kynapse 游戏AI开发的中间件\n> Granny, Havok Animation，处理动画骨骼等\n> Euphoria， 小型的游戏开发套件：https://sourceforge.net/projects/euphoriasdk/\n\n#### 数据结构与算法\n\nC++ 库\n1. STL : strings, data structures, stream-based I/O  \n2. STLport :portable and optimized of STL\n3. Boost :Powerful data structures and algorithms library\n4. Loki :Powerful generic programming template library\n\n\n#### 图形\n\n>硬件图形库\n> Glide  早期的3D图形SDK，针对Voodoo显卡。\n> OpenGL widely used!\n> DirectX Microsoft's 3D graphics SDK\n> libgcm   更底层的接口针对PS3的图形硬件，OpenGL更高效处理的选择。\n> Edge Naughty Dog 和Sony提供的PS3平台的库\n\n#### 物理与碰撞\n\n> Havok industrial-strength physics and collision engine.\n> PhysX  NVIDIA\n> Open Dynamics Engine.  open source\n\n#### 角色动画\n\n> Granny:\n> In my opinion, the Granny SDK\nhas the best-designed and most logical animation API of any I’ve seen,\ncommercial or proprietary, especially its excellent handling of time\n\n> Havok Animation\n>  The line between physics and animation is becoming\nincreasingly blurred as characters become more and more realistic.\n\n> Edge  PS3 from Sony\n\n#### 生物力学角色模型 Biomechanical Character Models\n\n>Endorphin and Euphoria. These are animation packages that produce\ncharacter motion using advanced biomechanical models of realistic human movement.\n> Endorphin, is a Maya plug-in that permits animators to\nrun full biomechanical simulations on characters and export the resulting animations as if they had been hand animated\n>Euphoria, is a real-time version of Endorphin intended\nto produce physically and biomechanically accurate character motion at runtime under the influence of unpredictable forces.\n\n> Endorphin， MAYA插件，执行动作的角色将运行一个完整的生物力学模拟同时导出动画。\n> Euphoria,  在一些不可预测的因素影响下，将动作更精细的模拟表现出来。\nhttps://space.bilibili.com/430600560/channel/detail?cid=75669\n\n\n### Platform Independence Layer\n\n>the platform independence layer ensures consistent\nbehavior across all hardware platforms.\n\n\n### Rendering Engine\n> The rendering engine is one of the largest and most complex components of\nany game engine.\n\n#### Low-Level Renderer\n![Low-Level Renderer](/img/1574756479212.png)\n\n> Graphics Device Interface\n> DirectX, OpenGL\n\n> The low-level renderer usually provides a viewport abstraction with an associated camera-to-world matrix and 3D projection parameters, such as field of view and the location of the near and far clip planes.\n\n>  底层的渲染提供一个显示区域，关联到相机-世界和投影的参数。\n\n#### Scene Graph / Culling Optimizations\n\n> For very small game worlds, a simple frustum cull (i.e., removing objects\nthat the camera cannot “see”) is probably all that is required. For larger game\nworlds, a more advanced spatial subdivision data structure might be used to\nimprove rendering efficiency by allowing the potentially visible set (PVS) of\nobjects to be determined very quickly. \n\n> potentially visible set (PVS)\n\n> 理想状态下，底层渲染应该完全不关心spatial subdivision或scene graph的使用类型。 \n>OGRE open source rendering engine (http://www.ogre3d.org) is a great example of this principle in action. OGRE provides a plug-and-play scene graph\narchitecture. Game developers can either select from a number of preimplemented scene graph designs, or they can provide a custom scene graph implementation.\n\n### Front End\n![Front End](/img/1574759871996.png)\n\n> HUD, Heads-up Display\n> 在顶层显示\n> FMV, Full-Motion Video 动作完整的视频回放\nThis system is responsible for playing full-screen movies that have been recorded earlier.\n> IGC, in-game cinematics system.  游戏内的视频，一般当玩家不可操作时显示\n\n\n### Profiling and Debugging Tools\n>常用\n• Intel’s VTune,\n• IBM’s Quantify and Purify (part of the PurifyPlus tool suite), and\n• Compuware’s Bounds Checker.\n\n>However, most game engines also incorporate a suite of custom profiling\nand debugging tools. For example, they might include one or more of the\nfollowing:\n>* a mechanism for manually instrumenting the code, so that specific sections of code can be timed;\n>* a facility for displaying the profiling statistics on-screen while the game\nis running;\n>* a facility for dumping performance stats to a text file or to an Excel\nspreadsheet;\n>* a facility for determining how much memory is being used by the engine, and by each subsystem, including various on-screen displays;\n>* the ability to dump memory usage, high water mark and leakage stats\nwhen the game terminates and/or during gameplay;\n>* tools that allow debug print statements to be peppered throughout the\ncode, along with an ability to turn on or off different categories of debug\noutput and control the level of verbosity of the output; and\n>* the ability to record game events and then play them back. This is tough\nto get right, but when done properly it can be a very valuable tool for\ntracking down bugs.\n\n### Collisions & Physics\n\nCollision and physics are usually quite tightly coupled. \n>* Havok is the gold standard in the industry today. It is feature-rich and\nperforms well across the boards.\n>* PhysX by NVIDIA is another excellent collision and dynamics engine.\nIt was integrated into Unreal Engine 4 and is also available for free as\na stand-alone product for PC game development. PhysX was originally\ndesigned as the interface to Ageia’s new physics accelerator chip. The\nSDK is now owned and distributed by NVIDIA, and the company has\nadapted PhysX to run on its latest GPUs.\n\n>Open source physics and collision engines are also available. Perhaps the best-known of these is the Open Dynamics Engine (ODE)\n>I-Collide, V-Collide and RAPID are other popular non-commercial collision detection engines. 开发于University of North Carolina\n>http://www.ode.org\n\n\n### Animations\n>类型：\n>* sprite/texture animation,\n>* rigid body hierarchy animation, \n>* skeletal animation, 骨骼动画，\n>* vertex animation， 顶点动画\n>* morph targets.， 拉伸变形目标\n\n![enter description here](/img/1574826629863.png)\n![enter description here](/img/1574826985515.png)\n\n### Human Interface Devices (HID)\n\ninput from the player , 玩家的输入设备\n> keyboard, mouse\n> joypad\n> other specialized game controllers, like steering wheels, fishing rods,\ndance pads, the Wiimote, etc.  方向盘，鱼竿，跳舞板，手柄控制器等\n\n>The HID engine component is sometimes architected to divorce the lowlevel details of the game controller(s) on a particular hardware platform from the high-level game controls.\n>It sometimes also includes a system for detecting\nchords (multiple buttons pressed together), sequences (buttons pressed in sequence within a certain time limit) and gestures (sequences of inputs from the\nbuttons, sticks, accelerometers, etc.).\n> HID engine 组件通常设计为划分出低等级的游戏控制器到高级游戏操作。\n> 通常也会考虑检测组合按钮等情况\n\n### Audio\n\nAudio engines vary greatly in sophistication.\n> For DirectX platforms (PC, Xbox 360, Xbox One), Microsoft provides an excellent audio tool\nsuite called XACT, supported at runtime by their feature-rich XAudio2 andX3DAudio APIs. \n\n>Electronic Arts has developed an advanced, high-powered\naudio engine internally called SoundR!OT\n\n>In conjunction with first-party studios like Naughty Dog, Sony Computer Entertainment America (SCEA) provides a powerful 3D audio engine called Scream\n\n### Online Multiplayer/Networking\n\n> That said, it is usually better to design multiplayer features from day one, if you\nhave that luxury.\n尽早设置多人在线的模式\n\n> 从多人在线转单机版，往往较为简单\n>The Quake engine is well known\nfor its client-on-top-of-server mode, in which a single executable, running on a\nsingle PC, acts both as the client and the server in single-player campaigns.\n\n### Gameplay Foundation Systems\n\n> 用于连接low-level engine systems 与 gameplay code。为了上层游戏逻辑可以更方便使用。\n\n![enter description here](/img/1574912330296.png)\n\n### Game Worlds and Object Models\n\n> 游戏内的对象：\n>* static background geometry, like buildings, roads, terrain (often a special case), etc.;\n>* dynamic rigid bodies, such as rocks, soda cans, chairs, etc.;\n>* player characters (PC);\n>* non-player characters (NPC);\n>* weapons;\n>* projectiles;\n>* vehicles;\n>* lights (which may be present in the dynamic scene at runtime, or only\nused for static lighting offline);\n>* cameras;\n\n\n### Scripting System & Event\n\n> Many game engines employ a scripting language in order to make development of game-specific gameplay rules and content easier and more rapid.\n\n### Artificial Intellience Foundations\n\n游戏的人工智能模块，一些游戏引擎已经在引入这一模块到引擎，虽然这并不是引擎模块考虑的。\nKynogon \n>A company called Kynogon developed a middleware SDK named Kynapse, which provided much of the low-level technology required to build commercially viable game AI.  This SDK provides low-level AI building blocks such as nav mesh generation, path finding, static and dynamic object avoidance, identification of vulnerabilities within a play space (e.g., an open window from which an ambush could come) and a well-defined interface between AI and animation. \n\n### Game-Specific Subsystems\n\n 顶端的游戏开发层\n> Practically speaking, this line is never perfectly distinct. At least\nsome game-specific knowledge invariably seeps down through the gameplay\nfoundations layer and sometimes even extends into the core of the engine\nitself.\n\n\n## (1.7) Tools and the asset pipeline\n\n游戏数据层的组成：\n如图：粗黑箭头， 表示源数据是怎样从工具中生成出\n\t\t细线箭头，表示不同数据资源之间的引用关系\n![enter description here](/img/1574995793894.png)\n\n### Digital Content Creation Tools\n\n游戏资源从3D mesh到图片bitmaps再到音频之类的，都需要设计师用工具制作，而这些工具被称为DCC（Digital Content Creation）\n\n> Maya,3d Max\n> SoundForge\n> Photoshop\n。。。\n\n>That said, tools must be relatively **easy to use**, and they absolutely must be reliable, if a game team is going to be able to develop a highly polished product in a timely manner.\n>工具的使用需要按项目所需来决定，关键在于好用，不一定要非常完美的工具。\n\n\n### The Asset Conditioning Pipeline\n\n往往DCC生成的文件并不能直接在游戏开发中使用，原因有下：\n1. DCC导出的数据，存在许多游戏开发不需要的，比如maya中会存储directed acyclic graph的场景结点，和复杂的联结的网络结构。\n\n2. DCC文件格式加载读取很慢，而且通常格式是各个DCC专属的\n\n>Once data has been exported from the DCC app, it often must be further\nprocessed before being sent to the game engine. And if a game studio is shipping its game on more than one platform, the intermediate files might be processed differently for each target platform. \nDCC应用一般需要生成给游戏引擎用的文件。\n\n>The pipeline from DCC app to game engine is sometimes called the asset\nconditioning pipeline (ACP). Every game engine has this in some form.\n这种途径：从DCC应用到游戏引擎通常被称为: ACP\n\n#### 3D Model/Mesh Data\n\n>A mesh is a complex shape composed of triangles and vertices. A mesh typically has one or more materials applied to it in order to define\nvisual surface properties\n> MESH：由三角面和点组成的复杂的形状\n\n> In this book, I will use the term “mesh” to refer to a single renderable shape,\nand “model” to refer to a composite object that may contain multiple meshes,\nplus animation data and other metadata for use by the game.\n\n>Brush Geometry\n>Brush geometry is defined as a collection of convex hulls, each of which is defined by multiple planes.Brushes are typically created and edited directly in the game world editor. This is essentially an “old school” approach to creating\nrenderable geometry, but it is still used in some engines.\n> 笔刷型的图形，每个都由多个平面组成，通常是凹凸面的一种实现工具。\n> Pros:\n• fast and easy to create;\n• accessible to game designers—often used to “block out” a game level for\nprototyping purposes;\n• can serve both as collision volumes and as renderable geometry.\n>Cons:\n• low-resolution;\n• difficult to create complex shapes;\n• cannot support articulated objects or animated characters.\n\n\n#### Skeletal Animation Data\n\nA skeletal mesh is a special kind of mesh that is bound to a skeletal hierarchy for\nthe purposes of articulated animation. \n>Each vertex of a skeletal mesh contains a list of indices indicating to which\njoint(s) in the skeleton it is bound. A vertex usually also includes a set of joint\nweights, specifying the amount of influence each joint has on the vertex.\n>骨骼mesh，包含骨骼连接点信息，通常还会有点的权重和数量影响的数据\n\n>In order to render a skeletal mesh, the game engine requires three distinct\nkinds of data:\n>1. the mesh itself,\n>2. the skeletal hierarchy (joint names, parent-child relationships and the\nbase pose the skeleton was in when it was originally bound to the mesh),\nand58 1. Introduction\n>3. one or more animation clips, which specify how the joints should move\nover time.\n\n> Mesh与skeleton通常由DCC导出在一个文件里，当然，当有多个mesh对应一个骨骼时，骨骼通常需要单独导出，另外动画文件一般也是单独导出。有些引擎会让这三者在一个大文件里。\n\n>An unoptimized skeletal animation is defined by a stream of 4 × 3 matrix\nsamples, taken at a frequency of at least 30 frames per second, for each of the\njoints in a skeleton (of which there can be 500 or more for a realistic humanoid\ncharacter).\n因此动画文件一般需要使用高强度的压缩方式来存储。\n\n#### Audio Data\n\nAudio clips are usually exported from Sound Forge or some other audio production tool in a variety of formats and at a number of different data sampling rates.\n\n#### Particle Systems Data\n\nModern games make use of complex particle effects. These are authored by\nartists who specialize in the creation of visual effects. Third-party tools, such\nas Houdini, permit film-quality effects to be authored\n\n\n### The World Editor\n\nThe game world is where everything in a game engine comes together. To my\nknowledge, there are no commercially available game world editors\n>* Some variant of the Radiant game editor is used by most game engines\nbased on Quake technology.\n>* The Half-Life 2 Source engine provides a world editor called Hammer.\n>* UnrealEd is the Unreal Engine’s world editor. This powerful tool also\nserves as the asset manager for all data types that the engine can consume.\n\n### The Resource Database\n\nEvery asset also carries with it a great deal of metadata. metadata with the following information:\n• A unique id that identifies the animation clip at runtime.\n• The name and directory path of the source Maya (.ma or .mb) file.\n• The frame range—on which frame the animation begins and ends.\n• Whether or not the animation is intended to loop.\n• The animator’s choice of compression technique and level. (Some assets\ncan be highly compressed without noticeably degrading their quality,\nwhile others require less or no compression in order to look right ingame.)\n\n### Some Approaches to Tool Architecture\n\nAs an interesting and unique example, Unreal’s world editor and asset\nmanager, UnrealEd, is built right into the runtime game engine.It permits the tools to\nhave total access to the full range of data structures used by the engine and\navoids a common problem of having to have two representations of every\ndata structure—one for the runtime engine and one for the tools.\n>  运行时编辑和访问游戏所有数据为开发带来便利和加速\n\n![一些游戏的工具架构](/img/1575083811284.png)\n![一些运行时可编辑的架构](/img/1575083796324.png)\n\n####  Web-Based User Interfaces\n网页基础的页面显示。这里主要指工具。\n>At Naughty Dog, we use a number of web-based\nUIs. Naughty Dog’s localization tool serves as the front-end portal into our\nlocalization database. Tasker is the web-based interface used by all Naughty\nDog employees to create, manage, schedule, communicate and collaborate on\ngame development tasks during production. A web-based interface known\nas Connector also serves as our window into the various streams of debugging\ninformation that are emitted by the game engine at runtime.\n\n\n\n","slug":"GEA-P2","published":1,"date":"2020-10-15T12:46:56.197Z","updated":"2020-10-15T12:46:56.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0zh00164wf0y25que0k","content":"<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1 介绍\"></a>1 介绍</h1><h2 id=\"1-6-Runtime-Engine-Architecture\"><a href=\"#1-6-Runtime-Engine-Architecture\" class=\"headerlink\" title=\"(1.6) Runtime Engine Architecture\"></a>(1.6) Runtime Engine Architecture</h2><p><img src=\"/img/1574738644796.png\" alt=\"Runtime Engine Architecture\"></p>\n<blockquote>\n<p>自底向上的顺序大概为：<br>硬件层<br>驱动层<br>系统层<br>ＳＤＫ层<br>＞平台独立层<br>核心库<br>资源库<br>　渲染，调试，物理检测，游戏平台基础<br>＞游戏级渲染，各上层动画机制，相机机制，ＡＩ机制<br>＞游戏逻辑层</p>\n</blockquote>\n<h3 id=\"操作系统层\"><a href=\"#操作系统层\" class=\"headerlink\" title=\"操作系统层\"></a>操作系统层</h3><p>分为PC与主机（游戏）系统，PC系统如windows 提供了一种线程的机制为分享硬件资源，而主机游戏一般来说则可占用所有的硬件资源，但这两者的差距在逐渐减少。</p>\n<blockquote>\n<p>Operating systems like Microsoft<br>Windows employ a time-sliced approach to sharing the hardware with multiple running programs, known as preemptive multitasking.<br>On a console, the game typically<br>“owns” the entire machine.<br>So the gap between console and PC development is<br>gradually closing (for better or for worse).</p>\n</blockquote>\n<h3 id=\"3rd-Party-SDKS\"><a href=\"#3rd-Party-SDKS\" class=\"headerlink\" title=\"3rd Party SDKS\"></a>3rd Party SDKS</h3><blockquote>\n<p>DirectX Opengl<br>Havok, PhysX ODE etc.. 实现增强物理效果的SDK<br>Boost++ C++标准库之一<br>STL C++标准库之一<br>Kynapse 游戏AI开发的中间件<br>Granny, Havok Animation，处理动画骨骼等<br>Euphoria， 小型的游戏开发套件：<a href=\"https://sourceforge.net/projects/euphoriasdk/\">https://sourceforge.net/projects/euphoriasdk/</a></p>\n</blockquote>\n<h4 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h4><p>C++ 库</p>\n<ol>\n<li>STL : strings, data structures, stream-based I/O  </li>\n<li>STLport :portable and optimized of STL</li>\n<li>Boost :Powerful data structures and algorithms library</li>\n<li>Loki :Powerful generic programming template library</li>\n</ol>\n<h4 id=\"图形\"><a href=\"#图形\" class=\"headerlink\" title=\"图形\"></a>图形</h4><blockquote>\n<p>硬件图形库<br>Glide  早期的3D图形SDK，针对Voodoo显卡。<br>OpenGL widely used!<br>DirectX Microsoft’s 3D graphics SDK<br>libgcm   更底层的接口针对PS3的图形硬件，OpenGL更高效处理的选择。<br>Edge Naughty Dog 和Sony提供的PS3平台的库</p>\n</blockquote>\n<h4 id=\"物理与碰撞\"><a href=\"#物理与碰撞\" class=\"headerlink\" title=\"物理与碰撞\"></a>物理与碰撞</h4><blockquote>\n<p>Havok industrial-strength physics and collision engine.<br>PhysX  NVIDIA<br>Open Dynamics Engine.  open source</p>\n</blockquote>\n<h4 id=\"角色动画\"><a href=\"#角色动画\" class=\"headerlink\" title=\"角色动画\"></a>角色动画</h4><blockquote>\n<p>Granny:<br>In my opinion, the Granny SDK<br>has the best-designed and most logical animation API of any I’ve seen,<br>commercial or proprietary, especially its excellent handling of time</p>\n</blockquote>\n<blockquote>\n<p>Havok Animation<br> The line between physics and animation is becoming<br>increasingly blurred as characters become more and more realistic.</p>\n</blockquote>\n<blockquote>\n<p>Edge  PS3 from Sony</p>\n</blockquote>\n<h4 id=\"生物力学角色模型-Biomechanical-Character-Models\"><a href=\"#生物力学角色模型-Biomechanical-Character-Models\" class=\"headerlink\" title=\"生物力学角色模型 Biomechanical Character Models\"></a>生物力学角色模型 Biomechanical Character Models</h4><blockquote>\n<p>Endorphin and Euphoria. These are animation packages that produce<br>character motion using advanced biomechanical models of realistic human movement.<br>Endorphin, is a Maya plug-in that permits animators to<br>run full biomechanical simulations on characters and export the resulting animations as if they had been hand animated<br>Euphoria, is a real-time version of Endorphin intended<br>to produce physically and biomechanically accurate character motion at runtime under the influence of unpredictable forces.</p>\n</blockquote>\n<blockquote>\n<p>Endorphin， MAYA插件，执行动作的角色将运行一个完整的生物力学模拟同时导出动画。<br>Euphoria,  在一些不可预测的因素影响下，将动作更精细的模拟表现出来。<br><a href=\"https://space.bilibili.com/430600560/channel/detail?cid=75669\">https://space.bilibili.com/430600560/channel/detail?cid=75669</a></p>\n</blockquote>\n<h3 id=\"Platform-Independence-Layer\"><a href=\"#Platform-Independence-Layer\" class=\"headerlink\" title=\"Platform Independence Layer\"></a>Platform Independence Layer</h3><blockquote>\n<p>the platform independence layer ensures consistent<br>behavior across all hardware platforms.</p>\n</blockquote>\n<h3 id=\"Rendering-Engine\"><a href=\"#Rendering-Engine\" class=\"headerlink\" title=\"Rendering Engine\"></a>Rendering Engine</h3><blockquote>\n<p>The rendering engine is one of the largest and most complex components of<br>any game engine.</p>\n</blockquote>\n<h4 id=\"Low-Level-Renderer\"><a href=\"#Low-Level-Renderer\" class=\"headerlink\" title=\"Low-Level Renderer\"></a>Low-Level Renderer</h4><p><img src=\"/img/1574756479212.png\" alt=\"Low-Level Renderer\"></p>\n<blockquote>\n<p>Graphics Device Interface<br>DirectX, OpenGL</p>\n</blockquote>\n<blockquote>\n<p>The low-level renderer usually provides a viewport abstraction with an associated camera-to-world matrix and 3D projection parameters, such as field of view and the location of the near and far clip planes.</p>\n</blockquote>\n<blockquote>\n<p> 底层的渲染提供一个显示区域，关联到相机-世界和投影的参数。</p>\n</blockquote>\n<h4 id=\"Scene-Graph-Culling-Optimizations\"><a href=\"#Scene-Graph-Culling-Optimizations\" class=\"headerlink\" title=\"Scene Graph / Culling Optimizations\"></a>Scene Graph / Culling Optimizations</h4><blockquote>\n<p>For very small game worlds, a simple frustum cull (i.e., removing objects<br>that the camera cannot “see”) is probably all that is required. For larger game<br>worlds, a more advanced spatial subdivision data structure might be used to<br>improve rendering efficiency by allowing the potentially visible set (PVS) of<br>objects to be determined very quickly. </p>\n</blockquote>\n<blockquote>\n<p>potentially visible set (PVS)</p>\n</blockquote>\n<blockquote>\n<p>理想状态下，底层渲染应该完全不关心spatial subdivision或scene graph的使用类型。<br>OGRE open source rendering engine (<a href=\"http://www.ogre3d.org\">http://www.ogre3d.org</a>) is a great example of this principle in action. OGRE provides a plug-and-play scene graph<br>architecture. Game developers can either select from a number of preimplemented scene graph designs, or they can provide a custom scene graph implementation.</p>\n</blockquote>\n<h3 id=\"Front-End\"><a href=\"#Front-End\" class=\"headerlink\" title=\"Front End\"></a>Front End</h3><p><img src=\"/img/1574759871996.png\" alt=\"Front End\"></p>\n<blockquote>\n<p>HUD, Heads-up Display<br>在顶层显示<br>FMV, Full-Motion Video 动作完整的视频回放<br>This system is responsible for playing full-screen movies that have been recorded earlier.<br>IGC, in-game cinematics system.  游戏内的视频，一般当玩家不可操作时显示</p>\n</blockquote>\n<h3 id=\"Profiling-and-Debugging-Tools\"><a href=\"#Profiling-and-Debugging-Tools\" class=\"headerlink\" title=\"Profiling and Debugging Tools\"></a>Profiling and Debugging Tools</h3><blockquote>\n<p>常用<br>• Intel’s VTune,<br>• IBM’s Quantify and Purify (part of the PurifyPlus tool suite), and<br>• Compuware’s Bounds Checker.</p>\n</blockquote>\n<blockquote>\n<p>However, most game engines also incorporate a suite of custom profiling<br>and debugging tools. For example, they might include one or more of the<br>following:</p>\n<ul>\n<li>a mechanism for manually instrumenting the code, so that specific sections of code can be timed;</li>\n<li>a facility for displaying the profiling statistics on-screen while the game<br>is running;</li>\n<li>a facility for dumping performance stats to a text file or to an Excel<br>spreadsheet;</li>\n<li>a facility for determining how much memory is being used by the engine, and by each subsystem, including various on-screen displays;</li>\n<li>the ability to dump memory usage, high water mark and leakage stats<br>when the game terminates and/or during gameplay;</li>\n<li>tools that allow debug print statements to be peppered throughout the<br>code, along with an ability to turn on or off different categories of debug<br>output and control the level of verbosity of the output; and</li>\n<li>the ability to record game events and then play them back. This is tough<br>to get right, but when done properly it can be a very valuable tool for<br>tracking down bugs.</li>\n</ul>\n</blockquote>\n<h3 id=\"Collisions-amp-Physics\"><a href=\"#Collisions-amp-Physics\" class=\"headerlink\" title=\"Collisions &amp; Physics\"></a>Collisions &amp; Physics</h3><p>Collision and physics are usually quite tightly coupled. </p>\n<blockquote>\n<ul>\n<li>Havok is the gold standard in the industry today. It is feature-rich and<br>performs well across the boards.</li>\n<li>PhysX by NVIDIA is another excellent collision and dynamics engine.<br>It was integrated into Unreal Engine 4 and is also available for free as<br>a stand-alone product for PC game development. PhysX was originally<br>designed as the interface to Ageia’s new physics accelerator chip. The<br>SDK is now owned and distributed by NVIDIA, and the company has<br>adapted PhysX to run on its latest GPUs.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Open source physics and collision engines are also available. Perhaps the best-known of these is the Open Dynamics Engine (ODE)<br>I-Collide, V-Collide and RAPID are other popular non-commercial collision detection engines. 开发于University of North Carolina<br><a href=\"http://www.ode.org\">http://www.ode.org</a></p>\n</blockquote>\n<h3 id=\"Animations\"><a href=\"#Animations\" class=\"headerlink\" title=\"Animations\"></a>Animations</h3><blockquote>\n<p>类型：</p>\n<ul>\n<li>sprite/texture animation,</li>\n<li>rigid body hierarchy animation, </li>\n<li>skeletal animation, 骨骼动画，</li>\n<li>vertex animation， 顶点动画</li>\n<li>morph targets.， 拉伸变形目标</li>\n</ul>\n</blockquote>\n<p><img src=\"/img/1574826629863.png\" alt=\"enter description here\"><br><img src=\"/img/1574826985515.png\" alt=\"enter description here\"></p>\n<h3 id=\"Human-Interface-Devices-HID\"><a href=\"#Human-Interface-Devices-HID\" class=\"headerlink\" title=\"Human Interface Devices (HID)\"></a>Human Interface Devices (HID)</h3><p>input from the player , 玩家的输入设备</p>\n<blockquote>\n<p>keyboard, mouse<br>joypad<br>other specialized game controllers, like steering wheels, fishing rods,<br>dance pads, the Wiimote, etc.  方向盘，鱼竿，跳舞板，手柄控制器等</p>\n</blockquote>\n<blockquote>\n<p>The HID engine component is sometimes architected to divorce the lowlevel details of the game controller(s) on a particular hardware platform from the high-level game controls.<br>It sometimes also includes a system for detecting<br>chords (multiple buttons pressed together), sequences (buttons pressed in sequence within a certain time limit) and gestures (sequences of inputs from the<br>buttons, sticks, accelerometers, etc.).<br>HID engine 组件通常设计为划分出低等级的游戏控制器到高级游戏操作。<br>通常也会考虑检测组合按钮等情况</p>\n</blockquote>\n<h3 id=\"Audio\"><a href=\"#Audio\" class=\"headerlink\" title=\"Audio\"></a>Audio</h3><p>Audio engines vary greatly in sophistication.</p>\n<blockquote>\n<p>For DirectX platforms (PC, Xbox 360, Xbox One), Microsoft provides an excellent audio tool<br>suite called XACT, supported at runtime by their feature-rich XAudio2 andX3DAudio APIs. </p>\n</blockquote>\n<blockquote>\n<p>Electronic Arts has developed an advanced, high-powered<br>audio engine internally called SoundR!OT</p>\n</blockquote>\n<blockquote>\n<p>In conjunction with first-party studios like Naughty Dog, Sony Computer Entertainment America (SCEA) provides a powerful 3D audio engine called Scream</p>\n</blockquote>\n<h3 id=\"Online-Multiplayer-Networking\"><a href=\"#Online-Multiplayer-Networking\" class=\"headerlink\" title=\"Online Multiplayer/Networking\"></a>Online Multiplayer/Networking</h3><blockquote>\n<p>That said, it is usually better to design multiplayer features from day one, if you<br>have that luxury.<br>尽早设置多人在线的模式</p>\n</blockquote>\n<blockquote>\n<p>从多人在线转单机版，往往较为简单<br>The Quake engine is well known<br>for its client-on-top-of-server mode, in which a single executable, running on a<br>single PC, acts both as the client and the server in single-player campaigns.</p>\n</blockquote>\n<h3 id=\"Gameplay-Foundation-Systems\"><a href=\"#Gameplay-Foundation-Systems\" class=\"headerlink\" title=\"Gameplay Foundation Systems\"></a>Gameplay Foundation Systems</h3><blockquote>\n<p>用于连接low-level engine systems 与 gameplay code。为了上层游戏逻辑可以更方便使用。</p>\n</blockquote>\n<p><img src=\"/img/1574912330296.png\" alt=\"enter description here\"></p>\n<h3 id=\"Game-Worlds-and-Object-Models\"><a href=\"#Game-Worlds-and-Object-Models\" class=\"headerlink\" title=\"Game Worlds and Object Models\"></a>Game Worlds and Object Models</h3><blockquote>\n<p>游戏内的对象：</p>\n<ul>\n<li>static background geometry, like buildings, roads, terrain (often a special case), etc.;</li>\n<li>dynamic rigid bodies, such as rocks, soda cans, chairs, etc.;</li>\n<li>player characters (PC);</li>\n<li>non-player characters (NPC);</li>\n<li>weapons;</li>\n<li>projectiles;</li>\n<li>vehicles;</li>\n<li>lights (which may be present in the dynamic scene at runtime, or only<br>used for static lighting offline);</li>\n<li>cameras;</li>\n</ul>\n</blockquote>\n<h3 id=\"Scripting-System-amp-Event\"><a href=\"#Scripting-System-amp-Event\" class=\"headerlink\" title=\"Scripting System &amp; Event\"></a>Scripting System &amp; Event</h3><blockquote>\n<p>Many game engines employ a scripting language in order to make development of game-specific gameplay rules and content easier and more rapid.</p>\n</blockquote>\n<h3 id=\"Artificial-Intellience-Foundations\"><a href=\"#Artificial-Intellience-Foundations\" class=\"headerlink\" title=\"Artificial Intellience Foundations\"></a>Artificial Intellience Foundations</h3><p>游戏的人工智能模块，一些游戏引擎已经在引入这一模块到引擎，虽然这并不是引擎模块考虑的。<br>Kynogon </p>\n<blockquote>\n<p>A company called Kynogon developed a middleware SDK named Kynapse, which provided much of the low-level technology required to build commercially viable game AI.  This SDK provides low-level AI building blocks such as nav mesh generation, path finding, static and dynamic object avoidance, identification of vulnerabilities within a play space (e.g., an open window from which an ambush could come) and a well-defined interface between AI and animation. </p>\n</blockquote>\n<h3 id=\"Game-Specific-Subsystems\"><a href=\"#Game-Specific-Subsystems\" class=\"headerlink\" title=\"Game-Specific Subsystems\"></a>Game-Specific Subsystems</h3><p> 顶端的游戏开发层</p>\n<blockquote>\n<p>Practically speaking, this line is never perfectly distinct. At least<br>some game-specific knowledge invariably seeps down through the gameplay<br>foundations layer and sometimes even extends into the core of the engine<br>itself.</p>\n</blockquote>\n<h2 id=\"1-7-Tools-and-the-asset-pipeline\"><a href=\"#1-7-Tools-and-the-asset-pipeline\" class=\"headerlink\" title=\"(1.7) Tools and the asset pipeline\"></a>(1.7) Tools and the asset pipeline</h2><p>游戏数据层的组成：<br>如图：粗黑箭头， 表示源数据是怎样从工具中生成出<br>        细线箭头，表示不同数据资源之间的引用关系<br><img src=\"/img/1574995793894.png\" alt=\"enter description here\"></p>\n<h3 id=\"Digital-Content-Creation-Tools\"><a href=\"#Digital-Content-Creation-Tools\" class=\"headerlink\" title=\"Digital Content Creation Tools\"></a>Digital Content Creation Tools</h3><p>游戏资源从3D mesh到图片bitmaps再到音频之类的，都需要设计师用工具制作，而这些工具被称为DCC（Digital Content Creation）</p>\n<blockquote>\n<p>Maya,3d Max<br>SoundForge<br>Photoshop<br>。。。</p>\n</blockquote>\n<blockquote>\n<p>That said, tools must be relatively <strong>easy to use</strong>, and they absolutely must be reliable, if a game team is going to be able to develop a highly polished product in a timely manner.<br>工具的使用需要按项目所需来决定，关键在于好用，不一定要非常完美的工具。</p>\n</blockquote>\n<h3 id=\"The-Asset-Conditioning-Pipeline\"><a href=\"#The-Asset-Conditioning-Pipeline\" class=\"headerlink\" title=\"The Asset Conditioning Pipeline\"></a>The Asset Conditioning Pipeline</h3><p>往往DCC生成的文件并不能直接在游戏开发中使用，原因有下：</p>\n<ol>\n<li><p>DCC导出的数据，存在许多游戏开发不需要的，比如maya中会存储directed acyclic graph的场景结点，和复杂的联结的网络结构。</p>\n</li>\n<li><p>DCC文件格式加载读取很慢，而且通常格式是各个DCC专属的</p>\n</li>\n</ol>\n<blockquote>\n<p>Once data has been exported from the DCC app, it often must be further<br>processed before being sent to the game engine. And if a game studio is shipping its game on more than one platform, the intermediate files might be processed differently for each target platform.<br>DCC应用一般需要生成给游戏引擎用的文件。</p>\n</blockquote>\n<blockquote>\n<p>The pipeline from DCC app to game engine is sometimes called the asset<br>conditioning pipeline (ACP). Every game engine has this in some form.<br>这种途径：从DCC应用到游戏引擎通常被称为: ACP</p>\n</blockquote>\n<h4 id=\"3D-Model-Mesh-Data\"><a href=\"#3D-Model-Mesh-Data\" class=\"headerlink\" title=\"3D Model/Mesh Data\"></a>3D Model/Mesh Data</h4><blockquote>\n<p>A mesh is a complex shape composed of triangles and vertices. A mesh typically has one or more materials applied to it in order to define<br>visual surface properties<br>MESH：由三角面和点组成的复杂的形状</p>\n</blockquote>\n<blockquote>\n<p>In this book, I will use the term “mesh” to refer to a single renderable shape,<br>and “model” to refer to a composite object that may contain multiple meshes,<br>plus animation data and other metadata for use by the game.</p>\n</blockquote>\n<blockquote>\n<p>Brush Geometry<br>Brush geometry is defined as a collection of convex hulls, each of which is defined by multiple planes.Brushes are typically created and edited directly in the game world editor. This is essentially an “old school” approach to creating<br>renderable geometry, but it is still used in some engines.<br>笔刷型的图形，每个都由多个平面组成，通常是凹凸面的一种实现工具。<br>Pros:<br>• fast and easy to create;<br>• accessible to game designers—often used to “block out” a game level for<br>prototyping purposes;<br>• can serve both as collision volumes and as renderable geometry.<br>Cons:<br>• low-resolution;<br>• difficult to create complex shapes;<br>• cannot support articulated objects or animated characters.</p>\n</blockquote>\n<h4 id=\"Skeletal-Animation-Data\"><a href=\"#Skeletal-Animation-Data\" class=\"headerlink\" title=\"Skeletal Animation Data\"></a>Skeletal Animation Data</h4><p>A skeletal mesh is a special kind of mesh that is bound to a skeletal hierarchy for<br>the purposes of articulated animation. </p>\n<blockquote>\n<p>Each vertex of a skeletal mesh contains a list of indices indicating to which<br>joint(s) in the skeleton it is bound. A vertex usually also includes a set of joint<br>weights, specifying the amount of influence each joint has on the vertex.<br>骨骼mesh，包含骨骼连接点信息，通常还会有点的权重和数量影响的数据</p>\n</blockquote>\n<blockquote>\n<p>In order to render a skeletal mesh, the game engine requires three distinct<br>kinds of data:</p>\n<ol>\n<li>the mesh itself,</li>\n<li>the skeletal hierarchy (joint names, parent-child relationships and the<br>base pose the skeleton was in when it was originally bound to the mesh),<br>and58 1. Introduction</li>\n<li>one or more animation clips, which specify how the joints should move<br>over time.</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>Mesh与skeleton通常由DCC导出在一个文件里，当然，当有多个mesh对应一个骨骼时，骨骼通常需要单独导出，另外动画文件一般也是单独导出。有些引擎会让这三者在一个大文件里。</p>\n</blockquote>\n<blockquote>\n<p>An unoptimized skeletal animation is defined by a stream of 4 × 3 matrix<br>samples, taken at a frequency of at least 30 frames per second, for each of the<br>joints in a skeleton (of which there can be 500 or more for a realistic humanoid<br>character).<br>因此动画文件一般需要使用高强度的压缩方式来存储。</p>\n</blockquote>\n<h4 id=\"Audio-Data\"><a href=\"#Audio-Data\" class=\"headerlink\" title=\"Audio Data\"></a>Audio Data</h4><p>Audio clips are usually exported from Sound Forge or some other audio production tool in a variety of formats and at a number of different data sampling rates.</p>\n<h4 id=\"Particle-Systems-Data\"><a href=\"#Particle-Systems-Data\" class=\"headerlink\" title=\"Particle Systems Data\"></a>Particle Systems Data</h4><p>Modern games make use of complex particle effects. These are authored by<br>artists who specialize in the creation of visual effects. Third-party tools, such<br>as Houdini, permit film-quality effects to be authored</p>\n<h3 id=\"The-World-Editor\"><a href=\"#The-World-Editor\" class=\"headerlink\" title=\"The World Editor\"></a>The World Editor</h3><p>The game world is where everything in a game engine comes together. To my<br>knowledge, there are no commercially available game world editors</p>\n<blockquote>\n<ul>\n<li>Some variant of the Radiant game editor is used by most game engines<br>based on Quake technology.</li>\n<li>The Half-Life 2 Source engine provides a world editor called Hammer.</li>\n<li>UnrealEd is the Unreal Engine’s world editor. This powerful tool also<br>serves as the asset manager for all data types that the engine can consume.</li>\n</ul>\n</blockquote>\n<h3 id=\"The-Resource-Database\"><a href=\"#The-Resource-Database\" class=\"headerlink\" title=\"The Resource Database\"></a>The Resource Database</h3><p>Every asset also carries with it a great deal of metadata. metadata with the following information:<br>• A unique id that identifies the animation clip at runtime.<br>• The name and directory path of the source Maya (.ma or .mb) file.<br>• The frame range—on which frame the animation begins and ends.<br>• Whether or not the animation is intended to loop.<br>• The animator’s choice of compression technique and level. (Some assets<br>can be highly compressed without noticeably degrading their quality,<br>while others require less or no compression in order to look right ingame.)</p>\n<h3 id=\"Some-Approaches-to-Tool-Architecture\"><a href=\"#Some-Approaches-to-Tool-Architecture\" class=\"headerlink\" title=\"Some Approaches to Tool Architecture\"></a>Some Approaches to Tool Architecture</h3><p>As an interesting and unique example, Unreal’s world editor and asset<br>manager, UnrealEd, is built right into the runtime game engine.It permits the tools to<br>have total access to the full range of data structures used by the engine and<br>avoids a common problem of having to have two representations of every<br>data structure—one for the runtime engine and one for the tools.</p>\n<blockquote>\n<p> 运行时编辑和访问游戏所有数据为开发带来便利和加速</p>\n</blockquote>\n<p><img src=\"/img/1575083811284.png\" alt=\"一些游戏的工具架构\"><br><img src=\"/img/1575083796324.png\" alt=\"一些运行时可编辑的架构\"></p>\n<h4 id=\"Web-Based-User-Interfaces\"><a href=\"#Web-Based-User-Interfaces\" class=\"headerlink\" title=\"Web-Based User Interfaces\"></a>Web-Based User Interfaces</h4><p>网页基础的页面显示。这里主要指工具。</p>\n<blockquote>\n<p>At Naughty Dog, we use a number of web-based<br>UIs. Naughty Dog’s localization tool serves as the front-end portal into our<br>localization database. Tasker is the web-based interface used by all Naughty<br>Dog employees to create, manage, schedule, communicate and collaborate on<br>game development tasks during production. A web-based interface known<br>as Connector also serves as our window into the various streams of debugging<br>information that are emitted by the game engine at runtime.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1 介绍\"></a>1 介绍</h1><h2 id=\"1-6-Runtime-Engine-Architecture\"><a href=\"#1-6-Runtime-Engine-Architecture\" class=\"headerlink\" title=\"(1.6) Runtime Engine Architecture\"></a>(1.6) Runtime Engine Architecture</h2><p><img src=\"/img/1574738644796.png\" alt=\"Runtime Engine Architecture\"></p>\n<blockquote>\n<p>自底向上的顺序大概为：<br>硬件层<br>驱动层<br>系统层<br>ＳＤＫ层<br>＞平台独立层<br>核心库<br>资源库<br>　渲染，调试，物理检测，游戏平台基础<br>＞游戏级渲染，各上层动画机制，相机机制，ＡＩ机制<br>＞游戏逻辑层</p>\n</blockquote>\n<h3 id=\"操作系统层\"><a href=\"#操作系统层\" class=\"headerlink\" title=\"操作系统层\"></a>操作系统层</h3><p>分为PC与主机（游戏）系统，PC系统如windows 提供了一种线程的机制为分享硬件资源，而主机游戏一般来说则可占用所有的硬件资源，但这两者的差距在逐渐减少。</p>\n<blockquote>\n<p>Operating systems like Microsoft<br>Windows employ a time-sliced approach to sharing the hardware with multiple running programs, known as preemptive multitasking.<br>On a console, the game typically<br>“owns” the entire machine.<br>So the gap between console and PC development is<br>gradually closing (for better or for worse).</p>\n</blockquote>\n<h3 id=\"3rd-Party-SDKS\"><a href=\"#3rd-Party-SDKS\" class=\"headerlink\" title=\"3rd Party SDKS\"></a>3rd Party SDKS</h3><blockquote>\n<p>DirectX Opengl<br>Havok, PhysX ODE etc.. 实现增强物理效果的SDK<br>Boost++ C++标准库之一<br>STL C++标准库之一<br>Kynapse 游戏AI开发的中间件<br>Granny, Havok Animation，处理动画骨骼等<br>Euphoria， 小型的游戏开发套件：<a href=\"https://sourceforge.net/projects/euphoriasdk/\">https://sourceforge.net/projects/euphoriasdk/</a></p>\n</blockquote>\n<h4 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h4><p>C++ 库</p>\n<ol>\n<li>STL : strings, data structures, stream-based I/O  </li>\n<li>STLport :portable and optimized of STL</li>\n<li>Boost :Powerful data structures and algorithms library</li>\n<li>Loki :Powerful generic programming template library</li>\n</ol>\n<h4 id=\"图形\"><a href=\"#图形\" class=\"headerlink\" title=\"图形\"></a>图形</h4><blockquote>\n<p>硬件图形库<br>Glide  早期的3D图形SDK，针对Voodoo显卡。<br>OpenGL widely used!<br>DirectX Microsoft’s 3D graphics SDK<br>libgcm   更底层的接口针对PS3的图形硬件，OpenGL更高效处理的选择。<br>Edge Naughty Dog 和Sony提供的PS3平台的库</p>\n</blockquote>\n<h4 id=\"物理与碰撞\"><a href=\"#物理与碰撞\" class=\"headerlink\" title=\"物理与碰撞\"></a>物理与碰撞</h4><blockquote>\n<p>Havok industrial-strength physics and collision engine.<br>PhysX  NVIDIA<br>Open Dynamics Engine.  open source</p>\n</blockquote>\n<h4 id=\"角色动画\"><a href=\"#角色动画\" class=\"headerlink\" title=\"角色动画\"></a>角色动画</h4><blockquote>\n<p>Granny:<br>In my opinion, the Granny SDK<br>has the best-designed and most logical animation API of any I’ve seen,<br>commercial or proprietary, especially its excellent handling of time</p>\n</blockquote>\n<blockquote>\n<p>Havok Animation<br> The line between physics and animation is becoming<br>increasingly blurred as characters become more and more realistic.</p>\n</blockquote>\n<blockquote>\n<p>Edge  PS3 from Sony</p>\n</blockquote>\n<h4 id=\"生物力学角色模型-Biomechanical-Character-Models\"><a href=\"#生物力学角色模型-Biomechanical-Character-Models\" class=\"headerlink\" title=\"生物力学角色模型 Biomechanical Character Models\"></a>生物力学角色模型 Biomechanical Character Models</h4><blockquote>\n<p>Endorphin and Euphoria. These are animation packages that produce<br>character motion using advanced biomechanical models of realistic human movement.<br>Endorphin, is a Maya plug-in that permits animators to<br>run full biomechanical simulations on characters and export the resulting animations as if they had been hand animated<br>Euphoria, is a real-time version of Endorphin intended<br>to produce physically and biomechanically accurate character motion at runtime under the influence of unpredictable forces.</p>\n</blockquote>\n<blockquote>\n<p>Endorphin， MAYA插件，执行动作的角色将运行一个完整的生物力学模拟同时导出动画。<br>Euphoria,  在一些不可预测的因素影响下，将动作更精细的模拟表现出来。<br><a href=\"https://space.bilibili.com/430600560/channel/detail?cid=75669\">https://space.bilibili.com/430600560/channel/detail?cid=75669</a></p>\n</blockquote>\n<h3 id=\"Platform-Independence-Layer\"><a href=\"#Platform-Independence-Layer\" class=\"headerlink\" title=\"Platform Independence Layer\"></a>Platform Independence Layer</h3><blockquote>\n<p>the platform independence layer ensures consistent<br>behavior across all hardware platforms.</p>\n</blockquote>\n<h3 id=\"Rendering-Engine\"><a href=\"#Rendering-Engine\" class=\"headerlink\" title=\"Rendering Engine\"></a>Rendering Engine</h3><blockquote>\n<p>The rendering engine is one of the largest and most complex components of<br>any game engine.</p>\n</blockquote>\n<h4 id=\"Low-Level-Renderer\"><a href=\"#Low-Level-Renderer\" class=\"headerlink\" title=\"Low-Level Renderer\"></a>Low-Level Renderer</h4><p><img src=\"/img/1574756479212.png\" alt=\"Low-Level Renderer\"></p>\n<blockquote>\n<p>Graphics Device Interface<br>DirectX, OpenGL</p>\n</blockquote>\n<blockquote>\n<p>The low-level renderer usually provides a viewport abstraction with an associated camera-to-world matrix and 3D projection parameters, such as field of view and the location of the near and far clip planes.</p>\n</blockquote>\n<blockquote>\n<p> 底层的渲染提供一个显示区域，关联到相机-世界和投影的参数。</p>\n</blockquote>\n<h4 id=\"Scene-Graph-Culling-Optimizations\"><a href=\"#Scene-Graph-Culling-Optimizations\" class=\"headerlink\" title=\"Scene Graph / Culling Optimizations\"></a>Scene Graph / Culling Optimizations</h4><blockquote>\n<p>For very small game worlds, a simple frustum cull (i.e., removing objects<br>that the camera cannot “see”) is probably all that is required. For larger game<br>worlds, a more advanced spatial subdivision data structure might be used to<br>improve rendering efficiency by allowing the potentially visible set (PVS) of<br>objects to be determined very quickly. </p>\n</blockquote>\n<blockquote>\n<p>potentially visible set (PVS)</p>\n</blockquote>\n<blockquote>\n<p>理想状态下，底层渲染应该完全不关心spatial subdivision或scene graph的使用类型。<br>OGRE open source rendering engine (<a href=\"http://www.ogre3d.org\">http://www.ogre3d.org</a>) is a great example of this principle in action. OGRE provides a plug-and-play scene graph<br>architecture. Game developers can either select from a number of preimplemented scene graph designs, or they can provide a custom scene graph implementation.</p>\n</blockquote>\n<h3 id=\"Front-End\"><a href=\"#Front-End\" class=\"headerlink\" title=\"Front End\"></a>Front End</h3><p><img src=\"/img/1574759871996.png\" alt=\"Front End\"></p>\n<blockquote>\n<p>HUD, Heads-up Display<br>在顶层显示<br>FMV, Full-Motion Video 动作完整的视频回放<br>This system is responsible for playing full-screen movies that have been recorded earlier.<br>IGC, in-game cinematics system.  游戏内的视频，一般当玩家不可操作时显示</p>\n</blockquote>\n<h3 id=\"Profiling-and-Debugging-Tools\"><a href=\"#Profiling-and-Debugging-Tools\" class=\"headerlink\" title=\"Profiling and Debugging Tools\"></a>Profiling and Debugging Tools</h3><blockquote>\n<p>常用<br>• Intel’s VTune,<br>• IBM’s Quantify and Purify (part of the PurifyPlus tool suite), and<br>• Compuware’s Bounds Checker.</p>\n</blockquote>\n<blockquote>\n<p>However, most game engines also incorporate a suite of custom profiling<br>and debugging tools. For example, they might include one or more of the<br>following:</p>\n<ul>\n<li>a mechanism for manually instrumenting the code, so that specific sections of code can be timed;</li>\n<li>a facility for displaying the profiling statistics on-screen while the game<br>is running;</li>\n<li>a facility for dumping performance stats to a text file or to an Excel<br>spreadsheet;</li>\n<li>a facility for determining how much memory is being used by the engine, and by each subsystem, including various on-screen displays;</li>\n<li>the ability to dump memory usage, high water mark and leakage stats<br>when the game terminates and/or during gameplay;</li>\n<li>tools that allow debug print statements to be peppered throughout the<br>code, along with an ability to turn on or off different categories of debug<br>output and control the level of verbosity of the output; and</li>\n<li>the ability to record game events and then play them back. This is tough<br>to get right, but when done properly it can be a very valuable tool for<br>tracking down bugs.</li>\n</ul>\n</blockquote>\n<h3 id=\"Collisions-amp-Physics\"><a href=\"#Collisions-amp-Physics\" class=\"headerlink\" title=\"Collisions &amp; Physics\"></a>Collisions &amp; Physics</h3><p>Collision and physics are usually quite tightly coupled. </p>\n<blockquote>\n<ul>\n<li>Havok is the gold standard in the industry today. It is feature-rich and<br>performs well across the boards.</li>\n<li>PhysX by NVIDIA is another excellent collision and dynamics engine.<br>It was integrated into Unreal Engine 4 and is also available for free as<br>a stand-alone product for PC game development. PhysX was originally<br>designed as the interface to Ageia’s new physics accelerator chip. The<br>SDK is now owned and distributed by NVIDIA, and the company has<br>adapted PhysX to run on its latest GPUs.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Open source physics and collision engines are also available. Perhaps the best-known of these is the Open Dynamics Engine (ODE)<br>I-Collide, V-Collide and RAPID are other popular non-commercial collision detection engines. 开发于University of North Carolina<br><a href=\"http://www.ode.org\">http://www.ode.org</a></p>\n</blockquote>\n<h3 id=\"Animations\"><a href=\"#Animations\" class=\"headerlink\" title=\"Animations\"></a>Animations</h3><blockquote>\n<p>类型：</p>\n<ul>\n<li>sprite/texture animation,</li>\n<li>rigid body hierarchy animation, </li>\n<li>skeletal animation, 骨骼动画，</li>\n<li>vertex animation， 顶点动画</li>\n<li>morph targets.， 拉伸变形目标</li>\n</ul>\n</blockquote>\n<p><img src=\"/img/1574826629863.png\" alt=\"enter description here\"><br><img src=\"/img/1574826985515.png\" alt=\"enter description here\"></p>\n<h3 id=\"Human-Interface-Devices-HID\"><a href=\"#Human-Interface-Devices-HID\" class=\"headerlink\" title=\"Human Interface Devices (HID)\"></a>Human Interface Devices (HID)</h3><p>input from the player , 玩家的输入设备</p>\n<blockquote>\n<p>keyboard, mouse<br>joypad<br>other specialized game controllers, like steering wheels, fishing rods,<br>dance pads, the Wiimote, etc.  方向盘，鱼竿，跳舞板，手柄控制器等</p>\n</blockquote>\n<blockquote>\n<p>The HID engine component is sometimes architected to divorce the lowlevel details of the game controller(s) on a particular hardware platform from the high-level game controls.<br>It sometimes also includes a system for detecting<br>chords (multiple buttons pressed together), sequences (buttons pressed in sequence within a certain time limit) and gestures (sequences of inputs from the<br>buttons, sticks, accelerometers, etc.).<br>HID engine 组件通常设计为划分出低等级的游戏控制器到高级游戏操作。<br>通常也会考虑检测组合按钮等情况</p>\n</blockquote>\n<h3 id=\"Audio\"><a href=\"#Audio\" class=\"headerlink\" title=\"Audio\"></a>Audio</h3><p>Audio engines vary greatly in sophistication.</p>\n<blockquote>\n<p>For DirectX platforms (PC, Xbox 360, Xbox One), Microsoft provides an excellent audio tool<br>suite called XACT, supported at runtime by their feature-rich XAudio2 andX3DAudio APIs. </p>\n</blockquote>\n<blockquote>\n<p>Electronic Arts has developed an advanced, high-powered<br>audio engine internally called SoundR!OT</p>\n</blockquote>\n<blockquote>\n<p>In conjunction with first-party studios like Naughty Dog, Sony Computer Entertainment America (SCEA) provides a powerful 3D audio engine called Scream</p>\n</blockquote>\n<h3 id=\"Online-Multiplayer-Networking\"><a href=\"#Online-Multiplayer-Networking\" class=\"headerlink\" title=\"Online Multiplayer/Networking\"></a>Online Multiplayer/Networking</h3><blockquote>\n<p>That said, it is usually better to design multiplayer features from day one, if you<br>have that luxury.<br>尽早设置多人在线的模式</p>\n</blockquote>\n<blockquote>\n<p>从多人在线转单机版，往往较为简单<br>The Quake engine is well known<br>for its client-on-top-of-server mode, in which a single executable, running on a<br>single PC, acts both as the client and the server in single-player campaigns.</p>\n</blockquote>\n<h3 id=\"Gameplay-Foundation-Systems\"><a href=\"#Gameplay-Foundation-Systems\" class=\"headerlink\" title=\"Gameplay Foundation Systems\"></a>Gameplay Foundation Systems</h3><blockquote>\n<p>用于连接low-level engine systems 与 gameplay code。为了上层游戏逻辑可以更方便使用。</p>\n</blockquote>\n<p><img src=\"/img/1574912330296.png\" alt=\"enter description here\"></p>\n<h3 id=\"Game-Worlds-and-Object-Models\"><a href=\"#Game-Worlds-and-Object-Models\" class=\"headerlink\" title=\"Game Worlds and Object Models\"></a>Game Worlds and Object Models</h3><blockquote>\n<p>游戏内的对象：</p>\n<ul>\n<li>static background geometry, like buildings, roads, terrain (often a special case), etc.;</li>\n<li>dynamic rigid bodies, such as rocks, soda cans, chairs, etc.;</li>\n<li>player characters (PC);</li>\n<li>non-player characters (NPC);</li>\n<li>weapons;</li>\n<li>projectiles;</li>\n<li>vehicles;</li>\n<li>lights (which may be present in the dynamic scene at runtime, or only<br>used for static lighting offline);</li>\n<li>cameras;</li>\n</ul>\n</blockquote>\n<h3 id=\"Scripting-System-amp-Event\"><a href=\"#Scripting-System-amp-Event\" class=\"headerlink\" title=\"Scripting System &amp; Event\"></a>Scripting System &amp; Event</h3><blockquote>\n<p>Many game engines employ a scripting language in order to make development of game-specific gameplay rules and content easier and more rapid.</p>\n</blockquote>\n<h3 id=\"Artificial-Intellience-Foundations\"><a href=\"#Artificial-Intellience-Foundations\" class=\"headerlink\" title=\"Artificial Intellience Foundations\"></a>Artificial Intellience Foundations</h3><p>游戏的人工智能模块，一些游戏引擎已经在引入这一模块到引擎，虽然这并不是引擎模块考虑的。<br>Kynogon </p>\n<blockquote>\n<p>A company called Kynogon developed a middleware SDK named Kynapse, which provided much of the low-level technology required to build commercially viable game AI.  This SDK provides low-level AI building blocks such as nav mesh generation, path finding, static and dynamic object avoidance, identification of vulnerabilities within a play space (e.g., an open window from which an ambush could come) and a well-defined interface between AI and animation. </p>\n</blockquote>\n<h3 id=\"Game-Specific-Subsystems\"><a href=\"#Game-Specific-Subsystems\" class=\"headerlink\" title=\"Game-Specific Subsystems\"></a>Game-Specific Subsystems</h3><p> 顶端的游戏开发层</p>\n<blockquote>\n<p>Practically speaking, this line is never perfectly distinct. At least<br>some game-specific knowledge invariably seeps down through the gameplay<br>foundations layer and sometimes even extends into the core of the engine<br>itself.</p>\n</blockquote>\n<h2 id=\"1-7-Tools-and-the-asset-pipeline\"><a href=\"#1-7-Tools-and-the-asset-pipeline\" class=\"headerlink\" title=\"(1.7) Tools and the asset pipeline\"></a>(1.7) Tools and the asset pipeline</h2><p>游戏数据层的组成：<br>如图：粗黑箭头， 表示源数据是怎样从工具中生成出<br>        细线箭头，表示不同数据资源之间的引用关系<br><img src=\"/img/1574995793894.png\" alt=\"enter description here\"></p>\n<h3 id=\"Digital-Content-Creation-Tools\"><a href=\"#Digital-Content-Creation-Tools\" class=\"headerlink\" title=\"Digital Content Creation Tools\"></a>Digital Content Creation Tools</h3><p>游戏资源从3D mesh到图片bitmaps再到音频之类的，都需要设计师用工具制作，而这些工具被称为DCC（Digital Content Creation）</p>\n<blockquote>\n<p>Maya,3d Max<br>SoundForge<br>Photoshop<br>。。。</p>\n</blockquote>\n<blockquote>\n<p>That said, tools must be relatively <strong>easy to use</strong>, and they absolutely must be reliable, if a game team is going to be able to develop a highly polished product in a timely manner.<br>工具的使用需要按项目所需来决定，关键在于好用，不一定要非常完美的工具。</p>\n</blockquote>\n<h3 id=\"The-Asset-Conditioning-Pipeline\"><a href=\"#The-Asset-Conditioning-Pipeline\" class=\"headerlink\" title=\"The Asset Conditioning Pipeline\"></a>The Asset Conditioning Pipeline</h3><p>往往DCC生成的文件并不能直接在游戏开发中使用，原因有下：</p>\n<ol>\n<li><p>DCC导出的数据，存在许多游戏开发不需要的，比如maya中会存储directed acyclic graph的场景结点，和复杂的联结的网络结构。</p>\n</li>\n<li><p>DCC文件格式加载读取很慢，而且通常格式是各个DCC专属的</p>\n</li>\n</ol>\n<blockquote>\n<p>Once data has been exported from the DCC app, it often must be further<br>processed before being sent to the game engine. And if a game studio is shipping its game on more than one platform, the intermediate files might be processed differently for each target platform.<br>DCC应用一般需要生成给游戏引擎用的文件。</p>\n</blockquote>\n<blockquote>\n<p>The pipeline from DCC app to game engine is sometimes called the asset<br>conditioning pipeline (ACP). Every game engine has this in some form.<br>这种途径：从DCC应用到游戏引擎通常被称为: ACP</p>\n</blockquote>\n<h4 id=\"3D-Model-Mesh-Data\"><a href=\"#3D-Model-Mesh-Data\" class=\"headerlink\" title=\"3D Model/Mesh Data\"></a>3D Model/Mesh Data</h4><blockquote>\n<p>A mesh is a complex shape composed of triangles and vertices. A mesh typically has one or more materials applied to it in order to define<br>visual surface properties<br>MESH：由三角面和点组成的复杂的形状</p>\n</blockquote>\n<blockquote>\n<p>In this book, I will use the term “mesh” to refer to a single renderable shape,<br>and “model” to refer to a composite object that may contain multiple meshes,<br>plus animation data and other metadata for use by the game.</p>\n</blockquote>\n<blockquote>\n<p>Brush Geometry<br>Brush geometry is defined as a collection of convex hulls, each of which is defined by multiple planes.Brushes are typically created and edited directly in the game world editor. This is essentially an “old school” approach to creating<br>renderable geometry, but it is still used in some engines.<br>笔刷型的图形，每个都由多个平面组成，通常是凹凸面的一种实现工具。<br>Pros:<br>• fast and easy to create;<br>• accessible to game designers—often used to “block out” a game level for<br>prototyping purposes;<br>• can serve both as collision volumes and as renderable geometry.<br>Cons:<br>• low-resolution;<br>• difficult to create complex shapes;<br>• cannot support articulated objects or animated characters.</p>\n</blockquote>\n<h4 id=\"Skeletal-Animation-Data\"><a href=\"#Skeletal-Animation-Data\" class=\"headerlink\" title=\"Skeletal Animation Data\"></a>Skeletal Animation Data</h4><p>A skeletal mesh is a special kind of mesh that is bound to a skeletal hierarchy for<br>the purposes of articulated animation. </p>\n<blockquote>\n<p>Each vertex of a skeletal mesh contains a list of indices indicating to which<br>joint(s) in the skeleton it is bound. A vertex usually also includes a set of joint<br>weights, specifying the amount of influence each joint has on the vertex.<br>骨骼mesh，包含骨骼连接点信息，通常还会有点的权重和数量影响的数据</p>\n</blockquote>\n<blockquote>\n<p>In order to render a skeletal mesh, the game engine requires three distinct<br>kinds of data:</p>\n<ol>\n<li>the mesh itself,</li>\n<li>the skeletal hierarchy (joint names, parent-child relationships and the<br>base pose the skeleton was in when it was originally bound to the mesh),<br>and58 1. Introduction</li>\n<li>one or more animation clips, which specify how the joints should move<br>over time.</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>Mesh与skeleton通常由DCC导出在一个文件里，当然，当有多个mesh对应一个骨骼时，骨骼通常需要单独导出，另外动画文件一般也是单独导出。有些引擎会让这三者在一个大文件里。</p>\n</blockquote>\n<blockquote>\n<p>An unoptimized skeletal animation is defined by a stream of 4 × 3 matrix<br>samples, taken at a frequency of at least 30 frames per second, for each of the<br>joints in a skeleton (of which there can be 500 or more for a realistic humanoid<br>character).<br>因此动画文件一般需要使用高强度的压缩方式来存储。</p>\n</blockquote>\n<h4 id=\"Audio-Data\"><a href=\"#Audio-Data\" class=\"headerlink\" title=\"Audio Data\"></a>Audio Data</h4><p>Audio clips are usually exported from Sound Forge or some other audio production tool in a variety of formats and at a number of different data sampling rates.</p>\n<h4 id=\"Particle-Systems-Data\"><a href=\"#Particle-Systems-Data\" class=\"headerlink\" title=\"Particle Systems Data\"></a>Particle Systems Data</h4><p>Modern games make use of complex particle effects. These are authored by<br>artists who specialize in the creation of visual effects. Third-party tools, such<br>as Houdini, permit film-quality effects to be authored</p>\n<h3 id=\"The-World-Editor\"><a href=\"#The-World-Editor\" class=\"headerlink\" title=\"The World Editor\"></a>The World Editor</h3><p>The game world is where everything in a game engine comes together. To my<br>knowledge, there are no commercially available game world editors</p>\n<blockquote>\n<ul>\n<li>Some variant of the Radiant game editor is used by most game engines<br>based on Quake technology.</li>\n<li>The Half-Life 2 Source engine provides a world editor called Hammer.</li>\n<li>UnrealEd is the Unreal Engine’s world editor. This powerful tool also<br>serves as the asset manager for all data types that the engine can consume.</li>\n</ul>\n</blockquote>\n<h3 id=\"The-Resource-Database\"><a href=\"#The-Resource-Database\" class=\"headerlink\" title=\"The Resource Database\"></a>The Resource Database</h3><p>Every asset also carries with it a great deal of metadata. metadata with the following information:<br>• A unique id that identifies the animation clip at runtime.<br>• The name and directory path of the source Maya (.ma or .mb) file.<br>• The frame range—on which frame the animation begins and ends.<br>• Whether or not the animation is intended to loop.<br>• The animator’s choice of compression technique and level. (Some assets<br>can be highly compressed without noticeably degrading their quality,<br>while others require less or no compression in order to look right ingame.)</p>\n<h3 id=\"Some-Approaches-to-Tool-Architecture\"><a href=\"#Some-Approaches-to-Tool-Architecture\" class=\"headerlink\" title=\"Some Approaches to Tool Architecture\"></a>Some Approaches to Tool Architecture</h3><p>As an interesting and unique example, Unreal’s world editor and asset<br>manager, UnrealEd, is built right into the runtime game engine.It permits the tools to<br>have total access to the full range of data structures used by the engine and<br>avoids a common problem of having to have two representations of every<br>data structure—one for the runtime engine and one for the tools.</p>\n<blockquote>\n<p> 运行时编辑和访问游戏所有数据为开发带来便利和加速</p>\n</blockquote>\n<p><img src=\"/img/1575083811284.png\" alt=\"一些游戏的工具架构\"><br><img src=\"/img/1575083796324.png\" alt=\"一些运行时可编辑的架构\"></p>\n<h4 id=\"Web-Based-User-Interfaces\"><a href=\"#Web-Based-User-Interfaces\" class=\"headerlink\" title=\"Web-Based User Interfaces\"></a>Web-Based User Interfaces</h4><p>网页基础的页面显示。这里主要指工具。</p>\n<blockquote>\n<p>At Naughty Dog, we use a number of web-based<br>UIs. Naughty Dog’s localization tool serves as the front-end portal into our<br>localization database. Tasker is the web-based interface used by all Naughty<br>Dog employees to create, manage, schedule, communicate and collaborate on<br>game development tasks during production. A web-based interface known<br>as Connector also serves as our window into the various streams of debugging<br>information that are emitted by the game engine at runtime.</p>\n</blockquote>\n"},{"title":"GEA-P4","_content":"\n# 5 引擎的支持系统\n\n## (5.1) 子系统的启动与关闭\n游戏引擎由若干子系统组成，在启动时如果系统间有相互依赖，同销毁时的顺序也需要按要求。如B系统依赖A，则A需要先启动再启动B，销毁时则是B先销毁再销毁A。\n\n#### 处理各子系统启动关闭的方式\n* 1. 单例模式： 第一次使用时，构造函数中初始化所依赖的其他子系统\n* 2. 【推荐】使用另一个管理器，统一管理所有的子系统启动与关闭。\n\n\n## (5.2) 内存管理\n内存影响性能的两个方面：\n1. 动态内存分配 ：malloc或new。将比较低效，可以避免一次性分配 \n2. CPU内存的高效性与普通大内存\n\n### 5.2.1 优化动态内存分配 \n规则： Keep heap allocations to a minimum, and never allocate from the heap within a tight loop.\n\n效率低下的原因： 1. 堆分配器的管理消耗。 2. 大部分操作系统free()函数调用需要切换模式。（用户切到内存，再切回来）\n保证越少分配越好，从不要在update中申请堆内存。\n\n#####  5.2.1.1 自定义动态内存分配器\n\n1. Stack -Based Allocators 以栈为基础的分配器\n * 许多游戏以类似栈的方式分配内存。每当一个新的游戏关卡被加载时，内存就会被分配给它。一旦加载了该级别，就很少或不进行动态内存分配。在这一层的最后，它的数据被卸载，它的所有内存可以被释放。对于这些类型的内存分配，使用类似栈的数据结构是很有意义的。\n \n * 栈分配器是非常容易实现的。我们简单地使用malloc()或global new分配一个大的连续内存块，或者通过声明一个全局字节数组(在这种情况下，内存是从可执行文件的BSS段中有效分配的)。维护一个指向栈顶部的指针，这个指针下面的所有内存地址被认为是在使用中，而它上面的所有地址被认为是空闲的。顶端指针被初始化为栈中最低的内存地址。每个分配请求只是将指针按请求的字节数向上移动。只需将顶部指针按blockIt的大小向后移动，就可以释放最近分配的块。\n \n * 要意识到，对于栈分配器，内存不能以任意顺序释放。所有释放必须按照与分配它们相反的顺序执行。执行这些限制的一种简单方法是根本不允许释放单个块。替代的方案就是,我们可以提供一个函数栈顶部回滚之前标记位置,从而释放之间的所有块当前最高和回滚位置。\n \n * 非常重要的一点是，要总是将顶部指针回滚到两个分配好的内存块中间,否则新分配将覆盖最顶部的块的末端。为了确保正确地执行此操作，堆栈分配器通常提供一个函数，该函数返回表示堆栈当前顶部的标记。回滚函数然后将这些标记中的一个作为其参数。如图所示。栈分配器的接口通常看起来像这样。\n\n![栈分配器的回收](/img/1599634350864.png)\n\n> Double ended stack allocator 双端栈分配器\n\n* 单个内存块实际上可以包含两个栈分配器——一个从块的底部向上分配，另一个从块的顶部向下分配。双端栈分配器很有用，因为它允许在底层栈的内存使用和顶层栈的内存使用之间进行权衡，从而更有效地使用内存。在某些情况下，两个栈可能使用大致相同的内存，并在块的中间相遇。在其他情况下，两个栈中的一个可能会比另一个栈消耗更多的内存，但是只要请求的内存总量不大于两个栈共享的内存块，所有分配请求仍然可以得到满足。\n![双端栈分配器](/img/1599634811580.png)\n\n2. 池子为基础的分配器： Pool Allocators\n \n * 预先申请一块大的内容，将元素放在一个链表结构上。\n * 初始时池子里链表空闲位是满的，当使用一个时，获取最后一个空闲位。当使用完成时，将其放回链表。分配和释放都是O(1)的消耗。\n * 链表设计时应注意使用指针指向 下一个空闲的内存块，而不是预先申请一个大的内存。\n\n####  5.2.1.2 对齐分配\n\n* 在大多数实现中，分配的额外字节数等于对齐。例如，如果请求的是一个16字节对齐的内存块，我们将分配额外的16个字节。这允许最坏情况下15个字节的地址调整，加上一个额外的字节，这样即使原始块已经对齐，我们也可以使用相同的计算。这样可以简化和加速代码，但每次分配都会浪费一个字节。它还很重要，因为我们将在下面看到，我们将需要这些额外的字节来存储将在块释放时使用的一些额外信息\n\n* 我们通过屏蔽原始块内存地址的最不重要的位，从期望的对齐中减去这个位，并使用结果作为调整偏移量来确定必须调整的块地址的数量。对齐应该始终是两个字节(典型的是4字节和16字节对齐)，因此要生成掩码，只需从对齐中减去一个。例如，如果请求的是一个16字节对齐的块，那么掩码将是(16-1)= 15= 0x0000000F。使用这个掩码的按位和和任何未对齐的地址将产生该地址未对齐的数量。例如，如果最初分配的块的地址是0x50341233，那么该地址与掩码0x0000000F共vields x00000000，因此该地址错对齐了三个字节。为了对齐地址，我们向它添加(对齐-不对齐)-(16-3)-13- oxd字节。因此最终对齐的地址是0x50341233 + 0xD= 0x50341240\n\n> 对齐内存分配器实现示例：\n> ![对齐内存分配器实现示例](/img/1602736304626.png)\n\n* 当这个块稍后被释放时，代码将传递给我们调整后的地址，而不是我们分配的原始地址。那么，我们如何释放内存呢?我们需要一些方法将调整后的地址转换回原始的，可能是不对齐的地址。\n\n* 为此，我们只需在分配的额外字节中存储一些元信息，以便首先对数据进行对齐。我们可能做的最小调整是一个字节。这样就有足够的空间来存储调整地址所使用的字节数(因为它永远不会超过字节数256)。我们总是将此信息存储在调整后的地址之前的字节中(无论我们实际添加了多少字节的调整)，因此，给定调整后的地址，再次查找它是很容易的。这里的。修改后的allocateAligned()函数的外观。分配和释放对齐块的过程如Fiqure 5.3。\n \n![分配和释放对齐块过程](/img/1602736411263.png)\n\n\n> ![Fiqure 5.3](/img/1602736500822.png) 。\n> 要求16字节对齐的对齐内存分配。分配的内存地址和调整的(对齐的)地址之间的差异存储在调整地址之前的字节中，以便在空闲时可以检索。\n\n#### 5.2.1.3 单帧和双缓冲内存分配器\n\n* 实际上，所有的游戏引擎在游戏循环期间都至少分配一些临时数据。该数据在循环的每次迭代结束时丢弃2485. 引擎支持系统或用于下一帧，然后丢弃。这种分配模式非常常见，许多引擎都支持单帧和双缓冲的分配器。\n \n* 单帧分配器: 通过保留一块内存并使用上面描述的简单堆栈分配器来管理它来实现的。在每一帧的开始，堆栈的“顶部”指针被清除到内存块的底部。随着帧数增长，不断往顶部分配。清洗和重复的方法。\n* 单帧分配器的主要好处之一是，分配的内存不需要占用——我们可以依赖这样一个事实，即分配器将在每一帧开始时被清除。单帧分配器也非常快。最大的缺点是，使用单帧分配器需要程序员有合理的纪律。您需要认识到，从单帧缓冲区分配的内存块只在当前帧期间有效。程序员绝对不能跨帧边界缓存一个指向单帧内存块的指针!\n\n* 双缓冲分配器：允许在 frame(i)上分配的内存块在frame(i+1)上使用。为此，我们创建了两个大小相同的单帧堆栈分配器，然后每帧都在它们之间来回移动.\n* 这种分配器对于缓存多核游戏控制台异步处理的结果非常有用，比如Xbox 360、Xbox One PlayStation 3或PlayStation 4。在帧i上，我们可以在PS3的一个spu上启动异步作业，例如，将从双缓冲分配器分配的目标缓冲区的地址交给它。作业在第i帧结束之前运行并产生结果，并将它们存储到我们提供的缓冲区中。在帧(i+ 1)，缓冲区被交换。作业的结果现在在非活动缓冲区中，因此它们不会被此帧期间可能进行的任何双缓冲分配覆盖。只要我们使用帧(i + 2)之前的作业结果，我们的数据就不会被覆盖\n\n### 5.2.2 内存碎片化\n\n* 内存碎片的问题是，即使有足够的空闲字节来满足请求，分配也可能失败。问题的关键是分配的内存块必须始终是连续的。例如，为了满足一个128 KiB的请求，必须存在一个128 KiB或更大的空闲“洞”。如果有两个孔，每个孔的大小为64 KiB，那么就有足够的字节可用，但分配失败，因为它们不是连续的字节。\n\n* 对于支持虚拟内存的操作系统来说，内存碎片并不是一个大问题。虚拟内存系统将称为页面的不连续的物理内存块映射到虚拟地址空间中，其中的页面在应用程序看来是连续的。当物理内存不足时，可以将陈旧的页面交换到硬盘，并在需要时从磁盘重新加载。有关虚拟内存如何工作的详细讨论，请参阅http://en.wikipedia.org/wiki/Virtual memory。大多数嵌入式系统无法实现虚拟内存系统。虽然一些现代的主机确实在技术上支持虚拟内存，但由于固有的性能开销，大多数主机游戏引擎仍然不使用虚拟内存。\n\n![内存碎片化](/img/1602742566579.png)\n\n#### 5.2.2.1 使用栈和池子分配器来避免内存碎片化\n\n* 栈分配器不受碎片影响，因为分配总是连续的，块的释放顺序必须与它们被分配的顺序相反。如图所示。\n* 池分配器也没有碎片问题。池会变成碎片化，但是碎片化不会像在一般用途的堆中那样造成内存不足的情况。池分配请求永远不会因为缺少足够大的连续空闲块而失败。因为所有的块大小都是一样的。如图所示。\n\n![栈和池子分配器](/img/1602742636082.png)\n\n#### 5.2.2.2 碎片整理和重新安置\n\n* 当以随机顺序分配和释放不同大小的对象时，既不能使用基于堆栈的分配器，也不能使用基于池的分配器。在这种情况下，可以通过定期整理堆碎片来避免碎片。碎片整理涉及到通过将分配的块从较高的内存地址移到较低的地址(从而将洞移到较高的地址)来合并堆中的所有空闲“洞”。一个简单的算法是搜索第一个“洞”，然后立即将分配的区块移到holc的开始位置。这样做的效果是“冒泡”到一个更高的内存地址的洞。如果重复这个过程，最终所有分配的块将占据堆地址空间低端的一个连续的内存区域，而所有的洞将在堆的高端冒泡成一个大洞。如图5.7所示。\n\n![图5.7](/img/1602742820576.png)\n\n* 1. 交换内存块并不是最大的问题，问题是： 移动一个分配的内存块，将会导致某个指向此内存块的指针失效。\n* 2.上面描述的内存块的移动并不是特别需要技巧来实现的。需要注意的是，我们正在移动分配的内存块。如果任何人有一个指针指向这些已分配的块中的一个，那么移动该块将使该指针失效这个问题的解决方案是修补任何和所有的指针到一个移位的内存块，使他们指向正确的新地址后，移位。这个过程称为指针重定位。不幸的是，没有通用的方法来查找指向内存某个特定区域的所有指针。所以如果我们要支持内存碎片整理我们的游戏引擎,程序员必须仔细手动跟踪所有的指针,这样他们就可以被重新安置,或指针必须放弃支持更加适合搬迁的事情,如智能指针或句柄。\n  \n > 智能指针是一个包含指针的小类，它在大多数意图和目的中扮演指针的角色。但是因为智能指针是一个类，所以可以对它进行编码来正确地处理内存重定位。一种方法是安排所有智能指针将自己添加到一个全局链表中。每当在堆中移动一块内存时，就可以扫描所有智能指针的链表，并且可以适当地调整指向移位内存块的每个指针。\n \n > 句柄通常实现为不可重定位表的索引，表本身包含指针。当一个已分配的块在内存中移位时，可以扫描句柄表，自动找到并更新所有相关的指针。因为句柄只是指针表的索引，所以无论内存块如何移动，它们的值都不会改变，所以使用句柄的对象不会受到内存重定位的影响。\n\n* 当某些内存块无法重新定位时，就会出现重新定位的另一个问题。例如，如果您使用的第三方库可以做到这一点2545. 引擎支持系统不使用智能指针或句柄，任何指向其数据结构的指针都有可能是不可重定位的。解决这个问题的最佳方法通常是安排相关库从可重定位内存区域外的一个特殊缓冲区分配内存。另一种选择是简单地接受某些块是不可重定位的。如果不可重定位块的数量和大小都很小，那么重定位系统仍然可以运行得很好\n\n* 均摊碎片整理成本碎片整理可能是一个缓慢的操作，因为它涉及到复制内存块。但是，我们不需要一次对堆进行完全的碎片整理。相反，代价可以平摊到多个帧上。我们可以允许在每一帧中移动N个已分配的块，比如8或16。如果我们的游戏每秒运行30帧，那么每帧持续1/30秒(33毫秒)。因此，堆通常可以在不到一秒的时间内被完全整理，而不会对游戏的帧率产生任何明显的影响。只要分配和分配的速度没有比碎片整理的速度快，堆就会一直保持大部分碎片整理。\n* 这种方法仅在每个块的大小相对较小时有效，以便移动单个块所需的时间不超过分配给重新定位每个帧的时间。如果需要重新定位非常大的块，我们通常可以将它们分成两个或更多的子块，每个子块都可以独立地重新定位。这在Naughty Dog的引擎中并没有被证明是一个问题，因为重新定位只用于动态游戏对象，而且它们永远不会比几个kibibytes大——而且通常要小得多。\n\n## (5.3) 容器\n\n* 常用的容器：\n* 1.数组， 顺序存储结构，大小在编译时就固定了。\n* 2.动态数组， 运行时长度动态变化\n* 3.动态链表，顺序结构，但内存中存储地址不一定连续\n* 4.栈，LIFO，后进先出\n* 5.队列， FIFO， 先进先出\n* 6.双向队列，支持高效的插入与删除操作\n* 7.树，树型分组的结构，每个结点有0到1个父结点，和0到多个子结点。\n* 8.二叉搜索树 BST： 每个结点只能最多有两个子结点，同时有一定顺序结构可按一定规则排序。 例如有红黑树，AVL 树，splay 树等\n* 9.二叉堆，分为最大堆和最小堆。 必定满足完全二叉树，且有最大堆和最小堆的特性\n* 10.优先队列， 一直保持一种排序好的状态的队列。通常由堆来实现（std::priority_queue), 很少用list来实现。\n* 11.字典Dictionary， 键值对的存储容器， 也称为map, hash_table (std::map, std::hash_map)\n* 12.集合Set，以一定规则存储一系列不重复的项。 类似于没有value的字典\n* 13.图，集合里的结点互相连接，有向和无向。\n* 14.有向无环图(DAG)。具有单向(即定向)互连的节点集合，没有循环(即不存在从同一节点开始和结束的非空路径)。\n\n### 5.3.1 容器的操作\n\n* 插入\n* 删除\n* 顺序读取：以一些“自然”预先定义好的顺序访问\n* 随机存取：任意的顺序读取\n* 查找\n* 排序\n\n### 5.3.2 迭代器\n\n* 迭代器是一个小类，它“知道”如何有效地访问特定类型容器中的元素。它的作用类似于数组索引或指针——它一次引用容器中的一个元素，它可以被推进到下一个元素，并且它提供了某种机制来测试容器中的所有元素是否都被访问了。例如，下面两个代码片段中的第一个使用指针在c样式数组上迭代，而第二个使用几乎相同的语法在STL链表上迭代。\n  \n``` c++\nvoid processArray(int container[], int numElements)\n{\nint* pBegin = &container[0];\nint* pEnd = &container[numElements];\nfor (int* p = pBegin; p != pEnd; p++)\n{\nint element = *p;\n// process element...\n}\n}\nvoid processList(std::list<int>& container)\n{\nstd::list<int>::iterator pBegin = container.begin();\nstd::list<int>::iterator pEnd = container.end();\nstd::list<inf>::iterator p;\nfor (p = pBegin; p != pEnd; p++)\n{\nint element = *p;\n// process element...\n}\n}\n\n```\n\n > 使用迭代器的好处\n > 直接访问会破坏容器类的封装。另一方面，迭代器通常是容器类的朋友，因此它可以高效地迭代，而不向外界公开任何实现细节。(事实上，大多数好的容器类都隐藏其内部的实现，如果不用迭代器将无法遍历。)\n > 迭代器可以简化迭代过程。大多数迭代器的作用类似于数组索引或指针，因此可以编写一个简单的循环，其中5. 引擎支持系统迭代器递增，并与终止条件进行比较，即使底层数据结构是任意复杂的。例如，迭代器可以使按顺序深度优先的树遍历看起来并不比简单的数组迭代复杂。\n\n#### 5.3.2.1 前增量与后增量\n\n* 注意，在上面的示例中，我们使用的是c++的后增量运算符，而不是前增量运算符，++p。这是一个微妙但有时很重要的优化。在表达式中使用变量(现在已修改)的值之前，preincrement操作符递增变量的内容。后增量运算符在变量被使用后对其内容进行增量。这意味着编写++p会在代码中引入一个数据依赖项——CPU必须等待增量操作完成后，它的值才能在表达式中使用。在深度流水线化的CPU上，这将导致停机。另一方面，使用p++没有数据依赖性。变量的值可以立即使用，而递增操作可以稍后进行，也可以在使用它的同时进行。无论哪种方式，都不会在管道中出现失速。当然，在for循环的“update”表达式中(for(init_expr;test_expr;update_expr){…})，前后增量之间不应该有区别。这是因为任何好的编译器都能识别出update_expr中没有使用变量的值。但是在使用该值的情况下，后增量更优，因为它不会在CPU的管道中引入停顿。因此，养成使用后增量的aluays的习惯是很好的，除非您绝对需要前增量的语义。\n\n### 5.3.3 算法复杂度\n\n* 算法的顺序通常可以通过检查伪代码来确定。如果算法的执行时间完全不依赖于容器中元素的数量，我们就说它是O(1)(也就是说，它在常量时间内完成)。如果算法在容器中的元素上执行一个循环，并访问每个元素一次，比如在对未排序列表进行线性搜索时，我们称该算法为O(n)。如果两个循环是嵌套的，每个循环都可能访问每个节点一次，那么我们说算法是O(n2)。如果使用“分而治之”的方法,在一个二叉搜索(其中一半的列表是消除每一步),然后我们只能期望| log2 (n) + 1元素会被访问的算法在最坏的情况下,因此我们称它为O (logn)操作。如果一个算法执行一个子算法n次，且子算法为O(log n)，则生成的算法将是O (nlogn)。\n\n* 我们还应该考虑容器的内存布局和使用特性。例如，一个数组(例如int a[5]或std:: vector)在内存中连续存储它的元素，除了元素本身之外不需要额外的存储开销。(注意，动态数组确实需要一个小的固定开销。)另一方面,一个链表(例如,std:: list)包裹在“链接”的数据结构,每个元素也可能包含一个指针指向下一个元素和一个指向前一个元素,总共16字节的开销64位机器上的每个元素。此外，链表中的元素在内存中不需要是连续的，而且通常不是。一个连续的内存块通常比一组不同的内存块对缓存更友好。因此，对于高速算法，数组在缓存性能方面通常比链表更好(除非链表的节点本身就是从数组中分配的)2605. 引擎支持系统一个小的、连续的内存块)。但是链表更适合插入和删除元素的速度最重要的情况\n\n### 5.3.4 创建自定义的容器类\n\n* 许多游戏引擎都提供了它们自己的通用容器数据结构的自定义实现。这种做法在主机游戏引擎和针对移动电话和PDA平台的游戏中尤其普遍。自己构建这些类的原因包括:\n* 总控制。您可以控制数据结构的内存需求、使用的算法、何时以及如何分配内存等。\n* 优化的机会。您可以优化数据结构和算法，以利用特定于目标控制台的硬件特性;或者针对引擎中的特定应用程序对它们进行微调。\n* 可定制性。您可以提供在第三方库(如STL)中不常见的自定义算法(例如，搜索容器中n个最相关的元素，而不是只搜索一个最相关的元素)。\n* 消除外部依赖。由于软件是您自己构建的，所以您不需要任何其他公司或团队来维护它。如果出现问题，可以立即进行调试和修复，而不是等到库的下一个发行版(可能要等到你的游戏发行之后!)并发数据结构的控制。当您编写自己的容器类时，您可以完全控制在多线程或多核系统上保护它们不受并发访问的方法。例如，在PS4上，Naughty Dog为我们的大多数并发数据结构使用了轻量级的“旋转锁”互斥锁，因为它们在我们基于光纤的作业调度系统中工作得很好。第三方容器库可能无法提供这种灵活性\n\n我们不能在这里涵盖所有可能的数据结构，但是让我们看看游戏引擎程序员处理容器的几种常见方法。\n\n#### 5.3.4.1 To Build or Not to Build\n\n* 作为游戏引擎设计师，我们有以下几种选择:\n* 1. 手动构建所需的数据结构\n* 2. 依赖于第三方实现。一些常见的选择包括a. c++标准模板库(STL)b. STL的一种变体，如STLportc.强大而健壮的Boost库(http://www.boost.org)。STL和Boost都很有吸引力，因为它们提供了一组丰富而强大的容器类，涵盖了几乎所有可以想象到的数据结构类型。此外，这两个包都提供了一套功能强大的基于模板的通用算法——常见算法的实现，例如查找容器中的元素，这些算法可以应用于几乎任何类型的数据对象。然而，像这样的第三方软件包可能不适合somc类游戏cngincs。即使我们决定使用第三方包，我们也必须在Boost和各种风格的STL或其他第三方库之间进行选择。因此，让我们花一点时间来研究每种方法的优缺点。\n\n> STL:\n> Stl标准模板库的好处包括:\n> * STL提供了一组丰富的特性。\n> * 相当健壮的实现可以在各种各样的平台上使用。\n> * STL是几乎所有c++编译器的“标准”。\n> 然而，STL也有很多缺点，包括:\n> * STL有一个陡峭的学习曲线。文档现在已经很好了，但是头文件在大多数平台上都很晦涩，很难理解。\n> * STL通常比专门针对特定问题设计的数据结构要慢。\n> * STL几乎总是比定制设计的数据结构消耗更多的内存。\n> * STL需要进行大量的动态内存分配，有时要以适合高性能、内存有限的控制台游戏的方式控制它对内存的需求是一项挑战\n> * STL的实现和行为在不同的编译器之间略有不同，这使得它在多平台引擎中的使用更加困难。\n\n因为现代pc上的高级虚拟内存系统使内存分配更便宜，而且耗尽物理RAM的可能性往往可以忽略不计。另一方面，STL通常不适合在内存有限、缺乏高级cpu和虚拟内存的控制台上使用。使用STL的代码可能不容易移植到其他平台。\n\n>以下是我使用的一些经验法则:\n>* 首先，也最重要的是，要了解您正在使用的特定STL类的性能和内存特征\n>* 尽量避免在您认为会成为性能瓶颈的代码中使用重的STL类。\n>* 在内存不是很重要的情况下，选择STL。举例来说，在游戏对象中嵌入std:: list是可以的，但是在3D网格的每个顶点中嵌入std:: list可能不是一个好主意。将3D网格的每个顶点添加到std::list可能也不行——std::list类会动态地为插入其中的每个元素分配一个小的“link”对象，这可能会导致大量微小的、碎片化的内存分配\n>* 如果您的引擎是多平台的，我强烈推荐STLport (http://www.stlport.org)，这是一种STL实现，专门设计用于跨广泛的编译器和目标平台移植，比原始的STI mplementations更高效、功能更丰富。\n\n> Boost:\n> Boost项目是由c++标准委员会库工作组的成员发起的，但是现在它是一个开源项目，有许多来自世界各地的贡献者。该项目的目标是生成扩展STL并与之协同工作的库，用于商业和其他用途5.3。容器263非商业用途。许多Boost库已经包含在c++标准委员会的库技术报告(TR1)中，这是迈向成为未来c++标准的一部分的一步。\n> 以下是Boost带来的好处的简要总结:\n> Boost提供了许多在STL中不可用的有用工具\n> 在某些情况下，Boost提供了解决STL设计或实现中的某些问题的备选方案\n> Boost在处理一些非常复杂的问题(如智能指针)方面做得很好。(请记住，智能指针是复杂的东西，它们可能会影响性能。手柄通常更好;详见15.5节。)\n> Boost库的文档通常都很出色。文档不仅解释了每个库做什么以及如何使用它，而且在大多数情况下，它还对设计决策、约束和组合库的需求提供了极好的深入讨论。因此，阅读Boost文档是了解软件设计原理的好方法。\n\n>如果您已经在使用STL，那么Boost可以作为许多STL特性的优秀扩展和/或替代品。\n>不过，请注意下列注意事项:\n>大多数核心Boost类都是模板，因此使用它们所需要的只是一组适当的头文件。然而，一些Boost库构建到相当大的.lib文件中，可能不适合在非常小的游戏项目中使用。\n>虽然全球Boost社区是一个优秀的支持网络，但是Boost库并没有得到保证。如果您遇到一个bug，解决它或修复它最终将是您的团队的责任。\n>Boost库是在Boost软件许可下发布的。阅读许可信息(http://www.boost.org/more/license info)。小心地确保它适合您的引擎。\n\n>Loki\n>C++的模板元编程\n>到目前为止，最著名的、可能也是最强大的c++模板元编程库是Loki，它是由Andrei Alexandrescu设计和编写的(其主页在http://www.erdani.org)。该库可以从SourceForge获得，网址是[Loki](http://loki-lib.sourceforge.net)。Loki非常强大;这是一组令人着迷的代码，值得研究和学习。然而,它的两大弱点的实际性质:(a)的代码可以令人生畏的阅读和使用,更少的真正理解,(b)它的一些组件依赖于利用“side-effect” 的编译器Behaviours,需要小心仔细自定义以便在新的编译器上运行。因此，Loki使用起来有些困难，而且它的可移植性不如一些“不那么极端”的同类产品。洛基不适合胆小的人。也就是说，一些Loki的概念(如基于策略的编程)可以应用到任何c++项目中，即使您没有使用Loki library本身。我强烈推荐所有的软件工程师阅读Andrei开创性的书，现代c++设计[2]，Loki库就是从这本书诞生的。","source":"_posts/GEA-P4.md","raw":"---\ntitle: GEA-P4\ncategories:\n- IT阅读\ntags: \n- Game\n---\n\n# 5 引擎的支持系统\n\n## (5.1) 子系统的启动与关闭\n游戏引擎由若干子系统组成，在启动时如果系统间有相互依赖，同销毁时的顺序也需要按要求。如B系统依赖A，则A需要先启动再启动B，销毁时则是B先销毁再销毁A。\n\n#### 处理各子系统启动关闭的方式\n* 1. 单例模式： 第一次使用时，构造函数中初始化所依赖的其他子系统\n* 2. 【推荐】使用另一个管理器，统一管理所有的子系统启动与关闭。\n\n\n## (5.2) 内存管理\n内存影响性能的两个方面：\n1. 动态内存分配 ：malloc或new。将比较低效，可以避免一次性分配 \n2. CPU内存的高效性与普通大内存\n\n### 5.2.1 优化动态内存分配 \n规则： Keep heap allocations to a minimum, and never allocate from the heap within a tight loop.\n\n效率低下的原因： 1. 堆分配器的管理消耗。 2. 大部分操作系统free()函数调用需要切换模式。（用户切到内存，再切回来）\n保证越少分配越好，从不要在update中申请堆内存。\n\n#####  5.2.1.1 自定义动态内存分配器\n\n1. Stack -Based Allocators 以栈为基础的分配器\n * 许多游戏以类似栈的方式分配内存。每当一个新的游戏关卡被加载时，内存就会被分配给它。一旦加载了该级别，就很少或不进行动态内存分配。在这一层的最后，它的数据被卸载，它的所有内存可以被释放。对于这些类型的内存分配，使用类似栈的数据结构是很有意义的。\n \n * 栈分配器是非常容易实现的。我们简单地使用malloc()或global new分配一个大的连续内存块，或者通过声明一个全局字节数组(在这种情况下，内存是从可执行文件的BSS段中有效分配的)。维护一个指向栈顶部的指针，这个指针下面的所有内存地址被认为是在使用中，而它上面的所有地址被认为是空闲的。顶端指针被初始化为栈中最低的内存地址。每个分配请求只是将指针按请求的字节数向上移动。只需将顶部指针按blockIt的大小向后移动，就可以释放最近分配的块。\n \n * 要意识到，对于栈分配器，内存不能以任意顺序释放。所有释放必须按照与分配它们相反的顺序执行。执行这些限制的一种简单方法是根本不允许释放单个块。替代的方案就是,我们可以提供一个函数栈顶部回滚之前标记位置,从而释放之间的所有块当前最高和回滚位置。\n \n * 非常重要的一点是，要总是将顶部指针回滚到两个分配好的内存块中间,否则新分配将覆盖最顶部的块的末端。为了确保正确地执行此操作，堆栈分配器通常提供一个函数，该函数返回表示堆栈当前顶部的标记。回滚函数然后将这些标记中的一个作为其参数。如图所示。栈分配器的接口通常看起来像这样。\n\n![栈分配器的回收](/img/1599634350864.png)\n\n> Double ended stack allocator 双端栈分配器\n\n* 单个内存块实际上可以包含两个栈分配器——一个从块的底部向上分配，另一个从块的顶部向下分配。双端栈分配器很有用，因为它允许在底层栈的内存使用和顶层栈的内存使用之间进行权衡，从而更有效地使用内存。在某些情况下，两个栈可能使用大致相同的内存，并在块的中间相遇。在其他情况下，两个栈中的一个可能会比另一个栈消耗更多的内存，但是只要请求的内存总量不大于两个栈共享的内存块，所有分配请求仍然可以得到满足。\n![双端栈分配器](/img/1599634811580.png)\n\n2. 池子为基础的分配器： Pool Allocators\n \n * 预先申请一块大的内容，将元素放在一个链表结构上。\n * 初始时池子里链表空闲位是满的，当使用一个时，获取最后一个空闲位。当使用完成时，将其放回链表。分配和释放都是O(1)的消耗。\n * 链表设计时应注意使用指针指向 下一个空闲的内存块，而不是预先申请一个大的内存。\n\n####  5.2.1.2 对齐分配\n\n* 在大多数实现中，分配的额外字节数等于对齐。例如，如果请求的是一个16字节对齐的内存块，我们将分配额外的16个字节。这允许最坏情况下15个字节的地址调整，加上一个额外的字节，这样即使原始块已经对齐，我们也可以使用相同的计算。这样可以简化和加速代码，但每次分配都会浪费一个字节。它还很重要，因为我们将在下面看到，我们将需要这些额外的字节来存储将在块释放时使用的一些额外信息\n\n* 我们通过屏蔽原始块内存地址的最不重要的位，从期望的对齐中减去这个位，并使用结果作为调整偏移量来确定必须调整的块地址的数量。对齐应该始终是两个字节(典型的是4字节和16字节对齐)，因此要生成掩码，只需从对齐中减去一个。例如，如果请求的是一个16字节对齐的块，那么掩码将是(16-1)= 15= 0x0000000F。使用这个掩码的按位和和任何未对齐的地址将产生该地址未对齐的数量。例如，如果最初分配的块的地址是0x50341233，那么该地址与掩码0x0000000F共vields x00000000，因此该地址错对齐了三个字节。为了对齐地址，我们向它添加(对齐-不对齐)-(16-3)-13- oxd字节。因此最终对齐的地址是0x50341233 + 0xD= 0x50341240\n\n> 对齐内存分配器实现示例：\n> ![对齐内存分配器实现示例](/img/1602736304626.png)\n\n* 当这个块稍后被释放时，代码将传递给我们调整后的地址，而不是我们分配的原始地址。那么，我们如何释放内存呢?我们需要一些方法将调整后的地址转换回原始的，可能是不对齐的地址。\n\n* 为此，我们只需在分配的额外字节中存储一些元信息，以便首先对数据进行对齐。我们可能做的最小调整是一个字节。这样就有足够的空间来存储调整地址所使用的字节数(因为它永远不会超过字节数256)。我们总是将此信息存储在调整后的地址之前的字节中(无论我们实际添加了多少字节的调整)，因此，给定调整后的地址，再次查找它是很容易的。这里的。修改后的allocateAligned()函数的外观。分配和释放对齐块的过程如Fiqure 5.3。\n \n![分配和释放对齐块过程](/img/1602736411263.png)\n\n\n> ![Fiqure 5.3](/img/1602736500822.png) 。\n> 要求16字节对齐的对齐内存分配。分配的内存地址和调整的(对齐的)地址之间的差异存储在调整地址之前的字节中，以便在空闲时可以检索。\n\n#### 5.2.1.3 单帧和双缓冲内存分配器\n\n* 实际上，所有的游戏引擎在游戏循环期间都至少分配一些临时数据。该数据在循环的每次迭代结束时丢弃2485. 引擎支持系统或用于下一帧，然后丢弃。这种分配模式非常常见，许多引擎都支持单帧和双缓冲的分配器。\n \n* 单帧分配器: 通过保留一块内存并使用上面描述的简单堆栈分配器来管理它来实现的。在每一帧的开始，堆栈的“顶部”指针被清除到内存块的底部。随着帧数增长，不断往顶部分配。清洗和重复的方法。\n* 单帧分配器的主要好处之一是，分配的内存不需要占用——我们可以依赖这样一个事实，即分配器将在每一帧开始时被清除。单帧分配器也非常快。最大的缺点是，使用单帧分配器需要程序员有合理的纪律。您需要认识到，从单帧缓冲区分配的内存块只在当前帧期间有效。程序员绝对不能跨帧边界缓存一个指向单帧内存块的指针!\n\n* 双缓冲分配器：允许在 frame(i)上分配的内存块在frame(i+1)上使用。为此，我们创建了两个大小相同的单帧堆栈分配器，然后每帧都在它们之间来回移动.\n* 这种分配器对于缓存多核游戏控制台异步处理的结果非常有用，比如Xbox 360、Xbox One PlayStation 3或PlayStation 4。在帧i上，我们可以在PS3的一个spu上启动异步作业，例如，将从双缓冲分配器分配的目标缓冲区的地址交给它。作业在第i帧结束之前运行并产生结果，并将它们存储到我们提供的缓冲区中。在帧(i+ 1)，缓冲区被交换。作业的结果现在在非活动缓冲区中，因此它们不会被此帧期间可能进行的任何双缓冲分配覆盖。只要我们使用帧(i + 2)之前的作业结果，我们的数据就不会被覆盖\n\n### 5.2.2 内存碎片化\n\n* 内存碎片的问题是，即使有足够的空闲字节来满足请求，分配也可能失败。问题的关键是分配的内存块必须始终是连续的。例如，为了满足一个128 KiB的请求，必须存在一个128 KiB或更大的空闲“洞”。如果有两个孔，每个孔的大小为64 KiB，那么就有足够的字节可用，但分配失败，因为它们不是连续的字节。\n\n* 对于支持虚拟内存的操作系统来说，内存碎片并不是一个大问题。虚拟内存系统将称为页面的不连续的物理内存块映射到虚拟地址空间中，其中的页面在应用程序看来是连续的。当物理内存不足时，可以将陈旧的页面交换到硬盘，并在需要时从磁盘重新加载。有关虚拟内存如何工作的详细讨论，请参阅http://en.wikipedia.org/wiki/Virtual memory。大多数嵌入式系统无法实现虚拟内存系统。虽然一些现代的主机确实在技术上支持虚拟内存，但由于固有的性能开销，大多数主机游戏引擎仍然不使用虚拟内存。\n\n![内存碎片化](/img/1602742566579.png)\n\n#### 5.2.2.1 使用栈和池子分配器来避免内存碎片化\n\n* 栈分配器不受碎片影响，因为分配总是连续的，块的释放顺序必须与它们被分配的顺序相反。如图所示。\n* 池分配器也没有碎片问题。池会变成碎片化，但是碎片化不会像在一般用途的堆中那样造成内存不足的情况。池分配请求永远不会因为缺少足够大的连续空闲块而失败。因为所有的块大小都是一样的。如图所示。\n\n![栈和池子分配器](/img/1602742636082.png)\n\n#### 5.2.2.2 碎片整理和重新安置\n\n* 当以随机顺序分配和释放不同大小的对象时，既不能使用基于堆栈的分配器，也不能使用基于池的分配器。在这种情况下，可以通过定期整理堆碎片来避免碎片。碎片整理涉及到通过将分配的块从较高的内存地址移到较低的地址(从而将洞移到较高的地址)来合并堆中的所有空闲“洞”。一个简单的算法是搜索第一个“洞”，然后立即将分配的区块移到holc的开始位置。这样做的效果是“冒泡”到一个更高的内存地址的洞。如果重复这个过程，最终所有分配的块将占据堆地址空间低端的一个连续的内存区域，而所有的洞将在堆的高端冒泡成一个大洞。如图5.7所示。\n\n![图5.7](/img/1602742820576.png)\n\n* 1. 交换内存块并不是最大的问题，问题是： 移动一个分配的内存块，将会导致某个指向此内存块的指针失效。\n* 2.上面描述的内存块的移动并不是特别需要技巧来实现的。需要注意的是，我们正在移动分配的内存块。如果任何人有一个指针指向这些已分配的块中的一个，那么移动该块将使该指针失效这个问题的解决方案是修补任何和所有的指针到一个移位的内存块，使他们指向正确的新地址后，移位。这个过程称为指针重定位。不幸的是，没有通用的方法来查找指向内存某个特定区域的所有指针。所以如果我们要支持内存碎片整理我们的游戏引擎,程序员必须仔细手动跟踪所有的指针,这样他们就可以被重新安置,或指针必须放弃支持更加适合搬迁的事情,如智能指针或句柄。\n  \n > 智能指针是一个包含指针的小类，它在大多数意图和目的中扮演指针的角色。但是因为智能指针是一个类，所以可以对它进行编码来正确地处理内存重定位。一种方法是安排所有智能指针将自己添加到一个全局链表中。每当在堆中移动一块内存时，就可以扫描所有智能指针的链表，并且可以适当地调整指向移位内存块的每个指针。\n \n > 句柄通常实现为不可重定位表的索引，表本身包含指针。当一个已分配的块在内存中移位时，可以扫描句柄表，自动找到并更新所有相关的指针。因为句柄只是指针表的索引，所以无论内存块如何移动，它们的值都不会改变，所以使用句柄的对象不会受到内存重定位的影响。\n\n* 当某些内存块无法重新定位时，就会出现重新定位的另一个问题。例如，如果您使用的第三方库可以做到这一点2545. 引擎支持系统不使用智能指针或句柄，任何指向其数据结构的指针都有可能是不可重定位的。解决这个问题的最佳方法通常是安排相关库从可重定位内存区域外的一个特殊缓冲区分配内存。另一种选择是简单地接受某些块是不可重定位的。如果不可重定位块的数量和大小都很小，那么重定位系统仍然可以运行得很好\n\n* 均摊碎片整理成本碎片整理可能是一个缓慢的操作，因为它涉及到复制内存块。但是，我们不需要一次对堆进行完全的碎片整理。相反，代价可以平摊到多个帧上。我们可以允许在每一帧中移动N个已分配的块，比如8或16。如果我们的游戏每秒运行30帧，那么每帧持续1/30秒(33毫秒)。因此，堆通常可以在不到一秒的时间内被完全整理，而不会对游戏的帧率产生任何明显的影响。只要分配和分配的速度没有比碎片整理的速度快，堆就会一直保持大部分碎片整理。\n* 这种方法仅在每个块的大小相对较小时有效，以便移动单个块所需的时间不超过分配给重新定位每个帧的时间。如果需要重新定位非常大的块，我们通常可以将它们分成两个或更多的子块，每个子块都可以独立地重新定位。这在Naughty Dog的引擎中并没有被证明是一个问题，因为重新定位只用于动态游戏对象，而且它们永远不会比几个kibibytes大——而且通常要小得多。\n\n## (5.3) 容器\n\n* 常用的容器：\n* 1.数组， 顺序存储结构，大小在编译时就固定了。\n* 2.动态数组， 运行时长度动态变化\n* 3.动态链表，顺序结构，但内存中存储地址不一定连续\n* 4.栈，LIFO，后进先出\n* 5.队列， FIFO， 先进先出\n* 6.双向队列，支持高效的插入与删除操作\n* 7.树，树型分组的结构，每个结点有0到1个父结点，和0到多个子结点。\n* 8.二叉搜索树 BST： 每个结点只能最多有两个子结点，同时有一定顺序结构可按一定规则排序。 例如有红黑树，AVL 树，splay 树等\n* 9.二叉堆，分为最大堆和最小堆。 必定满足完全二叉树，且有最大堆和最小堆的特性\n* 10.优先队列， 一直保持一种排序好的状态的队列。通常由堆来实现（std::priority_queue), 很少用list来实现。\n* 11.字典Dictionary， 键值对的存储容器， 也称为map, hash_table (std::map, std::hash_map)\n* 12.集合Set，以一定规则存储一系列不重复的项。 类似于没有value的字典\n* 13.图，集合里的结点互相连接，有向和无向。\n* 14.有向无环图(DAG)。具有单向(即定向)互连的节点集合，没有循环(即不存在从同一节点开始和结束的非空路径)。\n\n### 5.3.1 容器的操作\n\n* 插入\n* 删除\n* 顺序读取：以一些“自然”预先定义好的顺序访问\n* 随机存取：任意的顺序读取\n* 查找\n* 排序\n\n### 5.3.2 迭代器\n\n* 迭代器是一个小类，它“知道”如何有效地访问特定类型容器中的元素。它的作用类似于数组索引或指针——它一次引用容器中的一个元素，它可以被推进到下一个元素，并且它提供了某种机制来测试容器中的所有元素是否都被访问了。例如，下面两个代码片段中的第一个使用指针在c样式数组上迭代，而第二个使用几乎相同的语法在STL链表上迭代。\n  \n``` c++\nvoid processArray(int container[], int numElements)\n{\nint* pBegin = &container[0];\nint* pEnd = &container[numElements];\nfor (int* p = pBegin; p != pEnd; p++)\n{\nint element = *p;\n// process element...\n}\n}\nvoid processList(std::list<int>& container)\n{\nstd::list<int>::iterator pBegin = container.begin();\nstd::list<int>::iterator pEnd = container.end();\nstd::list<inf>::iterator p;\nfor (p = pBegin; p != pEnd; p++)\n{\nint element = *p;\n// process element...\n}\n}\n\n```\n\n > 使用迭代器的好处\n > 直接访问会破坏容器类的封装。另一方面，迭代器通常是容器类的朋友，因此它可以高效地迭代，而不向外界公开任何实现细节。(事实上，大多数好的容器类都隐藏其内部的实现，如果不用迭代器将无法遍历。)\n > 迭代器可以简化迭代过程。大多数迭代器的作用类似于数组索引或指针，因此可以编写一个简单的循环，其中5. 引擎支持系统迭代器递增，并与终止条件进行比较，即使底层数据结构是任意复杂的。例如，迭代器可以使按顺序深度优先的树遍历看起来并不比简单的数组迭代复杂。\n\n#### 5.3.2.1 前增量与后增量\n\n* 注意，在上面的示例中，我们使用的是c++的后增量运算符，而不是前增量运算符，++p。这是一个微妙但有时很重要的优化。在表达式中使用变量(现在已修改)的值之前，preincrement操作符递增变量的内容。后增量运算符在变量被使用后对其内容进行增量。这意味着编写++p会在代码中引入一个数据依赖项——CPU必须等待增量操作完成后，它的值才能在表达式中使用。在深度流水线化的CPU上，这将导致停机。另一方面，使用p++没有数据依赖性。变量的值可以立即使用，而递增操作可以稍后进行，也可以在使用它的同时进行。无论哪种方式，都不会在管道中出现失速。当然，在for循环的“update”表达式中(for(init_expr;test_expr;update_expr){…})，前后增量之间不应该有区别。这是因为任何好的编译器都能识别出update_expr中没有使用变量的值。但是在使用该值的情况下，后增量更优，因为它不会在CPU的管道中引入停顿。因此，养成使用后增量的aluays的习惯是很好的，除非您绝对需要前增量的语义。\n\n### 5.3.3 算法复杂度\n\n* 算法的顺序通常可以通过检查伪代码来确定。如果算法的执行时间完全不依赖于容器中元素的数量，我们就说它是O(1)(也就是说，它在常量时间内完成)。如果算法在容器中的元素上执行一个循环，并访问每个元素一次，比如在对未排序列表进行线性搜索时，我们称该算法为O(n)。如果两个循环是嵌套的，每个循环都可能访问每个节点一次，那么我们说算法是O(n2)。如果使用“分而治之”的方法,在一个二叉搜索(其中一半的列表是消除每一步),然后我们只能期望| log2 (n) + 1元素会被访问的算法在最坏的情况下,因此我们称它为O (logn)操作。如果一个算法执行一个子算法n次，且子算法为O(log n)，则生成的算法将是O (nlogn)。\n\n* 我们还应该考虑容器的内存布局和使用特性。例如，一个数组(例如int a[5]或std:: vector)在内存中连续存储它的元素，除了元素本身之外不需要额外的存储开销。(注意，动态数组确实需要一个小的固定开销。)另一方面,一个链表(例如,std:: list)包裹在“链接”的数据结构,每个元素也可能包含一个指针指向下一个元素和一个指向前一个元素,总共16字节的开销64位机器上的每个元素。此外，链表中的元素在内存中不需要是连续的，而且通常不是。一个连续的内存块通常比一组不同的内存块对缓存更友好。因此，对于高速算法，数组在缓存性能方面通常比链表更好(除非链表的节点本身就是从数组中分配的)2605. 引擎支持系统一个小的、连续的内存块)。但是链表更适合插入和删除元素的速度最重要的情况\n\n### 5.3.4 创建自定义的容器类\n\n* 许多游戏引擎都提供了它们自己的通用容器数据结构的自定义实现。这种做法在主机游戏引擎和针对移动电话和PDA平台的游戏中尤其普遍。自己构建这些类的原因包括:\n* 总控制。您可以控制数据结构的内存需求、使用的算法、何时以及如何分配内存等。\n* 优化的机会。您可以优化数据结构和算法，以利用特定于目标控制台的硬件特性;或者针对引擎中的特定应用程序对它们进行微调。\n* 可定制性。您可以提供在第三方库(如STL)中不常见的自定义算法(例如，搜索容器中n个最相关的元素，而不是只搜索一个最相关的元素)。\n* 消除外部依赖。由于软件是您自己构建的，所以您不需要任何其他公司或团队来维护它。如果出现问题，可以立即进行调试和修复，而不是等到库的下一个发行版(可能要等到你的游戏发行之后!)并发数据结构的控制。当您编写自己的容器类时，您可以完全控制在多线程或多核系统上保护它们不受并发访问的方法。例如，在PS4上，Naughty Dog为我们的大多数并发数据结构使用了轻量级的“旋转锁”互斥锁，因为它们在我们基于光纤的作业调度系统中工作得很好。第三方容器库可能无法提供这种灵活性\n\n我们不能在这里涵盖所有可能的数据结构，但是让我们看看游戏引擎程序员处理容器的几种常见方法。\n\n#### 5.3.4.1 To Build or Not to Build\n\n* 作为游戏引擎设计师，我们有以下几种选择:\n* 1. 手动构建所需的数据结构\n* 2. 依赖于第三方实现。一些常见的选择包括a. c++标准模板库(STL)b. STL的一种变体，如STLportc.强大而健壮的Boost库(http://www.boost.org)。STL和Boost都很有吸引力，因为它们提供了一组丰富而强大的容器类，涵盖了几乎所有可以想象到的数据结构类型。此外，这两个包都提供了一套功能强大的基于模板的通用算法——常见算法的实现，例如查找容器中的元素，这些算法可以应用于几乎任何类型的数据对象。然而，像这样的第三方软件包可能不适合somc类游戏cngincs。即使我们决定使用第三方包，我们也必须在Boost和各种风格的STL或其他第三方库之间进行选择。因此，让我们花一点时间来研究每种方法的优缺点。\n\n> STL:\n> Stl标准模板库的好处包括:\n> * STL提供了一组丰富的特性。\n> * 相当健壮的实现可以在各种各样的平台上使用。\n> * STL是几乎所有c++编译器的“标准”。\n> 然而，STL也有很多缺点，包括:\n> * STL有一个陡峭的学习曲线。文档现在已经很好了，但是头文件在大多数平台上都很晦涩，很难理解。\n> * STL通常比专门针对特定问题设计的数据结构要慢。\n> * STL几乎总是比定制设计的数据结构消耗更多的内存。\n> * STL需要进行大量的动态内存分配，有时要以适合高性能、内存有限的控制台游戏的方式控制它对内存的需求是一项挑战\n> * STL的实现和行为在不同的编译器之间略有不同，这使得它在多平台引擎中的使用更加困难。\n\n因为现代pc上的高级虚拟内存系统使内存分配更便宜，而且耗尽物理RAM的可能性往往可以忽略不计。另一方面，STL通常不适合在内存有限、缺乏高级cpu和虚拟内存的控制台上使用。使用STL的代码可能不容易移植到其他平台。\n\n>以下是我使用的一些经验法则:\n>* 首先，也最重要的是，要了解您正在使用的特定STL类的性能和内存特征\n>* 尽量避免在您认为会成为性能瓶颈的代码中使用重的STL类。\n>* 在内存不是很重要的情况下，选择STL。举例来说，在游戏对象中嵌入std:: list是可以的，但是在3D网格的每个顶点中嵌入std:: list可能不是一个好主意。将3D网格的每个顶点添加到std::list可能也不行——std::list类会动态地为插入其中的每个元素分配一个小的“link”对象，这可能会导致大量微小的、碎片化的内存分配\n>* 如果您的引擎是多平台的，我强烈推荐STLport (http://www.stlport.org)，这是一种STL实现，专门设计用于跨广泛的编译器和目标平台移植，比原始的STI mplementations更高效、功能更丰富。\n\n> Boost:\n> Boost项目是由c++标准委员会库工作组的成员发起的，但是现在它是一个开源项目，有许多来自世界各地的贡献者。该项目的目标是生成扩展STL并与之协同工作的库，用于商业和其他用途5.3。容器263非商业用途。许多Boost库已经包含在c++标准委员会的库技术报告(TR1)中，这是迈向成为未来c++标准的一部分的一步。\n> 以下是Boost带来的好处的简要总结:\n> Boost提供了许多在STL中不可用的有用工具\n> 在某些情况下，Boost提供了解决STL设计或实现中的某些问题的备选方案\n> Boost在处理一些非常复杂的问题(如智能指针)方面做得很好。(请记住，智能指针是复杂的东西，它们可能会影响性能。手柄通常更好;详见15.5节。)\n> Boost库的文档通常都很出色。文档不仅解释了每个库做什么以及如何使用它，而且在大多数情况下，它还对设计决策、约束和组合库的需求提供了极好的深入讨论。因此，阅读Boost文档是了解软件设计原理的好方法。\n\n>如果您已经在使用STL，那么Boost可以作为许多STL特性的优秀扩展和/或替代品。\n>不过，请注意下列注意事项:\n>大多数核心Boost类都是模板，因此使用它们所需要的只是一组适当的头文件。然而，一些Boost库构建到相当大的.lib文件中，可能不适合在非常小的游戏项目中使用。\n>虽然全球Boost社区是一个优秀的支持网络，但是Boost库并没有得到保证。如果您遇到一个bug，解决它或修复它最终将是您的团队的责任。\n>Boost库是在Boost软件许可下发布的。阅读许可信息(http://www.boost.org/more/license info)。小心地确保它适合您的引擎。\n\n>Loki\n>C++的模板元编程\n>到目前为止，最著名的、可能也是最强大的c++模板元编程库是Loki，它是由Andrei Alexandrescu设计和编写的(其主页在http://www.erdani.org)。该库可以从SourceForge获得，网址是[Loki](http://loki-lib.sourceforge.net)。Loki非常强大;这是一组令人着迷的代码，值得研究和学习。然而,它的两大弱点的实际性质:(a)的代码可以令人生畏的阅读和使用,更少的真正理解,(b)它的一些组件依赖于利用“side-effect” 的编译器Behaviours,需要小心仔细自定义以便在新的编译器上运行。因此，Loki使用起来有些困难，而且它的可移植性不如一些“不那么极端”的同类产品。洛基不适合胆小的人。也就是说，一些Loki的概念(如基于策略的编程)可以应用到任何c++项目中，即使您没有使用Loki library本身。我强烈推荐所有的软件工程师阅读Andrei开创性的书，现代c++设计[2]，Loki库就是从这本书诞生的。","slug":"GEA-P4","published":1,"date":"2020-10-15T12:46:56.198Z","updated":"2020-10-15T12:46:56.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0zi00194wf08hfpcyow","content":"<h1 id=\"5-引擎的支持系统\"><a href=\"#5-引擎的支持系统\" class=\"headerlink\" title=\"5 引擎的支持系统\"></a>5 引擎的支持系统</h1><h2 id=\"5-1-子系统的启动与关闭\"><a href=\"#5-1-子系统的启动与关闭\" class=\"headerlink\" title=\"(5.1) 子系统的启动与关闭\"></a>(5.1) 子系统的启动与关闭</h2><p>游戏引擎由若干子系统组成，在启动时如果系统间有相互依赖，同销毁时的顺序也需要按要求。如B系统依赖A，则A需要先启动再启动B，销毁时则是B先销毁再销毁A。</p>\n<h4 id=\"处理各子系统启动关闭的方式\"><a href=\"#处理各子系统启动关闭的方式\" class=\"headerlink\" title=\"处理各子系统启动关闭的方式\"></a>处理各子系统启动关闭的方式</h4><ul>\n<li><ol>\n<li>单例模式： 第一次使用时，构造函数中初始化所依赖的其他子系统</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>【推荐】使用另一个管理器，统一管理所有的子系统启动与关闭。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-2-内存管理\"><a href=\"#5-2-内存管理\" class=\"headerlink\" title=\"(5.2) 内存管理\"></a>(5.2) 内存管理</h2><p>内存影响性能的两个方面：</p>\n<ol>\n<li>动态内存分配 ：malloc或new。将比较低效，可以避免一次性分配 </li>\n<li>CPU内存的高效性与普通大内存</li>\n</ol>\n<h3 id=\"5-2-1-优化动态内存分配\"><a href=\"#5-2-1-优化动态内存分配\" class=\"headerlink\" title=\"5.2.1 优化动态内存分配\"></a>5.2.1 优化动态内存分配</h3><p>规则： Keep heap allocations to a minimum, and never allocate from the heap within a tight loop.</p>\n<p>效率低下的原因： 1. 堆分配器的管理消耗。 2. 大部分操作系统free()函数调用需要切换模式。（用户切到内存，再切回来）<br>保证越少分配越好，从不要在update中申请堆内存。</p>\n<h5 id=\"5-2-1-1-自定义动态内存分配器\"><a href=\"#5-2-1-1-自定义动态内存分配器\" class=\"headerlink\" title=\"5.2.1.1 自定义动态内存分配器\"></a>5.2.1.1 自定义动态内存分配器</h5><ol>\n<li><p>Stack -Based Allocators 以栈为基础的分配器</p>\n<ul>\n<li><p>许多游戏以类似栈的方式分配内存。每当一个新的游戏关卡被加载时，内存就会被分配给它。一旦加载了该级别，就很少或不进行动态内存分配。在这一层的最后，它的数据被卸载，它的所有内存可以被释放。对于这些类型的内存分配，使用类似栈的数据结构是很有意义的。</p>\n</li>\n<li><p>栈分配器是非常容易实现的。我们简单地使用malloc()或global new分配一个大的连续内存块，或者通过声明一个全局字节数组(在这种情况下，内存是从可执行文件的BSS段中有效分配的)。维护一个指向栈顶部的指针，这个指针下面的所有内存地址被认为是在使用中，而它上面的所有地址被认为是空闲的。顶端指针被初始化为栈中最低的内存地址。每个分配请求只是将指针按请求的字节数向上移动。只需将顶部指针按blockIt的大小向后移动，就可以释放最近分配的块。</p>\n</li>\n<li><p>要意识到，对于栈分配器，内存不能以任意顺序释放。所有释放必须按照与分配它们相反的顺序执行。执行这些限制的一种简单方法是根本不允许释放单个块。替代的方案就是,我们可以提供一个函数栈顶部回滚之前标记位置,从而释放之间的所有块当前最高和回滚位置。</p>\n</li>\n<li><p>非常重要的一点是，要总是将顶部指针回滚到两个分配好的内存块中间,否则新分配将覆盖最顶部的块的末端。为了确保正确地执行此操作，堆栈分配器通常提供一个函数，该函数返回表示堆栈当前顶部的标记。回滚函数然后将这些标记中的一个作为其参数。如图所示。栈分配器的接口通常看起来像这样。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/img/1599634350864.png\" alt=\"栈分配器的回收\"></p>\n<blockquote>\n<p>Double ended stack allocator 双端栈分配器</p>\n</blockquote>\n<ul>\n<li>单个内存块实际上可以包含两个栈分配器——一个从块的底部向上分配，另一个从块的顶部向下分配。双端栈分配器很有用，因为它允许在底层栈的内存使用和顶层栈的内存使用之间进行权衡，从而更有效地使用内存。在某些情况下，两个栈可能使用大致相同的内存，并在块的中间相遇。在其他情况下，两个栈中的一个可能会比另一个栈消耗更多的内存，但是只要请求的内存总量不大于两个栈共享的内存块，所有分配请求仍然可以得到满足。<br><img src=\"/img/1599634811580.png\" alt=\"双端栈分配器\"></li>\n</ul>\n<ol start=\"2\">\n<li><p>池子为基础的分配器： Pool Allocators</p>\n<ul>\n<li>预先申请一块大的内容，将元素放在一个链表结构上。</li>\n<li>初始时池子里链表空闲位是满的，当使用一个时，获取最后一个空闲位。当使用完成时，将其放回链表。分配和释放都是O(1)的消耗。</li>\n<li>链表设计时应注意使用指针指向 下一个空闲的内存块，而不是预先申请一个大的内存。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-2-1-2-对齐分配\"><a href=\"#5-2-1-2-对齐分配\" class=\"headerlink\" title=\"5.2.1.2 对齐分配\"></a>5.2.1.2 对齐分配</h4><ul>\n<li><p>在大多数实现中，分配的额外字节数等于对齐。例如，如果请求的是一个16字节对齐的内存块，我们将分配额外的16个字节。这允许最坏情况下15个字节的地址调整，加上一个额外的字节，这样即使原始块已经对齐，我们也可以使用相同的计算。这样可以简化和加速代码，但每次分配都会浪费一个字节。它还很重要，因为我们将在下面看到，我们将需要这些额外的字节来存储将在块释放时使用的一些额外信息</p>\n</li>\n<li><p>我们通过屏蔽原始块内存地址的最不重要的位，从期望的对齐中减去这个位，并使用结果作为调整偏移量来确定必须调整的块地址的数量。对齐应该始终是两个字节(典型的是4字节和16字节对齐)，因此要生成掩码，只需从对齐中减去一个。例如，如果请求的是一个16字节对齐的块，那么掩码将是(16-1)= 15= 0x0000000F。使用这个掩码的按位和和任何未对齐的地址将产生该地址未对齐的数量。例如，如果最初分配的块的地址是0x50341233，那么该地址与掩码0x0000000F共vields x00000000，因此该地址错对齐了三个字节。为了对齐地址，我们向它添加(对齐-不对齐)-(16-3)-13- oxd字节。因此最终对齐的地址是0x50341233 + 0xD= 0x50341240</p>\n</li>\n</ul>\n<blockquote>\n<p>对齐内存分配器实现示例：<br><img src=\"/img/1602736304626.png\" alt=\"对齐内存分配器实现示例\"></p>\n</blockquote>\n<ul>\n<li><p>当这个块稍后被释放时，代码将传递给我们调整后的地址，而不是我们分配的原始地址。那么，我们如何释放内存呢?我们需要一些方法将调整后的地址转换回原始的，可能是不对齐的地址。</p>\n</li>\n<li><p>为此，我们只需在分配的额外字节中存储一些元信息，以便首先对数据进行对齐。我们可能做的最小调整是一个字节。这样就有足够的空间来存储调整地址所使用的字节数(因为它永远不会超过字节数256)。我们总是将此信息存储在调整后的地址之前的字节中(无论我们实际添加了多少字节的调整)，因此，给定调整后的地址，再次查找它是很容易的。这里的。修改后的allocateAligned()函数的外观。分配和释放对齐块的过程如Fiqure 5.3。</p>\n</li>\n</ul>\n<p><img src=\"/img/1602736411263.png\" alt=\"分配和释放对齐块过程\"></p>\n<blockquote>\n<p><img src=\"/img/1602736500822.png\" alt=\"Fiqure 5.3\"> 。<br>要求16字节对齐的对齐内存分配。分配的内存地址和调整的(对齐的)地址之间的差异存储在调整地址之前的字节中，以便在空闲时可以检索。</p>\n</blockquote>\n<h4 id=\"5-2-1-3-单帧和双缓冲内存分配器\"><a href=\"#5-2-1-3-单帧和双缓冲内存分配器\" class=\"headerlink\" title=\"5.2.1.3 单帧和双缓冲内存分配器\"></a>5.2.1.3 单帧和双缓冲内存分配器</h4><ul>\n<li><p>实际上，所有的游戏引擎在游戏循环期间都至少分配一些临时数据。该数据在循环的每次迭代结束时丢弃2485. 引擎支持系统或用于下一帧，然后丢弃。这种分配模式非常常见，许多引擎都支持单帧和双缓冲的分配器。</p>\n</li>\n<li><p>单帧分配器: 通过保留一块内存并使用上面描述的简单堆栈分配器来管理它来实现的。在每一帧的开始，堆栈的“顶部”指针被清除到内存块的底部。随着帧数增长，不断往顶部分配。清洗和重复的方法。</p>\n</li>\n<li><p>单帧分配器的主要好处之一是，分配的内存不需要占用——我们可以依赖这样一个事实，即分配器将在每一帧开始时被清除。单帧分配器也非常快。最大的缺点是，使用单帧分配器需要程序员有合理的纪律。您需要认识到，从单帧缓冲区分配的内存块只在当前帧期间有效。程序员绝对不能跨帧边界缓存一个指向单帧内存块的指针!</p>\n</li>\n<li><p>双缓冲分配器：允许在 frame(i)上分配的内存块在frame(i+1)上使用。为此，我们创建了两个大小相同的单帧堆栈分配器，然后每帧都在它们之间来回移动.</p>\n</li>\n<li><p>这种分配器对于缓存多核游戏控制台异步处理的结果非常有用，比如Xbox 360、Xbox One PlayStation 3或PlayStation 4。在帧i上，我们可以在PS3的一个spu上启动异步作业，例如，将从双缓冲分配器分配的目标缓冲区的地址交给它。作业在第i帧结束之前运行并产生结果，并将它们存储到我们提供的缓冲区中。在帧(i+ 1)，缓冲区被交换。作业的结果现在在非活动缓冲区中，因此它们不会被此帧期间可能进行的任何双缓冲分配覆盖。只要我们使用帧(i + 2)之前的作业结果，我们的数据就不会被覆盖</p>\n</li>\n</ul>\n<h3 id=\"5-2-2-内存碎片化\"><a href=\"#5-2-2-内存碎片化\" class=\"headerlink\" title=\"5.2.2 内存碎片化\"></a>5.2.2 内存碎片化</h3><ul>\n<li><p>内存碎片的问题是，即使有足够的空闲字节来满足请求，分配也可能失败。问题的关键是分配的内存块必须始终是连续的。例如，为了满足一个128 KiB的请求，必须存在一个128 KiB或更大的空闲“洞”。如果有两个孔，每个孔的大小为64 KiB，那么就有足够的字节可用，但分配失败，因为它们不是连续的字节。</p>\n</li>\n<li><p>对于支持虚拟内存的操作系统来说，内存碎片并不是一个大问题。虚拟内存系统将称为页面的不连续的物理内存块映射到虚拟地址空间中，其中的页面在应用程序看来是连续的。当物理内存不足时，可以将陈旧的页面交换到硬盘，并在需要时从磁盘重新加载。有关虚拟内存如何工作的详细讨论，请参阅<a href=\"http://en.wikipedia.org/wiki/Virtual\">http://en.wikipedia.org/wiki/Virtual</a> memory。大多数嵌入式系统无法实现虚拟内存系统。虽然一些现代的主机确实在技术上支持虚拟内存，但由于固有的性能开销，大多数主机游戏引擎仍然不使用虚拟内存。</p>\n</li>\n</ul>\n<p><img src=\"/img/1602742566579.png\" alt=\"内存碎片化\"></p>\n<h4 id=\"5-2-2-1-使用栈和池子分配器来避免内存碎片化\"><a href=\"#5-2-2-1-使用栈和池子分配器来避免内存碎片化\" class=\"headerlink\" title=\"5.2.2.1 使用栈和池子分配器来避免内存碎片化\"></a>5.2.2.1 使用栈和池子分配器来避免内存碎片化</h4><ul>\n<li>栈分配器不受碎片影响，因为分配总是连续的，块的释放顺序必须与它们被分配的顺序相反。如图所示。</li>\n<li>池分配器也没有碎片问题。池会变成碎片化，但是碎片化不会像在一般用途的堆中那样造成内存不足的情况。池分配请求永远不会因为缺少足够大的连续空闲块而失败。因为所有的块大小都是一样的。如图所示。</li>\n</ul>\n<p><img src=\"/img/1602742636082.png\" alt=\"栈和池子分配器\"></p>\n<h4 id=\"5-2-2-2-碎片整理和重新安置\"><a href=\"#5-2-2-2-碎片整理和重新安置\" class=\"headerlink\" title=\"5.2.2.2 碎片整理和重新安置\"></a>5.2.2.2 碎片整理和重新安置</h4><ul>\n<li>当以随机顺序分配和释放不同大小的对象时，既不能使用基于堆栈的分配器，也不能使用基于池的分配器。在这种情况下，可以通过定期整理堆碎片来避免碎片。碎片整理涉及到通过将分配的块从较高的内存地址移到较低的地址(从而将洞移到较高的地址)来合并堆中的所有空闲“洞”。一个简单的算法是搜索第一个“洞”，然后立即将分配的区块移到holc的开始位置。这样做的效果是“冒泡”到一个更高的内存地址的洞。如果重复这个过程，最终所有分配的块将占据堆地址空间低端的一个连续的内存区域，而所有的洞将在堆的高端冒泡成一个大洞。如图5.7所示。</li>\n</ul>\n<p><img src=\"/img/1602742820576.png\" alt=\"图5.7\"></p>\n<ul>\n<li><ol>\n<li>交换内存块并不是最大的问题，问题是： 移动一个分配的内存块，将会导致某个指向此内存块的指针失效。</li>\n</ol>\n</li>\n<li><p>2.上面描述的内存块的移动并不是特别需要技巧来实现的。需要注意的是，我们正在移动分配的内存块。如果任何人有一个指针指向这些已分配的块中的一个，那么移动该块将使该指针失效这个问题的解决方案是修补任何和所有的指针到一个移位的内存块，使他们指向正确的新地址后，移位。这个过程称为指针重定位。不幸的是，没有通用的方法来查找指向内存某个特定区域的所有指针。所以如果我们要支持内存碎片整理我们的游戏引擎,程序员必须仔细手动跟踪所有的指针,这样他们就可以被重新安置,或指针必须放弃支持更加适合搬迁的事情,如智能指针或句柄。</p>\n<blockquote>\n<p>智能指针是一个包含指针的小类，它在大多数意图和目的中扮演指针的角色。但是因为智能指针是一个类，所以可以对它进行编码来正确地处理内存重定位。一种方法是安排所有智能指针将自己添加到一个全局链表中。每当在堆中移动一块内存时，就可以扫描所有智能指针的链表，并且可以适当地调整指向移位内存块的每个指针。</p>\n</blockquote>\n<blockquote>\n<p>句柄通常实现为不可重定位表的索引，表本身包含指针。当一个已分配的块在内存中移位时，可以扫描句柄表，自动找到并更新所有相关的指针。因为句柄只是指针表的索引，所以无论内存块如何移动，它们的值都不会改变，所以使用句柄的对象不会受到内存重定位的影响。</p>\n</blockquote>\n</li>\n<li><p>当某些内存块无法重新定位时，就会出现重新定位的另一个问题。例如，如果您使用的第三方库可以做到这一点2545. 引擎支持系统不使用智能指针或句柄，任何指向其数据结构的指针都有可能是不可重定位的。解决这个问题的最佳方法通常是安排相关库从可重定位内存区域外的一个特殊缓冲区分配内存。另一种选择是简单地接受某些块是不可重定位的。如果不可重定位块的数量和大小都很小，那么重定位系统仍然可以运行得很好</p>\n</li>\n<li><p>均摊碎片整理成本碎片整理可能是一个缓慢的操作，因为它涉及到复制内存块。但是，我们不需要一次对堆进行完全的碎片整理。相反，代价可以平摊到多个帧上。我们可以允许在每一帧中移动N个已分配的块，比如8或16。如果我们的游戏每秒运行30帧，那么每帧持续1/30秒(33毫秒)。因此，堆通常可以在不到一秒的时间内被完全整理，而不会对游戏的帧率产生任何明显的影响。只要分配和分配的速度没有比碎片整理的速度快，堆就会一直保持大部分碎片整理。</p>\n</li>\n<li><p>这种方法仅在每个块的大小相对较小时有效，以便移动单个块所需的时间不超过分配给重新定位每个帧的时间。如果需要重新定位非常大的块，我们通常可以将它们分成两个或更多的子块，每个子块都可以独立地重新定位。这在Naughty Dog的引擎中并没有被证明是一个问题，因为重新定位只用于动态游戏对象，而且它们永远不会比几个kibibytes大——而且通常要小得多。</p>\n</li>\n</ul>\n<h2 id=\"5-3-容器\"><a href=\"#5-3-容器\" class=\"headerlink\" title=\"(5.3) 容器\"></a>(5.3) 容器</h2><ul>\n<li>常用的容器：</li>\n<li>1.数组， 顺序存储结构，大小在编译时就固定了。</li>\n<li>2.动态数组， 运行时长度动态变化</li>\n<li>3.动态链表，顺序结构，但内存中存储地址不一定连续</li>\n<li>4.栈，LIFO，后进先出</li>\n<li>5.队列， FIFO， 先进先出</li>\n<li>6.双向队列，支持高效的插入与删除操作</li>\n<li>7.树，树型分组的结构，每个结点有0到1个父结点，和0到多个子结点。</li>\n<li>8.二叉搜索树 BST： 每个结点只能最多有两个子结点，同时有一定顺序结构可按一定规则排序。 例如有红黑树，AVL 树，splay 树等</li>\n<li>9.二叉堆，分为最大堆和最小堆。 必定满足完全二叉树，且有最大堆和最小堆的特性</li>\n<li>10.优先队列， 一直保持一种排序好的状态的队列。通常由堆来实现（std::priority_queue), 很少用list来实现。</li>\n<li>11.字典Dictionary， 键值对的存储容器， 也称为map, hash_table (std::map, std::hash_map)</li>\n<li>12.集合Set，以一定规则存储一系列不重复的项。 类似于没有value的字典</li>\n<li>13.图，集合里的结点互相连接，有向和无向。</li>\n<li>14.有向无环图(DAG)。具有单向(即定向)互连的节点集合，没有循环(即不存在从同一节点开始和结束的非空路径)。</li>\n</ul>\n<h3 id=\"5-3-1-容器的操作\"><a href=\"#5-3-1-容器的操作\" class=\"headerlink\" title=\"5.3.1 容器的操作\"></a>5.3.1 容器的操作</h3><ul>\n<li>插入</li>\n<li>删除</li>\n<li>顺序读取：以一些“自然”预先定义好的顺序访问</li>\n<li>随机存取：任意的顺序读取</li>\n<li>查找</li>\n<li>排序</li>\n</ul>\n<h3 id=\"5-3-2-迭代器\"><a href=\"#5-3-2-迭代器\" class=\"headerlink\" title=\"5.3.2 迭代器\"></a>5.3.2 迭代器</h3><ul>\n<li>迭代器是一个小类，它“知道”如何有效地访问特定类型容器中的元素。它的作用类似于数组索引或指针——它一次引用容器中的一个元素，它可以被推进到下一个元素，并且它提供了某种机制来测试容器中的所有元素是否都被访问了。例如，下面两个代码片段中的第一个使用指针在c样式数组上迭代，而第二个使用几乎相同的语法在STL链表上迭代。</li>\n</ul>\n<pre><code class=\"c++\">void processArray(int container[], int numElements)\n{\nint* pBegin = &amp;container[0];\nint* pEnd = &amp;container[numElements];\nfor (int* p = pBegin; p != pEnd; p++)\n{\nint element = *p;\n// process element...\n}\n}\nvoid processList(std::list&lt;int&gt;&amp; container)\n{\nstd::list&lt;int&gt;::iterator pBegin = container.begin();\nstd::list&lt;int&gt;::iterator pEnd = container.end();\nstd::list&lt;inf&gt;::iterator p;\nfor (p = pBegin; p != pEnd; p++)\n{\nint element = *p;\n// process element...\n}\n}\n</code></pre>\n<blockquote>\n<p>使用迭代器的好处<br>直接访问会破坏容器类的封装。另一方面，迭代器通常是容器类的朋友，因此它可以高效地迭代，而不向外界公开任何实现细节。(事实上，大多数好的容器类都隐藏其内部的实现，如果不用迭代器将无法遍历。)<br>迭代器可以简化迭代过程。大多数迭代器的作用类似于数组索引或指针，因此可以编写一个简单的循环，其中5. 引擎支持系统迭代器递增，并与终止条件进行比较，即使底层数据结构是任意复杂的。例如，迭代器可以使按顺序深度优先的树遍历看起来并不比简单的数组迭代复杂。</p>\n</blockquote>\n<h4 id=\"5-3-2-1-前增量与后增量\"><a href=\"#5-3-2-1-前增量与后增量\" class=\"headerlink\" title=\"5.3.2.1 前增量与后增量\"></a>5.3.2.1 前增量与后增量</h4><ul>\n<li>注意，在上面的示例中，我们使用的是c++的后增量运算符，而不是前增量运算符，++p。这是一个微妙但有时很重要的优化。在表达式中使用变量(现在已修改)的值之前，preincrement操作符递增变量的内容。后增量运算符在变量被使用后对其内容进行增量。这意味着编写++p会在代码中引入一个数据依赖项——CPU必须等待增量操作完成后，它的值才能在表达式中使用。在深度流水线化的CPU上，这将导致停机。另一方面，使用p++没有数据依赖性。变量的值可以立即使用，而递增操作可以稍后进行，也可以在使用它的同时进行。无论哪种方式，都不会在管道中出现失速。当然，在for循环的“update”表达式中(for(init_expr;test_expr;update_expr){…})，前后增量之间不应该有区别。这是因为任何好的编译器都能识别出update_expr中没有使用变量的值。但是在使用该值的情况下，后增量更优，因为它不会在CPU的管道中引入停顿。因此，养成使用后增量的aluays的习惯是很好的，除非您绝对需要前增量的语义。</li>\n</ul>\n<h3 id=\"5-3-3-算法复杂度\"><a href=\"#5-3-3-算法复杂度\" class=\"headerlink\" title=\"5.3.3 算法复杂度\"></a>5.3.3 算法复杂度</h3><ul>\n<li><p>算法的顺序通常可以通过检查伪代码来确定。如果算法的执行时间完全不依赖于容器中元素的数量，我们就说它是O(1)(也就是说，它在常量时间内完成)。如果算法在容器中的元素上执行一个循环，并访问每个元素一次，比如在对未排序列表进行线性搜索时，我们称该算法为O(n)。如果两个循环是嵌套的，每个循环都可能访问每个节点一次，那么我们说算法是O(n2)。如果使用“分而治之”的方法,在一个二叉搜索(其中一半的列表是消除每一步),然后我们只能期望| log2 (n) + 1元素会被访问的算法在最坏的情况下,因此我们称它为O (logn)操作。如果一个算法执行一个子算法n次，且子算法为O(log n)，则生成的算法将是O (nlogn)。</p>\n</li>\n<li><p>我们还应该考虑容器的内存布局和使用特性。例如，一个数组(例如int a[5]或std:: vector)在内存中连续存储它的元素，除了元素本身之外不需要额外的存储开销。(注意，动态数组确实需要一个小的固定开销。)另一方面,一个链表(例如,std:: list)包裹在“链接”的数据结构,每个元素也可能包含一个指针指向下一个元素和一个指向前一个元素,总共16字节的开销64位机器上的每个元素。此外，链表中的元素在内存中不需要是连续的，而且通常不是。一个连续的内存块通常比一组不同的内存块对缓存更友好。因此，对于高速算法，数组在缓存性能方面通常比链表更好(除非链表的节点本身就是从数组中分配的)2605. 引擎支持系统一个小的、连续的内存块)。但是链表更适合插入和删除元素的速度最重要的情况</p>\n</li>\n</ul>\n<h3 id=\"5-3-4-创建自定义的容器类\"><a href=\"#5-3-4-创建自定义的容器类\" class=\"headerlink\" title=\"5.3.4 创建自定义的容器类\"></a>5.3.4 创建自定义的容器类</h3><ul>\n<li>许多游戏引擎都提供了它们自己的通用容器数据结构的自定义实现。这种做法在主机游戏引擎和针对移动电话和PDA平台的游戏中尤其普遍。自己构建这些类的原因包括:</li>\n<li>总控制。您可以控制数据结构的内存需求、使用的算法、何时以及如何分配内存等。</li>\n<li>优化的机会。您可以优化数据结构和算法，以利用特定于目标控制台的硬件特性;或者针对引擎中的特定应用程序对它们进行微调。</li>\n<li>可定制性。您可以提供在第三方库(如STL)中不常见的自定义算法(例如，搜索容器中n个最相关的元素，而不是只搜索一个最相关的元素)。</li>\n<li>消除外部依赖。由于软件是您自己构建的，所以您不需要任何其他公司或团队来维护它。如果出现问题，可以立即进行调试和修复，而不是等到库的下一个发行版(可能要等到你的游戏发行之后!)并发数据结构的控制。当您编写自己的容器类时，您可以完全控制在多线程或多核系统上保护它们不受并发访问的方法。例如，在PS4上，Naughty Dog为我们的大多数并发数据结构使用了轻量级的“旋转锁”互斥锁，因为它们在我们基于光纤的作业调度系统中工作得很好。第三方容器库可能无法提供这种灵活性</li>\n</ul>\n<p>我们不能在这里涵盖所有可能的数据结构，但是让我们看看游戏引擎程序员处理容器的几种常见方法。</p>\n<h4 id=\"5-3-4-1-To-Build-or-Not-to-Build\"><a href=\"#5-3-4-1-To-Build-or-Not-to-Build\" class=\"headerlink\" title=\"5.3.4.1 To Build or Not to Build\"></a>5.3.4.1 To Build or Not to Build</h4><ul>\n<li>作为游戏引擎设计师，我们有以下几种选择:</li>\n<li><ol>\n<li>手动构建所需的数据结构</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>依赖于第三方实现。一些常见的选择包括a. c++标准模板库(STL)b. STL的一种变体，如STLportc.强大而健壮的Boost库(<a href=\"http://www.boost.org)。STL和Boost都很有吸引力，因为它们提供了一组丰富而强大的容器类，涵盖了几乎所有可以想象到的数据结构类型。此外，这两个包都提供了一套功能强大的基于模板的通用算法——常见算法的实现，例如查找容器中的元素，这些算法可以应用于几乎任何类型的数据对象。然而，像这样的第三方软件包可能不适合somc类游戏cngincs。即使我们决定使用第三方包，我们也必须在Boost和各种风格的STL或其他第三方库之间进行选择。因此，让我们花一点时间来研究每种方法的优缺点。\">http://www.boost.org)。STL和Boost都很有吸引力，因为它们提供了一组丰富而强大的容器类，涵盖了几乎所有可以想象到的数据结构类型。此外，这两个包都提供了一套功能强大的基于模板的通用算法——常见算法的实现，例如查找容器中的元素，这些算法可以应用于几乎任何类型的数据对象。然而，像这样的第三方软件包可能不适合somc类游戏cngincs。即使我们决定使用第三方包，我们也必须在Boost和各种风格的STL或其他第三方库之间进行选择。因此，让我们花一点时间来研究每种方法的优缺点。</a></li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>STL:<br>Stl标准模板库的好处包括:</p>\n<ul>\n<li>STL提供了一组丰富的特性。</li>\n<li>相当健壮的实现可以在各种各样的平台上使用。</li>\n<li>STL是几乎所有c++编译器的“标准”。<br>然而，STL也有很多缺点，包括:</li>\n<li>STL有一个陡峭的学习曲线。文档现在已经很好了，但是头文件在大多数平台上都很晦涩，很难理解。</li>\n<li>STL通常比专门针对特定问题设计的数据结构要慢。</li>\n<li>STL几乎总是比定制设计的数据结构消耗更多的内存。</li>\n<li>STL需要进行大量的动态内存分配，有时要以适合高性能、内存有限的控制台游戏的方式控制它对内存的需求是一项挑战</li>\n<li>STL的实现和行为在不同的编译器之间略有不同，这使得它在多平台引擎中的使用更加困难。</li>\n</ul>\n</blockquote>\n<p>因为现代pc上的高级虚拟内存系统使内存分配更便宜，而且耗尽物理RAM的可能性往往可以忽略不计。另一方面，STL通常不适合在内存有限、缺乏高级cpu和虚拟内存的控制台上使用。使用STL的代码可能不容易移植到其他平台。</p>\n<blockquote>\n<p>以下是我使用的一些经验法则:</p>\n<ul>\n<li>首先，也最重要的是，要了解您正在使用的特定STL类的性能和内存特征</li>\n<li>尽量避免在您认为会成为性能瓶颈的代码中使用重的STL类。</li>\n<li>在内存不是很重要的情况下，选择STL。举例来说，在游戏对象中嵌入std:: list是可以的，但是在3D网格的每个顶点中嵌入std:: list可能不是一个好主意。将3D网格的每个顶点添加到std::list可能也不行——std::list类会动态地为插入其中的每个元素分配一个小的“link”对象，这可能会导致大量微小的、碎片化的内存分配</li>\n<li>如果您的引擎是多平台的，我强烈推荐STLport (<a href=\"http://www.stlport.org)，这是一种STL实现，专门设计用于跨广泛的编译器和目标平台移植，比原始的STI\">http://www.stlport.org)，这是一种STL实现，专门设计用于跨广泛的编译器和目标平台移植，比原始的STI</a> mplementations更高效、功能更丰富。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Boost:<br>Boost项目是由c++标准委员会库工作组的成员发起的，但是现在它是一个开源项目，有许多来自世界各地的贡献者。该项目的目标是生成扩展STL并与之协同工作的库，用于商业和其他用途5.3。容器263非商业用途。许多Boost库已经包含在c++标准委员会的库技术报告(TR1)中，这是迈向成为未来c++标准的一部分的一步。<br>以下是Boost带来的好处的简要总结:<br>Boost提供了许多在STL中不可用的有用工具<br>在某些情况下，Boost提供了解决STL设计或实现中的某些问题的备选方案<br>Boost在处理一些非常复杂的问题(如智能指针)方面做得很好。(请记住，智能指针是复杂的东西，它们可能会影响性能。手柄通常更好;详见15.5节。)<br>Boost库的文档通常都很出色。文档不仅解释了每个库做什么以及如何使用它，而且在大多数情况下，它还对设计决策、约束和组合库的需求提供了极好的深入讨论。因此，阅读Boost文档是了解软件设计原理的好方法。</p>\n</blockquote>\n<blockquote>\n<p>如果您已经在使用STL，那么Boost可以作为许多STL特性的优秀扩展和/或替代品。<br>不过，请注意下列注意事项:<br>大多数核心Boost类都是模板，因此使用它们所需要的只是一组适当的头文件。然而，一些Boost库构建到相当大的.lib文件中，可能不适合在非常小的游戏项目中使用。<br>虽然全球Boost社区是一个优秀的支持网络，但是Boost库并没有得到保证。如果您遇到一个bug，解决它或修复它最终将是您的团队的责任。<br>Boost库是在Boost软件许可下发布的。阅读许可信息(<a href=\"http://www.boost.org/more/license\">http://www.boost.org/more/license</a> info)。小心地确保它适合您的引擎。</p>\n</blockquote>\n<blockquote>\n<p>Loki<br>C++的模板元编程<br>到目前为止，最著名的、可能也是最强大的c++模板元编程库是Loki，它是由Andrei Alexandrescu设计和编写的(其主页在<a href=\"http://www.erdani.org)。该库可以从SourceForge获得，网址是[Loki](http://loki-lib.sourceforge.net)。Loki非常强大;这是一组令人着迷的代码，值得研究和学习。然而,它的两大弱点的实际性质:(a)的代码可以令人生畏的阅读和使用,更少的真正理解,(b)它的一些组件依赖于利用“side-effect”\">http://www.erdani.org)。该库可以从SourceForge获得，网址是[Loki](http://loki-lib.sourceforge.net)。Loki非常强大;这是一组令人着迷的代码，值得研究和学习。然而,它的两大弱点的实际性质:(a)的代码可以令人生畏的阅读和使用,更少的真正理解,(b)它的一些组件依赖于利用“side-effect”</a> 的编译器Behaviours,需要小心仔细自定义以便在新的编译器上运行。因此，Loki使用起来有些困难，而且它的可移植性不如一些“不那么极端”的同类产品。洛基不适合胆小的人。也就是说，一些Loki的概念(如基于策略的编程)可以应用到任何c++项目中，即使您没有使用Loki library本身。我强烈推荐所有的软件工程师阅读Andrei开创性的书，现代c++设计[2]，Loki库就是从这本书诞生的。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"5-引擎的支持系统\"><a href=\"#5-引擎的支持系统\" class=\"headerlink\" title=\"5 引擎的支持系统\"></a>5 引擎的支持系统</h1><h2 id=\"5-1-子系统的启动与关闭\"><a href=\"#5-1-子系统的启动与关闭\" class=\"headerlink\" title=\"(5.1) 子系统的启动与关闭\"></a>(5.1) 子系统的启动与关闭</h2><p>游戏引擎由若干子系统组成，在启动时如果系统间有相互依赖，同销毁时的顺序也需要按要求。如B系统依赖A，则A需要先启动再启动B，销毁时则是B先销毁再销毁A。</p>\n<h4 id=\"处理各子系统启动关闭的方式\"><a href=\"#处理各子系统启动关闭的方式\" class=\"headerlink\" title=\"处理各子系统启动关闭的方式\"></a>处理各子系统启动关闭的方式</h4><ul>\n<li><ol>\n<li>单例模式： 第一次使用时，构造函数中初始化所依赖的其他子系统</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>【推荐】使用另一个管理器，统一管理所有的子系统启动与关闭。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-2-内存管理\"><a href=\"#5-2-内存管理\" class=\"headerlink\" title=\"(5.2) 内存管理\"></a>(5.2) 内存管理</h2><p>内存影响性能的两个方面：</p>\n<ol>\n<li>动态内存分配 ：malloc或new。将比较低效，可以避免一次性分配 </li>\n<li>CPU内存的高效性与普通大内存</li>\n</ol>\n<h3 id=\"5-2-1-优化动态内存分配\"><a href=\"#5-2-1-优化动态内存分配\" class=\"headerlink\" title=\"5.2.1 优化动态内存分配\"></a>5.2.1 优化动态内存分配</h3><p>规则： Keep heap allocations to a minimum, and never allocate from the heap within a tight loop.</p>\n<p>效率低下的原因： 1. 堆分配器的管理消耗。 2. 大部分操作系统free()函数调用需要切换模式。（用户切到内存，再切回来）<br>保证越少分配越好，从不要在update中申请堆内存。</p>\n<h5 id=\"5-2-1-1-自定义动态内存分配器\"><a href=\"#5-2-1-1-自定义动态内存分配器\" class=\"headerlink\" title=\"5.2.1.1 自定义动态内存分配器\"></a>5.2.1.1 自定义动态内存分配器</h5><ol>\n<li><p>Stack -Based Allocators 以栈为基础的分配器</p>\n<ul>\n<li><p>许多游戏以类似栈的方式分配内存。每当一个新的游戏关卡被加载时，内存就会被分配给它。一旦加载了该级别，就很少或不进行动态内存分配。在这一层的最后，它的数据被卸载，它的所有内存可以被释放。对于这些类型的内存分配，使用类似栈的数据结构是很有意义的。</p>\n</li>\n<li><p>栈分配器是非常容易实现的。我们简单地使用malloc()或global new分配一个大的连续内存块，或者通过声明一个全局字节数组(在这种情况下，内存是从可执行文件的BSS段中有效分配的)。维护一个指向栈顶部的指针，这个指针下面的所有内存地址被认为是在使用中，而它上面的所有地址被认为是空闲的。顶端指针被初始化为栈中最低的内存地址。每个分配请求只是将指针按请求的字节数向上移动。只需将顶部指针按blockIt的大小向后移动，就可以释放最近分配的块。</p>\n</li>\n<li><p>要意识到，对于栈分配器，内存不能以任意顺序释放。所有释放必须按照与分配它们相反的顺序执行。执行这些限制的一种简单方法是根本不允许释放单个块。替代的方案就是,我们可以提供一个函数栈顶部回滚之前标记位置,从而释放之间的所有块当前最高和回滚位置。</p>\n</li>\n<li><p>非常重要的一点是，要总是将顶部指针回滚到两个分配好的内存块中间,否则新分配将覆盖最顶部的块的末端。为了确保正确地执行此操作，堆栈分配器通常提供一个函数，该函数返回表示堆栈当前顶部的标记。回滚函数然后将这些标记中的一个作为其参数。如图所示。栈分配器的接口通常看起来像这样。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/img/1599634350864.png\" alt=\"栈分配器的回收\"></p>\n<blockquote>\n<p>Double ended stack allocator 双端栈分配器</p>\n</blockquote>\n<ul>\n<li>单个内存块实际上可以包含两个栈分配器——一个从块的底部向上分配，另一个从块的顶部向下分配。双端栈分配器很有用，因为它允许在底层栈的内存使用和顶层栈的内存使用之间进行权衡，从而更有效地使用内存。在某些情况下，两个栈可能使用大致相同的内存，并在块的中间相遇。在其他情况下，两个栈中的一个可能会比另一个栈消耗更多的内存，但是只要请求的内存总量不大于两个栈共享的内存块，所有分配请求仍然可以得到满足。<br><img src=\"/img/1599634811580.png\" alt=\"双端栈分配器\"></li>\n</ul>\n<ol start=\"2\">\n<li><p>池子为基础的分配器： Pool Allocators</p>\n<ul>\n<li>预先申请一块大的内容，将元素放在一个链表结构上。</li>\n<li>初始时池子里链表空闲位是满的，当使用一个时，获取最后一个空闲位。当使用完成时，将其放回链表。分配和释放都是O(1)的消耗。</li>\n<li>链表设计时应注意使用指针指向 下一个空闲的内存块，而不是预先申请一个大的内存。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-2-1-2-对齐分配\"><a href=\"#5-2-1-2-对齐分配\" class=\"headerlink\" title=\"5.2.1.2 对齐分配\"></a>5.2.1.2 对齐分配</h4><ul>\n<li><p>在大多数实现中，分配的额外字节数等于对齐。例如，如果请求的是一个16字节对齐的内存块，我们将分配额外的16个字节。这允许最坏情况下15个字节的地址调整，加上一个额外的字节，这样即使原始块已经对齐，我们也可以使用相同的计算。这样可以简化和加速代码，但每次分配都会浪费一个字节。它还很重要，因为我们将在下面看到，我们将需要这些额外的字节来存储将在块释放时使用的一些额外信息</p>\n</li>\n<li><p>我们通过屏蔽原始块内存地址的最不重要的位，从期望的对齐中减去这个位，并使用结果作为调整偏移量来确定必须调整的块地址的数量。对齐应该始终是两个字节(典型的是4字节和16字节对齐)，因此要生成掩码，只需从对齐中减去一个。例如，如果请求的是一个16字节对齐的块，那么掩码将是(16-1)= 15= 0x0000000F。使用这个掩码的按位和和任何未对齐的地址将产生该地址未对齐的数量。例如，如果最初分配的块的地址是0x50341233，那么该地址与掩码0x0000000F共vields x00000000，因此该地址错对齐了三个字节。为了对齐地址，我们向它添加(对齐-不对齐)-(16-3)-13- oxd字节。因此最终对齐的地址是0x50341233 + 0xD= 0x50341240</p>\n</li>\n</ul>\n<blockquote>\n<p>对齐内存分配器实现示例：<br><img src=\"/img/1602736304626.png\" alt=\"对齐内存分配器实现示例\"></p>\n</blockquote>\n<ul>\n<li><p>当这个块稍后被释放时，代码将传递给我们调整后的地址，而不是我们分配的原始地址。那么，我们如何释放内存呢?我们需要一些方法将调整后的地址转换回原始的，可能是不对齐的地址。</p>\n</li>\n<li><p>为此，我们只需在分配的额外字节中存储一些元信息，以便首先对数据进行对齐。我们可能做的最小调整是一个字节。这样就有足够的空间来存储调整地址所使用的字节数(因为它永远不会超过字节数256)。我们总是将此信息存储在调整后的地址之前的字节中(无论我们实际添加了多少字节的调整)，因此，给定调整后的地址，再次查找它是很容易的。这里的。修改后的allocateAligned()函数的外观。分配和释放对齐块的过程如Fiqure 5.3。</p>\n</li>\n</ul>\n<p><img src=\"/img/1602736411263.png\" alt=\"分配和释放对齐块过程\"></p>\n<blockquote>\n<p><img src=\"/img/1602736500822.png\" alt=\"Fiqure 5.3\"> 。<br>要求16字节对齐的对齐内存分配。分配的内存地址和调整的(对齐的)地址之间的差异存储在调整地址之前的字节中，以便在空闲时可以检索。</p>\n</blockquote>\n<h4 id=\"5-2-1-3-单帧和双缓冲内存分配器\"><a href=\"#5-2-1-3-单帧和双缓冲内存分配器\" class=\"headerlink\" title=\"5.2.1.3 单帧和双缓冲内存分配器\"></a>5.2.1.3 单帧和双缓冲内存分配器</h4><ul>\n<li><p>实际上，所有的游戏引擎在游戏循环期间都至少分配一些临时数据。该数据在循环的每次迭代结束时丢弃2485. 引擎支持系统或用于下一帧，然后丢弃。这种分配模式非常常见，许多引擎都支持单帧和双缓冲的分配器。</p>\n</li>\n<li><p>单帧分配器: 通过保留一块内存并使用上面描述的简单堆栈分配器来管理它来实现的。在每一帧的开始，堆栈的“顶部”指针被清除到内存块的底部。随着帧数增长，不断往顶部分配。清洗和重复的方法。</p>\n</li>\n<li><p>单帧分配器的主要好处之一是，分配的内存不需要占用——我们可以依赖这样一个事实，即分配器将在每一帧开始时被清除。单帧分配器也非常快。最大的缺点是，使用单帧分配器需要程序员有合理的纪律。您需要认识到，从单帧缓冲区分配的内存块只在当前帧期间有效。程序员绝对不能跨帧边界缓存一个指向单帧内存块的指针!</p>\n</li>\n<li><p>双缓冲分配器：允许在 frame(i)上分配的内存块在frame(i+1)上使用。为此，我们创建了两个大小相同的单帧堆栈分配器，然后每帧都在它们之间来回移动.</p>\n</li>\n<li><p>这种分配器对于缓存多核游戏控制台异步处理的结果非常有用，比如Xbox 360、Xbox One PlayStation 3或PlayStation 4。在帧i上，我们可以在PS3的一个spu上启动异步作业，例如，将从双缓冲分配器分配的目标缓冲区的地址交给它。作业在第i帧结束之前运行并产生结果，并将它们存储到我们提供的缓冲区中。在帧(i+ 1)，缓冲区被交换。作业的结果现在在非活动缓冲区中，因此它们不会被此帧期间可能进行的任何双缓冲分配覆盖。只要我们使用帧(i + 2)之前的作业结果，我们的数据就不会被覆盖</p>\n</li>\n</ul>\n<h3 id=\"5-2-2-内存碎片化\"><a href=\"#5-2-2-内存碎片化\" class=\"headerlink\" title=\"5.2.2 内存碎片化\"></a>5.2.2 内存碎片化</h3><ul>\n<li><p>内存碎片的问题是，即使有足够的空闲字节来满足请求，分配也可能失败。问题的关键是分配的内存块必须始终是连续的。例如，为了满足一个128 KiB的请求，必须存在一个128 KiB或更大的空闲“洞”。如果有两个孔，每个孔的大小为64 KiB，那么就有足够的字节可用，但分配失败，因为它们不是连续的字节。</p>\n</li>\n<li><p>对于支持虚拟内存的操作系统来说，内存碎片并不是一个大问题。虚拟内存系统将称为页面的不连续的物理内存块映射到虚拟地址空间中，其中的页面在应用程序看来是连续的。当物理内存不足时，可以将陈旧的页面交换到硬盘，并在需要时从磁盘重新加载。有关虚拟内存如何工作的详细讨论，请参阅<a href=\"http://en.wikipedia.org/wiki/Virtual\">http://en.wikipedia.org/wiki/Virtual</a> memory。大多数嵌入式系统无法实现虚拟内存系统。虽然一些现代的主机确实在技术上支持虚拟内存，但由于固有的性能开销，大多数主机游戏引擎仍然不使用虚拟内存。</p>\n</li>\n</ul>\n<p><img src=\"/img/1602742566579.png\" alt=\"内存碎片化\"></p>\n<h4 id=\"5-2-2-1-使用栈和池子分配器来避免内存碎片化\"><a href=\"#5-2-2-1-使用栈和池子分配器来避免内存碎片化\" class=\"headerlink\" title=\"5.2.2.1 使用栈和池子分配器来避免内存碎片化\"></a>5.2.2.1 使用栈和池子分配器来避免内存碎片化</h4><ul>\n<li>栈分配器不受碎片影响，因为分配总是连续的，块的释放顺序必须与它们被分配的顺序相反。如图所示。</li>\n<li>池分配器也没有碎片问题。池会变成碎片化，但是碎片化不会像在一般用途的堆中那样造成内存不足的情况。池分配请求永远不会因为缺少足够大的连续空闲块而失败。因为所有的块大小都是一样的。如图所示。</li>\n</ul>\n<p><img src=\"/img/1602742636082.png\" alt=\"栈和池子分配器\"></p>\n<h4 id=\"5-2-2-2-碎片整理和重新安置\"><a href=\"#5-2-2-2-碎片整理和重新安置\" class=\"headerlink\" title=\"5.2.2.2 碎片整理和重新安置\"></a>5.2.2.2 碎片整理和重新安置</h4><ul>\n<li>当以随机顺序分配和释放不同大小的对象时，既不能使用基于堆栈的分配器，也不能使用基于池的分配器。在这种情况下，可以通过定期整理堆碎片来避免碎片。碎片整理涉及到通过将分配的块从较高的内存地址移到较低的地址(从而将洞移到较高的地址)来合并堆中的所有空闲“洞”。一个简单的算法是搜索第一个“洞”，然后立即将分配的区块移到holc的开始位置。这样做的效果是“冒泡”到一个更高的内存地址的洞。如果重复这个过程，最终所有分配的块将占据堆地址空间低端的一个连续的内存区域，而所有的洞将在堆的高端冒泡成一个大洞。如图5.7所示。</li>\n</ul>\n<p><img src=\"/img/1602742820576.png\" alt=\"图5.7\"></p>\n<ul>\n<li><ol>\n<li>交换内存块并不是最大的问题，问题是： 移动一个分配的内存块，将会导致某个指向此内存块的指针失效。</li>\n</ol>\n</li>\n<li><p>2.上面描述的内存块的移动并不是特别需要技巧来实现的。需要注意的是，我们正在移动分配的内存块。如果任何人有一个指针指向这些已分配的块中的一个，那么移动该块将使该指针失效这个问题的解决方案是修补任何和所有的指针到一个移位的内存块，使他们指向正确的新地址后，移位。这个过程称为指针重定位。不幸的是，没有通用的方法来查找指向内存某个特定区域的所有指针。所以如果我们要支持内存碎片整理我们的游戏引擎,程序员必须仔细手动跟踪所有的指针,这样他们就可以被重新安置,或指针必须放弃支持更加适合搬迁的事情,如智能指针或句柄。</p>\n<blockquote>\n<p>智能指针是一个包含指针的小类，它在大多数意图和目的中扮演指针的角色。但是因为智能指针是一个类，所以可以对它进行编码来正确地处理内存重定位。一种方法是安排所有智能指针将自己添加到一个全局链表中。每当在堆中移动一块内存时，就可以扫描所有智能指针的链表，并且可以适当地调整指向移位内存块的每个指针。</p>\n</blockquote>\n<blockquote>\n<p>句柄通常实现为不可重定位表的索引，表本身包含指针。当一个已分配的块在内存中移位时，可以扫描句柄表，自动找到并更新所有相关的指针。因为句柄只是指针表的索引，所以无论内存块如何移动，它们的值都不会改变，所以使用句柄的对象不会受到内存重定位的影响。</p>\n</blockquote>\n</li>\n<li><p>当某些内存块无法重新定位时，就会出现重新定位的另一个问题。例如，如果您使用的第三方库可以做到这一点2545. 引擎支持系统不使用智能指针或句柄，任何指向其数据结构的指针都有可能是不可重定位的。解决这个问题的最佳方法通常是安排相关库从可重定位内存区域外的一个特殊缓冲区分配内存。另一种选择是简单地接受某些块是不可重定位的。如果不可重定位块的数量和大小都很小，那么重定位系统仍然可以运行得很好</p>\n</li>\n<li><p>均摊碎片整理成本碎片整理可能是一个缓慢的操作，因为它涉及到复制内存块。但是，我们不需要一次对堆进行完全的碎片整理。相反，代价可以平摊到多个帧上。我们可以允许在每一帧中移动N个已分配的块，比如8或16。如果我们的游戏每秒运行30帧，那么每帧持续1/30秒(33毫秒)。因此，堆通常可以在不到一秒的时间内被完全整理，而不会对游戏的帧率产生任何明显的影响。只要分配和分配的速度没有比碎片整理的速度快，堆就会一直保持大部分碎片整理。</p>\n</li>\n<li><p>这种方法仅在每个块的大小相对较小时有效，以便移动单个块所需的时间不超过分配给重新定位每个帧的时间。如果需要重新定位非常大的块，我们通常可以将它们分成两个或更多的子块，每个子块都可以独立地重新定位。这在Naughty Dog的引擎中并没有被证明是一个问题，因为重新定位只用于动态游戏对象，而且它们永远不会比几个kibibytes大——而且通常要小得多。</p>\n</li>\n</ul>\n<h2 id=\"5-3-容器\"><a href=\"#5-3-容器\" class=\"headerlink\" title=\"(5.3) 容器\"></a>(5.3) 容器</h2><ul>\n<li>常用的容器：</li>\n<li>1.数组， 顺序存储结构，大小在编译时就固定了。</li>\n<li>2.动态数组， 运行时长度动态变化</li>\n<li>3.动态链表，顺序结构，但内存中存储地址不一定连续</li>\n<li>4.栈，LIFO，后进先出</li>\n<li>5.队列， FIFO， 先进先出</li>\n<li>6.双向队列，支持高效的插入与删除操作</li>\n<li>7.树，树型分组的结构，每个结点有0到1个父结点，和0到多个子结点。</li>\n<li>8.二叉搜索树 BST： 每个结点只能最多有两个子结点，同时有一定顺序结构可按一定规则排序。 例如有红黑树，AVL 树，splay 树等</li>\n<li>9.二叉堆，分为最大堆和最小堆。 必定满足完全二叉树，且有最大堆和最小堆的特性</li>\n<li>10.优先队列， 一直保持一种排序好的状态的队列。通常由堆来实现（std::priority_queue), 很少用list来实现。</li>\n<li>11.字典Dictionary， 键值对的存储容器， 也称为map, hash_table (std::map, std::hash_map)</li>\n<li>12.集合Set，以一定规则存储一系列不重复的项。 类似于没有value的字典</li>\n<li>13.图，集合里的结点互相连接，有向和无向。</li>\n<li>14.有向无环图(DAG)。具有单向(即定向)互连的节点集合，没有循环(即不存在从同一节点开始和结束的非空路径)。</li>\n</ul>\n<h3 id=\"5-3-1-容器的操作\"><a href=\"#5-3-1-容器的操作\" class=\"headerlink\" title=\"5.3.1 容器的操作\"></a>5.3.1 容器的操作</h3><ul>\n<li>插入</li>\n<li>删除</li>\n<li>顺序读取：以一些“自然”预先定义好的顺序访问</li>\n<li>随机存取：任意的顺序读取</li>\n<li>查找</li>\n<li>排序</li>\n</ul>\n<h3 id=\"5-3-2-迭代器\"><a href=\"#5-3-2-迭代器\" class=\"headerlink\" title=\"5.3.2 迭代器\"></a>5.3.2 迭代器</h3><ul>\n<li>迭代器是一个小类，它“知道”如何有效地访问特定类型容器中的元素。它的作用类似于数组索引或指针——它一次引用容器中的一个元素，它可以被推进到下一个元素，并且它提供了某种机制来测试容器中的所有元素是否都被访问了。例如，下面两个代码片段中的第一个使用指针在c样式数组上迭代，而第二个使用几乎相同的语法在STL链表上迭代。</li>\n</ul>\n<pre><code class=\"c++\">void processArray(int container[], int numElements)\n{\nint* pBegin = &amp;container[0];\nint* pEnd = &amp;container[numElements];\nfor (int* p = pBegin; p != pEnd; p++)\n{\nint element = *p;\n// process element...\n}\n}\nvoid processList(std::list&lt;int&gt;&amp; container)\n{\nstd::list&lt;int&gt;::iterator pBegin = container.begin();\nstd::list&lt;int&gt;::iterator pEnd = container.end();\nstd::list&lt;inf&gt;::iterator p;\nfor (p = pBegin; p != pEnd; p++)\n{\nint element = *p;\n// process element...\n}\n}\n</code></pre>\n<blockquote>\n<p>使用迭代器的好处<br>直接访问会破坏容器类的封装。另一方面，迭代器通常是容器类的朋友，因此它可以高效地迭代，而不向外界公开任何实现细节。(事实上，大多数好的容器类都隐藏其内部的实现，如果不用迭代器将无法遍历。)<br>迭代器可以简化迭代过程。大多数迭代器的作用类似于数组索引或指针，因此可以编写一个简单的循环，其中5. 引擎支持系统迭代器递增，并与终止条件进行比较，即使底层数据结构是任意复杂的。例如，迭代器可以使按顺序深度优先的树遍历看起来并不比简单的数组迭代复杂。</p>\n</blockquote>\n<h4 id=\"5-3-2-1-前增量与后增量\"><a href=\"#5-3-2-1-前增量与后增量\" class=\"headerlink\" title=\"5.3.2.1 前增量与后增量\"></a>5.3.2.1 前增量与后增量</h4><ul>\n<li>注意，在上面的示例中，我们使用的是c++的后增量运算符，而不是前增量运算符，++p。这是一个微妙但有时很重要的优化。在表达式中使用变量(现在已修改)的值之前，preincrement操作符递增变量的内容。后增量运算符在变量被使用后对其内容进行增量。这意味着编写++p会在代码中引入一个数据依赖项——CPU必须等待增量操作完成后，它的值才能在表达式中使用。在深度流水线化的CPU上，这将导致停机。另一方面，使用p++没有数据依赖性。变量的值可以立即使用，而递增操作可以稍后进行，也可以在使用它的同时进行。无论哪种方式，都不会在管道中出现失速。当然，在for循环的“update”表达式中(for(init_expr;test_expr;update_expr){…})，前后增量之间不应该有区别。这是因为任何好的编译器都能识别出update_expr中没有使用变量的值。但是在使用该值的情况下，后增量更优，因为它不会在CPU的管道中引入停顿。因此，养成使用后增量的aluays的习惯是很好的，除非您绝对需要前增量的语义。</li>\n</ul>\n<h3 id=\"5-3-3-算法复杂度\"><a href=\"#5-3-3-算法复杂度\" class=\"headerlink\" title=\"5.3.3 算法复杂度\"></a>5.3.3 算法复杂度</h3><ul>\n<li><p>算法的顺序通常可以通过检查伪代码来确定。如果算法的执行时间完全不依赖于容器中元素的数量，我们就说它是O(1)(也就是说，它在常量时间内完成)。如果算法在容器中的元素上执行一个循环，并访问每个元素一次，比如在对未排序列表进行线性搜索时，我们称该算法为O(n)。如果两个循环是嵌套的，每个循环都可能访问每个节点一次，那么我们说算法是O(n2)。如果使用“分而治之”的方法,在一个二叉搜索(其中一半的列表是消除每一步),然后我们只能期望| log2 (n) + 1元素会被访问的算法在最坏的情况下,因此我们称它为O (logn)操作。如果一个算法执行一个子算法n次，且子算法为O(log n)，则生成的算法将是O (nlogn)。</p>\n</li>\n<li><p>我们还应该考虑容器的内存布局和使用特性。例如，一个数组(例如int a[5]或std:: vector)在内存中连续存储它的元素，除了元素本身之外不需要额外的存储开销。(注意，动态数组确实需要一个小的固定开销。)另一方面,一个链表(例如,std:: list)包裹在“链接”的数据结构,每个元素也可能包含一个指针指向下一个元素和一个指向前一个元素,总共16字节的开销64位机器上的每个元素。此外，链表中的元素在内存中不需要是连续的，而且通常不是。一个连续的内存块通常比一组不同的内存块对缓存更友好。因此，对于高速算法，数组在缓存性能方面通常比链表更好(除非链表的节点本身就是从数组中分配的)2605. 引擎支持系统一个小的、连续的内存块)。但是链表更适合插入和删除元素的速度最重要的情况</p>\n</li>\n</ul>\n<h3 id=\"5-3-4-创建自定义的容器类\"><a href=\"#5-3-4-创建自定义的容器类\" class=\"headerlink\" title=\"5.3.4 创建自定义的容器类\"></a>5.3.4 创建自定义的容器类</h3><ul>\n<li>许多游戏引擎都提供了它们自己的通用容器数据结构的自定义实现。这种做法在主机游戏引擎和针对移动电话和PDA平台的游戏中尤其普遍。自己构建这些类的原因包括:</li>\n<li>总控制。您可以控制数据结构的内存需求、使用的算法、何时以及如何分配内存等。</li>\n<li>优化的机会。您可以优化数据结构和算法，以利用特定于目标控制台的硬件特性;或者针对引擎中的特定应用程序对它们进行微调。</li>\n<li>可定制性。您可以提供在第三方库(如STL)中不常见的自定义算法(例如，搜索容器中n个最相关的元素，而不是只搜索一个最相关的元素)。</li>\n<li>消除外部依赖。由于软件是您自己构建的，所以您不需要任何其他公司或团队来维护它。如果出现问题，可以立即进行调试和修复，而不是等到库的下一个发行版(可能要等到你的游戏发行之后!)并发数据结构的控制。当您编写自己的容器类时，您可以完全控制在多线程或多核系统上保护它们不受并发访问的方法。例如，在PS4上，Naughty Dog为我们的大多数并发数据结构使用了轻量级的“旋转锁”互斥锁，因为它们在我们基于光纤的作业调度系统中工作得很好。第三方容器库可能无法提供这种灵活性</li>\n</ul>\n<p>我们不能在这里涵盖所有可能的数据结构，但是让我们看看游戏引擎程序员处理容器的几种常见方法。</p>\n<h4 id=\"5-3-4-1-To-Build-or-Not-to-Build\"><a href=\"#5-3-4-1-To-Build-or-Not-to-Build\" class=\"headerlink\" title=\"5.3.4.1 To Build or Not to Build\"></a>5.3.4.1 To Build or Not to Build</h4><ul>\n<li>作为游戏引擎设计师，我们有以下几种选择:</li>\n<li><ol>\n<li>手动构建所需的数据结构</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>依赖于第三方实现。一些常见的选择包括a. c++标准模板库(STL)b. STL的一种变体，如STLportc.强大而健壮的Boost库(<a href=\"http://www.boost.org)。STL和Boost都很有吸引力，因为它们提供了一组丰富而强大的容器类，涵盖了几乎所有可以想象到的数据结构类型。此外，这两个包都提供了一套功能强大的基于模板的通用算法——常见算法的实现，例如查找容器中的元素，这些算法可以应用于几乎任何类型的数据对象。然而，像这样的第三方软件包可能不适合somc类游戏cngincs。即使我们决定使用第三方包，我们也必须在Boost和各种风格的STL或其他第三方库之间进行选择。因此，让我们花一点时间来研究每种方法的优缺点。\">http://www.boost.org)。STL和Boost都很有吸引力，因为它们提供了一组丰富而强大的容器类，涵盖了几乎所有可以想象到的数据结构类型。此外，这两个包都提供了一套功能强大的基于模板的通用算法——常见算法的实现，例如查找容器中的元素，这些算法可以应用于几乎任何类型的数据对象。然而，像这样的第三方软件包可能不适合somc类游戏cngincs。即使我们决定使用第三方包，我们也必须在Boost和各种风格的STL或其他第三方库之间进行选择。因此，让我们花一点时间来研究每种方法的优缺点。</a></li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>STL:<br>Stl标准模板库的好处包括:</p>\n<ul>\n<li>STL提供了一组丰富的特性。</li>\n<li>相当健壮的实现可以在各种各样的平台上使用。</li>\n<li>STL是几乎所有c++编译器的“标准”。<br>然而，STL也有很多缺点，包括:</li>\n<li>STL有一个陡峭的学习曲线。文档现在已经很好了，但是头文件在大多数平台上都很晦涩，很难理解。</li>\n<li>STL通常比专门针对特定问题设计的数据结构要慢。</li>\n<li>STL几乎总是比定制设计的数据结构消耗更多的内存。</li>\n<li>STL需要进行大量的动态内存分配，有时要以适合高性能、内存有限的控制台游戏的方式控制它对内存的需求是一项挑战</li>\n<li>STL的实现和行为在不同的编译器之间略有不同，这使得它在多平台引擎中的使用更加困难。</li>\n</ul>\n</blockquote>\n<p>因为现代pc上的高级虚拟内存系统使内存分配更便宜，而且耗尽物理RAM的可能性往往可以忽略不计。另一方面，STL通常不适合在内存有限、缺乏高级cpu和虚拟内存的控制台上使用。使用STL的代码可能不容易移植到其他平台。</p>\n<blockquote>\n<p>以下是我使用的一些经验法则:</p>\n<ul>\n<li>首先，也最重要的是，要了解您正在使用的特定STL类的性能和内存特征</li>\n<li>尽量避免在您认为会成为性能瓶颈的代码中使用重的STL类。</li>\n<li>在内存不是很重要的情况下，选择STL。举例来说，在游戏对象中嵌入std:: list是可以的，但是在3D网格的每个顶点中嵌入std:: list可能不是一个好主意。将3D网格的每个顶点添加到std::list可能也不行——std::list类会动态地为插入其中的每个元素分配一个小的“link”对象，这可能会导致大量微小的、碎片化的内存分配</li>\n<li>如果您的引擎是多平台的，我强烈推荐STLport (<a href=\"http://www.stlport.org)，这是一种STL实现，专门设计用于跨广泛的编译器和目标平台移植，比原始的STI\">http://www.stlport.org)，这是一种STL实现，专门设计用于跨广泛的编译器和目标平台移植，比原始的STI</a> mplementations更高效、功能更丰富。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Boost:<br>Boost项目是由c++标准委员会库工作组的成员发起的，但是现在它是一个开源项目，有许多来自世界各地的贡献者。该项目的目标是生成扩展STL并与之协同工作的库，用于商业和其他用途5.3。容器263非商业用途。许多Boost库已经包含在c++标准委员会的库技术报告(TR1)中，这是迈向成为未来c++标准的一部分的一步。<br>以下是Boost带来的好处的简要总结:<br>Boost提供了许多在STL中不可用的有用工具<br>在某些情况下，Boost提供了解决STL设计或实现中的某些问题的备选方案<br>Boost在处理一些非常复杂的问题(如智能指针)方面做得很好。(请记住，智能指针是复杂的东西，它们可能会影响性能。手柄通常更好;详见15.5节。)<br>Boost库的文档通常都很出色。文档不仅解释了每个库做什么以及如何使用它，而且在大多数情况下，它还对设计决策、约束和组合库的需求提供了极好的深入讨论。因此，阅读Boost文档是了解软件设计原理的好方法。</p>\n</blockquote>\n<blockquote>\n<p>如果您已经在使用STL，那么Boost可以作为许多STL特性的优秀扩展和/或替代品。<br>不过，请注意下列注意事项:<br>大多数核心Boost类都是模板，因此使用它们所需要的只是一组适当的头文件。然而，一些Boost库构建到相当大的.lib文件中，可能不适合在非常小的游戏项目中使用。<br>虽然全球Boost社区是一个优秀的支持网络，但是Boost库并没有得到保证。如果您遇到一个bug，解决它或修复它最终将是您的团队的责任。<br>Boost库是在Boost软件许可下发布的。阅读许可信息(<a href=\"http://www.boost.org/more/license\">http://www.boost.org/more/license</a> info)。小心地确保它适合您的引擎。</p>\n</blockquote>\n<blockquote>\n<p>Loki<br>C++的模板元编程<br>到目前为止，最著名的、可能也是最强大的c++模板元编程库是Loki，它是由Andrei Alexandrescu设计和编写的(其主页在<a href=\"http://www.erdani.org)。该库可以从SourceForge获得，网址是[Loki](http://loki-lib.sourceforge.net)。Loki非常强大;这是一组令人着迷的代码，值得研究和学习。然而,它的两大弱点的实际性质:(a)的代码可以令人生畏的阅读和使用,更少的真正理解,(b)它的一些组件依赖于利用“side-effect”\">http://www.erdani.org)。该库可以从SourceForge获得，网址是[Loki](http://loki-lib.sourceforge.net)。Loki非常强大;这是一组令人着迷的代码，值得研究和学习。然而,它的两大弱点的实际性质:(a)的代码可以令人生畏的阅读和使用,更少的真正理解,(b)它的一些组件依赖于利用“side-effect”</a> 的编译器Behaviours,需要小心仔细自定义以便在新的编译器上运行。因此，Loki使用起来有些困难，而且它的可移植性不如一些“不那么极端”的同类产品。洛基不适合胆小的人。也就是说，一些Loki的概念(如基于策略的编程)可以应用到任何c++项目中，即使您没有使用Loki library本身。我强烈推荐所有的软件工程师阅读Andrei开创性的书，现代c++设计[2]，Loki库就是从这本书诞生的。</p>\n</blockquote>\n"},{"title":"Game Engine Architecture - English","_content":"\n## hence\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/hence--_gb_1.mp3\">\n      </audio>\n\t  \n adv. 因此；今后     \n\n\n## emit\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/emit--_gb_1.mp3\">\n      </audio>\nvt. 发出，放射；发行；发表\n\n## derivative\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/derivative--_gb_1.mp3\">\n      </audio>\nn. 派生物；金融衍生产品；派生词；（化学）衍生物；导数\nadj. （艺术家或艺术作品）模仿的；受……影响的；（金融产品）衍生的\n\n## comprise\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/comprise--_gb_1.mp3\">\n      </audio>\nvt. 包含；由…组成\n\n## manipulate\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/manipulate--_gb_1.mp3\">\n      </audio>\nvt. 操纵；操作；巧妙地处理；篡改\n\n## indistinguishable\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/indistinguishable--_gb_1.mp3\">\n      </audio>\nadj. 不能区别的，不能辨别的；不易察觉的\n\n## vehicle\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/vehicle--_gb_1.mp3\">\n      </audio>\n\t  \nn. [车辆] 车辆；工具；交通工具；运载工具；传播媒介；媒介物\n\n## loosely\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/loosely--_gb_1.mp3\">\n      </audio>\nadv. 宽松地；放荡地；轻率地\n\n## intuitive notion\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/intuitive--_gb_1.mp3\">\n      </audio>\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n     <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/notion--_gb_1.mp3\">\n      </audio>\n\t \n直觉概念\n\n## insanely\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/insanely--_gb_1.mp3\">\n      </audio>\n\t  \nadv. 疯狂地；狂暴地；精神错乱地\n\n## mod\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/mod--_gb_1.mp3\">\n      </audio>\n\t  \nabbr. 模组（modulus）\n\n## considerable\nadj. 相当大的；重要的，值得考虑的\n\t  \n\n## blurry\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/blurry--_gb_1.mp3\">\n      </audio>\nadj. 模糊的；污脏的；不清楚的\n\n## orc\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/orc--_gb_1.mp3\">\n      </audio>\nn. 虎鲸；乐队；妖魔（等于orca）\n\n## arguably\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/arguably--_gb_1.mp3\">\n      </audio>\nadv. 可论证地；可争辩地；正如可提出证据加以证明的那样地\n\n## reserve\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/reserve--_gb_1.mp3\">\n      </audio>\nv. 预订（座位等）；储备；拥有（某种权利）；留出（一部分稍后使用）；用于（特定场合）；暂不作（判断或决定）；把……专门留给；弥撒后保留部分圣餐\nn. 储备（量）；自然保护区；居住地；预备队；预备役部队；缄默；保留意见；储备金；（拍卖中的）底价；（印染中的）防染本色区\n\n## gamut\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/gamut--_gb_1.mp3\">\n      </audio>\nn. 全音阶；全音域；整个范围\n\n## akin\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/akin--_gb_1.mp3\">\n      </audio>\nadj. 类似的；同类的；同族的\n\n## craft\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/craft--_gb_1.mp3\">\n      </audio>\nn. 工艺；手艺；太空船\nvt. 精巧地制作\n\n## genre\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/genre--_gb_1.mp3\">\n      </audio>\nn. 类型；种类；体裁；样式；流派；风俗画\n(Genre)人名；(法)让尔\nadj. 风俗画的；以日常情景为主题的\n\n## optimal\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/optimal--_gb_1.mp3\">\n      </audio>\nadj. 最佳的；最理想的\n\n## trade-off\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/trade--_gb_1.mp3\">\n      </audio>\nn. 交换，交易；权衡；协定\n\n## corridor\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/corridor--_gb_1.mp3\">\n      </audio>\nn. 走廊\n\n## roaming\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/roaming--_gb_1.mp3\">\n      </audio>\nn. 漫游；移动\nv. 漫步；闲逛；徘徊（roam的ing形式）\n\n## confined\nv. 限制，使局限；禁止离开，关押；卧床分娩（confine 的过去式和过去分词）\nadj. 有限制的；封闭的，狭窄的；幽禁的；在分娩中的\n\n## traversal\nn. [计] 遍历；横越；横断物\n\n## forgiving\nadj. 宽恕的；宽容的；宽大的\nv. 原谅；豁免（forgive的ing形式）\n\n## fidelity\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/fidelity--_gb_1.mp3\">\n      </audio>\nn. 保真度；忠诚；精确；尽责\n\n## ubiquitous\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/ubiquitous--_gb_1.mp3\">\n      </audio>\nadj. 普遍存在的；无所不在的\n\n## dungeon crawl\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/dungeon--_gb_1.mp3\">\n      </audio>\n地牢爬行\n\n## devote\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/devote--_gb_1.mp3\">\n      </audio>\nv. 致力于，奉献于；把……用于，作……专用；降祸于，诅咒\n\n## kart\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/kart--_gb_1.mp3\">\n      </audio>\nn. （美）小型赛车\n\n## cockpit\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/cockpit--_gb_1.mp3\">\n      </audio>\nn. 驾驶员座舱；战场\n\n## collaborate\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/colaborate--_gb_1.mp3\">\n      </audio>\nvi. 合作；勾结，通敌\n\n## indie\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/indie--_gb_1.mp3\">\n      </audio>\nadj. （摇滚、流行音乐、影片等）独立制作的，非大公司的；（流行乐队）追求非主流的\nn. 独立制片公司；独立小公司的产品\n\n## leverage\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/leverage--_gb_1.mp3\">\n      </audio>\nn. 手段，影响力；杠杆作用；杠杆效率\nv. 利用；举债经营\n\n## conductive\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/conductive--_gb_1.mp3\">\n      </audio>\nadj. 传导的；传导性的；有传导力的\n\n## primitives\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/primitive--_gb_1.mp3\">\n      </audio>\nn. [计] 基元（primitive的复数）；原始事物；基本体\n\n## terminology\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/terminology--_gb_1.mp3\">\n      </audio>\nn. 术语，术语学；用辞\n\n## subdivision\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/subdivision--_gb_1.mp3\">\n      </audio>\nn. 细分；分部；供出卖而分成的小块土地\n\n## subsume\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/subsume--_gb_1.mp3\">\n      </audio>\nvt. 把……归入；把……包括在内\n\n## latter \n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/latter--_gb_1.mp3\">\n      </audio>\nadj. 后者的；近来的；后面的；较后的\n\n## former\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/former--_gb_1.mp3\">\n      </audio>\nadj. 从前的，前者的；前任的\nn. 模型，样板；起形成作用的人\n\n## palette of matrices\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/palette--_gb_1.mp3\">\n      </audio>\n矩阵的调色板\n\n## retrofit\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/retrofit--_gb_1.mp3\">\n      </audio>\nvt. 改进；[计] 更新；式样翻新\nn. 式样翻新；花样翻新\n\n## trivial\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/trivial--_gb_1.mp3\">\n      </audio>\nadj. 不重要的，琐碎的；琐细的\n\n## intimately\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/intimate--_gb_1.mp3\">\n      </audio>\nadv. 熟悉地；亲切地；私下地\n\n## pervade\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/pervade--_gb_1.mp3\">\n      </audio>\nThis model can end up pervading the entire engine.\nvt. 遍及；弥漫\n\n## depict\nvt. 描述；描画\n\n## prove\nvi. 证明是\nvt. 证明；检验；显示\n\n## invaluable\nadj. 无价的；非常贵重的\n\n## endeavor\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/endeavour--_gb_1.mp3\">\n      </audio>\n>We’ll briefly review the basic concepts of object-oriented pro- gramming (OOP) and then delve into some advanced topics that should\nprove invaluable in any software engineering endeavor (and especially when\ncreating games).\nn. 努力；尽力（等于 endeavour）\nvi. 努力；尽力（等于 endeavour）\nvt. 努力；尽力（等于 endeavour）\n\n## rusty\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/rusty--_gb_1.mp3\">\n      </audio>\nadj. 生锈的，腐蚀的；铁锈色的，锈色的；迟钝的\n\n## hollow triangular \n空心三角形","source":"_posts/IT-English.md","raw":"---\ntitle: Game Engine Architecture - English\ncategories:\n- IT阅读\ntags: \n- Game\n- English\n---\n\n## hence\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/hence--_gb_1.mp3\">\n      </audio>\n\t  \n adv. 因此；今后     \n\n\n## emit\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/emit--_gb_1.mp3\">\n      </audio>\nvt. 发出，放射；发行；发表\n\n## derivative\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/derivative--_gb_1.mp3\">\n      </audio>\nn. 派生物；金融衍生产品；派生词；（化学）衍生物；导数\nadj. （艺术家或艺术作品）模仿的；受……影响的；（金融产品）衍生的\n\n## comprise\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/comprise--_gb_1.mp3\">\n      </audio>\nvt. 包含；由…组成\n\n## manipulate\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/manipulate--_gb_1.mp3\">\n      </audio>\nvt. 操纵；操作；巧妙地处理；篡改\n\n## indistinguishable\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/indistinguishable--_gb_1.mp3\">\n      </audio>\nadj. 不能区别的，不能辨别的；不易察觉的\n\n## vehicle\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/vehicle--_gb_1.mp3\">\n      </audio>\n\t  \nn. [车辆] 车辆；工具；交通工具；运载工具；传播媒介；媒介物\n\n## loosely\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/loosely--_gb_1.mp3\">\n      </audio>\nadv. 宽松地；放荡地；轻率地\n\n## intuitive notion\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/intuitive--_gb_1.mp3\">\n      </audio>\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n     <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/notion--_gb_1.mp3\">\n      </audio>\n\t \n直觉概念\n\n## insanely\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/insanely--_gb_1.mp3\">\n      </audio>\n\t  \nadv. 疯狂地；狂暴地；精神错乱地\n\n## mod\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/mod--_gb_1.mp3\">\n      </audio>\n\t  \nabbr. 模组（modulus）\n\n## considerable\nadj. 相当大的；重要的，值得考虑的\n\t  \n\n## blurry\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/blurry--_gb_1.mp3\">\n      </audio>\nadj. 模糊的；污脏的；不清楚的\n\n## orc\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/orc--_gb_1.mp3\">\n      </audio>\nn. 虎鲸；乐队；妖魔（等于orca）\n\n## arguably\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/arguably--_gb_1.mp3\">\n      </audio>\nadv. 可论证地；可争辩地；正如可提出证据加以证明的那样地\n\n## reserve\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/reserve--_gb_1.mp3\">\n      </audio>\nv. 预订（座位等）；储备；拥有（某种权利）；留出（一部分稍后使用）；用于（特定场合）；暂不作（判断或决定）；把……专门留给；弥撒后保留部分圣餐\nn. 储备（量）；自然保护区；居住地；预备队；预备役部队；缄默；保留意见；储备金；（拍卖中的）底价；（印染中的）防染本色区\n\n## gamut\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/gamut--_gb_1.mp3\">\n      </audio>\nn. 全音阶；全音域；整个范围\n\n## akin\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/akin--_gb_1.mp3\">\n      </audio>\nadj. 类似的；同类的；同族的\n\n## craft\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/craft--_gb_1.mp3\">\n      </audio>\nn. 工艺；手艺；太空船\nvt. 精巧地制作\n\n## genre\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/genre--_gb_1.mp3\">\n      </audio>\nn. 类型；种类；体裁；样式；流派；风俗画\n(Genre)人名；(法)让尔\nadj. 风俗画的；以日常情景为主题的\n\n## optimal\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/optimal--_gb_1.mp3\">\n      </audio>\nadj. 最佳的；最理想的\n\n## trade-off\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/trade--_gb_1.mp3\">\n      </audio>\nn. 交换，交易；权衡；协定\n\n## corridor\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/corridor--_gb_1.mp3\">\n      </audio>\nn. 走廊\n\n## roaming\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/roaming--_gb_1.mp3\">\n      </audio>\nn. 漫游；移动\nv. 漫步；闲逛；徘徊（roam的ing形式）\n\n## confined\nv. 限制，使局限；禁止离开，关押；卧床分娩（confine 的过去式和过去分词）\nadj. 有限制的；封闭的，狭窄的；幽禁的；在分娩中的\n\n## traversal\nn. [计] 遍历；横越；横断物\n\n## forgiving\nadj. 宽恕的；宽容的；宽大的\nv. 原谅；豁免（forgive的ing形式）\n\n## fidelity\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/fidelity--_gb_1.mp3\">\n      </audio>\nn. 保真度；忠诚；精确；尽责\n\n## ubiquitous\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/ubiquitous--_gb_1.mp3\">\n      </audio>\nadj. 普遍存在的；无所不在的\n\n## dungeon crawl\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/dungeon--_gb_1.mp3\">\n      </audio>\n地牢爬行\n\n## devote\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/devote--_gb_1.mp3\">\n      </audio>\nv. 致力于，奉献于；把……用于，作……专用；降祸于，诅咒\n\n## kart\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/kart--_gb_1.mp3\">\n      </audio>\nn. （美）小型赛车\n\n## cockpit\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/cockpit--_gb_1.mp3\">\n      </audio>\nn. 驾驶员座舱；战场\n\n## collaborate\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/colaborate--_gb_1.mp3\">\n      </audio>\nvi. 合作；勾结，通敌\n\n## indie\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/indie--_gb_1.mp3\">\n      </audio>\nadj. （摇滚、流行音乐、影片等）独立制作的，非大公司的；（流行乐队）追求非主流的\nn. 独立制片公司；独立小公司的产品\n\n## leverage\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/leverage--_gb_1.mp3\">\n      </audio>\nn. 手段，影响力；杠杆作用；杠杆效率\nv. 利用；举债经营\n\n## conductive\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/conductive--_gb_1.mp3\">\n      </audio>\nadj. 传导的；传导性的；有传导力的\n\n## primitives\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/primitive--_gb_1.mp3\">\n      </audio>\nn. [计] 基元（primitive的复数）；原始事物；基本体\n\n## terminology\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/terminology--_gb_1.mp3\">\n      </audio>\nn. 术语，术语学；用辞\n\n## subdivision\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/subdivision--_gb_1.mp3\">\n      </audio>\nn. 细分；分部；供出卖而分成的小块土地\n\n## subsume\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/subsume--_gb_1.mp3\">\n      </audio>\nvt. 把……归入；把……包括在内\n\n## latter \n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/latter--_gb_1.mp3\">\n      </audio>\nadj. 后者的；近来的；后面的；较后的\n\n## former\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/former--_gb_1.mp3\">\n      </audio>\nadj. 从前的，前者的；前任的\nn. 模型，样板；起形成作用的人\n\n## palette of matrices\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/palette--_gb_1.mp3\">\n      </audio>\n矩阵的调色板\n\n## retrofit\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/retrofit--_gb_1.mp3\">\n      </audio>\nvt. 改进；[计] 更新；式样翻新\nn. 式样翻新；花样翻新\n\n## trivial\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/trivial--_gb_1.mp3\">\n      </audio>\nadj. 不重要的，琐碎的；琐细的\n\n## intimately\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/intimate--_gb_1.mp3\">\n      </audio>\nadv. 熟悉地；亲切地；私下地\n\n## pervade\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/pervade--_gb_1.mp3\">\n      </audio>\nThis model can end up pervading the entire engine.\nvt. 遍及；弥漫\n\n## depict\nvt. 描述；描画\n\n## prove\nvi. 证明是\nvt. 证明；检验；显示\n\n## invaluable\nadj. 无价的；非常贵重的\n\n## endeavor\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/endeavour--_gb_1.mp3\">\n      </audio>\n>We’ll briefly review the basic concepts of object-oriented pro- gramming (OOP) and then delve into some advanced topics that should\nprove invaluable in any software engineering endeavor (and especially when\ncreating games).\nn. 努力；尽力（等于 endeavour）\nvi. 努力；尽力（等于 endeavour）\nvt. 努力；尽力（等于 endeavour）\n\n## rusty\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/rusty--_gb_1.mp3\">\n      </audio>\nadj. 生锈的，腐蚀的；铁锈色的，锈色的；迟钝的\n\n## hollow triangular \n空心三角形","slug":"IT-English","published":1,"date":"2020-09-09T02:46:51.346Z","updated":"2020-09-09T02:46:51.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0zp001e4wf0st5613gs","content":"<h2 id=\"hence\"><a href=\"#hence\" class=\"headerlink\" title=\"hence\"></a>hence</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/hence--_gb_1.mp3\">\n      </audio>\n\n<p> adv. 因此；今后     </p>\n<h2 id=\"emit\"><a href=\"#emit\" class=\"headerlink\" title=\"emit\"></a>emit</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/emit--_gb_1.mp3\">\n      </audio>\nvt. 发出，放射；发行；发表\n\n<h2 id=\"derivative\"><a href=\"#derivative\" class=\"headerlink\" title=\"derivative\"></a>derivative</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/derivative--_gb_1.mp3\">\n      </audio>\nn. 派生物；金融衍生产品；派生词；（化学）衍生物；导数\nadj. （艺术家或艺术作品）模仿的；受……影响的；（金融产品）衍生的\n\n<h2 id=\"comprise\"><a href=\"#comprise\" class=\"headerlink\" title=\"comprise\"></a>comprise</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/comprise--_gb_1.mp3\">\n      </audio>\nvt. 包含；由…组成\n\n<h2 id=\"manipulate\"><a href=\"#manipulate\" class=\"headerlink\" title=\"manipulate\"></a>manipulate</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/manipulate--_gb_1.mp3\">\n      </audio>\nvt. 操纵；操作；巧妙地处理；篡改\n\n<h2 id=\"indistinguishable\"><a href=\"#indistinguishable\" class=\"headerlink\" title=\"indistinguishable\"></a>indistinguishable</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/indistinguishable--_gb_1.mp3\">\n      </audio>\nadj. 不能区别的，不能辨别的；不易察觉的\n\n<h2 id=\"vehicle\"><a href=\"#vehicle\" class=\"headerlink\" title=\"vehicle\"></a>vehicle</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/vehicle--_gb_1.mp3\">\n      </audio>\n\n<p>n. [车辆] 车辆；工具；交通工具；运载工具；传播媒介；媒介物</p>\n<h2 id=\"loosely\"><a href=\"#loosely\" class=\"headerlink\" title=\"loosely\"></a>loosely</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/loosely--_gb_1.mp3\">\n      </audio>\nadv. 宽松地；放荡地；轻率地\n\n<h2 id=\"intuitive-notion\"><a href=\"#intuitive-notion\" class=\"headerlink\" title=\"intuitive notion\"></a>intuitive notion</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/intuitive--_gb_1.mp3\">\n      </audio>\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n     <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/notion--_gb_1.mp3\">\n      </audio>\n\n<p>直觉概念</p>\n<h2 id=\"insanely\"><a href=\"#insanely\" class=\"headerlink\" title=\"insanely\"></a>insanely</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/insanely--_gb_1.mp3\">\n      </audio>\n\n<p>adv. 疯狂地；狂暴地；精神错乱地</p>\n<h2 id=\"mod\"><a href=\"#mod\" class=\"headerlink\" title=\"mod\"></a>mod</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/mod--_gb_1.mp3\">\n      </audio>\n\n<p>abbr. 模组（modulus）</p>\n<h2 id=\"considerable\"><a href=\"#considerable\" class=\"headerlink\" title=\"considerable\"></a>considerable</h2><p>adj. 相当大的；重要的，值得考虑的</p>\n<h2 id=\"blurry\"><a href=\"#blurry\" class=\"headerlink\" title=\"blurry\"></a>blurry</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/blurry--_gb_1.mp3\">\n      </audio>\nadj. 模糊的；污脏的；不清楚的\n\n<h2 id=\"orc\"><a href=\"#orc\" class=\"headerlink\" title=\"orc\"></a>orc</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/orc--_gb_1.mp3\">\n      </audio>\nn. 虎鲸；乐队；妖魔（等于orca）\n\n<h2 id=\"arguably\"><a href=\"#arguably\" class=\"headerlink\" title=\"arguably\"></a>arguably</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/arguably--_gb_1.mp3\">\n      </audio>\nadv. 可论证地；可争辩地；正如可提出证据加以证明的那样地\n\n<h2 id=\"reserve\"><a href=\"#reserve\" class=\"headerlink\" title=\"reserve\"></a>reserve</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/reserve--_gb_1.mp3\">\n      </audio>\nv. 预订（座位等）；储备；拥有（某种权利）；留出（一部分稍后使用）；用于（特定场合）；暂不作（判断或决定）；把……专门留给；弥撒后保留部分圣餐\nn. 储备（量）；自然保护区；居住地；预备队；预备役部队；缄默；保留意见；储备金；（拍卖中的）底价；（印染中的）防染本色区\n\n<h2 id=\"gamut\"><a href=\"#gamut\" class=\"headerlink\" title=\"gamut\"></a>gamut</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/gamut--_gb_1.mp3\">\n      </audio>\nn. 全音阶；全音域；整个范围\n\n<h2 id=\"akin\"><a href=\"#akin\" class=\"headerlink\" title=\"akin\"></a>akin</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/akin--_gb_1.mp3\">\n      </audio>\nadj. 类似的；同类的；同族的\n\n<h2 id=\"craft\"><a href=\"#craft\" class=\"headerlink\" title=\"craft\"></a>craft</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/craft--_gb_1.mp3\">\n      </audio>\nn. 工艺；手艺；太空船\nvt. 精巧地制作\n\n<h2 id=\"genre\"><a href=\"#genre\" class=\"headerlink\" title=\"genre\"></a>genre</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/genre--_gb_1.mp3\">\n      </audio>\nn. 类型；种类；体裁；样式；流派；风俗画\n(Genre)人名；(法)让尔\nadj. 风俗画的；以日常情景为主题的\n\n<h2 id=\"optimal\"><a href=\"#optimal\" class=\"headerlink\" title=\"optimal\"></a>optimal</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/optimal--_gb_1.mp3\">\n      </audio>\nadj. 最佳的；最理想的\n\n<h2 id=\"trade-off\"><a href=\"#trade-off\" class=\"headerlink\" title=\"trade-off\"></a>trade-off</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/trade--_gb_1.mp3\">\n      </audio>\nn. 交换，交易；权衡；协定\n\n<h2 id=\"corridor\"><a href=\"#corridor\" class=\"headerlink\" title=\"corridor\"></a>corridor</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/corridor--_gb_1.mp3\">\n      </audio>\nn. 走廊\n\n<h2 id=\"roaming\"><a href=\"#roaming\" class=\"headerlink\" title=\"roaming\"></a>roaming</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/roaming--_gb_1.mp3\">\n      </audio>\nn. 漫游；移动\nv. 漫步；闲逛；徘徊（roam的ing形式）\n\n<h2 id=\"confined\"><a href=\"#confined\" class=\"headerlink\" title=\"confined\"></a>confined</h2><p>v. 限制，使局限；禁止离开，关押；卧床分娩（confine 的过去式和过去分词）<br>adj. 有限制的；封闭的，狭窄的；幽禁的；在分娩中的</p>\n<h2 id=\"traversal\"><a href=\"#traversal\" class=\"headerlink\" title=\"traversal\"></a>traversal</h2><p>n. [计] 遍历；横越；横断物</p>\n<h2 id=\"forgiving\"><a href=\"#forgiving\" class=\"headerlink\" title=\"forgiving\"></a>forgiving</h2><p>adj. 宽恕的；宽容的；宽大的<br>v. 原谅；豁免（forgive的ing形式）</p>\n<h2 id=\"fidelity\"><a href=\"#fidelity\" class=\"headerlink\" title=\"fidelity\"></a>fidelity</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/fidelity--_gb_1.mp3\">\n      </audio>\nn. 保真度；忠诚；精确；尽责\n\n<h2 id=\"ubiquitous\"><a href=\"#ubiquitous\" class=\"headerlink\" title=\"ubiquitous\"></a>ubiquitous</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/ubiquitous--_gb_1.mp3\">\n      </audio>\nadj. 普遍存在的；无所不在的\n\n<h2 id=\"dungeon-crawl\"><a href=\"#dungeon-crawl\" class=\"headerlink\" title=\"dungeon crawl\"></a>dungeon crawl</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/dungeon--_gb_1.mp3\">\n      </audio>\n地牢爬行\n\n<h2 id=\"devote\"><a href=\"#devote\" class=\"headerlink\" title=\"devote\"></a>devote</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/devote--_gb_1.mp3\">\n      </audio>\nv. 致力于，奉献于；把……用于，作……专用；降祸于，诅咒\n\n<h2 id=\"kart\"><a href=\"#kart\" class=\"headerlink\" title=\"kart\"></a>kart</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/kart--_gb_1.mp3\">\n      </audio>\nn. （美）小型赛车\n\n<h2 id=\"cockpit\"><a href=\"#cockpit\" class=\"headerlink\" title=\"cockpit\"></a>cockpit</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/cockpit--_gb_1.mp3\">\n      </audio>\nn. 驾驶员座舱；战场\n\n<h2 id=\"collaborate\"><a href=\"#collaborate\" class=\"headerlink\" title=\"collaborate\"></a>collaborate</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/colaborate--_gb_1.mp3\">\n      </audio>\nvi. 合作；勾结，通敌\n\n<h2 id=\"indie\"><a href=\"#indie\" class=\"headerlink\" title=\"indie\"></a>indie</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/indie--_gb_1.mp3\">\n      </audio>\nadj. （摇滚、流行音乐、影片等）独立制作的，非大公司的；（流行乐队）追求非主流的\nn. 独立制片公司；独立小公司的产品\n\n<h2 id=\"leverage\"><a href=\"#leverage\" class=\"headerlink\" title=\"leverage\"></a>leverage</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/leverage--_gb_1.mp3\">\n      </audio>\nn. 手段，影响力；杠杆作用；杠杆效率\nv. 利用；举债经营\n\n<h2 id=\"conductive\"><a href=\"#conductive\" class=\"headerlink\" title=\"conductive\"></a>conductive</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/conductive--_gb_1.mp3\">\n      </audio>\nadj. 传导的；传导性的；有传导力的\n\n<h2 id=\"primitives\"><a href=\"#primitives\" class=\"headerlink\" title=\"primitives\"></a>primitives</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/primitive--_gb_1.mp3\">\n      </audio>\nn. [计] 基元（primitive的复数）；原始事物；基本体\n\n<h2 id=\"terminology\"><a href=\"#terminology\" class=\"headerlink\" title=\"terminology\"></a>terminology</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/terminology--_gb_1.mp3\">\n      </audio>\nn. 术语，术语学；用辞\n\n<h2 id=\"subdivision\"><a href=\"#subdivision\" class=\"headerlink\" title=\"subdivision\"></a>subdivision</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/subdivision--_gb_1.mp3\">\n      </audio>\nn. 细分；分部；供出卖而分成的小块土地\n\n<h2 id=\"subsume\"><a href=\"#subsume\" class=\"headerlink\" title=\"subsume\"></a>subsume</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/subsume--_gb_1.mp3\">\n      </audio>\nvt. 把……归入；把……包括在内\n\n<h2 id=\"latter\"><a href=\"#latter\" class=\"headerlink\" title=\"latter\"></a>latter</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/latter--_gb_1.mp3\">\n      </audio>\nadj. 后者的；近来的；后面的；较后的\n\n<h2 id=\"former\"><a href=\"#former\" class=\"headerlink\" title=\"former\"></a>former</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/former--_gb_1.mp3\">\n      </audio>\nadj. 从前的，前者的；前任的\nn. 模型，样板；起形成作用的人\n\n<h2 id=\"palette-of-matrices\"><a href=\"#palette-of-matrices\" class=\"headerlink\" title=\"palette of matrices\"></a>palette of matrices</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/palette--_gb_1.mp3\">\n      </audio>\n矩阵的调色板\n\n<h2 id=\"retrofit\"><a href=\"#retrofit\" class=\"headerlink\" title=\"retrofit\"></a>retrofit</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/retrofit--_gb_1.mp3\">\n      </audio>\nvt. 改进；[计] 更新；式样翻新\nn. 式样翻新；花样翻新\n\n<h2 id=\"trivial\"><a href=\"#trivial\" class=\"headerlink\" title=\"trivial\"></a>trivial</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/trivial--_gb_1.mp3\">\n      </audio>\nadj. 不重要的，琐碎的；琐细的\n\n<h2 id=\"intimately\"><a href=\"#intimately\" class=\"headerlink\" title=\"intimately\"></a>intimately</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/intimate--_gb_1.mp3\">\n      </audio>\nadv. 熟悉地；亲切地；私下地\n\n<h2 id=\"pervade\"><a href=\"#pervade\" class=\"headerlink\" title=\"pervade\"></a>pervade</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/pervade--_gb_1.mp3\">\n      </audio>\nThis model can end up pervading the entire engine.\nvt. 遍及；弥漫\n\n<h2 id=\"depict\"><a href=\"#depict\" class=\"headerlink\" title=\"depict\"></a>depict</h2><p>vt. 描述；描画</p>\n<h2 id=\"prove\"><a href=\"#prove\" class=\"headerlink\" title=\"prove\"></a>prove</h2><p>vi. 证明是<br>vt. 证明；检验；显示</p>\n<h2 id=\"invaluable\"><a href=\"#invaluable\" class=\"headerlink\" title=\"invaluable\"></a>invaluable</h2><p>adj. 无价的；非常贵重的</p>\n<h2 id=\"endeavor\"><a href=\"#endeavor\" class=\"headerlink\" title=\"endeavor\"></a>endeavor</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/endeavour--_gb_1.mp3\">\n      </audio>\n>We’ll briefly review the basic concepts of object-oriented pro- gramming (OOP) and then delve into some advanced topics that should\nprove invaluable in any software engineering endeavor (and especially when\ncreating games).\nn. 努力；尽力（等于 endeavour）\nvi. 努力；尽力（等于 endeavour）\nvt. 努力；尽力（等于 endeavour）\n\n<h2 id=\"rusty\"><a href=\"#rusty\" class=\"headerlink\" title=\"rusty\"></a>rusty</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/rusty--_gb_1.mp3\">\n      </audio>\nadj. 生锈的，腐蚀的；铁锈色的，锈色的；迟钝的\n\n<h2 id=\"hollow-triangular\"><a href=\"#hollow-triangular\" class=\"headerlink\" title=\"hollow triangular\"></a>hollow triangular</h2><p>空心三角形</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"hence\"><a href=\"#hence\" class=\"headerlink\" title=\"hence\"></a>hence</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/hence--_gb_1.mp3\">\n      </audio>\n\n<p> adv. 因此；今后     </p>\n<h2 id=\"emit\"><a href=\"#emit\" class=\"headerlink\" title=\"emit\"></a>emit</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/emit--_gb_1.mp3\">\n      </audio>\nvt. 发出，放射；发行；发表\n\n<h2 id=\"derivative\"><a href=\"#derivative\" class=\"headerlink\" title=\"derivative\"></a>derivative</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/derivative--_gb_1.mp3\">\n      </audio>\nn. 派生物；金融衍生产品；派生词；（化学）衍生物；导数\nadj. （艺术家或艺术作品）模仿的；受……影响的；（金融产品）衍生的\n\n<h2 id=\"comprise\"><a href=\"#comprise\" class=\"headerlink\" title=\"comprise\"></a>comprise</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/comprise--_gb_1.mp3\">\n      </audio>\nvt. 包含；由…组成\n\n<h2 id=\"manipulate\"><a href=\"#manipulate\" class=\"headerlink\" title=\"manipulate\"></a>manipulate</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/manipulate--_gb_1.mp3\">\n      </audio>\nvt. 操纵；操作；巧妙地处理；篡改\n\n<h2 id=\"indistinguishable\"><a href=\"#indistinguishable\" class=\"headerlink\" title=\"indistinguishable\"></a>indistinguishable</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/indistinguishable--_gb_1.mp3\">\n      </audio>\nadj. 不能区别的，不能辨别的；不易察觉的\n\n<h2 id=\"vehicle\"><a href=\"#vehicle\" class=\"headerlink\" title=\"vehicle\"></a>vehicle</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/vehicle--_gb_1.mp3\">\n      </audio>\n\n<p>n. [车辆] 车辆；工具；交通工具；运载工具；传播媒介；媒介物</p>\n<h2 id=\"loosely\"><a href=\"#loosely\" class=\"headerlink\" title=\"loosely\"></a>loosely</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/loosely--_gb_1.mp3\">\n      </audio>\nadv. 宽松地；放荡地；轻率地\n\n<h2 id=\"intuitive-notion\"><a href=\"#intuitive-notion\" class=\"headerlink\" title=\"intuitive notion\"></a>intuitive notion</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/intuitive--_gb_1.mp3\">\n      </audio>\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n     <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/notion--_gb_1.mp3\">\n      </audio>\n\n<p>直觉概念</p>\n<h2 id=\"insanely\"><a href=\"#insanely\" class=\"headerlink\" title=\"insanely\"></a>insanely</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/insanely--_gb_1.mp3\">\n      </audio>\n\n<p>adv. 疯狂地；狂暴地；精神错乱地</p>\n<h2 id=\"mod\"><a href=\"#mod\" class=\"headerlink\" title=\"mod\"></a>mod</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/mod--_gb_1.mp3\">\n      </audio>\n\n<p>abbr. 模组（modulus）</p>\n<h2 id=\"considerable\"><a href=\"#considerable\" class=\"headerlink\" title=\"considerable\"></a>considerable</h2><p>adj. 相当大的；重要的，值得考虑的</p>\n<h2 id=\"blurry\"><a href=\"#blurry\" class=\"headerlink\" title=\"blurry\"></a>blurry</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/blurry--_gb_1.mp3\">\n      </audio>\nadj. 模糊的；污脏的；不清楚的\n\n<h2 id=\"orc\"><a href=\"#orc\" class=\"headerlink\" title=\"orc\"></a>orc</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/orc--_gb_1.mp3\">\n      </audio>\nn. 虎鲸；乐队；妖魔（等于orca）\n\n<h2 id=\"arguably\"><a href=\"#arguably\" class=\"headerlink\" title=\"arguably\"></a>arguably</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/arguably--_gb_1.mp3\">\n      </audio>\nadv. 可论证地；可争辩地；正如可提出证据加以证明的那样地\n\n<h2 id=\"reserve\"><a href=\"#reserve\" class=\"headerlink\" title=\"reserve\"></a>reserve</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/reserve--_gb_1.mp3\">\n      </audio>\nv. 预订（座位等）；储备；拥有（某种权利）；留出（一部分稍后使用）；用于（特定场合）；暂不作（判断或决定）；把……专门留给；弥撒后保留部分圣餐\nn. 储备（量）；自然保护区；居住地；预备队；预备役部队；缄默；保留意见；储备金；（拍卖中的）底价；（印染中的）防染本色区\n\n<h2 id=\"gamut\"><a href=\"#gamut\" class=\"headerlink\" title=\"gamut\"></a>gamut</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/gamut--_gb_1.mp3\">\n      </audio>\nn. 全音阶；全音域；整个范围\n\n<h2 id=\"akin\"><a href=\"#akin\" class=\"headerlink\" title=\"akin\"></a>akin</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/akin--_gb_1.mp3\">\n      </audio>\nadj. 类似的；同类的；同族的\n\n<h2 id=\"craft\"><a href=\"#craft\" class=\"headerlink\" title=\"craft\"></a>craft</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/craft--_gb_1.mp3\">\n      </audio>\nn. 工艺；手艺；太空船\nvt. 精巧地制作\n\n<h2 id=\"genre\"><a href=\"#genre\" class=\"headerlink\" title=\"genre\"></a>genre</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/genre--_gb_1.mp3\">\n      </audio>\nn. 类型；种类；体裁；样式；流派；风俗画\n(Genre)人名；(法)让尔\nadj. 风俗画的；以日常情景为主题的\n\n<h2 id=\"optimal\"><a href=\"#optimal\" class=\"headerlink\" title=\"optimal\"></a>optimal</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/optimal--_gb_1.mp3\">\n      </audio>\nadj. 最佳的；最理想的\n\n<h2 id=\"trade-off\"><a href=\"#trade-off\" class=\"headerlink\" title=\"trade-off\"></a>trade-off</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/trade--_gb_1.mp3\">\n      </audio>\nn. 交换，交易；权衡；协定\n\n<h2 id=\"corridor\"><a href=\"#corridor\" class=\"headerlink\" title=\"corridor\"></a>corridor</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/corridor--_gb_1.mp3\">\n      </audio>\nn. 走廊\n\n<h2 id=\"roaming\"><a href=\"#roaming\" class=\"headerlink\" title=\"roaming\"></a>roaming</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/roaming--_gb_1.mp3\">\n      </audio>\nn. 漫游；移动\nv. 漫步；闲逛；徘徊（roam的ing形式）\n\n<h2 id=\"confined\"><a href=\"#confined\" class=\"headerlink\" title=\"confined\"></a>confined</h2><p>v. 限制，使局限；禁止离开，关押；卧床分娩（confine 的过去式和过去分词）<br>adj. 有限制的；封闭的，狭窄的；幽禁的；在分娩中的</p>\n<h2 id=\"traversal\"><a href=\"#traversal\" class=\"headerlink\" title=\"traversal\"></a>traversal</h2><p>n. [计] 遍历；横越；横断物</p>\n<h2 id=\"forgiving\"><a href=\"#forgiving\" class=\"headerlink\" title=\"forgiving\"></a>forgiving</h2><p>adj. 宽恕的；宽容的；宽大的<br>v. 原谅；豁免（forgive的ing形式）</p>\n<h2 id=\"fidelity\"><a href=\"#fidelity\" class=\"headerlink\" title=\"fidelity\"></a>fidelity</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/fidelity--_gb_1.mp3\">\n      </audio>\nn. 保真度；忠诚；精确；尽责\n\n<h2 id=\"ubiquitous\"><a href=\"#ubiquitous\" class=\"headerlink\" title=\"ubiquitous\"></a>ubiquitous</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/ubiquitous--_gb_1.mp3\">\n      </audio>\nadj. 普遍存在的；无所不在的\n\n<h2 id=\"dungeon-crawl\"><a href=\"#dungeon-crawl\" class=\"headerlink\" title=\"dungeon crawl\"></a>dungeon crawl</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/dungeon--_gb_1.mp3\">\n      </audio>\n地牢爬行\n\n<h2 id=\"devote\"><a href=\"#devote\" class=\"headerlink\" title=\"devote\"></a>devote</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/devote--_gb_1.mp3\">\n      </audio>\nv. 致力于，奉献于；把……用于，作……专用；降祸于，诅咒\n\n<h2 id=\"kart\"><a href=\"#kart\" class=\"headerlink\" title=\"kart\"></a>kart</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/kart--_gb_1.mp3\">\n      </audio>\nn. （美）小型赛车\n\n<h2 id=\"cockpit\"><a href=\"#cockpit\" class=\"headerlink\" title=\"cockpit\"></a>cockpit</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/cockpit--_gb_1.mp3\">\n      </audio>\nn. 驾驶员座舱；战场\n\n<h2 id=\"collaborate\"><a href=\"#collaborate\" class=\"headerlink\" title=\"collaborate\"></a>collaborate</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/colaborate--_gb_1.mp3\">\n      </audio>\nvi. 合作；勾结，通敌\n\n<h2 id=\"indie\"><a href=\"#indie\" class=\"headerlink\" title=\"indie\"></a>indie</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/indie--_gb_1.mp3\">\n      </audio>\nadj. （摇滚、流行音乐、影片等）独立制作的，非大公司的；（流行乐队）追求非主流的\nn. 独立制片公司；独立小公司的产品\n\n<h2 id=\"leverage\"><a href=\"#leverage\" class=\"headerlink\" title=\"leverage\"></a>leverage</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/leverage--_gb_1.mp3\">\n      </audio>\nn. 手段，影响力；杠杆作用；杠杆效率\nv. 利用；举债经营\n\n<h2 id=\"conductive\"><a href=\"#conductive\" class=\"headerlink\" title=\"conductive\"></a>conductive</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/conductive--_gb_1.mp3\">\n      </audio>\nadj. 传导的；传导性的；有传导力的\n\n<h2 id=\"primitives\"><a href=\"#primitives\" class=\"headerlink\" title=\"primitives\"></a>primitives</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/primitive--_gb_1.mp3\">\n      </audio>\nn. [计] 基元（primitive的复数）；原始事物；基本体\n\n<h2 id=\"terminology\"><a href=\"#terminology\" class=\"headerlink\" title=\"terminology\"></a>terminology</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/terminology--_gb_1.mp3\">\n      </audio>\nn. 术语，术语学；用辞\n\n<h2 id=\"subdivision\"><a href=\"#subdivision\" class=\"headerlink\" title=\"subdivision\"></a>subdivision</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/subdivision--_gb_1.mp3\">\n      </audio>\nn. 细分；分部；供出卖而分成的小块土地\n\n<h2 id=\"subsume\"><a href=\"#subsume\" class=\"headerlink\" title=\"subsume\"></a>subsume</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/subsume--_gb_1.mp3\">\n      </audio>\nvt. 把……归入；把……包括在内\n\n<h2 id=\"latter\"><a href=\"#latter\" class=\"headerlink\" title=\"latter\"></a>latter</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/latter--_gb_1.mp3\">\n      </audio>\nadj. 后者的；近来的；后面的；较后的\n\n<h2 id=\"former\"><a href=\"#former\" class=\"headerlink\" title=\"former\"></a>former</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/former--_gb_1.mp3\">\n      </audio>\nadj. 从前的，前者的；前任的\nn. 模型，样板；起形成作用的人\n\n<h2 id=\"palette-of-matrices\"><a href=\"#palette-of-matrices\" class=\"headerlink\" title=\"palette of matrices\"></a>palette of matrices</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/palette--_gb_1.mp3\">\n      </audio>\n矩阵的调色板\n\n<h2 id=\"retrofit\"><a href=\"#retrofit\" class=\"headerlink\" title=\"retrofit\"></a>retrofit</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/retrofit--_gb_1.mp3\">\n      </audio>\nvt. 改进；[计] 更新；式样翻新\nn. 式样翻新；花样翻新\n\n<h2 id=\"trivial\"><a href=\"#trivial\" class=\"headerlink\" title=\"trivial\"></a>trivial</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/trivial--_gb_1.mp3\">\n      </audio>\nadj. 不重要的，琐碎的；琐细的\n\n<h2 id=\"intimately\"><a href=\"#intimately\" class=\"headerlink\" title=\"intimately\"></a>intimately</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/intimate--_gb_1.mp3\">\n      </audio>\nadv. 熟悉地；亲切地；私下地\n\n<h2 id=\"pervade\"><a href=\"#pervade\" class=\"headerlink\" title=\"pervade\"></a>pervade</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/pervade--_gb_1.mp3\">\n      </audio>\nThis model can end up pervading the entire engine.\nvt. 遍及；弥漫\n\n<h2 id=\"depict\"><a href=\"#depict\" class=\"headerlink\" title=\"depict\"></a>depict</h2><p>vt. 描述；描画</p>\n<h2 id=\"prove\"><a href=\"#prove\" class=\"headerlink\" title=\"prove\"></a>prove</h2><p>vi. 证明是<br>vt. 证明；检验；显示</p>\n<h2 id=\"invaluable\"><a href=\"#invaluable\" class=\"headerlink\" title=\"invaluable\"></a>invaluable</h2><p>adj. 无价的；非常贵重的</p>\n<h2 id=\"endeavor\"><a href=\"#endeavor\" class=\"headerlink\" title=\"endeavor\"></a>endeavor</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/endeavour--_gb_1.mp3\">\n      </audio>\n>We’ll briefly review the basic concepts of object-oriented pro- gramming (OOP) and then delve into some advanced topics that should\nprove invaluable in any software engineering endeavor (and especially when\ncreating games).\nn. 努力；尽力（等于 endeavour）\nvi. 努力；尽力（等于 endeavour）\nvt. 努力；尽力（等于 endeavour）\n\n<h2 id=\"rusty\"><a href=\"#rusty\" class=\"headerlink\" title=\"rusty\"></a>rusty</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"https://ssl.gstatic.com/dictionary/static/sounds/oxford/rusty--_gb_1.mp3\">\n      </audio>\nadj. 生锈的，腐蚀的；铁锈色的，锈色的；迟钝的\n\n<h2 id=\"hollow-triangular\"><a href=\"#hollow-triangular\" class=\"headerlink\" title=\"hollow triangular\"></a>hollow triangular</h2><p>空心三角形</p>\n"},{"title":"LWRP官方说明","_content":"\n## Render Pipeline 的build-in 的流程\n\n![build-in流程](/img/1578468743022.png)\n\n## Command Buffer说明\n![Command Buffer说明](/img/1578468782581.png)\n\n## 语法说明\n\n>原先shader使用的cginc引入，改成Include官方的hlsl文件\n>材质变量需要CBuffer块套好，这样才能使用LWRP的batcher\n>可使用LWRP独有的宏声明采样器\n>属性名的变更：使用Attribute替代input, 使用Varying替代v2f\n>获取顶点信息的函数变更\n\n\n![LWRP的shader](/img/1578469710690.png)\n![单独申明的采样器](/img/1578469737158.png)\n![顶点函数](/img/1578469925626.png)\n![LWRP](/img/1578470183627.png)\n![手写LWRP](/img/1578470217523.png)\n![LWRP Batcher](/img/1578470471751.png)\n\n\n## SRP Batcher\n![SRP Batcher](/img/1578470502893.png)\n![不支持情况](/img/1578470577651.png)","source":"_posts/LWRP官方说明.md","raw":"---\ntitle: LWRP官方说明\ncategories:\n- Unity学习\ntags: \n- Unity学习\n---\n\n## Render Pipeline 的build-in 的流程\n\n![build-in流程](/img/1578468743022.png)\n\n## Command Buffer说明\n![Command Buffer说明](/img/1578468782581.png)\n\n## 语法说明\n\n>原先shader使用的cginc引入，改成Include官方的hlsl文件\n>材质变量需要CBuffer块套好，这样才能使用LWRP的batcher\n>可使用LWRP独有的宏声明采样器\n>属性名的变更：使用Attribute替代input, 使用Varying替代v2f\n>获取顶点信息的函数变更\n\n\n![LWRP的shader](/img/1578469710690.png)\n![单独申明的采样器](/img/1578469737158.png)\n![顶点函数](/img/1578469925626.png)\n![LWRP](/img/1578470183627.png)\n![手写LWRP](/img/1578470217523.png)\n![LWRP Batcher](/img/1578470471751.png)\n\n\n## SRP Batcher\n![SRP Batcher](/img/1578470502893.png)\n![不支持情况](/img/1578470577651.png)","slug":"LWRP官方说明","published":1,"date":"2020-09-08T03:23:20.715Z","updated":"2020-09-08T03:23:20.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0zr001h4wf0cukf7xng","content":"<h2 id=\"Render-Pipeline-的build-in-的流程\"><a href=\"#Render-Pipeline-的build-in-的流程\" class=\"headerlink\" title=\"Render Pipeline 的build-in 的流程\"></a>Render Pipeline 的build-in 的流程</h2><p><img src=\"/img/1578468743022.png\" alt=\"build-in流程\"></p>\n<h2 id=\"Command-Buffer说明\"><a href=\"#Command-Buffer说明\" class=\"headerlink\" title=\"Command Buffer说明\"></a>Command Buffer说明</h2><p><img src=\"/img/1578468782581.png\" alt=\"Command Buffer说明\"></p>\n<h2 id=\"语法说明\"><a href=\"#语法说明\" class=\"headerlink\" title=\"语法说明\"></a>语法说明</h2><blockquote>\n<p>原先shader使用的cginc引入，改成Include官方的hlsl文件<br>材质变量需要CBuffer块套好，这样才能使用LWRP的batcher<br>可使用LWRP独有的宏声明采样器<br>属性名的变更：使用Attribute替代input, 使用Varying替代v2f<br>获取顶点信息的函数变更</p>\n</blockquote>\n<p><img src=\"/img/1578469710690.png\" alt=\"LWRP的shader\"><br><img src=\"/img/1578469737158.png\" alt=\"单独申明的采样器\"><br><img src=\"/img/1578469925626.png\" alt=\"顶点函数\"><br><img src=\"/img/1578470183627.png\" alt=\"LWRP\"><br><img src=\"/img/1578470217523.png\" alt=\"手写LWRP\"><br><img src=\"/img/1578470471751.png\" alt=\"LWRP Batcher\"></p>\n<h2 id=\"SRP-Batcher\"><a href=\"#SRP-Batcher\" class=\"headerlink\" title=\"SRP Batcher\"></a>SRP Batcher</h2><p><img src=\"/img/1578470502893.png\" alt=\"SRP Batcher\"><br><img src=\"/img/1578470577651.png\" alt=\"不支持情况\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Render-Pipeline-的build-in-的流程\"><a href=\"#Render-Pipeline-的build-in-的流程\" class=\"headerlink\" title=\"Render Pipeline 的build-in 的流程\"></a>Render Pipeline 的build-in 的流程</h2><p><img src=\"/img/1578468743022.png\" alt=\"build-in流程\"></p>\n<h2 id=\"Command-Buffer说明\"><a href=\"#Command-Buffer说明\" class=\"headerlink\" title=\"Command Buffer说明\"></a>Command Buffer说明</h2><p><img src=\"/img/1578468782581.png\" alt=\"Command Buffer说明\"></p>\n<h2 id=\"语法说明\"><a href=\"#语法说明\" class=\"headerlink\" title=\"语法说明\"></a>语法说明</h2><blockquote>\n<p>原先shader使用的cginc引入，改成Include官方的hlsl文件<br>材质变量需要CBuffer块套好，这样才能使用LWRP的batcher<br>可使用LWRP独有的宏声明采样器<br>属性名的变更：使用Attribute替代input, 使用Varying替代v2f<br>获取顶点信息的函数变更</p>\n</blockquote>\n<p><img src=\"/img/1578469710690.png\" alt=\"LWRP的shader\"><br><img src=\"/img/1578469737158.png\" alt=\"单独申明的采样器\"><br><img src=\"/img/1578469925626.png\" alt=\"顶点函数\"><br><img src=\"/img/1578470183627.png\" alt=\"LWRP\"><br><img src=\"/img/1578470217523.png\" alt=\"手写LWRP\"><br><img src=\"/img/1578470471751.png\" alt=\"LWRP Batcher\"></p>\n<h2 id=\"SRP-Batcher\"><a href=\"#SRP-Batcher\" class=\"headerlink\" title=\"SRP Batcher\"></a>SRP Batcher</h2><p><img src=\"/img/1578470502893.png\" alt=\"SRP Batcher\"><br><img src=\"/img/1578470577651.png\" alt=\"不支持情况\"></p>\n"},{"title":"Linux与window常用指令","_content":"\n## linux启动关闭服务\n\n```shell\nps -ef|grep tomcat                        //查看所有进程\nkill -9 pid                               //关闭对应pid进程\ncd /root/DCIM/apache-tomcat-7.0.90/bin    //打开服务所在的文件夹\nls                                        //查看所有文件 显示除隐藏文件外所有文件及目录的名字\n./startup.sh                              //启动.sh文件\ntail -f ../logs/catalina.out              //查看指定文件夹里的日志\n \n \nls –a                                     //显示当前目录中的所有文件，包含隐藏文件\n```\n\n\n## windows 查看服务\n\n```\nsc query redis //查询redis的服务\n\nsc stop/start redis\nsc showid redis\nsc qc redis //查询信息\nsc enumdepend redis //查询依赖\n```","source":"_posts/Linux与window常用指令.md","raw":"---\ntitle: Linux与window常用指令\ntags: \n- linux\n- 指令\n---\n\n## linux启动关闭服务\n\n```shell\nps -ef|grep tomcat                        //查看所有进程\nkill -9 pid                               //关闭对应pid进程\ncd /root/DCIM/apache-tomcat-7.0.90/bin    //打开服务所在的文件夹\nls                                        //查看所有文件 显示除隐藏文件外所有文件及目录的名字\n./startup.sh                              //启动.sh文件\ntail -f ../logs/catalina.out              //查看指定文件夹里的日志\n \n \nls –a                                     //显示当前目录中的所有文件，包含隐藏文件\n```\n\n\n## windows 查看服务\n\n```\nsc query redis //查询redis的服务\n\nsc stop/start redis\nsc showid redis\nsc qc redis //查询信息\nsc enumdepend redis //查询依赖\n```","slug":"Linux与window常用指令","published":1,"date":"2020-09-08T03:23:20.715Z","updated":"2020-09-08T03:23:20.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh0zt001l4wf0ubeph1m7","content":"<h2 id=\"linux启动关闭服务\"><a href=\"#linux启动关闭服务\" class=\"headerlink\" title=\"linux启动关闭服务\"></a>linux启动关闭服务</h2><pre><code class=\"shell\">ps -ef|grep tomcat                        //查看所有进程\nkill -9 pid                               //关闭对应pid进程\ncd /root/DCIM/apache-tomcat-7.0.90/bin    //打开服务所在的文件夹\nls                                        //查看所有文件 显示除隐藏文件外所有文件及目录的名字\n./startup.sh                              //启动.sh文件\ntail -f ../logs/catalina.out              //查看指定文件夹里的日志\n\n\nls –a                                     //显示当前目录中的所有文件，包含隐藏文件</code></pre>\n<h2 id=\"windows-查看服务\"><a href=\"#windows-查看服务\" class=\"headerlink\" title=\"windows 查看服务\"></a>windows 查看服务</h2><pre><code>sc query redis //查询redis的服务\n\nsc stop/start redis\nsc showid redis\nsc qc redis //查询信息\nsc enumdepend redis //查询依赖</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"linux启动关闭服务\"><a href=\"#linux启动关闭服务\" class=\"headerlink\" title=\"linux启动关闭服务\"></a>linux启动关闭服务</h2><pre><code class=\"shell\">ps -ef|grep tomcat                        //查看所有进程\nkill -9 pid                               //关闭对应pid进程\ncd /root/DCIM/apache-tomcat-7.0.90/bin    //打开服务所在的文件夹\nls                                        //查看所有文件 显示除隐藏文件外所有文件及目录的名字\n./startup.sh                              //启动.sh文件\ntail -f ../logs/catalina.out              //查看指定文件夹里的日志\n\n\nls –a                                     //显示当前目录中的所有文件，包含隐藏文件</code></pre>\n<h2 id=\"windows-查看服务\"><a href=\"#windows-查看服务\" class=\"headerlink\" title=\"windows 查看服务\"></a>windows 查看服务</h2><pre><code>sc query redis //查询redis的服务\n\nsc stop/start redis\nsc showid redis\nsc qc redis //查询信息\nsc enumdepend redis //查询依赖</code></pre>"},{"title":"Python Core Programming Note 1","_content":"\n## Regular Expression\n![常用表达式](/img/1570674939333.png)\n![续](/img/1570674953248.png)\n\n## match() & search()\n\n```python\nimport re\nm = re.match('\\d','a541')\nif m is not None:\n    print(m.group())\nelse:\n    print(\"none found\")\n\t\n## none found\n\nimport re\nm = re.match('\\d','a541')\nif m is not None:\n    print(m.group())\nelse:\n    print(\"none found\")\n\t\n## 5\n```\n```\nimport re\nm = re.search('..[\\d]{1,3}','\\na51')\nif m is not None:\n    print(m.group())\nelse:\n    print(\"none found\")\n# . 匹配除\\n外的任意字符，其他如\\t,\\.都可以\n```\n\n## 分组\n\n```python\nimport re\nm = re.search('\\w+@(\\w+\\.)*(\\w+)*\\.com','aaa@aa.a.com')\nif m is not None:\n    print(m.group())\nelse:\n    print(\"none found\")\n```\n\n## sub() & subn()\n\n```python\n#使用函数作为参数\ndef repl_t(txt):\n    if txt.group(0) == '-':\n        return 'x'\n    elif txt.group(0) == '--':\n        return '-'\n    elif txt.group(0) == '-1':\n        return '\\\"good\\\"'\nm = re.subn('(-{1,2})\\d?',repl_t,\"d----asf-s-a-123\")\nprint(m)\n```\n\n### Regular Expression -> Split()\n\n```python\ndata = (\n 'Mountain View, CA 94040',\n 'Sunnyvale, CA',\n 'Los Altos, 94023',\n 'Cupertino 95014',\n 'Palo Alto CA',\n )\n\nfor d in data:\n     v = re.split(r\", |(?= (?:\\d{5}|[A-Z]{2})) \",d)\n     print(v)\n```\n\n### 扩展表达式\n// 前瞻：\nexp1(?=exp2) 查找exp2前面的exp1\n// 后顾：\n(?<=exp2)exp1 查找exp2后面的exp1\n// 负前瞻：\nexp1(?!exp2) 查找后面不是exp2的exp1\n// 负后顾：\n(?<!exp2)exp1 查找前面不是exp2的exp1\n\n要理解?:则需要理解捕获分组和非捕获分组的概念：\n\n> ()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)\n> (?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来\n\n\n```python\nm = re.findall(r'(?<!YES)yes','YESyes? YESYes . YESyesYES!! ')\nprint(m)\n\nm = re.sub('\\B(?=(?:\\d{3})+(?!\\d))',',',\"123456789\")\nprint(m)\n```\n\n?i ignorecase\n?m multi-line search\n?s dotall, 点号也可表示\\n\n?x 格式化正则中的空格\n?: 分组查询但不保存在结果中\n\n```python\nm = re.findall(r'(?m)(^th[\\w ]+)', \"\"\"\nThis line is the first,\nanother line,\nthat line, it's the best\n\"\"\")\n\nprint(m)\n```\n\n```python\nm = re.search(r'''(?x)\n \\((\\d{3})\\) # 区号\n [ ] # 空白符\n (\\d{3}) # 前缀\n - # 横线\n (\\d{4}) # 终点数字\n ''', '(800) 555-1212').group()\nprint(m)\n```\n\n```python\nm = re.findall(r'http://(?:\\w+\\.)*(\\w+\\.com)','http://google.com http://www.google.com http://code.google.com')\nprint(m)\n```\n\n### 贪婪与非贪婪\n一个方案是使用“非贪婪”操作符“?”。读者可以在“*”、“+”或者“?”之后使\n用该操作符。该操作符将要求正则表达式引擎匹配尽可能少的字符。\n\n```python\ndata = 'Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8'\npatt = '.+?(\\d+-\\d+-\\d+)'\nm = re.match(patt, data).group(1)\nprint(m)\n```","source":"_posts/Python Core Programming Note 1.md","raw":"---\ntitle: Python Core Programming Note 1\ncategories:\n- Python\ntags: \n- Python\n- Core Programming\n- Note\n---\n\n## Regular Expression\n![常用表达式](/img/1570674939333.png)\n![续](/img/1570674953248.png)\n\n## match() & search()\n\n```python\nimport re\nm = re.match('\\d','a541')\nif m is not None:\n    print(m.group())\nelse:\n    print(\"none found\")\n\t\n## none found\n\nimport re\nm = re.match('\\d','a541')\nif m is not None:\n    print(m.group())\nelse:\n    print(\"none found\")\n\t\n## 5\n```\n```\nimport re\nm = re.search('..[\\d]{1,3}','\\na51')\nif m is not None:\n    print(m.group())\nelse:\n    print(\"none found\")\n# . 匹配除\\n外的任意字符，其他如\\t,\\.都可以\n```\n\n## 分组\n\n```python\nimport re\nm = re.search('\\w+@(\\w+\\.)*(\\w+)*\\.com','aaa@aa.a.com')\nif m is not None:\n    print(m.group())\nelse:\n    print(\"none found\")\n```\n\n## sub() & subn()\n\n```python\n#使用函数作为参数\ndef repl_t(txt):\n    if txt.group(0) == '-':\n        return 'x'\n    elif txt.group(0) == '--':\n        return '-'\n    elif txt.group(0) == '-1':\n        return '\\\"good\\\"'\nm = re.subn('(-{1,2})\\d?',repl_t,\"d----asf-s-a-123\")\nprint(m)\n```\n\n### Regular Expression -> Split()\n\n```python\ndata = (\n 'Mountain View, CA 94040',\n 'Sunnyvale, CA',\n 'Los Altos, 94023',\n 'Cupertino 95014',\n 'Palo Alto CA',\n )\n\nfor d in data:\n     v = re.split(r\", |(?= (?:\\d{5}|[A-Z]{2})) \",d)\n     print(v)\n```\n\n### 扩展表达式\n// 前瞻：\nexp1(?=exp2) 查找exp2前面的exp1\n// 后顾：\n(?<=exp2)exp1 查找exp2后面的exp1\n// 负前瞻：\nexp1(?!exp2) 查找后面不是exp2的exp1\n// 负后顾：\n(?<!exp2)exp1 查找前面不是exp2的exp1\n\n要理解?:则需要理解捕获分组和非捕获分组的概念：\n\n> ()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)\n> (?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来\n\n\n```python\nm = re.findall(r'(?<!YES)yes','YESyes? YESYes . YESyesYES!! ')\nprint(m)\n\nm = re.sub('\\B(?=(?:\\d{3})+(?!\\d))',',',\"123456789\")\nprint(m)\n```\n\n?i ignorecase\n?m multi-line search\n?s dotall, 点号也可表示\\n\n?x 格式化正则中的空格\n?: 分组查询但不保存在结果中\n\n```python\nm = re.findall(r'(?m)(^th[\\w ]+)', \"\"\"\nThis line is the first,\nanother line,\nthat line, it's the best\n\"\"\")\n\nprint(m)\n```\n\n```python\nm = re.search(r'''(?x)\n \\((\\d{3})\\) # 区号\n [ ] # 空白符\n (\\d{3}) # 前缀\n - # 横线\n (\\d{4}) # 终点数字\n ''', '(800) 555-1212').group()\nprint(m)\n```\n\n```python\nm = re.findall(r'http://(?:\\w+\\.)*(\\w+\\.com)','http://google.com http://www.google.com http://code.google.com')\nprint(m)\n```\n\n### 贪婪与非贪婪\n一个方案是使用“非贪婪”操作符“?”。读者可以在“*”、“+”或者“?”之后使\n用该操作符。该操作符将要求正则表达式引擎匹配尽可能少的字符。\n\n```python\ndata = 'Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8'\npatt = '.+?(\\d+-\\d+-\\d+)'\nm = re.match(patt, data).group(1)\nprint(m)\n```","slug":"Python Core Programming Note 1","published":1,"date":"2020-09-08T03:23:20.715Z","updated":"2020-09-08T03:23:20.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh101001o4wf0peev19vl","content":"<h2 id=\"Regular-Expression\"><a href=\"#Regular-Expression\" class=\"headerlink\" title=\"Regular Expression\"></a>Regular Expression</h2><p><img src=\"/img/1570674939333.png\" alt=\"常用表达式\"><br><img src=\"/img/1570674953248.png\" alt=\"续\"></p>\n<h2 id=\"match-amp-search\"><a href=\"#match-amp-search\" class=\"headerlink\" title=\"match() &amp; search()\"></a>match() &amp; search()</h2><pre><code class=\"python\">import re\nm = re.match(&#39;\\d&#39;,&#39;a541&#39;)\nif m is not None:\n    print(m.group())\nelse:\n    print(&quot;none found&quot;)\n\n## none found\n\nimport re\nm = re.match(&#39;\\d&#39;,&#39;a541&#39;)\nif m is not None:\n    print(m.group())\nelse:\n    print(&quot;none found&quot;)\n\n## 5</code></pre>\n<pre><code>import re\nm = re.search(&#39;..[\\d]{1,3}&#39;,&#39;\\na51&#39;)\nif m is not None:\n    print(m.group())\nelse:\n    print(&quot;none found&quot;)\n# . 匹配除\\n外的任意字符，其他如\\t,\\.都可以</code></pre><h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><pre><code class=\"python\">import re\nm = re.search(&#39;\\w+@(\\w+\\.)*(\\w+)*\\.com&#39;,&#39;aaa@aa.a.com&#39;)\nif m is not None:\n    print(m.group())\nelse:\n    print(&quot;none found&quot;)</code></pre>\n<h2 id=\"sub-amp-subn\"><a href=\"#sub-amp-subn\" class=\"headerlink\" title=\"sub() &amp; subn()\"></a>sub() &amp; subn()</h2><pre><code class=\"python\">#使用函数作为参数\ndef repl_t(txt):\n    if txt.group(0) == &#39;-&#39;:\n        return &#39;x&#39;\n    elif txt.group(0) == &#39;--&#39;:\n        return &#39;-&#39;\n    elif txt.group(0) == &#39;-1&#39;:\n        return &#39;\\&quot;good\\&quot;&#39;\nm = re.subn(&#39;(-{1,2})\\d?&#39;,repl_t,&quot;d----asf-s-a-123&quot;)\nprint(m)</code></pre>\n<h3 id=\"Regular-Expression-gt-Split\"><a href=\"#Regular-Expression-gt-Split\" class=\"headerlink\" title=\"Regular Expression -&gt; Split()\"></a>Regular Expression -&gt; Split()</h3><pre><code class=\"python\">data = (\n &#39;Mountain View, CA 94040&#39;,\n &#39;Sunnyvale, CA&#39;,\n &#39;Los Altos, 94023&#39;,\n &#39;Cupertino 95014&#39;,\n &#39;Palo Alto CA&#39;,\n )\n\nfor d in data:\n     v = re.split(r&quot;, |(?= (?:\\d{5}|[A-Z]{2})) &quot;,d)\n     print(v)</code></pre>\n<h3 id=\"扩展表达式\"><a href=\"#扩展表达式\" class=\"headerlink\" title=\"扩展表达式\"></a>扩展表达式</h3><p>// 前瞻：<br>exp1(?=exp2) 查找exp2前面的exp1<br>// 后顾：<br>(?&lt;=exp2)exp1 查找exp2后面的exp1<br>// 负前瞻：<br>exp1(?!exp2) 查找后面不是exp2的exp1<br>// 负后顾：<br>(?&lt;!exp2)exp1 查找前面不是exp2的exp1</p>\n<p>要理解?:则需要理解捕获分组和非捕获分组的概念：</p>\n<blockquote>\n<p>()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)<br>(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来</p>\n</blockquote>\n<pre><code class=\"python\">m = re.findall(r&#39;(?&lt;!YES)yes&#39;,&#39;YESyes? YESYes . YESyesYES!! &#39;)\nprint(m)\n\nm = re.sub(&#39;\\B(?=(?:\\d{3})+(?!\\d))&#39;,&#39;,&#39;,&quot;123456789&quot;)\nprint(m)</code></pre>\n<p>?i ignorecase<br>?m multi-line search<br>?s dotall, 点号也可表示\\n<br>?x 格式化正则中的空格<br>?: 分组查询但不保存在结果中</p>\n<pre><code class=\"python\">m = re.findall(r&#39;(?m)(^th[\\w ]+)&#39;, &quot;&quot;&quot;\nThis line is the first,\nanother line,\nthat line, it&#39;s the best\n&quot;&quot;&quot;)\n\nprint(m)</code></pre>\n<pre><code class=\"python\">m = re.search(r&#39;&#39;&#39;(?x)\n \\((\\d{3})\\) # 区号\n [ ] # 空白符\n (\\d{3}) # 前缀\n - # 横线\n (\\d{4}) # 终点数字\n &#39;&#39;&#39;, &#39;(800) 555-1212&#39;).group()\nprint(m)</code></pre>\n<pre><code class=\"python\">m = re.findall(r&#39;http://(?:\\w+\\.)*(\\w+\\.com)&#39;,&#39;http://google.com http://www.google.com http://code.google.com&#39;)\nprint(m)</code></pre>\n<h3 id=\"贪婪与非贪婪\"><a href=\"#贪婪与非贪婪\" class=\"headerlink\" title=\"贪婪与非贪婪\"></a>贪婪与非贪婪</h3><p>一个方案是使用“非贪婪”操作符“?”。读者可以在“*”、“+”或者“?”之后使<br>用该操作符。该操作符将要求正则表达式引擎匹配尽可能少的字符。</p>\n<pre><code class=\"python\">data = &#39;Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8&#39;\npatt = &#39;.+?(\\d+-\\d+-\\d+)&#39;\nm = re.match(patt, data).group(1)\nprint(m)</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Regular-Expression\"><a href=\"#Regular-Expression\" class=\"headerlink\" title=\"Regular Expression\"></a>Regular Expression</h2><p><img src=\"/img/1570674939333.png\" alt=\"常用表达式\"><br><img src=\"/img/1570674953248.png\" alt=\"续\"></p>\n<h2 id=\"match-amp-search\"><a href=\"#match-amp-search\" class=\"headerlink\" title=\"match() &amp; search()\"></a>match() &amp; search()</h2><pre><code class=\"python\">import re\nm = re.match(&#39;\\d&#39;,&#39;a541&#39;)\nif m is not None:\n    print(m.group())\nelse:\n    print(&quot;none found&quot;)\n\n## none found\n\nimport re\nm = re.match(&#39;\\d&#39;,&#39;a541&#39;)\nif m is not None:\n    print(m.group())\nelse:\n    print(&quot;none found&quot;)\n\n## 5</code></pre>\n<pre><code>import re\nm = re.search(&#39;..[\\d]{1,3}&#39;,&#39;\\na51&#39;)\nif m is not None:\n    print(m.group())\nelse:\n    print(&quot;none found&quot;)\n# . 匹配除\\n外的任意字符，其他如\\t,\\.都可以</code></pre><h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><pre><code class=\"python\">import re\nm = re.search(&#39;\\w+@(\\w+\\.)*(\\w+)*\\.com&#39;,&#39;aaa@aa.a.com&#39;)\nif m is not None:\n    print(m.group())\nelse:\n    print(&quot;none found&quot;)</code></pre>\n<h2 id=\"sub-amp-subn\"><a href=\"#sub-amp-subn\" class=\"headerlink\" title=\"sub() &amp; subn()\"></a>sub() &amp; subn()</h2><pre><code class=\"python\">#使用函数作为参数\ndef repl_t(txt):\n    if txt.group(0) == &#39;-&#39;:\n        return &#39;x&#39;\n    elif txt.group(0) == &#39;--&#39;:\n        return &#39;-&#39;\n    elif txt.group(0) == &#39;-1&#39;:\n        return &#39;\\&quot;good\\&quot;&#39;\nm = re.subn(&#39;(-{1,2})\\d?&#39;,repl_t,&quot;d----asf-s-a-123&quot;)\nprint(m)</code></pre>\n<h3 id=\"Regular-Expression-gt-Split\"><a href=\"#Regular-Expression-gt-Split\" class=\"headerlink\" title=\"Regular Expression -&gt; Split()\"></a>Regular Expression -&gt; Split()</h3><pre><code class=\"python\">data = (\n &#39;Mountain View, CA 94040&#39;,\n &#39;Sunnyvale, CA&#39;,\n &#39;Los Altos, 94023&#39;,\n &#39;Cupertino 95014&#39;,\n &#39;Palo Alto CA&#39;,\n )\n\nfor d in data:\n     v = re.split(r&quot;, |(?= (?:\\d{5}|[A-Z]{2})) &quot;,d)\n     print(v)</code></pre>\n<h3 id=\"扩展表达式\"><a href=\"#扩展表达式\" class=\"headerlink\" title=\"扩展表达式\"></a>扩展表达式</h3><p>// 前瞻：<br>exp1(?=exp2) 查找exp2前面的exp1<br>// 后顾：<br>(?&lt;=exp2)exp1 查找exp2后面的exp1<br>// 负前瞻：<br>exp1(?!exp2) 查找后面不是exp2的exp1<br>// 负后顾：<br>(?&lt;!exp2)exp1 查找前面不是exp2的exp1</p>\n<p>要理解?:则需要理解捕获分组和非捕获分组的概念：</p>\n<blockquote>\n<p>()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)<br>(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来</p>\n</blockquote>\n<pre><code class=\"python\">m = re.findall(r&#39;(?&lt;!YES)yes&#39;,&#39;YESyes? YESYes . YESyesYES!! &#39;)\nprint(m)\n\nm = re.sub(&#39;\\B(?=(?:\\d{3})+(?!\\d))&#39;,&#39;,&#39;,&quot;123456789&quot;)\nprint(m)</code></pre>\n<p>?i ignorecase<br>?m multi-line search<br>?s dotall, 点号也可表示\\n<br>?x 格式化正则中的空格<br>?: 分组查询但不保存在结果中</p>\n<pre><code class=\"python\">m = re.findall(r&#39;(?m)(^th[\\w ]+)&#39;, &quot;&quot;&quot;\nThis line is the first,\nanother line,\nthat line, it&#39;s the best\n&quot;&quot;&quot;)\n\nprint(m)</code></pre>\n<pre><code class=\"python\">m = re.search(r&#39;&#39;&#39;(?x)\n \\((\\d{3})\\) # 区号\n [ ] # 空白符\n (\\d{3}) # 前缀\n - # 横线\n (\\d{4}) # 终点数字\n &#39;&#39;&#39;, &#39;(800) 555-1212&#39;).group()\nprint(m)</code></pre>\n<pre><code class=\"python\">m = re.findall(r&#39;http://(?:\\w+\\.)*(\\w+\\.com)&#39;,&#39;http://google.com http://www.google.com http://code.google.com&#39;)\nprint(m)</code></pre>\n<h3 id=\"贪婪与非贪婪\"><a href=\"#贪婪与非贪婪\" class=\"headerlink\" title=\"贪婪与非贪婪\"></a>贪婪与非贪婪</h3><p>一个方案是使用“非贪婪”操作符“?”。读者可以在“*”、“+”或者“?”之后使<br>用该操作符。该操作符将要求正则表达式引擎匹配尽可能少的字符。</p>\n<pre><code class=\"python\">data = &#39;Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8&#39;\npatt = &#39;.+?(\\d+-\\d+-\\d+)&#39;\nm = re.match(patt, data).group(1)\nprint(m)</code></pre>\n"},{"title":"Jenkins打包事项","_content":"\n# Jenkins 打包说明\n\n\n\n## 脚本准备\n\n### 自动化脚本\n\n> 1. AutoCi.rar文件\n> 2. 将文件解压至与Assets同级目录即可\n\n### Unity脚本\n\n> 1. Editor 目录下创建类BundleMakerUtil.cs， 添加如下函数：\n>\n>    ```C#\n>      public static bool HasRawArg(string name)\n>      {\n>          var args = System.Environment.GetCommandLineArgs();\n>          for (int i = 0; i < args.Length; i++)\n>          {\n>              if (args[i].Trim() == name)\n>              {\n>                  return true;\n>              }\n>          }\n>          return false;\n>      }\n>    \n>    ```\n>\n>    \n>\n> 2. Editor目录下创建类BuilderMenu.cs　使用命名空间SGameBundleMaker. （也可自定义，但需要修改auto_ci.py里的配置）\n>\n> 3. BuilderMenu.cs类中创建 build_bundle_for_ci() 静态函数，示例：\n\n ```c#\n   public static void build_bundle_for_ci()\n   {\n   \t\t //... Code for build build \n          AssetBundleManifest bundle_manifest = null;\n            try\n            {\n                bundle_manifest = BuildPipeline.BuildAssetBundles(BundleMaker.BUNDLE_DIR, all_build, BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions.ChunkBasedCompression, EditorUserBuildSettings.activeBuildTarget);\n            }\n            catch (Exception e)\n            {\n                error_code_ = BundleMakerErrorCode.UNKNOWN;\n                Debug.LogError(\"BuildAssetBundles Error: \" + e.Message);\n                return;\n            }\n   }\n ```\n\n\n\n> 4. BuilderMenu.cs中创建 build_for_ci() 静态函数\n>\n>    注：-proj, -path 也可修改，需要与auto_ci.py中代码对应\n>\n>    示例如下:\n\n```c#\npublic static void build_for_ci()\n{\n    //！Builder类需要自己实现，具体作为对应不同平台打包用\n    string build_path = string.Empty;\n    #if UNITY_ANDROID\n        //是否输出项目文件或APK的标识\n        bool is_proj = BundleMakerUtil.HasRawArg(\"-proj\");\n    Debug.Log(\"build_for_ci, is_proj: \" + is_proj);\n    Builder.is_android_proj = is_proj;\n    if(Builder.is_android_proj){\n        build_path = Const.PROJECT_DIR + \"autopack/android/XGameProject\";\n    }else{\n        build_path = Const.PROJECT_DIR + \"autopack/android/XGame.apk\";\n    }\n    #elif UNITY_IPHONE\n        build_path = BundleMakerUtil.GetArg(\"-path\");\n    if (string.IsNullOrEmpty(build_path))\n    {\n        Debug.LogError(\"------build path null\");\n        return;\n    }\n    Debug.Log(\"build_for_ci, build_path: \" + build_path);\n    //build_path = string.Format(\"{0}autopack/ios/XcodeProject{1}\", new DirectoryInfo(Const.PROJECT_DIR).Parent.FullName, System.DateTime.Now.ToString(\"yyyy-MM-dd--HH-mm-ss\"));\n    #else\n        build_path = Const.PROJECT_DIR + \"autopack/win32/XGame.exe\";\n    #endif\n        //是否是debug版本的标识\n        bool is_debug = BundleMakerUtil.HasRawArg(\"-debug\");\n    Builder.is_debug_build_ = is_debug; \n    Builder.build_package(build_path, true);\n}\n```\n\n\n\n## Jenkins配置\n\n> 1. Jenkins安装 Powershell插件，在 插件列表中搜索到这个：\n\n<img src=\"./images/1571217538404.png\" alt=\"1571217538404\" style=\"zoom:100%;\" />\n\n> 2. 安装完后，重启下Jetkins\n> 3. 在项目配置->构建 里选择使用Windows PowerShell:\n\n<img src=\"./images/1571217610540.png\" alt=\"1571217610540\" style=\"zoom:100%;\" />\n\n> 4. 添加如下配置在Command格内：\n\n```powershell\necho ${ENV:WORKSPACE}\ncd ${ENV:WORKSPACE}/Unity\n./AutoCi/autobuild_android.ps1\n```\n\n<img src=\"./images/1571217788247.png\" alt=\"1571217788247\" style=\"zoom:100%;\" />\n\n\n\n## 打什么样的包？  设置环境变量\n\n> 1. 找到Jenkins环境变量设置\n>\n>    **Manage Jenkins**   ->  **Configure System**\n\n\n\n![1571216524617](./images/1571216524617.png)\n\n<img src=\"./images/1571216565243.png\" alt=\"1571216565243\" style=\"zoom:67%;\" />\n\n\n\n> 2.  打 Apk \n\n设置 IsApk 为 true\n\n\n\n> 3. 打 aar到平台\n\n设置 IsApk 为false或其他\n\n\n\n> 4. 带Debug的包\n\n设置 IsDebug为true,  当不为true时则默认为relase包\n\n\n\n## CI的执行脚本说明\n\n> 1. auto_ci.py -仅打aar到平台需要\n>    * 修改manifest.xml文件，去掉intent-filter\n>    * 修改build.gradle文件，设置为library，去掉applicationId，设置gradle版本，添加jcenter(),google()到 all projects块\n> 2. jksdk_util.py -上传aar到平台\n>    \n>    * 需要打开文件，更改下id为对应项目\n>    \n>    * 上传到平台，需要改成指定格式的名字： \n>    \n>        游戏名称-框架类型-debug/release-version.出包号.aar\n\n\n\n## 注意事项\n\n> 1. Powershell 脚本访问Jenkins环境变量记得加 **ENV:** 前缀\n> 2. 在build.gradle加入的all projects块的代码，是由于gradle有时会找不到相关的jar包，又不会启动自动下载导致\n\n","source":"_posts/Jenkins打包事项.md","raw":"---\ntitle: Jenkins打包事项\ncategories:\n- 工作相关\ntags: \n- Jenkins\n- CI\n---\n\n# Jenkins 打包说明\n\n\n\n## 脚本准备\n\n### 自动化脚本\n\n> 1. AutoCi.rar文件\n> 2. 将文件解压至与Assets同级目录即可\n\n### Unity脚本\n\n> 1. Editor 目录下创建类BundleMakerUtil.cs， 添加如下函数：\n>\n>    ```C#\n>      public static bool HasRawArg(string name)\n>      {\n>          var args = System.Environment.GetCommandLineArgs();\n>          for (int i = 0; i < args.Length; i++)\n>          {\n>              if (args[i].Trim() == name)\n>              {\n>                  return true;\n>              }\n>          }\n>          return false;\n>      }\n>    \n>    ```\n>\n>    \n>\n> 2. Editor目录下创建类BuilderMenu.cs　使用命名空间SGameBundleMaker. （也可自定义，但需要修改auto_ci.py里的配置）\n>\n> 3. BuilderMenu.cs类中创建 build_bundle_for_ci() 静态函数，示例：\n\n ```c#\n   public static void build_bundle_for_ci()\n   {\n   \t\t //... Code for build build \n          AssetBundleManifest bundle_manifest = null;\n            try\n            {\n                bundle_manifest = BuildPipeline.BuildAssetBundles(BundleMaker.BUNDLE_DIR, all_build, BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions.ChunkBasedCompression, EditorUserBuildSettings.activeBuildTarget);\n            }\n            catch (Exception e)\n            {\n                error_code_ = BundleMakerErrorCode.UNKNOWN;\n                Debug.LogError(\"BuildAssetBundles Error: \" + e.Message);\n                return;\n            }\n   }\n ```\n\n\n\n> 4. BuilderMenu.cs中创建 build_for_ci() 静态函数\n>\n>    注：-proj, -path 也可修改，需要与auto_ci.py中代码对应\n>\n>    示例如下:\n\n```c#\npublic static void build_for_ci()\n{\n    //！Builder类需要自己实现，具体作为对应不同平台打包用\n    string build_path = string.Empty;\n    #if UNITY_ANDROID\n        //是否输出项目文件或APK的标识\n        bool is_proj = BundleMakerUtil.HasRawArg(\"-proj\");\n    Debug.Log(\"build_for_ci, is_proj: \" + is_proj);\n    Builder.is_android_proj = is_proj;\n    if(Builder.is_android_proj){\n        build_path = Const.PROJECT_DIR + \"autopack/android/XGameProject\";\n    }else{\n        build_path = Const.PROJECT_DIR + \"autopack/android/XGame.apk\";\n    }\n    #elif UNITY_IPHONE\n        build_path = BundleMakerUtil.GetArg(\"-path\");\n    if (string.IsNullOrEmpty(build_path))\n    {\n        Debug.LogError(\"------build path null\");\n        return;\n    }\n    Debug.Log(\"build_for_ci, build_path: \" + build_path);\n    //build_path = string.Format(\"{0}autopack/ios/XcodeProject{1}\", new DirectoryInfo(Const.PROJECT_DIR).Parent.FullName, System.DateTime.Now.ToString(\"yyyy-MM-dd--HH-mm-ss\"));\n    #else\n        build_path = Const.PROJECT_DIR + \"autopack/win32/XGame.exe\";\n    #endif\n        //是否是debug版本的标识\n        bool is_debug = BundleMakerUtil.HasRawArg(\"-debug\");\n    Builder.is_debug_build_ = is_debug; \n    Builder.build_package(build_path, true);\n}\n```\n\n\n\n## Jenkins配置\n\n> 1. Jenkins安装 Powershell插件，在 插件列表中搜索到这个：\n\n<img src=\"./images/1571217538404.png\" alt=\"1571217538404\" style=\"zoom:100%;\" />\n\n> 2. 安装完后，重启下Jetkins\n> 3. 在项目配置->构建 里选择使用Windows PowerShell:\n\n<img src=\"./images/1571217610540.png\" alt=\"1571217610540\" style=\"zoom:100%;\" />\n\n> 4. 添加如下配置在Command格内：\n\n```powershell\necho ${ENV:WORKSPACE}\ncd ${ENV:WORKSPACE}/Unity\n./AutoCi/autobuild_android.ps1\n```\n\n<img src=\"./images/1571217788247.png\" alt=\"1571217788247\" style=\"zoom:100%;\" />\n\n\n\n## 打什么样的包？  设置环境变量\n\n> 1. 找到Jenkins环境变量设置\n>\n>    **Manage Jenkins**   ->  **Configure System**\n\n\n\n![1571216524617](./images/1571216524617.png)\n\n<img src=\"./images/1571216565243.png\" alt=\"1571216565243\" style=\"zoom:67%;\" />\n\n\n\n> 2.  打 Apk \n\n设置 IsApk 为 true\n\n\n\n> 3. 打 aar到平台\n\n设置 IsApk 为false或其他\n\n\n\n> 4. 带Debug的包\n\n设置 IsDebug为true,  当不为true时则默认为relase包\n\n\n\n## CI的执行脚本说明\n\n> 1. auto_ci.py -仅打aar到平台需要\n>    * 修改manifest.xml文件，去掉intent-filter\n>    * 修改build.gradle文件，设置为library，去掉applicationId，设置gradle版本，添加jcenter(),google()到 all projects块\n> 2. jksdk_util.py -上传aar到平台\n>    \n>    * 需要打开文件，更改下id为对应项目\n>    \n>    * 上传到平台，需要改成指定格式的名字： \n>    \n>        游戏名称-框架类型-debug/release-version.出包号.aar\n\n\n\n## 注意事项\n\n> 1. Powershell 脚本访问Jenkins环境变量记得加 **ENV:** 前缀\n> 2. 在build.gradle加入的all projects块的代码，是由于gradle有时会找不到相关的jar包，又不会启动自动下载导致\n\n","slug":"Jenkins打包事项","published":1,"date":"2020-09-08T03:23:20.715Z","updated":"2020-09-08T03:23:20.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh103001s4wf0bafr6iq1","content":"<h1 id=\"Jenkins-打包说明\"><a href=\"#Jenkins-打包说明\" class=\"headerlink\" title=\"Jenkins 打包说明\"></a>Jenkins 打包说明</h1><h2 id=\"脚本准备\"><a href=\"#脚本准备\" class=\"headerlink\" title=\"脚本准备\"></a>脚本准备</h2><h3 id=\"自动化脚本\"><a href=\"#自动化脚本\" class=\"headerlink\" title=\"自动化脚本\"></a>自动化脚本</h3><blockquote>\n<ol>\n<li>AutoCi.rar文件</li>\n<li>将文件解压至与Assets同级目录即可</li>\n</ol>\n</blockquote>\n<h3 id=\"Unity脚本\"><a href=\"#Unity脚本\" class=\"headerlink\" title=\"Unity脚本\"></a>Unity脚本</h3><blockquote>\n<ol>\n<li><p>Editor 目录下创建类BundleMakerUtil.cs， 添加如下函数：</p>\n<pre><code class=\"C#\">  public static bool HasRawArg(string name)\n  {\n      var args = System.Environment.GetCommandLineArgs();\n      for (int i = 0; i &lt; args.Length; i++)\n      {\n          if (args[i].Trim() == name)\n          {\n              return true;\n          }\n      }\n      return false;\n  }\n</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>Editor目录下创建类BuilderMenu.cs　使用命名空间SGameBundleMaker. （也可自定义，但需要修改auto_ci.py里的配置）</p>\n</li>\n<li><p>BuilderMenu.cs类中创建 build_bundle_for_ci() 静态函数，示例：</p>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"c#\">   public static void build_bundle_for_ci()\n   {\n            //... Code for build build \n          AssetBundleManifest bundle_manifest = null;\n            try\n            {\n                bundle_manifest = BuildPipeline.BuildAssetBundles(BundleMaker.BUNDLE_DIR, all_build, BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions.ChunkBasedCompression, EditorUserBuildSettings.activeBuildTarget);\n            }\n            catch (Exception e)\n            {\n                error_code_ = BundleMakerErrorCode.UNKNOWN;\n                Debug.LogError(&quot;BuildAssetBundles Error: &quot; + e.Message);\n                return;\n            }\n   }</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li><p>BuilderMenu.cs中创建 build_for_ci() 静态函数</p>\n<p>注：-proj, -path 也可修改，需要与auto_ci.py中代码对应</p>\n<p>示例如下:</p>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"c#\">public static void build_for_ci()\n{\n    //！Builder类需要自己实现，具体作为对应不同平台打包用\n    string build_path = string.Empty;\n    #if UNITY_ANDROID\n        //是否输出项目文件或APK的标识\n        bool is_proj = BundleMakerUtil.HasRawArg(&quot;-proj&quot;);\n    Debug.Log(&quot;build_for_ci, is_proj: &quot; + is_proj);\n    Builder.is_android_proj = is_proj;\n    if(Builder.is_android_proj){\n        build_path = Const.PROJECT_DIR + &quot;autopack/android/XGameProject&quot;;\n    }else{\n        build_path = Const.PROJECT_DIR + &quot;autopack/android/XGame.apk&quot;;\n    }\n    #elif UNITY_IPHONE\n        build_path = BundleMakerUtil.GetArg(&quot;-path&quot;);\n    if (string.IsNullOrEmpty(build_path))\n    {\n        Debug.LogError(&quot;------build path null&quot;);\n        return;\n    }\n    Debug.Log(&quot;build_for_ci, build_path: &quot; + build_path);\n    //build_path = string.Format(&quot;{0}autopack/ios/XcodeProject{1}&quot;, new DirectoryInfo(Const.PROJECT_DIR).Parent.FullName, System.DateTime.Now.ToString(&quot;yyyy-MM-dd--HH-mm-ss&quot;));\n    #else\n        build_path = Const.PROJECT_DIR + &quot;autopack/win32/XGame.exe&quot;;\n    #endif\n        //是否是debug版本的标识\n        bool is_debug = BundleMakerUtil.HasRawArg(&quot;-debug&quot;);\n    Builder.is_debug_build_ = is_debug; \n    Builder.build_package(build_path, true);\n}</code></pre>\n<h2 id=\"Jenkins配置\"><a href=\"#Jenkins配置\" class=\"headerlink\" title=\"Jenkins配置\"></a>Jenkins配置</h2><blockquote>\n<ol>\n<li>Jenkins安装 Powershell插件，在 插件列表中搜索到这个：</li>\n</ol>\n</blockquote>\n<img src=\"./images/1571217538404.png\" alt=\"1571217538404\" style=\"zoom:100%;\" />\n\n<blockquote>\n<ol start=\"2\">\n<li>安装完后，重启下Jetkins</li>\n<li>在项目配置-&gt;构建 里选择使用Windows PowerShell:</li>\n</ol>\n</blockquote>\n<img src=\"./images/1571217610540.png\" alt=\"1571217610540\" style=\"zoom:100%;\" />\n\n<blockquote>\n<ol start=\"4\">\n<li>添加如下配置在Command格内：</li>\n</ol>\n</blockquote>\n<pre><code class=\"powershell\">echo ${ENV:WORKSPACE}\ncd ${ENV:WORKSPACE}/Unity\n./AutoCi/autobuild_android.ps1</code></pre>\n<img src=\"./images/1571217788247.png\" alt=\"1571217788247\" style=\"zoom:100%;\" />\n\n\n\n<h2 id=\"打什么样的包？-设置环境变量\"><a href=\"#打什么样的包？-设置环境变量\" class=\"headerlink\" title=\"打什么样的包？  设置环境变量\"></a>打什么样的包？  设置环境变量</h2><blockquote>\n<ol>\n<li><p>找到Jenkins环境变量设置</p>\n<p><strong>Manage Jenkins</strong>   -&gt;  <strong>Configure System</strong></p>\n</li>\n</ol>\n</blockquote>\n<p><img src=\"./images/1571216524617.png\" alt=\"1571216524617\"></p>\n<img src=\"./images/1571216565243.png\" alt=\"1571216565243\" style=\"zoom:67%;\" />\n\n\n\n<blockquote>\n<ol start=\"2\">\n<li>打 Apk </li>\n</ol>\n</blockquote>\n<p>设置 IsApk 为 true</p>\n<blockquote>\n<ol start=\"3\">\n<li>打 aar到平台</li>\n</ol>\n</blockquote>\n<p>设置 IsApk 为false或其他</p>\n<blockquote>\n<ol start=\"4\">\n<li>带Debug的包</li>\n</ol>\n</blockquote>\n<p>设置 IsDebug为true,  当不为true时则默认为relase包</p>\n<h2 id=\"CI的执行脚本说明\"><a href=\"#CI的执行脚本说明\" class=\"headerlink\" title=\"CI的执行脚本说明\"></a>CI的执行脚本说明</h2><blockquote>\n<ol>\n<li><p>auto_ci.py -仅打aar到平台需要</p>\n<ul>\n<li>修改manifest.xml文件，去掉intent-filter</li>\n<li>修改build.gradle文件，设置为library，去掉applicationId，设置gradle版本，添加jcenter(),google()到 all projects块</li>\n</ul>\n</li>\n<li><p>jksdk_util.py -上传aar到平台</p>\n<ul>\n<li><p>需要打开文件，更改下id为对应项目</p>\n</li>\n<li><p>上传到平台，需要改成指定格式的名字： </p>\n<p>  游戏名称-框架类型-debug/release-version.出包号.aar</p>\n</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><blockquote>\n<ol>\n<li>Powershell 脚本访问Jenkins环境变量记得加 <strong>ENV:</strong> 前缀</li>\n<li>在build.gradle加入的all projects块的代码，是由于gradle有时会找不到相关的jar包，又不会启动自动下载导致</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Jenkins-打包说明\"><a href=\"#Jenkins-打包说明\" class=\"headerlink\" title=\"Jenkins 打包说明\"></a>Jenkins 打包说明</h1><h2 id=\"脚本准备\"><a href=\"#脚本准备\" class=\"headerlink\" title=\"脚本准备\"></a>脚本准备</h2><h3 id=\"自动化脚本\"><a href=\"#自动化脚本\" class=\"headerlink\" title=\"自动化脚本\"></a>自动化脚本</h3><blockquote>\n<ol>\n<li>AutoCi.rar文件</li>\n<li>将文件解压至与Assets同级目录即可</li>\n</ol>\n</blockquote>\n<h3 id=\"Unity脚本\"><a href=\"#Unity脚本\" class=\"headerlink\" title=\"Unity脚本\"></a>Unity脚本</h3><blockquote>\n<ol>\n<li><p>Editor 目录下创建类BundleMakerUtil.cs， 添加如下函数：</p>\n<pre><code class=\"C#\">  public static bool HasRawArg(string name)\n  {\n      var args = System.Environment.GetCommandLineArgs();\n      for (int i = 0; i &lt; args.Length; i++)\n      {\n          if (args[i].Trim() == name)\n          {\n              return true;\n          }\n      }\n      return false;\n  }\n</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>Editor目录下创建类BuilderMenu.cs　使用命名空间SGameBundleMaker. （也可自定义，但需要修改auto_ci.py里的配置）</p>\n</li>\n<li><p>BuilderMenu.cs类中创建 build_bundle_for_ci() 静态函数，示例：</p>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"c#\">   public static void build_bundle_for_ci()\n   {\n            //... Code for build build \n          AssetBundleManifest bundle_manifest = null;\n            try\n            {\n                bundle_manifest = BuildPipeline.BuildAssetBundles(BundleMaker.BUNDLE_DIR, all_build, BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions.ChunkBasedCompression, EditorUserBuildSettings.activeBuildTarget);\n            }\n            catch (Exception e)\n            {\n                error_code_ = BundleMakerErrorCode.UNKNOWN;\n                Debug.LogError(&quot;BuildAssetBundles Error: &quot; + e.Message);\n                return;\n            }\n   }</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li><p>BuilderMenu.cs中创建 build_for_ci() 静态函数</p>\n<p>注：-proj, -path 也可修改，需要与auto_ci.py中代码对应</p>\n<p>示例如下:</p>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"c#\">public static void build_for_ci()\n{\n    //！Builder类需要自己实现，具体作为对应不同平台打包用\n    string build_path = string.Empty;\n    #if UNITY_ANDROID\n        //是否输出项目文件或APK的标识\n        bool is_proj = BundleMakerUtil.HasRawArg(&quot;-proj&quot;);\n    Debug.Log(&quot;build_for_ci, is_proj: &quot; + is_proj);\n    Builder.is_android_proj = is_proj;\n    if(Builder.is_android_proj){\n        build_path = Const.PROJECT_DIR + &quot;autopack/android/XGameProject&quot;;\n    }else{\n        build_path = Const.PROJECT_DIR + &quot;autopack/android/XGame.apk&quot;;\n    }\n    #elif UNITY_IPHONE\n        build_path = BundleMakerUtil.GetArg(&quot;-path&quot;);\n    if (string.IsNullOrEmpty(build_path))\n    {\n        Debug.LogError(&quot;------build path null&quot;);\n        return;\n    }\n    Debug.Log(&quot;build_for_ci, build_path: &quot; + build_path);\n    //build_path = string.Format(&quot;{0}autopack/ios/XcodeProject{1}&quot;, new DirectoryInfo(Const.PROJECT_DIR).Parent.FullName, System.DateTime.Now.ToString(&quot;yyyy-MM-dd--HH-mm-ss&quot;));\n    #else\n        build_path = Const.PROJECT_DIR + &quot;autopack/win32/XGame.exe&quot;;\n    #endif\n        //是否是debug版本的标识\n        bool is_debug = BundleMakerUtil.HasRawArg(&quot;-debug&quot;);\n    Builder.is_debug_build_ = is_debug; \n    Builder.build_package(build_path, true);\n}</code></pre>\n<h2 id=\"Jenkins配置\"><a href=\"#Jenkins配置\" class=\"headerlink\" title=\"Jenkins配置\"></a>Jenkins配置</h2><blockquote>\n<ol>\n<li>Jenkins安装 Powershell插件，在 插件列表中搜索到这个：</li>\n</ol>\n</blockquote>\n<img src=\"./images/1571217538404.png\" alt=\"1571217538404\" style=\"zoom:100%;\" />\n\n<blockquote>\n<ol start=\"2\">\n<li>安装完后，重启下Jetkins</li>\n<li>在项目配置-&gt;构建 里选择使用Windows PowerShell:</li>\n</ol>\n</blockquote>\n<img src=\"./images/1571217610540.png\" alt=\"1571217610540\" style=\"zoom:100%;\" />\n\n<blockquote>\n<ol start=\"4\">\n<li>添加如下配置在Command格内：</li>\n</ol>\n</blockquote>\n<pre><code class=\"powershell\">echo ${ENV:WORKSPACE}\ncd ${ENV:WORKSPACE}/Unity\n./AutoCi/autobuild_android.ps1</code></pre>\n<img src=\"./images/1571217788247.png\" alt=\"1571217788247\" style=\"zoom:100%;\" />\n\n\n\n<h2 id=\"打什么样的包？-设置环境变量\"><a href=\"#打什么样的包？-设置环境变量\" class=\"headerlink\" title=\"打什么样的包？  设置环境变量\"></a>打什么样的包？  设置环境变量</h2><blockquote>\n<ol>\n<li><p>找到Jenkins环境变量设置</p>\n<p><strong>Manage Jenkins</strong>   -&gt;  <strong>Configure System</strong></p>\n</li>\n</ol>\n</blockquote>\n<p><img src=\"./images/1571216524617.png\" alt=\"1571216524617\"></p>\n<img src=\"./images/1571216565243.png\" alt=\"1571216565243\" style=\"zoom:67%;\" />\n\n\n\n<blockquote>\n<ol start=\"2\">\n<li>打 Apk </li>\n</ol>\n</blockquote>\n<p>设置 IsApk 为 true</p>\n<blockquote>\n<ol start=\"3\">\n<li>打 aar到平台</li>\n</ol>\n</blockquote>\n<p>设置 IsApk 为false或其他</p>\n<blockquote>\n<ol start=\"4\">\n<li>带Debug的包</li>\n</ol>\n</blockquote>\n<p>设置 IsDebug为true,  当不为true时则默认为relase包</p>\n<h2 id=\"CI的执行脚本说明\"><a href=\"#CI的执行脚本说明\" class=\"headerlink\" title=\"CI的执行脚本说明\"></a>CI的执行脚本说明</h2><blockquote>\n<ol>\n<li><p>auto_ci.py -仅打aar到平台需要</p>\n<ul>\n<li>修改manifest.xml文件，去掉intent-filter</li>\n<li>修改build.gradle文件，设置为library，去掉applicationId，设置gradle版本，添加jcenter(),google()到 all projects块</li>\n</ul>\n</li>\n<li><p>jksdk_util.py -上传aar到平台</p>\n<ul>\n<li><p>需要打开文件，更改下id为对应项目</p>\n</li>\n<li><p>上传到平台，需要改成指定格式的名字： </p>\n<p>  游戏名称-框架类型-debug/release-version.出包号.aar</p>\n</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><blockquote>\n<ol>\n<li>Powershell 脚本访问Jenkins环境变量记得加 <strong>ENV:</strong> 前缀</li>\n<li>在build.gradle加入的all projects块的代码，是由于gradle有时会找不到相关的jar包，又不会启动自动下载导致</li>\n</ol>\n</blockquote>\n"},{"title":"Python Core Programming Note 3","_content":"\n## Multi-thread \n\n### Python 的 threading 模块\nPython 提供了多个模块来支持多线程编程，包括 thread、 threading 和 Queue 模块等。程\n序是可以使用 thread 和 threading 模块来创建与管理线程。 thread 模块提供了基本的线程和锁\n定支持；而 threading 模块提供了更高级别、功能更全面的线程管理。使用 Queue 模块，用户\n可以创建一个队列数据结构，用于在多线程之间进行共享。\n\n> **核心提示：避免使用 thread 模块**\n推荐使用更高级别的 threading 模块，而不使用 thread 模块有很多原因。 threading 模\n块更加先进，有更好的线程支持，并且 thread 模块中的一些属性会和 threading 模块有冲突。\n另一个原因是低级别的 thread 模块拥有的同步原语很少（实际上只有一个），而 threading\n模块则有很多。\n不过，出于对 Python 和线程学习的兴趣，我们将给出使用 thread 模块的一些代码。\n给出这些代码只是出于学习目的，希望它能够让你更好地领悟为什么应该避免使用\nthread 模块。我们还将展示如何使用更加合适的工具，如 threading 和 Queue 模块中的那\n些方法。\n避免使用 thread 模块的另一个原因是它对于进程何时退出没有控制。当主线程结束\n时，所有其他线程也都强制结束，不会发出警告或者进行适当的清理。如前所述，至少\nthreading 模块能确保重要的子线程在进程退出前结束。\n我们只建议那些想访问线程的更底层级别的专家使用 thread 模块。为了强调这一点，\n在 Python3 中该模块被重命名为_thread。你创建的任何多线程应用都应该使用 threading 模\n块或其他更高级别的模块。\n\n> **核心提示：守护线程**\n避免使用 thread 模块的另一个原因是该模块不支持守护线程这个概念。当主线程退出\n时，所有子线程都将终止，不管它们是否仍在工作。如果你不希望发生这种行为，就要引\n入守护线程的概念了。\nthreading 模块支持守护线程，其工作方式是：守护线程一般是一个等待客户端请\n求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置\n为守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成。\n如同在第 2 章中看到的那样，服务器线程远行在一个无限循环里，并且在正常情况下\n不会退出。\n如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护\n线程标记。该标记值为真时，表示该线程是不重要的，或者说该线程只是用来等待客户端\n请求而不做任何其他事情。\n要将一个线程设置为守护线程，需要在启动线程之前执行如下赋值语句：\nthread.daemon = True（调用 thread.setDaemon(True)的旧方法已经弃用了）。同样，要检\n查线程的守护状态，也只需要检查这个值即可（对比过去调用 thread.isDaemon()的方\n法）。一个新的子线程会继承父线程的守护标记。整个 Python 程序（可以解读为：主线\n程）将在所有非守护线程退出之后才退出，换句话说，就是没有剩下存活的非守护线\n程时。\n\n>当所有线程都分配完成之后，通过调用每个线程的 start()方法让它们开始执行，而不是\n在这之前就会执行。相比于管理一组锁（分配、获取、释放、检查锁状态等）而言，这里只\n需要为每个线程调用 join()方法即可。 join()方法将等待线程结束，或者在提供了超时时间的\n情况下，达到超时时间。使用 join()方法要比等待锁释放的无限循环更加清晰（这也是这种锁\n又称为自旋锁的原因）。136 第 1 部分 通用应用主题\n对于 join()方法而言，其另一个重要方面是其实它根本不需要调用。一旦线程启动，它们\n就会一直执行，直到给定的函数完成后退出。如果主线程还有其他事情要去做，而不是等待\n这些线程完成（例如其他处理或者等待新的客户端请求），就可以不调用 join()。 join()方法只\n有在你需要等待线程完成的时候才是有用的。\n\n\n>使用 Thread 类，可以有很多方法来创建线程。我们将介绍其中比较相似的三种方法。选\n择你觉得最舒服的，或者是最适合你的应用和未来扩展的方法（我们更倾向于最后一种方案）。\n• 创建 Thread 的实例，传给它一个函数。\n• 创建 Thread 的实例，传给它一个可调用的类实例。\n• 派生 Thread 的子类，并创建子类的实例。\n你会发现你将选择第一个或第三个方案。当你需要一个更加符合面向对象的接口时，\n会选择后者；否则会选择前者。老实说，你会发现第二种方案显得有些尴尬并且稍微难以\n阅读，以下示例详细介绍：\n\n> 函数形式创建\n\n```python\nimport threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\ndef loop(nloop, nsec):\n    print(\"thread start! :\",nloop , ctime())\n    sleep(nsec)\n    print(\"thread end! :\",nloop , ctime())\n\n\ndef main():\n    print(f\"starting at :{ctime()}\")\n    threads = []\n    for i in range(len(loops)):\n        t = thread.Thread(target=loop, args=(i, loops[i]))\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n    \n    print(\"all done\")\n\nmain()\n```\n\n> 类形式创建\n\n```python\nimport threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\n\nclass MyThread():\n    def __init__(self, func, args, name=''):\n        self.func = func\n        self.args = args\n        self.name = name\n    def __call__(self):\n        self.func(*self.args)\n        \n\ndef loop(nloop, nsec):\n    print(\"thread start! :\",nloop , ctime())\n    sleep(nsec)\n    print(\"thread end! :\",nloop , ctime())\n\n\ndef main():\n    print(f\"starting at :{ctime()}\")\n    threads = []\n    for i in range(len(loops)):\n        t = thread.Thread(target=MyThread(loop,(i,loops[i]),loop.__name__))\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n    \n    print(\"all done\")\n\nmain()\n```\n\n\n> 子类形式创建\n\n```python\nimport threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\n\nclass MyThread(thread.Thread):\n    def __init__(self, func, args, name=''):\n        thread.Thread.__init__(self) #Changed: need to inherit and call parent's init\n        self.func = func\n        self.args = args\n        self.name = name\n\n    def get_result(self):\n        return self.res\n\n    def run(self):\n        print('starting', self.name, 'at: ', ctime())\n        self.res = self.func(*self.args)\n        print('finished', self.name, 'at: ', ctime())\n        \n\ndef loop(nloop, nsec):\n    sleep(nsec)\n\n\ndef main():\n    threads = []\n    for i in range(len(loops)):\n        t = MyThread(loop, (i, loops[i]), loop.__name__+str(i)) #Changed:no need to use threading.Thread() method\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n    \n    print(\"all done\")\n\nmain()\n\n```\n\n> 实例：\n\n```python\n#my_thread.py\nimport threading as thread\nfrom time import ctime\n\nclass MyThread(thread.Thread):\n    def __init__(self, func, args, name=''):\n        thread.Thread.__init__(self)  # Changed: need to inherit and call parent's init\n        self.func = func\n        self.args = args\n        self.name = name\n\n    def get_result(self):\n        return self.res\n\n    def run(self):\n        print('starting', self.name, 'at: ', ctime())\n        self.res = self.func(*self.args)\n        print('finished', self.name, 'at: ', ctime())\n\n```\n\n\n ```python\n #main.py\n from my_thread import MyThread\nfrom time import ctime, sleep\n\n\ndef fib(x):\n    sleep(0.002)\n    if x < 2: return 1\n    return fib(x-2) + fib(x-1)\n\n\ndef fac(x):\n    sleep(0.1)\n    if x < 2: return 1\n    return x * fac(x-1)\n\n\ndef sum(x):\n    sleep(0.2)\n    if x < 2: return 1\n    return x + sum(x-1)\n\n\nfuncs = [fib, fac, sum]\nn = 12\n\ndef main():\n    print(\"****** Single THREAD ********\")\n    for i in range(len(funcs)):\n        print(\"start function %s\" % funcs[i].__name__)\n        print(funcs[i](n))\n        print(\"end function %s\" % funcs[i].__name__)\n\n    threads = []\n    print(\"****** Multi THREAD ********\")\n    for i in range(len(funcs)):\n        t = MyThread(funcs[i], (n,), funcs[i].__name__)\n        threads.append(t)\n\n    for i in range(len(funcs)):\n        threads[i].start()\n\n    for i in range(len(funcs)):\n        threads[i].join()\n        print(threads[i].get_result())\n\n    print(\"all done\")\nmain()\n\n ```\n\n\n","source":"_posts/Python Core Programming Note 3.md","raw":"---\ntitle: Python Core Programming Note 3\ncategories:\n- Python\ntags: \n- Python\n- Core Programming\n- Note\n---\n\n## Multi-thread \n\n### Python 的 threading 模块\nPython 提供了多个模块来支持多线程编程，包括 thread、 threading 和 Queue 模块等。程\n序是可以使用 thread 和 threading 模块来创建与管理线程。 thread 模块提供了基本的线程和锁\n定支持；而 threading 模块提供了更高级别、功能更全面的线程管理。使用 Queue 模块，用户\n可以创建一个队列数据结构，用于在多线程之间进行共享。\n\n> **核心提示：避免使用 thread 模块**\n推荐使用更高级别的 threading 模块，而不使用 thread 模块有很多原因。 threading 模\n块更加先进，有更好的线程支持，并且 thread 模块中的一些属性会和 threading 模块有冲突。\n另一个原因是低级别的 thread 模块拥有的同步原语很少（实际上只有一个），而 threading\n模块则有很多。\n不过，出于对 Python 和线程学习的兴趣，我们将给出使用 thread 模块的一些代码。\n给出这些代码只是出于学习目的，希望它能够让你更好地领悟为什么应该避免使用\nthread 模块。我们还将展示如何使用更加合适的工具，如 threading 和 Queue 模块中的那\n些方法。\n避免使用 thread 模块的另一个原因是它对于进程何时退出没有控制。当主线程结束\n时，所有其他线程也都强制结束，不会发出警告或者进行适当的清理。如前所述，至少\nthreading 模块能确保重要的子线程在进程退出前结束。\n我们只建议那些想访问线程的更底层级别的专家使用 thread 模块。为了强调这一点，\n在 Python3 中该模块被重命名为_thread。你创建的任何多线程应用都应该使用 threading 模\n块或其他更高级别的模块。\n\n> **核心提示：守护线程**\n避免使用 thread 模块的另一个原因是该模块不支持守护线程这个概念。当主线程退出\n时，所有子线程都将终止，不管它们是否仍在工作。如果你不希望发生这种行为，就要引\n入守护线程的概念了。\nthreading 模块支持守护线程，其工作方式是：守护线程一般是一个等待客户端请\n求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置\n为守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成。\n如同在第 2 章中看到的那样，服务器线程远行在一个无限循环里，并且在正常情况下\n不会退出。\n如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护\n线程标记。该标记值为真时，表示该线程是不重要的，或者说该线程只是用来等待客户端\n请求而不做任何其他事情。\n要将一个线程设置为守护线程，需要在启动线程之前执行如下赋值语句：\nthread.daemon = True（调用 thread.setDaemon(True)的旧方法已经弃用了）。同样，要检\n查线程的守护状态，也只需要检查这个值即可（对比过去调用 thread.isDaemon()的方\n法）。一个新的子线程会继承父线程的守护标记。整个 Python 程序（可以解读为：主线\n程）将在所有非守护线程退出之后才退出，换句话说，就是没有剩下存活的非守护线\n程时。\n\n>当所有线程都分配完成之后，通过调用每个线程的 start()方法让它们开始执行，而不是\n在这之前就会执行。相比于管理一组锁（分配、获取、释放、检查锁状态等）而言，这里只\n需要为每个线程调用 join()方法即可。 join()方法将等待线程结束，或者在提供了超时时间的\n情况下，达到超时时间。使用 join()方法要比等待锁释放的无限循环更加清晰（这也是这种锁\n又称为自旋锁的原因）。136 第 1 部分 通用应用主题\n对于 join()方法而言，其另一个重要方面是其实它根本不需要调用。一旦线程启动，它们\n就会一直执行，直到给定的函数完成后退出。如果主线程还有其他事情要去做，而不是等待\n这些线程完成（例如其他处理或者等待新的客户端请求），就可以不调用 join()。 join()方法只\n有在你需要等待线程完成的时候才是有用的。\n\n\n>使用 Thread 类，可以有很多方法来创建线程。我们将介绍其中比较相似的三种方法。选\n择你觉得最舒服的，或者是最适合你的应用和未来扩展的方法（我们更倾向于最后一种方案）。\n• 创建 Thread 的实例，传给它一个函数。\n• 创建 Thread 的实例，传给它一个可调用的类实例。\n• 派生 Thread 的子类，并创建子类的实例。\n你会发现你将选择第一个或第三个方案。当你需要一个更加符合面向对象的接口时，\n会选择后者；否则会选择前者。老实说，你会发现第二种方案显得有些尴尬并且稍微难以\n阅读，以下示例详细介绍：\n\n> 函数形式创建\n\n```python\nimport threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\ndef loop(nloop, nsec):\n    print(\"thread start! :\",nloop , ctime())\n    sleep(nsec)\n    print(\"thread end! :\",nloop , ctime())\n\n\ndef main():\n    print(f\"starting at :{ctime()}\")\n    threads = []\n    for i in range(len(loops)):\n        t = thread.Thread(target=loop, args=(i, loops[i]))\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n    \n    print(\"all done\")\n\nmain()\n```\n\n> 类形式创建\n\n```python\nimport threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\n\nclass MyThread():\n    def __init__(self, func, args, name=''):\n        self.func = func\n        self.args = args\n        self.name = name\n    def __call__(self):\n        self.func(*self.args)\n        \n\ndef loop(nloop, nsec):\n    print(\"thread start! :\",nloop , ctime())\n    sleep(nsec)\n    print(\"thread end! :\",nloop , ctime())\n\n\ndef main():\n    print(f\"starting at :{ctime()}\")\n    threads = []\n    for i in range(len(loops)):\n        t = thread.Thread(target=MyThread(loop,(i,loops[i]),loop.__name__))\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n    \n    print(\"all done\")\n\nmain()\n```\n\n\n> 子类形式创建\n\n```python\nimport threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\n\nclass MyThread(thread.Thread):\n    def __init__(self, func, args, name=''):\n        thread.Thread.__init__(self) #Changed: need to inherit and call parent's init\n        self.func = func\n        self.args = args\n        self.name = name\n\n    def get_result(self):\n        return self.res\n\n    def run(self):\n        print('starting', self.name, 'at: ', ctime())\n        self.res = self.func(*self.args)\n        print('finished', self.name, 'at: ', ctime())\n        \n\ndef loop(nloop, nsec):\n    sleep(nsec)\n\n\ndef main():\n    threads = []\n    for i in range(len(loops)):\n        t = MyThread(loop, (i, loops[i]), loop.__name__+str(i)) #Changed:no need to use threading.Thread() method\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n    \n    print(\"all done\")\n\nmain()\n\n```\n\n> 实例：\n\n```python\n#my_thread.py\nimport threading as thread\nfrom time import ctime\n\nclass MyThread(thread.Thread):\n    def __init__(self, func, args, name=''):\n        thread.Thread.__init__(self)  # Changed: need to inherit and call parent's init\n        self.func = func\n        self.args = args\n        self.name = name\n\n    def get_result(self):\n        return self.res\n\n    def run(self):\n        print('starting', self.name, 'at: ', ctime())\n        self.res = self.func(*self.args)\n        print('finished', self.name, 'at: ', ctime())\n\n```\n\n\n ```python\n #main.py\n from my_thread import MyThread\nfrom time import ctime, sleep\n\n\ndef fib(x):\n    sleep(0.002)\n    if x < 2: return 1\n    return fib(x-2) + fib(x-1)\n\n\ndef fac(x):\n    sleep(0.1)\n    if x < 2: return 1\n    return x * fac(x-1)\n\n\ndef sum(x):\n    sleep(0.2)\n    if x < 2: return 1\n    return x + sum(x-1)\n\n\nfuncs = [fib, fac, sum]\nn = 12\n\ndef main():\n    print(\"****** Single THREAD ********\")\n    for i in range(len(funcs)):\n        print(\"start function %s\" % funcs[i].__name__)\n        print(funcs[i](n))\n        print(\"end function %s\" % funcs[i].__name__)\n\n    threads = []\n    print(\"****** Multi THREAD ********\")\n    for i in range(len(funcs)):\n        t = MyThread(funcs[i], (n,), funcs[i].__name__)\n        threads.append(t)\n\n    for i in range(len(funcs)):\n        threads[i].start()\n\n    for i in range(len(funcs)):\n        threads[i].join()\n        print(threads[i].get_result())\n\n    print(\"all done\")\nmain()\n\n ```\n\n\n","slug":"Python Core Programming Note 3","published":1,"date":"2020-09-08T03:23:20.715Z","updated":"2020-09-08T03:23:20.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh105001u4wf0bv2x6usr","content":"<h2 id=\"Multi-thread\"><a href=\"#Multi-thread\" class=\"headerlink\" title=\"Multi-thread\"></a>Multi-thread</h2><h3 id=\"Python-的-threading-模块\"><a href=\"#Python-的-threading-模块\" class=\"headerlink\" title=\"Python 的 threading 模块\"></a>Python 的 threading 模块</h3><p>Python 提供了多个模块来支持多线程编程，包括 thread、 threading 和 Queue 模块等。程<br>序是可以使用 thread 和 threading 模块来创建与管理线程。 thread 模块提供了基本的线程和锁<br>定支持；而 threading 模块提供了更高级别、功能更全面的线程管理。使用 Queue 模块，用户<br>可以创建一个队列数据结构，用于在多线程之间进行共享。</p>\n<blockquote>\n<p><strong>核心提示：避免使用 thread 模块</strong><br>推荐使用更高级别的 threading 模块，而不使用 thread 模块有很多原因。 threading 模<br>块更加先进，有更好的线程支持，并且 thread 模块中的一些属性会和 threading 模块有冲突。<br>另一个原因是低级别的 thread 模块拥有的同步原语很少（实际上只有一个），而 threading<br>模块则有很多。<br>不过，出于对 Python 和线程学习的兴趣，我们将给出使用 thread 模块的一些代码。<br>给出这些代码只是出于学习目的，希望它能够让你更好地领悟为什么应该避免使用<br>thread 模块。我们还将展示如何使用更加合适的工具，如 threading 和 Queue 模块中的那<br>些方法。<br>避免使用 thread 模块的另一个原因是它对于进程何时退出没有控制。当主线程结束<br>时，所有其他线程也都强制结束，不会发出警告或者进行适当的清理。如前所述，至少<br>threading 模块能确保重要的子线程在进程退出前结束。<br>我们只建议那些想访问线程的更底层级别的专家使用 thread 模块。为了强调这一点，<br>在 Python3 中该模块被重命名为_thread。你创建的任何多线程应用都应该使用 threading 模<br>块或其他更高级别的模块。</p>\n</blockquote>\n<blockquote>\n<p><strong>核心提示：守护线程</strong><br>避免使用 thread 模块的另一个原因是该模块不支持守护线程这个概念。当主线程退出<br>时，所有子线程都将终止，不管它们是否仍在工作。如果你不希望发生这种行为，就要引<br>入守护线程的概念了。<br>threading 模块支持守护线程，其工作方式是：守护线程一般是一个等待客户端请<br>求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置<br>为守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成。<br>如同在第 2 章中看到的那样，服务器线程远行在一个无限循环里，并且在正常情况下<br>不会退出。<br>如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护<br>线程标记。该标记值为真时，表示该线程是不重要的，或者说该线程只是用来等待客户端<br>请求而不做任何其他事情。<br>要将一个线程设置为守护线程，需要在启动线程之前执行如下赋值语句：<br>thread.daemon = True（调用 thread.setDaemon(True)的旧方法已经弃用了）。同样，要检<br>查线程的守护状态，也只需要检查这个值即可（对比过去调用 thread.isDaemon()的方<br>法）。一个新的子线程会继承父线程的守护标记。整个 Python 程序（可以解读为：主线<br>程）将在所有非守护线程退出之后才退出，换句话说，就是没有剩下存活的非守护线<br>程时。</p>\n</blockquote>\n<blockquote>\n<p>当所有线程都分配完成之后，通过调用每个线程的 start()方法让它们开始执行，而不是<br>在这之前就会执行。相比于管理一组锁（分配、获取、释放、检查锁状态等）而言，这里只<br>需要为每个线程调用 join()方法即可。 join()方法将等待线程结束，或者在提供了超时时间的<br>情况下，达到超时时间。使用 join()方法要比等待锁释放的无限循环更加清晰（这也是这种锁<br>又称为自旋锁的原因）。136 第 1 部分 通用应用主题<br>对于 join()方法而言，其另一个重要方面是其实它根本不需要调用。一旦线程启动，它们<br>就会一直执行，直到给定的函数完成后退出。如果主线程还有其他事情要去做，而不是等待<br>这些线程完成（例如其他处理或者等待新的客户端请求），就可以不调用 join()。 join()方法只<br>有在你需要等待线程完成的时候才是有用的。</p>\n</blockquote>\n<blockquote>\n<p>使用 Thread 类，可以有很多方法来创建线程。我们将介绍其中比较相似的三种方法。选<br>择你觉得最舒服的，或者是最适合你的应用和未来扩展的方法（我们更倾向于最后一种方案）。<br>• 创建 Thread 的实例，传给它一个函数。<br>• 创建 Thread 的实例，传给它一个可调用的类实例。<br>• 派生 Thread 的子类，并创建子类的实例。<br>你会发现你将选择第一个或第三个方案。当你需要一个更加符合面向对象的接口时，<br>会选择后者；否则会选择前者。老实说，你会发现第二种方案显得有些尴尬并且稍微难以<br>阅读，以下示例详细介绍：</p>\n</blockquote>\n<blockquote>\n<p>函数形式创建</p>\n</blockquote>\n<pre><code class=\"python\">import threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\ndef loop(nloop, nsec):\n    print(&quot;thread start! :&quot;,nloop , ctime())\n    sleep(nsec)\n    print(&quot;thread end! :&quot;,nloop , ctime())\n\n\ndef main():\n    print(f&quot;starting at :{ctime()}&quot;)\n    threads = []\n    for i in range(len(loops)):\n        t = thread.Thread(target=loop, args=(i, loops[i]))\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n\n    print(&quot;all done&quot;)\n\nmain()</code></pre>\n<blockquote>\n<p>类形式创建</p>\n</blockquote>\n<pre><code class=\"python\">import threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\n\nclass MyThread():\n    def __init__(self, func, args, name=&#39;&#39;):\n        self.func = func\n        self.args = args\n        self.name = name\n    def __call__(self):\n        self.func(*self.args)\n\n\ndef loop(nloop, nsec):\n    print(&quot;thread start! :&quot;,nloop , ctime())\n    sleep(nsec)\n    print(&quot;thread end! :&quot;,nloop , ctime())\n\n\ndef main():\n    print(f&quot;starting at :{ctime()}&quot;)\n    threads = []\n    for i in range(len(loops)):\n        t = thread.Thread(target=MyThread(loop,(i,loops[i]),loop.__name__))\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n\n    print(&quot;all done&quot;)\n\nmain()</code></pre>\n<blockquote>\n<p>子类形式创建</p>\n</blockquote>\n<pre><code class=\"python\">import threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\n\nclass MyThread(thread.Thread):\n    def __init__(self, func, args, name=&#39;&#39;):\n        thread.Thread.__init__(self) #Changed: need to inherit and call parent&#39;s init\n        self.func = func\n        self.args = args\n        self.name = name\n\n    def get_result(self):\n        return self.res\n\n    def run(self):\n        print(&#39;starting&#39;, self.name, &#39;at: &#39;, ctime())\n        self.res = self.func(*self.args)\n        print(&#39;finished&#39;, self.name, &#39;at: &#39;, ctime())\n\n\ndef loop(nloop, nsec):\n    sleep(nsec)\n\n\ndef main():\n    threads = []\n    for i in range(len(loops)):\n        t = MyThread(loop, (i, loops[i]), loop.__name__+str(i)) #Changed:no need to use threading.Thread() method\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n\n    print(&quot;all done&quot;)\n\nmain()\n</code></pre>\n<blockquote>\n<p>实例：</p>\n</blockquote>\n<pre><code class=\"python\">#my_thread.py\nimport threading as thread\nfrom time import ctime\n\nclass MyThread(thread.Thread):\n    def __init__(self, func, args, name=&#39;&#39;):\n        thread.Thread.__init__(self)  # Changed: need to inherit and call parent&#39;s init\n        self.func = func\n        self.args = args\n        self.name = name\n\n    def get_result(self):\n        return self.res\n\n    def run(self):\n        print(&#39;starting&#39;, self.name, &#39;at: &#39;, ctime())\n        self.res = self.func(*self.args)\n        print(&#39;finished&#39;, self.name, &#39;at: &#39;, ctime())\n</code></pre>\n<pre><code class=\"python\"> #main.py\n from my_thread import MyThread\nfrom time import ctime, sleep\n\n\ndef fib(x):\n    sleep(0.002)\n    if x &lt; 2: return 1\n    return fib(x-2) + fib(x-1)\n\n\ndef fac(x):\n    sleep(0.1)\n    if x &lt; 2: return 1\n    return x * fac(x-1)\n\n\ndef sum(x):\n    sleep(0.2)\n    if x &lt; 2: return 1\n    return x + sum(x-1)\n\n\nfuncs = [fib, fac, sum]\nn = 12\n\ndef main():\n    print(&quot;****** Single THREAD ********&quot;)\n    for i in range(len(funcs)):\n        print(&quot;start function %s&quot; % funcs[i].__name__)\n        print(funcs[i](n))\n        print(&quot;end function %s&quot; % funcs[i].__name__)\n\n    threads = []\n    print(&quot;****** Multi THREAD ********&quot;)\n    for i in range(len(funcs)):\n        t = MyThread(funcs[i], (n,), funcs[i].__name__)\n        threads.append(t)\n\n    for i in range(len(funcs)):\n        threads[i].start()\n\n    for i in range(len(funcs)):\n        threads[i].join()\n        print(threads[i].get_result())\n\n    print(&quot;all done&quot;)\nmain()\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Multi-thread\"><a href=\"#Multi-thread\" class=\"headerlink\" title=\"Multi-thread\"></a>Multi-thread</h2><h3 id=\"Python-的-threading-模块\"><a href=\"#Python-的-threading-模块\" class=\"headerlink\" title=\"Python 的 threading 模块\"></a>Python 的 threading 模块</h3><p>Python 提供了多个模块来支持多线程编程，包括 thread、 threading 和 Queue 模块等。程<br>序是可以使用 thread 和 threading 模块来创建与管理线程。 thread 模块提供了基本的线程和锁<br>定支持；而 threading 模块提供了更高级别、功能更全面的线程管理。使用 Queue 模块，用户<br>可以创建一个队列数据结构，用于在多线程之间进行共享。</p>\n<blockquote>\n<p><strong>核心提示：避免使用 thread 模块</strong><br>推荐使用更高级别的 threading 模块，而不使用 thread 模块有很多原因。 threading 模<br>块更加先进，有更好的线程支持，并且 thread 模块中的一些属性会和 threading 模块有冲突。<br>另一个原因是低级别的 thread 模块拥有的同步原语很少（实际上只有一个），而 threading<br>模块则有很多。<br>不过，出于对 Python 和线程学习的兴趣，我们将给出使用 thread 模块的一些代码。<br>给出这些代码只是出于学习目的，希望它能够让你更好地领悟为什么应该避免使用<br>thread 模块。我们还将展示如何使用更加合适的工具，如 threading 和 Queue 模块中的那<br>些方法。<br>避免使用 thread 模块的另一个原因是它对于进程何时退出没有控制。当主线程结束<br>时，所有其他线程也都强制结束，不会发出警告或者进行适当的清理。如前所述，至少<br>threading 模块能确保重要的子线程在进程退出前结束。<br>我们只建议那些想访问线程的更底层级别的专家使用 thread 模块。为了强调这一点，<br>在 Python3 中该模块被重命名为_thread。你创建的任何多线程应用都应该使用 threading 模<br>块或其他更高级别的模块。</p>\n</blockquote>\n<blockquote>\n<p><strong>核心提示：守护线程</strong><br>避免使用 thread 模块的另一个原因是该模块不支持守护线程这个概念。当主线程退出<br>时，所有子线程都将终止，不管它们是否仍在工作。如果你不希望发生这种行为，就要引<br>入守护线程的概念了。<br>threading 模块支持守护线程，其工作方式是：守护线程一般是一个等待客户端请<br>求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置<br>为守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成。<br>如同在第 2 章中看到的那样，服务器线程远行在一个无限循环里，并且在正常情况下<br>不会退出。<br>如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护<br>线程标记。该标记值为真时，表示该线程是不重要的，或者说该线程只是用来等待客户端<br>请求而不做任何其他事情。<br>要将一个线程设置为守护线程，需要在启动线程之前执行如下赋值语句：<br>thread.daemon = True（调用 thread.setDaemon(True)的旧方法已经弃用了）。同样，要检<br>查线程的守护状态，也只需要检查这个值即可（对比过去调用 thread.isDaemon()的方<br>法）。一个新的子线程会继承父线程的守护标记。整个 Python 程序（可以解读为：主线<br>程）将在所有非守护线程退出之后才退出，换句话说，就是没有剩下存活的非守护线<br>程时。</p>\n</blockquote>\n<blockquote>\n<p>当所有线程都分配完成之后，通过调用每个线程的 start()方法让它们开始执行，而不是<br>在这之前就会执行。相比于管理一组锁（分配、获取、释放、检查锁状态等）而言，这里只<br>需要为每个线程调用 join()方法即可。 join()方法将等待线程结束，或者在提供了超时时间的<br>情况下，达到超时时间。使用 join()方法要比等待锁释放的无限循环更加清晰（这也是这种锁<br>又称为自旋锁的原因）。136 第 1 部分 通用应用主题<br>对于 join()方法而言，其另一个重要方面是其实它根本不需要调用。一旦线程启动，它们<br>就会一直执行，直到给定的函数完成后退出。如果主线程还有其他事情要去做，而不是等待<br>这些线程完成（例如其他处理或者等待新的客户端请求），就可以不调用 join()。 join()方法只<br>有在你需要等待线程完成的时候才是有用的。</p>\n</blockquote>\n<blockquote>\n<p>使用 Thread 类，可以有很多方法来创建线程。我们将介绍其中比较相似的三种方法。选<br>择你觉得最舒服的，或者是最适合你的应用和未来扩展的方法（我们更倾向于最后一种方案）。<br>• 创建 Thread 的实例，传给它一个函数。<br>• 创建 Thread 的实例，传给它一个可调用的类实例。<br>• 派生 Thread 的子类，并创建子类的实例。<br>你会发现你将选择第一个或第三个方案。当你需要一个更加符合面向对象的接口时，<br>会选择后者；否则会选择前者。老实说，你会发现第二种方案显得有些尴尬并且稍微难以<br>阅读，以下示例详细介绍：</p>\n</blockquote>\n<blockquote>\n<p>函数形式创建</p>\n</blockquote>\n<pre><code class=\"python\">import threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\ndef loop(nloop, nsec):\n    print(&quot;thread start! :&quot;,nloop , ctime())\n    sleep(nsec)\n    print(&quot;thread end! :&quot;,nloop , ctime())\n\n\ndef main():\n    print(f&quot;starting at :{ctime()}&quot;)\n    threads = []\n    for i in range(len(loops)):\n        t = thread.Thread(target=loop, args=(i, loops[i]))\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n\n    print(&quot;all done&quot;)\n\nmain()</code></pre>\n<blockquote>\n<p>类形式创建</p>\n</blockquote>\n<pre><code class=\"python\">import threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\n\nclass MyThread():\n    def __init__(self, func, args, name=&#39;&#39;):\n        self.func = func\n        self.args = args\n        self.name = name\n    def __call__(self):\n        self.func(*self.args)\n\n\ndef loop(nloop, nsec):\n    print(&quot;thread start! :&quot;,nloop , ctime())\n    sleep(nsec)\n    print(&quot;thread end! :&quot;,nloop , ctime())\n\n\ndef main():\n    print(f&quot;starting at :{ctime()}&quot;)\n    threads = []\n    for i in range(len(loops)):\n        t = thread.Thread(target=MyThread(loop,(i,loops[i]),loop.__name__))\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n\n    print(&quot;all done&quot;)\n\nmain()</code></pre>\n<blockquote>\n<p>子类形式创建</p>\n</blockquote>\n<pre><code class=\"python\">import threading as thread\nfrom time import sleep, ctime\n\nloops = [3,2]\n\nclass MyThread(thread.Thread):\n    def __init__(self, func, args, name=&#39;&#39;):\n        thread.Thread.__init__(self) #Changed: need to inherit and call parent&#39;s init\n        self.func = func\n        self.args = args\n        self.name = name\n\n    def get_result(self):\n        return self.res\n\n    def run(self):\n        print(&#39;starting&#39;, self.name, &#39;at: &#39;, ctime())\n        self.res = self.func(*self.args)\n        print(&#39;finished&#39;, self.name, &#39;at: &#39;, ctime())\n\n\ndef loop(nloop, nsec):\n    sleep(nsec)\n\n\ndef main():\n    threads = []\n    for i in range(len(loops)):\n        t = MyThread(loop, (i, loops[i]), loop.__name__+str(i)) #Changed:no need to use threading.Thread() method\n        t.daemon = True\n        threads.append(t)\n\n    for i in range(len(loops)):\n        threads[i].start()\n\n    for i in range(len(loops)):\n        threads[i].join()\n\n    print(&quot;all done&quot;)\n\nmain()\n</code></pre>\n<blockquote>\n<p>实例：</p>\n</blockquote>\n<pre><code class=\"python\">#my_thread.py\nimport threading as thread\nfrom time import ctime\n\nclass MyThread(thread.Thread):\n    def __init__(self, func, args, name=&#39;&#39;):\n        thread.Thread.__init__(self)  # Changed: need to inherit and call parent&#39;s init\n        self.func = func\n        self.args = args\n        self.name = name\n\n    def get_result(self):\n        return self.res\n\n    def run(self):\n        print(&#39;starting&#39;, self.name, &#39;at: &#39;, ctime())\n        self.res = self.func(*self.args)\n        print(&#39;finished&#39;, self.name, &#39;at: &#39;, ctime())\n</code></pre>\n<pre><code class=\"python\"> #main.py\n from my_thread import MyThread\nfrom time import ctime, sleep\n\n\ndef fib(x):\n    sleep(0.002)\n    if x &lt; 2: return 1\n    return fib(x-2) + fib(x-1)\n\n\ndef fac(x):\n    sleep(0.1)\n    if x &lt; 2: return 1\n    return x * fac(x-1)\n\n\ndef sum(x):\n    sleep(0.2)\n    if x &lt; 2: return 1\n    return x + sum(x-1)\n\n\nfuncs = [fib, fac, sum]\nn = 12\n\ndef main():\n    print(&quot;****** Single THREAD ********&quot;)\n    for i in range(len(funcs)):\n        print(&quot;start function %s&quot; % funcs[i].__name__)\n        print(funcs[i](n))\n        print(&quot;end function %s&quot; % funcs[i].__name__)\n\n    threads = []\n    print(&quot;****** Multi THREAD ********&quot;)\n    for i in range(len(funcs)):\n        t = MyThread(funcs[i], (n,), funcs[i].__name__)\n        threads.append(t)\n\n    for i in range(len(funcs)):\n        threads[i].start()\n\n    for i in range(len(funcs)):\n        threads[i].join()\n        print(threads[i].get_result())\n\n    print(&quot;all done&quot;)\nmain()\n</code></pre>\n"},{"title":"Python Core Programming Note 2","_content":"\n## Net Programming\n\n#### 1. TCP\n+ Server:\n\n```python\nfrom socket import *\nfrom time import ctime\n\nHOST = ''\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpSerSocket = socket(AF_INET, SOCK_STREAM)\ntcpSerSocket.bind(ADDR)\ntcpSerSocket.listen(5)\n\ntry:\n    while True:\n        print(\"waiting for connection...\")\n        tcpCliSocket, addr = tcpSerSocket.accept()\n        print(\"connected from :\",addr)\n        while True:\n            data = tcpCliSocket.recv(BUFSIZ)\n            if not data:\n                break\n            print(\"rec:\",data)\n            send_str = '[%s] %s' %(bytes(ctime(), 'utf-8'), 'Oh?')\n            tcpCliSocket.send(send_str.encode('utf-8'))\n        tcpCliSocket.close()\nexcept EOFError:\n    print(\"Error: EOFEError\")\nexcept KeyboardInterrupt:\n    print(\"Error: EOFEError\")\nfinally:\n    tcpSerSocket.close()\n```\n\n+ Client\n\n```python\nfrom socket import *\n\nHOST = '127.0.0.1' \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpCliSocket = socket(AF_INET, SOCK_STREAM)\ntcpCliSocket.connect(ADDR)\n\nwhile True:\n    data = input('> ')\n    if not data:\n        break\n\n    tcpCliSocket.send(data.encode('utf-8'))\n    data = tcpCliSocket.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode('utf-8'))\n\ntcpCliSocket.close()\n\n```\n\n#### 2. UDP\n\n+ Server\n\n```python\nfrom socket import *\nfrom time import ctime\n\nHOST = ''\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nudpSerSocket = socket(AF_INET, SOCK_DGRAM)\nudpSerSocket.bind(ADDR)\n\ntry:\n    while True:\n        print(\"waiting for message...\")\n        msg, addr = udpSerSocket.recvfrom(BUFSIZ)\n        if msg.decode('utf-8') == ' ':\n            break\n        print('Rev client:',msg)\n        send_str = '[%s] %s' %(bytes(ctime(), 'utf-8'), msg)\n        udpSerSocket.sendto(send_str.encode('utf-8'),addr)\n        \nexcept EOFError:\n    print(\"Error: EOFEError\")\nexcept KeyboardInterrupt:\n    print(\"Error: EOFEError\")\nfinally:\n    udpSerSocket.close()\n```\n\n+ Client\n\n```python\nfrom socket import *\n\nHOST = '127.0.0.1' \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nudpCliSocket = socket(AF_INET, SOCK_DGRAM)\nwhile True:\n    data = input('> ')\n    if not data:\n        break\n\n    udpCliSocket.sendto(data.encode('utf-8'),ADDR)\n    if data == ' ':\n        break\n    data,ADDR = udpCliSocket.recvfrom(BUFSIZ)\n    if not data:\n        break\n    print(data.decode('utf-8'))\n\nudpCliSocket.close()\n```\n\n### 使用SocketServer\n+ Server\n\n```python\nfrom socketserver import (TCPServer as TCP, StreamRequestHandler as SRH)\nfrom time import ctime\n\n\nHOST = ''\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nclass MyRequestHandler(SRH):\n    def handle(self):\n        print(\"connected from..\", self.client_address)\n        send_str = '[%s] %s' %(bytes(ctime(), 'utf-8'), self.rfile.readline())\n        self.wfile.write(send_str.encode('utf-8'))\n\ntcpServ = TCP(ADDR, MyRequestHandler)\nprint(\"waiting for connection...\")\ntcpServ.serve_forever()\n        \n```\n\n+ Client\n不同之处：需要把建立和连接放在每次循环中\n\n```\nfrom socket import *\n\nHOST = '127.0.0.1' \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\n\n\nwhile True:\n    tcpCliSocket = socket(AF_INET, SOCK_STREAM)\n    tcpCliSocket.connect(ADDR)\n    data = input('> ')\n    if not data:\n        break\n\n    send_data = \"%s\\n\" % data\n    tcpCliSocket.send(send_data.encode('utf-8'))\n    data = tcpCliSocket.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode('utf-8'))\n    tcpCliSocket.close()\n\n```\n","source":"_posts/Python Core Programming Note 2.md","raw":"---\ntitle: Python Core Programming Note 2\ncategories:\n- Python\ntags: \n- Python\n- Core Programming\n- Note\n---\n\n## Net Programming\n\n#### 1. TCP\n+ Server:\n\n```python\nfrom socket import *\nfrom time import ctime\n\nHOST = ''\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpSerSocket = socket(AF_INET, SOCK_STREAM)\ntcpSerSocket.bind(ADDR)\ntcpSerSocket.listen(5)\n\ntry:\n    while True:\n        print(\"waiting for connection...\")\n        tcpCliSocket, addr = tcpSerSocket.accept()\n        print(\"connected from :\",addr)\n        while True:\n            data = tcpCliSocket.recv(BUFSIZ)\n            if not data:\n                break\n            print(\"rec:\",data)\n            send_str = '[%s] %s' %(bytes(ctime(), 'utf-8'), 'Oh?')\n            tcpCliSocket.send(send_str.encode('utf-8'))\n        tcpCliSocket.close()\nexcept EOFError:\n    print(\"Error: EOFEError\")\nexcept KeyboardInterrupt:\n    print(\"Error: EOFEError\")\nfinally:\n    tcpSerSocket.close()\n```\n\n+ Client\n\n```python\nfrom socket import *\n\nHOST = '127.0.0.1' \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpCliSocket = socket(AF_INET, SOCK_STREAM)\ntcpCliSocket.connect(ADDR)\n\nwhile True:\n    data = input('> ')\n    if not data:\n        break\n\n    tcpCliSocket.send(data.encode('utf-8'))\n    data = tcpCliSocket.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode('utf-8'))\n\ntcpCliSocket.close()\n\n```\n\n#### 2. UDP\n\n+ Server\n\n```python\nfrom socket import *\nfrom time import ctime\n\nHOST = ''\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nudpSerSocket = socket(AF_INET, SOCK_DGRAM)\nudpSerSocket.bind(ADDR)\n\ntry:\n    while True:\n        print(\"waiting for message...\")\n        msg, addr = udpSerSocket.recvfrom(BUFSIZ)\n        if msg.decode('utf-8') == ' ':\n            break\n        print('Rev client:',msg)\n        send_str = '[%s] %s' %(bytes(ctime(), 'utf-8'), msg)\n        udpSerSocket.sendto(send_str.encode('utf-8'),addr)\n        \nexcept EOFError:\n    print(\"Error: EOFEError\")\nexcept KeyboardInterrupt:\n    print(\"Error: EOFEError\")\nfinally:\n    udpSerSocket.close()\n```\n\n+ Client\n\n```python\nfrom socket import *\n\nHOST = '127.0.0.1' \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nudpCliSocket = socket(AF_INET, SOCK_DGRAM)\nwhile True:\n    data = input('> ')\n    if not data:\n        break\n\n    udpCliSocket.sendto(data.encode('utf-8'),ADDR)\n    if data == ' ':\n        break\n    data,ADDR = udpCliSocket.recvfrom(BUFSIZ)\n    if not data:\n        break\n    print(data.decode('utf-8'))\n\nudpCliSocket.close()\n```\n\n### 使用SocketServer\n+ Server\n\n```python\nfrom socketserver import (TCPServer as TCP, StreamRequestHandler as SRH)\nfrom time import ctime\n\n\nHOST = ''\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nclass MyRequestHandler(SRH):\n    def handle(self):\n        print(\"connected from..\", self.client_address)\n        send_str = '[%s] %s' %(bytes(ctime(), 'utf-8'), self.rfile.readline())\n        self.wfile.write(send_str.encode('utf-8'))\n\ntcpServ = TCP(ADDR, MyRequestHandler)\nprint(\"waiting for connection...\")\ntcpServ.serve_forever()\n        \n```\n\n+ Client\n不同之处：需要把建立和连接放在每次循环中\n\n```\nfrom socket import *\n\nHOST = '127.0.0.1' \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\n\n\nwhile True:\n    tcpCliSocket = socket(AF_INET, SOCK_STREAM)\n    tcpCliSocket.connect(ADDR)\n    data = input('> ')\n    if not data:\n        break\n\n    send_data = \"%s\\n\" % data\n    tcpCliSocket.send(send_data.encode('utf-8'))\n    data = tcpCliSocket.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode('utf-8'))\n    tcpCliSocket.close()\n\n```\n","slug":"Python Core Programming Note 2","published":1,"date":"2020-09-08T03:23:20.715Z","updated":"2020-09-08T03:23:20.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh108001y4wf0f6vqxrjn","content":"<h2 id=\"Net-Programming\"><a href=\"#Net-Programming\" class=\"headerlink\" title=\"Net Programming\"></a>Net Programming</h2><h4 id=\"1-TCP\"><a href=\"#1-TCP\" class=\"headerlink\" title=\"1. TCP\"></a>1. TCP</h4><ul>\n<li>Server:</li>\n</ul>\n<pre><code class=\"python\">from socket import *\nfrom time import ctime\n\nHOST = &#39;&#39;\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpSerSocket = socket(AF_INET, SOCK_STREAM)\ntcpSerSocket.bind(ADDR)\ntcpSerSocket.listen(5)\n\ntry:\n    while True:\n        print(&quot;waiting for connection...&quot;)\n        tcpCliSocket, addr = tcpSerSocket.accept()\n        print(&quot;connected from :&quot;,addr)\n        while True:\n            data = tcpCliSocket.recv(BUFSIZ)\n            if not data:\n                break\n            print(&quot;rec:&quot;,data)\n            send_str = &#39;[%s] %s&#39; %(bytes(ctime(), &#39;utf-8&#39;), &#39;Oh?&#39;)\n            tcpCliSocket.send(send_str.encode(&#39;utf-8&#39;))\n        tcpCliSocket.close()\nexcept EOFError:\n    print(&quot;Error: EOFEError&quot;)\nexcept KeyboardInterrupt:\n    print(&quot;Error: EOFEError&quot;)\nfinally:\n    tcpSerSocket.close()</code></pre>\n<ul>\n<li>Client</li>\n</ul>\n<pre><code class=\"python\">from socket import *\n\nHOST = &#39;127.0.0.1&#39; \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpCliSocket = socket(AF_INET, SOCK_STREAM)\ntcpCliSocket.connect(ADDR)\n\nwhile True:\n    data = input(&#39;&gt; &#39;)\n    if not data:\n        break\n\n    tcpCliSocket.send(data.encode(&#39;utf-8&#39;))\n    data = tcpCliSocket.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode(&#39;utf-8&#39;))\n\ntcpCliSocket.close()\n</code></pre>\n<h4 id=\"2-UDP\"><a href=\"#2-UDP\" class=\"headerlink\" title=\"2. UDP\"></a>2. UDP</h4><ul>\n<li>Server</li>\n</ul>\n<pre><code class=\"python\">from socket import *\nfrom time import ctime\n\nHOST = &#39;&#39;\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nudpSerSocket = socket(AF_INET, SOCK_DGRAM)\nudpSerSocket.bind(ADDR)\n\ntry:\n    while True:\n        print(&quot;waiting for message...&quot;)\n        msg, addr = udpSerSocket.recvfrom(BUFSIZ)\n        if msg.decode(&#39;utf-8&#39;) == &#39; &#39;:\n            break\n        print(&#39;Rev client:&#39;,msg)\n        send_str = &#39;[%s] %s&#39; %(bytes(ctime(), &#39;utf-8&#39;), msg)\n        udpSerSocket.sendto(send_str.encode(&#39;utf-8&#39;),addr)\n\nexcept EOFError:\n    print(&quot;Error: EOFEError&quot;)\nexcept KeyboardInterrupt:\n    print(&quot;Error: EOFEError&quot;)\nfinally:\n    udpSerSocket.close()</code></pre>\n<ul>\n<li>Client</li>\n</ul>\n<pre><code class=\"python\">from socket import *\n\nHOST = &#39;127.0.0.1&#39; \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nudpCliSocket = socket(AF_INET, SOCK_DGRAM)\nwhile True:\n    data = input(&#39;&gt; &#39;)\n    if not data:\n        break\n\n    udpCliSocket.sendto(data.encode(&#39;utf-8&#39;),ADDR)\n    if data == &#39; &#39;:\n        break\n    data,ADDR = udpCliSocket.recvfrom(BUFSIZ)\n    if not data:\n        break\n    print(data.decode(&#39;utf-8&#39;))\n\nudpCliSocket.close()</code></pre>\n<h3 id=\"使用SocketServer\"><a href=\"#使用SocketServer\" class=\"headerlink\" title=\"使用SocketServer\"></a>使用SocketServer</h3><ul>\n<li>Server</li>\n</ul>\n<pre><code class=\"python\">from socketserver import (TCPServer as TCP, StreamRequestHandler as SRH)\nfrom time import ctime\n\n\nHOST = &#39;&#39;\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nclass MyRequestHandler(SRH):\n    def handle(self):\n        print(&quot;connected from..&quot;, self.client_address)\n        send_str = &#39;[%s] %s&#39; %(bytes(ctime(), &#39;utf-8&#39;), self.rfile.readline())\n        self.wfile.write(send_str.encode(&#39;utf-8&#39;))\n\ntcpServ = TCP(ADDR, MyRequestHandler)\nprint(&quot;waiting for connection...&quot;)\ntcpServ.serve_forever()\n</code></pre>\n<ul>\n<li>Client<br>不同之处：需要把建立和连接放在每次循环中</li>\n</ul>\n<pre><code>from socket import *\n\nHOST = &#39;127.0.0.1&#39; \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\n\n\nwhile True:\n    tcpCliSocket = socket(AF_INET, SOCK_STREAM)\n    tcpCliSocket.connect(ADDR)\n    data = input(&#39;&gt; &#39;)\n    if not data:\n        break\n\n    send_data = &quot;%s\\n&quot; % data\n    tcpCliSocket.send(send_data.encode(&#39;utf-8&#39;))\n    data = tcpCliSocket.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode(&#39;utf-8&#39;))\n    tcpCliSocket.close()\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Net-Programming\"><a href=\"#Net-Programming\" class=\"headerlink\" title=\"Net Programming\"></a>Net Programming</h2><h4 id=\"1-TCP\"><a href=\"#1-TCP\" class=\"headerlink\" title=\"1. TCP\"></a>1. TCP</h4><ul>\n<li>Server:</li>\n</ul>\n<pre><code class=\"python\">from socket import *\nfrom time import ctime\n\nHOST = &#39;&#39;\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpSerSocket = socket(AF_INET, SOCK_STREAM)\ntcpSerSocket.bind(ADDR)\ntcpSerSocket.listen(5)\n\ntry:\n    while True:\n        print(&quot;waiting for connection...&quot;)\n        tcpCliSocket, addr = tcpSerSocket.accept()\n        print(&quot;connected from :&quot;,addr)\n        while True:\n            data = tcpCliSocket.recv(BUFSIZ)\n            if not data:\n                break\n            print(&quot;rec:&quot;,data)\n            send_str = &#39;[%s] %s&#39; %(bytes(ctime(), &#39;utf-8&#39;), &#39;Oh?&#39;)\n            tcpCliSocket.send(send_str.encode(&#39;utf-8&#39;))\n        tcpCliSocket.close()\nexcept EOFError:\n    print(&quot;Error: EOFEError&quot;)\nexcept KeyboardInterrupt:\n    print(&quot;Error: EOFEError&quot;)\nfinally:\n    tcpSerSocket.close()</code></pre>\n<ul>\n<li>Client</li>\n</ul>\n<pre><code class=\"python\">from socket import *\n\nHOST = &#39;127.0.0.1&#39; \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\ntcpCliSocket = socket(AF_INET, SOCK_STREAM)\ntcpCliSocket.connect(ADDR)\n\nwhile True:\n    data = input(&#39;&gt; &#39;)\n    if not data:\n        break\n\n    tcpCliSocket.send(data.encode(&#39;utf-8&#39;))\n    data = tcpCliSocket.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode(&#39;utf-8&#39;))\n\ntcpCliSocket.close()\n</code></pre>\n<h4 id=\"2-UDP\"><a href=\"#2-UDP\" class=\"headerlink\" title=\"2. UDP\"></a>2. UDP</h4><ul>\n<li>Server</li>\n</ul>\n<pre><code class=\"python\">from socket import *\nfrom time import ctime\n\nHOST = &#39;&#39;\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nudpSerSocket = socket(AF_INET, SOCK_DGRAM)\nudpSerSocket.bind(ADDR)\n\ntry:\n    while True:\n        print(&quot;waiting for message...&quot;)\n        msg, addr = udpSerSocket.recvfrom(BUFSIZ)\n        if msg.decode(&#39;utf-8&#39;) == &#39; &#39;:\n            break\n        print(&#39;Rev client:&#39;,msg)\n        send_str = &#39;[%s] %s&#39; %(bytes(ctime(), &#39;utf-8&#39;), msg)\n        udpSerSocket.sendto(send_str.encode(&#39;utf-8&#39;),addr)\n\nexcept EOFError:\n    print(&quot;Error: EOFEError&quot;)\nexcept KeyboardInterrupt:\n    print(&quot;Error: EOFEError&quot;)\nfinally:\n    udpSerSocket.close()</code></pre>\n<ul>\n<li>Client</li>\n</ul>\n<pre><code class=\"python\">from socket import *\n\nHOST = &#39;127.0.0.1&#39; \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nudpCliSocket = socket(AF_INET, SOCK_DGRAM)\nwhile True:\n    data = input(&#39;&gt; &#39;)\n    if not data:\n        break\n\n    udpCliSocket.sendto(data.encode(&#39;utf-8&#39;),ADDR)\n    if data == &#39; &#39;:\n        break\n    data,ADDR = udpCliSocket.recvfrom(BUFSIZ)\n    if not data:\n        break\n    print(data.decode(&#39;utf-8&#39;))\n\nudpCliSocket.close()</code></pre>\n<h3 id=\"使用SocketServer\"><a href=\"#使用SocketServer\" class=\"headerlink\" title=\"使用SocketServer\"></a>使用SocketServer</h3><ul>\n<li>Server</li>\n</ul>\n<pre><code class=\"python\">from socketserver import (TCPServer as TCP, StreamRequestHandler as SRH)\nfrom time import ctime\n\n\nHOST = &#39;&#39;\nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\nclass MyRequestHandler(SRH):\n    def handle(self):\n        print(&quot;connected from..&quot;, self.client_address)\n        send_str = &#39;[%s] %s&#39; %(bytes(ctime(), &#39;utf-8&#39;), self.rfile.readline())\n        self.wfile.write(send_str.encode(&#39;utf-8&#39;))\n\ntcpServ = TCP(ADDR, MyRequestHandler)\nprint(&quot;waiting for connection...&quot;)\ntcpServ.serve_forever()\n</code></pre>\n<ul>\n<li>Client<br>不同之处：需要把建立和连接放在每次循环中</li>\n</ul>\n<pre><code>from socket import *\n\nHOST = &#39;127.0.0.1&#39; \nPORT = 21111\nBUFSIZ = 1024\nADDR = (HOST, PORT)\n\n\n\nwhile True:\n    tcpCliSocket = socket(AF_INET, SOCK_STREAM)\n    tcpCliSocket.connect(ADDR)\n    data = input(&#39;&gt; &#39;)\n    if not data:\n        break\n\n    send_data = &quot;%s\\n&quot; % data\n    tcpCliSocket.send(send_data.encode(&#39;utf-8&#39;))\n    data = tcpCliSocket.recv(BUFSIZ)\n    if not data:\n        break\n    print(data.decode(&#39;utf-8&#39;))\n    tcpCliSocket.close()\n</code></pre>"},{"title":"Python Note 3","_content":"# Python Note 3\n\n### Classes\n> Use Pacal naming convertion,not like variables/function use lower cases and underscore connection.\n> Basic usage:\n\n```python\nclass Point:\n\tdef draw(self):\n\t\tprint(\"draw\")\n\n\tdef print(self):\n\t\tprint(\"this is point\")\n\n\npoint1 = Point()\npoint1.x = 5\npoint1.draw()\nprint(point1.x)\n```\n\n### Constructor\n\n```python\nclass Point:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\n\tdef draw(self):\n\t\tprint(\"draw\")\n\n\tdef print(self):\n\t\tprint(\"this is point\")\n\n\npoint1 = Point(10, 5)\npoint1.draw()\nprint(point1.x)\n\n#exercise\nclass Person:\n\tdef __init__(self, name):\n\t\tself.name = name\n\n\tdef talk(self):\n\t\tprint(f\"{self.name} is talking..\")\n\n\nwhile True:\n\tperson_name = str(input(\"Please enter person: \"))\n\tif person_name == \"Quit\":\n\t\tbreak\n\telif person_name != \"\":\n\t\tnew_person = Person(person_name)\n\t\tnew_person.talk()\n\telse:\n\t\tprint(\"You enter a empty!\")\n\n```\n\n### inheritance\n> use bracket to inherit parent class\n\n```python\nclass Mammal:\n\tdef walk(self):\n\t\tprint(\"walk\")\n\n\nclass Dog(Mammal):\n\tdef bark(self):\n\t\tprint(\"bark\")\n\n\nclass Cat(Mammal):\n\tpass  # tell python to pass this line\n\n\ndog1 = Dog()\ndog1.walk()\ndog1.bark()\n\n```\n\n### module\n> each file refer a module\n\n```python\nimport converters #to import converters.py\nfrom converters import kg_to_lbs\n\n#exercise\nimport  convertors\nfrom convertors import weight_to_lbs\n\nprint(weight_to_lbs())\nnumbers = [5,1,8,2]\nmaximum = convertors.find_max(numbers)\nprint(max(numbers))\n```\n\n### package\n> a set of modules: directory with \"__init__.py\" file\n\n```python\nfrom ecommerce.shopping import test\nfrom ecommerce import shopping\ntest()\nshopping.test()\n```\n\n### use python build-in module\n> search [python module index](https://docs.python.org/3/py-modindex.html)\n> PEP: python enhancement proposal\n\n```python\nimport  random\nmembers = [\"Jack\", \"Rose\", \"Bob\", \"Avery\", \"Mosh\"]\nm = random.choice(members)\nprint(m)\n\n#exercise\nimport random\nclass Dice: #will get PEP 8 warning\n    def roll(self):\n        r1 = random.randint(0, 5)\n        r2 = random.randint(0, 5)\n        return r1,r2  #Python will auto make it to Tuple\n\n\n\nmydice = Dice()\nprint(mydice.roll())\n```\n\n```python\nfrom pathlib import Path\n\npath = Path(\"pydemo2/ecommerce\")\nfor p in path.glob(\"*.py\"):\n    print(p)\n\n```\n\n### 使用type直接拿到类句柄\n\n+ 以type取得的值为句柄创建一个新的对象\n```python\nresult = type(self)(self.a)\n```","source":"_posts/Python_3.md","raw":"---\ntitle: Python Note 3\ncategories:\n- Python\ntags: \n- Python\n- Note\n---\n# Python Note 3\n\n### Classes\n> Use Pacal naming convertion,not like variables/function use lower cases and underscore connection.\n> Basic usage:\n\n```python\nclass Point:\n\tdef draw(self):\n\t\tprint(\"draw\")\n\n\tdef print(self):\n\t\tprint(\"this is point\")\n\n\npoint1 = Point()\npoint1.x = 5\npoint1.draw()\nprint(point1.x)\n```\n\n### Constructor\n\n```python\nclass Point:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\n\tdef draw(self):\n\t\tprint(\"draw\")\n\n\tdef print(self):\n\t\tprint(\"this is point\")\n\n\npoint1 = Point(10, 5)\npoint1.draw()\nprint(point1.x)\n\n#exercise\nclass Person:\n\tdef __init__(self, name):\n\t\tself.name = name\n\n\tdef talk(self):\n\t\tprint(f\"{self.name} is talking..\")\n\n\nwhile True:\n\tperson_name = str(input(\"Please enter person: \"))\n\tif person_name == \"Quit\":\n\t\tbreak\n\telif person_name != \"\":\n\t\tnew_person = Person(person_name)\n\t\tnew_person.talk()\n\telse:\n\t\tprint(\"You enter a empty!\")\n\n```\n\n### inheritance\n> use bracket to inherit parent class\n\n```python\nclass Mammal:\n\tdef walk(self):\n\t\tprint(\"walk\")\n\n\nclass Dog(Mammal):\n\tdef bark(self):\n\t\tprint(\"bark\")\n\n\nclass Cat(Mammal):\n\tpass  # tell python to pass this line\n\n\ndog1 = Dog()\ndog1.walk()\ndog1.bark()\n\n```\n\n### module\n> each file refer a module\n\n```python\nimport converters #to import converters.py\nfrom converters import kg_to_lbs\n\n#exercise\nimport  convertors\nfrom convertors import weight_to_lbs\n\nprint(weight_to_lbs())\nnumbers = [5,1,8,2]\nmaximum = convertors.find_max(numbers)\nprint(max(numbers))\n```\n\n### package\n> a set of modules: directory with \"__init__.py\" file\n\n```python\nfrom ecommerce.shopping import test\nfrom ecommerce import shopping\ntest()\nshopping.test()\n```\n\n### use python build-in module\n> search [python module index](https://docs.python.org/3/py-modindex.html)\n> PEP: python enhancement proposal\n\n```python\nimport  random\nmembers = [\"Jack\", \"Rose\", \"Bob\", \"Avery\", \"Mosh\"]\nm = random.choice(members)\nprint(m)\n\n#exercise\nimport random\nclass Dice: #will get PEP 8 warning\n    def roll(self):\n        r1 = random.randint(0, 5)\n        r2 = random.randint(0, 5)\n        return r1,r2  #Python will auto make it to Tuple\n\n\n\nmydice = Dice()\nprint(mydice.roll())\n```\n\n```python\nfrom pathlib import Path\n\npath = Path(\"pydemo2/ecommerce\")\nfor p in path.glob(\"*.py\"):\n    print(p)\n\n```\n\n### 使用type直接拿到类句柄\n\n+ 以type取得的值为句柄创建一个新的对象\n```python\nresult = type(self)(self.a)\n```","slug":"Python_3","published":1,"date":"2020-09-08T03:23:20.715Z","updated":"2020-09-08T03:23:20.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10a00214wf0i8bud1nc","content":"<h1 id=\"Python-Note-3\"><a href=\"#Python-Note-3\" class=\"headerlink\" title=\"Python Note 3\"></a>Python Note 3</h1><h3 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h3><blockquote>\n<p>Use Pacal naming convertion,not like variables/function use lower cases and underscore connection.<br>Basic usage:</p>\n</blockquote>\n<pre><code class=\"python\">class Point:\n    def draw(self):\n        print(&quot;draw&quot;)\n\n    def print(self):\n        print(&quot;this is point&quot;)\n\n\npoint1 = Point()\npoint1.x = 5\npoint1.draw()\nprint(point1.x)</code></pre>\n<h3 id=\"Constructor\"><a href=\"#Constructor\" class=\"headerlink\" title=\"Constructor\"></a>Constructor</h3><pre><code class=\"python\">class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def draw(self):\n        print(&quot;draw&quot;)\n\n    def print(self):\n        print(&quot;this is point&quot;)\n\n\npoint1 = Point(10, 5)\npoint1.draw()\nprint(point1.x)\n\n#exercise\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\n    def talk(self):\n        print(f&quot;{self.name} is talking..&quot;)\n\n\nwhile True:\n    person_name = str(input(&quot;Please enter person: &quot;))\n    if person_name == &quot;Quit&quot;:\n        break\n    elif person_name != &quot;&quot;:\n        new_person = Person(person_name)\n        new_person.talk()\n    else:\n        print(&quot;You enter a empty!&quot;)\n</code></pre>\n<h3 id=\"inheritance\"><a href=\"#inheritance\" class=\"headerlink\" title=\"inheritance\"></a>inheritance</h3><blockquote>\n<p>use bracket to inherit parent class</p>\n</blockquote>\n<pre><code class=\"python\">class Mammal:\n    def walk(self):\n        print(&quot;walk&quot;)\n\n\nclass Dog(Mammal):\n    def bark(self):\n        print(&quot;bark&quot;)\n\n\nclass Cat(Mammal):\n    pass  # tell python to pass this line\n\n\ndog1 = Dog()\ndog1.walk()\ndog1.bark()\n</code></pre>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h3><blockquote>\n<p>each file refer a module</p>\n</blockquote>\n<pre><code class=\"python\">import converters #to import converters.py\nfrom converters import kg_to_lbs\n\n#exercise\nimport  convertors\nfrom convertors import weight_to_lbs\n\nprint(weight_to_lbs())\nnumbers = [5,1,8,2]\nmaximum = convertors.find_max(numbers)\nprint(max(numbers))</code></pre>\n<h3 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h3><blockquote>\n<p>a set of modules: directory with “<strong>init</strong>.py” file</p>\n</blockquote>\n<pre><code class=\"python\">from ecommerce.shopping import test\nfrom ecommerce import shopping\ntest()\nshopping.test()</code></pre>\n<h3 id=\"use-python-build-in-module\"><a href=\"#use-python-build-in-module\" class=\"headerlink\" title=\"use python build-in module\"></a>use python build-in module</h3><blockquote>\n<p>search <a href=\"https://docs.python.org/3/py-modindex.html\">python module index</a><br>PEP: python enhancement proposal</p>\n</blockquote>\n<pre><code class=\"python\">import  random\nmembers = [&quot;Jack&quot;, &quot;Rose&quot;, &quot;Bob&quot;, &quot;Avery&quot;, &quot;Mosh&quot;]\nm = random.choice(members)\nprint(m)\n\n#exercise\nimport random\nclass Dice: #will get PEP 8 warning\n    def roll(self):\n        r1 = random.randint(0, 5)\n        r2 = random.randint(0, 5)\n        return r1,r2  #Python will auto make it to Tuple\n\n\n\nmydice = Dice()\nprint(mydice.roll())</code></pre>\n<pre><code class=\"python\">from pathlib import Path\n\npath = Path(&quot;pydemo2/ecommerce&quot;)\nfor p in path.glob(&quot;*.py&quot;):\n    print(p)\n</code></pre>\n<h3 id=\"使用type直接拿到类句柄\"><a href=\"#使用type直接拿到类句柄\" class=\"headerlink\" title=\"使用type直接拿到类句柄\"></a>使用type直接拿到类句柄</h3><ul>\n<li>以type取得的值为句柄创建一个新的对象<pre><code class=\"python\">result = type(self)(self.a)</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python-Note-3\"><a href=\"#Python-Note-3\" class=\"headerlink\" title=\"Python Note 3\"></a>Python Note 3</h1><h3 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h3><blockquote>\n<p>Use Pacal naming convertion,not like variables/function use lower cases and underscore connection.<br>Basic usage:</p>\n</blockquote>\n<pre><code class=\"python\">class Point:\n    def draw(self):\n        print(&quot;draw&quot;)\n\n    def print(self):\n        print(&quot;this is point&quot;)\n\n\npoint1 = Point()\npoint1.x = 5\npoint1.draw()\nprint(point1.x)</code></pre>\n<h3 id=\"Constructor\"><a href=\"#Constructor\" class=\"headerlink\" title=\"Constructor\"></a>Constructor</h3><pre><code class=\"python\">class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def draw(self):\n        print(&quot;draw&quot;)\n\n    def print(self):\n        print(&quot;this is point&quot;)\n\n\npoint1 = Point(10, 5)\npoint1.draw()\nprint(point1.x)\n\n#exercise\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\n    def talk(self):\n        print(f&quot;{self.name} is talking..&quot;)\n\n\nwhile True:\n    person_name = str(input(&quot;Please enter person: &quot;))\n    if person_name == &quot;Quit&quot;:\n        break\n    elif person_name != &quot;&quot;:\n        new_person = Person(person_name)\n        new_person.talk()\n    else:\n        print(&quot;You enter a empty!&quot;)\n</code></pre>\n<h3 id=\"inheritance\"><a href=\"#inheritance\" class=\"headerlink\" title=\"inheritance\"></a>inheritance</h3><blockquote>\n<p>use bracket to inherit parent class</p>\n</blockquote>\n<pre><code class=\"python\">class Mammal:\n    def walk(self):\n        print(&quot;walk&quot;)\n\n\nclass Dog(Mammal):\n    def bark(self):\n        print(&quot;bark&quot;)\n\n\nclass Cat(Mammal):\n    pass  # tell python to pass this line\n\n\ndog1 = Dog()\ndog1.walk()\ndog1.bark()\n</code></pre>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h3><blockquote>\n<p>each file refer a module</p>\n</blockquote>\n<pre><code class=\"python\">import converters #to import converters.py\nfrom converters import kg_to_lbs\n\n#exercise\nimport  convertors\nfrom convertors import weight_to_lbs\n\nprint(weight_to_lbs())\nnumbers = [5,1,8,2]\nmaximum = convertors.find_max(numbers)\nprint(max(numbers))</code></pre>\n<h3 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h3><blockquote>\n<p>a set of modules: directory with “<strong>init</strong>.py” file</p>\n</blockquote>\n<pre><code class=\"python\">from ecommerce.shopping import test\nfrom ecommerce import shopping\ntest()\nshopping.test()</code></pre>\n<h3 id=\"use-python-build-in-module\"><a href=\"#use-python-build-in-module\" class=\"headerlink\" title=\"use python build-in module\"></a>use python build-in module</h3><blockquote>\n<p>search <a href=\"https://docs.python.org/3/py-modindex.html\">python module index</a><br>PEP: python enhancement proposal</p>\n</blockquote>\n<pre><code class=\"python\">import  random\nmembers = [&quot;Jack&quot;, &quot;Rose&quot;, &quot;Bob&quot;, &quot;Avery&quot;, &quot;Mosh&quot;]\nm = random.choice(members)\nprint(m)\n\n#exercise\nimport random\nclass Dice: #will get PEP 8 warning\n    def roll(self):\n        r1 = random.randint(0, 5)\n        r2 = random.randint(0, 5)\n        return r1,r2  #Python will auto make it to Tuple\n\n\n\nmydice = Dice()\nprint(mydice.roll())</code></pre>\n<pre><code class=\"python\">from pathlib import Path\n\npath = Path(&quot;pydemo2/ecommerce&quot;)\nfor p in path.glob(&quot;*.py&quot;):\n    print(p)\n</code></pre>\n<h3 id=\"使用type直接拿到类句柄\"><a href=\"#使用type直接拿到类句柄\" class=\"headerlink\" title=\"使用type直接拿到类句柄\"></a>使用type直接拿到类句柄</h3><ul>\n<li>以type取得的值为句柄创建一个新的对象<pre><code class=\"python\">result = type(self)(self.a)</code></pre>\n</li>\n</ul>\n"},{"title":"Python 杂项","_content":"## Python 杂项\n\n### 关于 *args 和 **kwargs参数的用法\n\n> * 允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。\n\n```python\ndef f(a,*args):\n    print(args)\n\nf(1,2,3,4)\n\n\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    print(sum)\n\ncalc(1,2,3,4)\n```\n\n>  ** ,关键字参数允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict。\n\n```python\ndef d(**kargs):\n    print(kargs)\n    \nd(a=1,b=2)\n\n#在函数混合使用*以及**。\ndef h(a,*args,**kargs):\n    print(a,args,kargs)\n\nh(1,2,3,x=4,y=5)\n\ndef person(name,age,**kw):\n    print('name:',name,'age:',age,'other:',kw)\n    \nperson('Adam', 45, gender='M', job='Engineer')\n```\n\n\n### 关于多线程与多进程\n\n作者：DarrenChan陈驰\n链接：https://www.zhihu.com/question/23474039/answer/269526476\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n在介绍Python中的线程之前，先明确一个问题，Python中的多线程是假的多线程！ 为什么这么说，我们先明确一个概念，全局解释器锁（GIL）。\n\nPython代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。\n\n\n对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。在多线程环境中，Python虚拟机按照以下方式执行。\n1.设置GIL。\n2.切换到一个线程去执行。\n3.运行。\n4.把线程设置为睡眠状态。\n5.解锁GIL。\n6.再次重复以上步骤。\n\n对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。\n\n\n作者：yegle\n链接：https://www.zhihu.com/question/23474039/answer/24695447\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n> 如果你的代码是CPU密集型，多个线程的代码很有可能是线性执行的。所以这种情况下多线程是鸡肋，效率可能还不如单线程因为有context switch但是：如果你的代码是IO密集型，多线程可以明显提高效率。例如制作爬虫（我就不明白为什么Python总和爬虫联系在一起…不过也只想起来这个例子…），绝大多数时间爬虫是在等待socket返回数据。这个时候C代码里是有release GIL的，最终结果是某个线程等待IO的时候其他线程可以继续执行。反过来讲：你就不应该用Python写CPU密集型的代码…效率摆在那里…\n\n\n如果确实需要在CPU密集型的代码里用concurrent，就去用multiprocessing库。这个库是基于multi process实现了类multi thread的API接口，并且用pickle部分地实现了变量共享。再加一条，如果你不知道你的代码到底算CPU密集型还是IO密集型，教你个方法：multiprocessing这个module有一个dummy的sub module，它是基于multithread实现了multiprocessing的API。\n\n假设你使用的是multiprocessing的Pool，是使用多进程实现了concurrency\n\n```from multiprocessing import Pool```\n\n如果把这个代码改成下面这样，就变成多线程实现concurrency\n\n```from multiprocessing.dummy import Pool```\n\n两种方式都跑一下，哪个速度快用哪个就行了。\n> 刚刚才发现concurrent.futures这个东西，包含ThreadPoolExecutor和ProcessPoolExecutor，可能比multiprocessing更简单\n\n\n作者：find goo\n链接：https://www.zhihu.com/question/23474039/answer/132530023\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n多线程还是有用的，多进程有多进程的好处，多线程有多线程的好处。多进程稳定，启动时开销大点，但如果你的运行时间远大于多进程的时间，用多进程比较方便，如postgresql用多进程，chrome 多进程。如果你只是想做个定时器样的简单东西，对稳定性要求低些，如vb,c#类似的定时器，用多线程吧，但线程的同步要注意了。python的线程更加类似定时器，python的线程不是真线程，但有的场合用这种定时器也能解决很多问题，因为开销小，开启也方便。进程和线程，一个是重量级的，一个轻量级的，重量级的进程有保护区，进程上下文都是操作系统保护的，而线程是自己管理，需要一定的技术，不能保证在并发时的稳定性（多进程也不稳定，但很容易看出来，因为多出了进程容易发现），而python的更像是定时器，定时器有时也可以模拟线程，定时器多时的开销比线程的开销要小，真线程有下上文开销，一个操作系统启动多进程和多线程会达到切换饱和是有数量的，真线程或进程太多都会导致cpu占用率居高不下，而定时器可以开n多。很多东西不是一种比另外一种先进，而是一种互补的关系，计算机的计算单位切换有优点必有缺点，关键在找到合适的使用方式扬长避短。\n\n\n### 参考教程\n\nhttps://learnku.com/docs/pymotw\n\n","source":"_posts/Python 杂项.md","raw":"---\ntitle:  Python 杂项\ncategories:\n- Python\ntags: \n- Python\n- Note\n---\n## Python 杂项\n\n### 关于 *args 和 **kwargs参数的用法\n\n> * 允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。\n\n```python\ndef f(a,*args):\n    print(args)\n\nf(1,2,3,4)\n\n\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    print(sum)\n\ncalc(1,2,3,4)\n```\n\n>  ** ,关键字参数允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict。\n\n```python\ndef d(**kargs):\n    print(kargs)\n    \nd(a=1,b=2)\n\n#在函数混合使用*以及**。\ndef h(a,*args,**kargs):\n    print(a,args,kargs)\n\nh(1,2,3,x=4,y=5)\n\ndef person(name,age,**kw):\n    print('name:',name,'age:',age,'other:',kw)\n    \nperson('Adam', 45, gender='M', job='Engineer')\n```\n\n\n### 关于多线程与多进程\n\n作者：DarrenChan陈驰\n链接：https://www.zhihu.com/question/23474039/answer/269526476\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n在介绍Python中的线程之前，先明确一个问题，Python中的多线程是假的多线程！ 为什么这么说，我们先明确一个概念，全局解释器锁（GIL）。\n\nPython代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。\n\n\n对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。在多线程环境中，Python虚拟机按照以下方式执行。\n1.设置GIL。\n2.切换到一个线程去执行。\n3.运行。\n4.把线程设置为睡眠状态。\n5.解锁GIL。\n6.再次重复以上步骤。\n\n对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。\n\n\n作者：yegle\n链接：https://www.zhihu.com/question/23474039/answer/24695447\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n> 如果你的代码是CPU密集型，多个线程的代码很有可能是线性执行的。所以这种情况下多线程是鸡肋，效率可能还不如单线程因为有context switch但是：如果你的代码是IO密集型，多线程可以明显提高效率。例如制作爬虫（我就不明白为什么Python总和爬虫联系在一起…不过也只想起来这个例子…），绝大多数时间爬虫是在等待socket返回数据。这个时候C代码里是有release GIL的，最终结果是某个线程等待IO的时候其他线程可以继续执行。反过来讲：你就不应该用Python写CPU密集型的代码…效率摆在那里…\n\n\n如果确实需要在CPU密集型的代码里用concurrent，就去用multiprocessing库。这个库是基于multi process实现了类multi thread的API接口，并且用pickle部分地实现了变量共享。再加一条，如果你不知道你的代码到底算CPU密集型还是IO密集型，教你个方法：multiprocessing这个module有一个dummy的sub module，它是基于multithread实现了multiprocessing的API。\n\n假设你使用的是multiprocessing的Pool，是使用多进程实现了concurrency\n\n```from multiprocessing import Pool```\n\n如果把这个代码改成下面这样，就变成多线程实现concurrency\n\n```from multiprocessing.dummy import Pool```\n\n两种方式都跑一下，哪个速度快用哪个就行了。\n> 刚刚才发现concurrent.futures这个东西，包含ThreadPoolExecutor和ProcessPoolExecutor，可能比multiprocessing更简单\n\n\n作者：find goo\n链接：https://www.zhihu.com/question/23474039/answer/132530023\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n多线程还是有用的，多进程有多进程的好处，多线程有多线程的好处。多进程稳定，启动时开销大点，但如果你的运行时间远大于多进程的时间，用多进程比较方便，如postgresql用多进程，chrome 多进程。如果你只是想做个定时器样的简单东西，对稳定性要求低些，如vb,c#类似的定时器，用多线程吧，但线程的同步要注意了。python的线程更加类似定时器，python的线程不是真线程，但有的场合用这种定时器也能解决很多问题，因为开销小，开启也方便。进程和线程，一个是重量级的，一个轻量级的，重量级的进程有保护区，进程上下文都是操作系统保护的，而线程是自己管理，需要一定的技术，不能保证在并发时的稳定性（多进程也不稳定，但很容易看出来，因为多出了进程容易发现），而python的更像是定时器，定时器有时也可以模拟线程，定时器多时的开销比线程的开销要小，真线程有下上文开销，一个操作系统启动多进程和多线程会达到切换饱和是有数量的，真线程或进程太多都会导致cpu占用率居高不下，而定时器可以开n多。很多东西不是一种比另外一种先进，而是一种互补的关系，计算机的计算单位切换有优点必有缺点，关键在找到合适的使用方式扬长避短。\n\n\n### 参考教程\n\nhttps://learnku.com/docs/pymotw\n\n","slug":"Python 杂项","published":1,"date":"2020-09-27T04:18:01.674Z","updated":"2020-09-27T04:18:01.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10d00264wf0aihh4x41","content":"<h2 id=\"Python-杂项\"><a href=\"#Python-杂项\" class=\"headerlink\" title=\"Python 杂项\"></a>Python 杂项</h2><h3 id=\"关于-args-和-kwargs参数的用法\"><a href=\"#关于-args-和-kwargs参数的用法\" class=\"headerlink\" title=\"关于 args 和 *kwargs参数的用法\"></a>关于 <em>args 和 *</em>kwargs参数的用法</h3><blockquote>\n<ul>\n<li>允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。</li>\n</ul>\n</blockquote>\n<pre><code class=\"python\">def f(a,*args):\n    print(args)\n\nf(1,2,3,4)\n\n\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    print(sum)\n\ncalc(1,2,3,4)</code></pre>\n<blockquote>\n<p> ** ,关键字参数允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict。</p>\n</blockquote>\n<pre><code class=\"python\">def d(**kargs):\n    print(kargs)\n\nd(a=1,b=2)\n\n#在函数混合使用*以及**。\ndef h(a,*args,**kargs):\n    print(a,args,kargs)\n\nh(1,2,3,x=4,y=5)\n\ndef person(name,age,**kw):\n    print(&#39;name:&#39;,name,&#39;age:&#39;,age,&#39;other:&#39;,kw)\n\nperson(&#39;Adam&#39;, 45, gender=&#39;M&#39;, job=&#39;Engineer&#39;)</code></pre>\n<h3 id=\"关于多线程与多进程\"><a href=\"#关于多线程与多进程\" class=\"headerlink\" title=\"关于多线程与多进程\"></a>关于多线程与多进程</h3><p>作者：DarrenChan陈驰<br>链接：<a href=\"https://www.zhihu.com/question/23474039/answer/269526476\">https://www.zhihu.com/question/23474039/answer/269526476</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>在介绍Python中的线程之前，先明确一个问题，Python中的多线程是假的多线程！ 为什么这么说，我们先明确一个概念，全局解释器锁（GIL）。</p>\n<p>Python代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。</p>\n<p>对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。在多线程环境中，Python虚拟机按照以下方式执行。<br>1.设置GIL。<br>2.切换到一个线程去执行。<br>3.运行。<br>4.把线程设置为睡眠状态。<br>5.解锁GIL。<br>6.再次重复以上步骤。</p>\n<p>对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>\n<p>作者：yegle<br>链接：<a href=\"https://www.zhihu.com/question/23474039/answer/24695447\">https://www.zhihu.com/question/23474039/answer/24695447</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>如果你的代码是CPU密集型，多个线程的代码很有可能是线性执行的。所以这种情况下多线程是鸡肋，效率可能还不如单线程因为有context switch但是：如果你的代码是IO密集型，多线程可以明显提高效率。例如制作爬虫（我就不明白为什么Python总和爬虫联系在一起…不过也只想起来这个例子…），绝大多数时间爬虫是在等待socket返回数据。这个时候C代码里是有release GIL的，最终结果是某个线程等待IO的时候其他线程可以继续执行。反过来讲：你就不应该用Python写CPU密集型的代码…效率摆在那里…</p>\n</blockquote>\n<p>如果确实需要在CPU密集型的代码里用concurrent，就去用multiprocessing库。这个库是基于multi process实现了类multi thread的API接口，并且用pickle部分地实现了变量共享。再加一条，如果你不知道你的代码到底算CPU密集型还是IO密集型，教你个方法：multiprocessing这个module有一个dummy的sub module，它是基于multithread实现了multiprocessing的API。</p>\n<p>假设你使用的是multiprocessing的Pool，是使用多进程实现了concurrency</p>\n<p><code>from multiprocessing import Pool</code></p>\n<p>如果把这个代码改成下面这样，就变成多线程实现concurrency</p>\n<p><code>from multiprocessing.dummy import Pool</code></p>\n<p>两种方式都跑一下，哪个速度快用哪个就行了。</p>\n<blockquote>\n<p>刚刚才发现concurrent.futures这个东西，包含ThreadPoolExecutor和ProcessPoolExecutor，可能比multiprocessing更简单</p>\n</blockquote>\n<p>作者：find goo<br>链接：<a href=\"https://www.zhihu.com/question/23474039/answer/132530023\">https://www.zhihu.com/question/23474039/answer/132530023</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>多线程还是有用的，多进程有多进程的好处，多线程有多线程的好处。多进程稳定，启动时开销大点，但如果你的运行时间远大于多进程的时间，用多进程比较方便，如postgresql用多进程，chrome 多进程。如果你只是想做个定时器样的简单东西，对稳定性要求低些，如vb,c#类似的定时器，用多线程吧，但线程的同步要注意了。python的线程更加类似定时器，python的线程不是真线程，但有的场合用这种定时器也能解决很多问题，因为开销小，开启也方便。进程和线程，一个是重量级的，一个轻量级的，重量级的进程有保护区，进程上下文都是操作系统保护的，而线程是自己管理，需要一定的技术，不能保证在并发时的稳定性（多进程也不稳定，但很容易看出来，因为多出了进程容易发现），而python的更像是定时器，定时器有时也可以模拟线程，定时器多时的开销比线程的开销要小，真线程有下上文开销，一个操作系统启动多进程和多线程会达到切换饱和是有数量的，真线程或进程太多都会导致cpu占用率居高不下，而定时器可以开n多。很多东西不是一种比另外一种先进，而是一种互补的关系，计算机的计算单位切换有优点必有缺点，关键在找到合适的使用方式扬长避短。</p>\n<h3 id=\"参考教程\"><a href=\"#参考教程\" class=\"headerlink\" title=\"参考教程\"></a>参考教程</h3><p><a href=\"https://learnku.com/docs/pymotw\">https://learnku.com/docs/pymotw</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Python-杂项\"><a href=\"#Python-杂项\" class=\"headerlink\" title=\"Python 杂项\"></a>Python 杂项</h2><h3 id=\"关于-args-和-kwargs参数的用法\"><a href=\"#关于-args-和-kwargs参数的用法\" class=\"headerlink\" title=\"关于 args 和 *kwargs参数的用法\"></a>关于 <em>args 和 *</em>kwargs参数的用法</h3><blockquote>\n<ul>\n<li>允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。</li>\n</ul>\n</blockquote>\n<pre><code class=\"python\">def f(a,*args):\n    print(args)\n\nf(1,2,3,4)\n\n\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    print(sum)\n\ncalc(1,2,3,4)</code></pre>\n<blockquote>\n<p> ** ,关键字参数允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict。</p>\n</blockquote>\n<pre><code class=\"python\">def d(**kargs):\n    print(kargs)\n\nd(a=1,b=2)\n\n#在函数混合使用*以及**。\ndef h(a,*args,**kargs):\n    print(a,args,kargs)\n\nh(1,2,3,x=4,y=5)\n\ndef person(name,age,**kw):\n    print(&#39;name:&#39;,name,&#39;age:&#39;,age,&#39;other:&#39;,kw)\n\nperson(&#39;Adam&#39;, 45, gender=&#39;M&#39;, job=&#39;Engineer&#39;)</code></pre>\n<h3 id=\"关于多线程与多进程\"><a href=\"#关于多线程与多进程\" class=\"headerlink\" title=\"关于多线程与多进程\"></a>关于多线程与多进程</h3><p>作者：DarrenChan陈驰<br>链接：<a href=\"https://www.zhihu.com/question/23474039/answer/269526476\">https://www.zhihu.com/question/23474039/answer/269526476</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>在介绍Python中的线程之前，先明确一个问题，Python中的多线程是假的多线程！ 为什么这么说，我们先明确一个概念，全局解释器锁（GIL）。</p>\n<p>Python代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。</p>\n<p>对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。在多线程环境中，Python虚拟机按照以下方式执行。<br>1.设置GIL。<br>2.切换到一个线程去执行。<br>3.运行。<br>4.把线程设置为睡眠状态。<br>5.解锁GIL。<br>6.再次重复以上步骤。</p>\n<p>对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>\n<p>作者：yegle<br>链接：<a href=\"https://www.zhihu.com/question/23474039/answer/24695447\">https://www.zhihu.com/question/23474039/answer/24695447</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>如果你的代码是CPU密集型，多个线程的代码很有可能是线性执行的。所以这种情况下多线程是鸡肋，效率可能还不如单线程因为有context switch但是：如果你的代码是IO密集型，多线程可以明显提高效率。例如制作爬虫（我就不明白为什么Python总和爬虫联系在一起…不过也只想起来这个例子…），绝大多数时间爬虫是在等待socket返回数据。这个时候C代码里是有release GIL的，最终结果是某个线程等待IO的时候其他线程可以继续执行。反过来讲：你就不应该用Python写CPU密集型的代码…效率摆在那里…</p>\n</blockquote>\n<p>如果确实需要在CPU密集型的代码里用concurrent，就去用multiprocessing库。这个库是基于multi process实现了类multi thread的API接口，并且用pickle部分地实现了变量共享。再加一条，如果你不知道你的代码到底算CPU密集型还是IO密集型，教你个方法：multiprocessing这个module有一个dummy的sub module，它是基于multithread实现了multiprocessing的API。</p>\n<p>假设你使用的是multiprocessing的Pool，是使用多进程实现了concurrency</p>\n<p><code>from multiprocessing import Pool</code></p>\n<p>如果把这个代码改成下面这样，就变成多线程实现concurrency</p>\n<p><code>from multiprocessing.dummy import Pool</code></p>\n<p>两种方式都跑一下，哪个速度快用哪个就行了。</p>\n<blockquote>\n<p>刚刚才发现concurrent.futures这个东西，包含ThreadPoolExecutor和ProcessPoolExecutor，可能比multiprocessing更简单</p>\n</blockquote>\n<p>作者：find goo<br>链接：<a href=\"https://www.zhihu.com/question/23474039/answer/132530023\">https://www.zhihu.com/question/23474039/answer/132530023</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>多线程还是有用的，多进程有多进程的好处，多线程有多线程的好处。多进程稳定，启动时开销大点，但如果你的运行时间远大于多进程的时间，用多进程比较方便，如postgresql用多进程，chrome 多进程。如果你只是想做个定时器样的简单东西，对稳定性要求低些，如vb,c#类似的定时器，用多线程吧，但线程的同步要注意了。python的线程更加类似定时器，python的线程不是真线程，但有的场合用这种定时器也能解决很多问题，因为开销小，开启也方便。进程和线程，一个是重量级的，一个轻量级的，重量级的进程有保护区，进程上下文都是操作系统保护的，而线程是自己管理，需要一定的技术，不能保证在并发时的稳定性（多进程也不稳定，但很容易看出来，因为多出了进程容易发现），而python的更像是定时器，定时器有时也可以模拟线程，定时器多时的开销比线程的开销要小，真线程有下上文开销，一个操作系统启动多进程和多线程会达到切换饱和是有数量的，真线程或进程太多都会导致cpu占用率居高不下，而定时器可以开n多。很多东西不是一种比另外一种先进，而是一种互补的关系，计算机的计算单位切换有优点必有缺点，关键在找到合适的使用方式扬长避短。</p>\n<h3 id=\"参考教程\"><a href=\"#参考教程\" class=\"headerlink\" title=\"参考教程\"></a>参考教程</h3><p><a href=\"https://learnku.com/docs/pymotw\">https://learnku.com/docs/pymotw</a></p>\n"},{"title":"Smargit  简单使用说明","_content":"\n## 下载安装\n\n* 打开网址：https://www.syntevo.com/smartgit/\n* 如图，点击Download，进入后选择自己自己的系统平台\n![enter description here](./images/1574504169104.png)\n\n![enter description here](./images/1574504183153.png)\n\n* 解压后，直接点击EXE文件安装，使用默认选项就行了。\n\n## 第一次打开\n\n1. 如果本地已经用过乌龟拉项目，smartgit会自动检测出项目，点击打开即可\n2. 如果没有项目，请直接选择克隆新项目\n![enter description here](./images/1574504408755.png)\n![](./images/1574504420111.png)\n![enter description here](./images/1574504426236.png)\n\n\n## 切换分支\n双击分支窗口的一个分支即可：\n![enter description here](./images/1574504495536.png)\n\n## 拉取最新\n![enter description here](./images/1574504516272.png)\n如果弹出窗口，选择“快进”的方式就可以了\n\n## 提交更改\n* 点亮来更改和新增的标识，来显示文件，如图：\n ![enter description here](./images/1574504592931.png)\n\n* 选择自己的更改项，点提交并推送就行\n![enter description here](./images/1574504634973.png)\n\n![enter description here](./images/1574504645523.png)\n\n## 建议\n\n1. 提交前先点一下拉取，获取到最新的代码\n2. 如果发现显示有问题，右击仓库窗口里的项目来刷新一下，如：\n![enter description here](./images/1574504738524.png)\n","source":"_posts/Smargit  简单使用说明.md","raw":"---\ntitle: Smargit  简单使用说明\ncategories:\n- 公司\ntags: \n- Git\n---\n\n## 下载安装\n\n* 打开网址：https://www.syntevo.com/smartgit/\n* 如图，点击Download，进入后选择自己自己的系统平台\n![enter description here](./images/1574504169104.png)\n\n![enter description here](./images/1574504183153.png)\n\n* 解压后，直接点击EXE文件安装，使用默认选项就行了。\n\n## 第一次打开\n\n1. 如果本地已经用过乌龟拉项目，smartgit会自动检测出项目，点击打开即可\n2. 如果没有项目，请直接选择克隆新项目\n![enter description here](./images/1574504408755.png)\n![](./images/1574504420111.png)\n![enter description here](./images/1574504426236.png)\n\n\n## 切换分支\n双击分支窗口的一个分支即可：\n![enter description here](./images/1574504495536.png)\n\n## 拉取最新\n![enter description here](./images/1574504516272.png)\n如果弹出窗口，选择“快进”的方式就可以了\n\n## 提交更改\n* 点亮来更改和新增的标识，来显示文件，如图：\n ![enter description here](./images/1574504592931.png)\n\n* 选择自己的更改项，点提交并推送就行\n![enter description here](./images/1574504634973.png)\n\n![enter description here](./images/1574504645523.png)\n\n## 建议\n\n1. 提交前先点一下拉取，获取到最新的代码\n2. 如果发现显示有问题，右击仓库窗口里的项目来刷新一下，如：\n![enter description here](./images/1574504738524.png)\n","slug":"Smargit  简单使用说明","published":1,"date":"2020-09-08T03:23:20.715Z","updated":"2020-09-08T03:23:20.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10h00294wf05d0yt558","content":"<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><ul>\n<li>打开网址：<a href=\"https://www.syntevo.com/smartgit/\">https://www.syntevo.com/smartgit/</a></li>\n<li>如图，点击Download，进入后选择自己自己的系统平台<br><img src=\"./images/1574504169104.png\" alt=\"enter description here\"></li>\n</ul>\n<p><img src=\"./images/1574504183153.png\" alt=\"enter description here\"></p>\n<ul>\n<li>解压后，直接点击EXE文件安装，使用默认选项就行了。</li>\n</ul>\n<h2 id=\"第一次打开\"><a href=\"#第一次打开\" class=\"headerlink\" title=\"第一次打开\"></a>第一次打开</h2><ol>\n<li>如果本地已经用过乌龟拉项目，smartgit会自动检测出项目，点击打开即可</li>\n<li>如果没有项目，请直接选择克隆新项目<br><img src=\"./images/1574504408755.png\" alt=\"enter description here\"><br><img src=\"./images/1574504420111.png\" alt=\"\"><br><img src=\"./images/1574504426236.png\" alt=\"enter description here\"></li>\n</ol>\n<h2 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h2><p>双击分支窗口的一个分支即可：<br><img src=\"./images/1574504495536.png\" alt=\"enter description here\"></p>\n<h2 id=\"拉取最新\"><a href=\"#拉取最新\" class=\"headerlink\" title=\"拉取最新\"></a>拉取最新</h2><p><img src=\"./images/1574504516272.png\" alt=\"enter description here\"><br>如果弹出窗口，选择“快进”的方式就可以了</p>\n<h2 id=\"提交更改\"><a href=\"#提交更改\" class=\"headerlink\" title=\"提交更改\"></a>提交更改</h2><ul>\n<li><p>点亮来更改和新增的标识，来显示文件，如图：<br><img src=\"./images/1574504592931.png\" alt=\"enter description here\"></p>\n</li>\n<li><p>选择自己的更改项，点提交并推送就行<br><img src=\"./images/1574504634973.png\" alt=\"enter description here\"></p>\n</li>\n</ul>\n<p><img src=\"./images/1574504645523.png\" alt=\"enter description here\"></p>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h2><ol>\n<li>提交前先点一下拉取，获取到最新的代码</li>\n<li>如果发现显示有问题，右击仓库窗口里的项目来刷新一下，如：<br><img src=\"./images/1574504738524.png\" alt=\"enter description here\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><ul>\n<li>打开网址：<a href=\"https://www.syntevo.com/smartgit/\">https://www.syntevo.com/smartgit/</a></li>\n<li>如图，点击Download，进入后选择自己自己的系统平台<br><img src=\"./images/1574504169104.png\" alt=\"enter description here\"></li>\n</ul>\n<p><img src=\"./images/1574504183153.png\" alt=\"enter description here\"></p>\n<ul>\n<li>解压后，直接点击EXE文件安装，使用默认选项就行了。</li>\n</ul>\n<h2 id=\"第一次打开\"><a href=\"#第一次打开\" class=\"headerlink\" title=\"第一次打开\"></a>第一次打开</h2><ol>\n<li>如果本地已经用过乌龟拉项目，smartgit会自动检测出项目，点击打开即可</li>\n<li>如果没有项目，请直接选择克隆新项目<br><img src=\"./images/1574504408755.png\" alt=\"enter description here\"><br><img src=\"./images/1574504420111.png\" alt=\"\"><br><img src=\"./images/1574504426236.png\" alt=\"enter description here\"></li>\n</ol>\n<h2 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h2><p>双击分支窗口的一个分支即可：<br><img src=\"./images/1574504495536.png\" alt=\"enter description here\"></p>\n<h2 id=\"拉取最新\"><a href=\"#拉取最新\" class=\"headerlink\" title=\"拉取最新\"></a>拉取最新</h2><p><img src=\"./images/1574504516272.png\" alt=\"enter description here\"><br>如果弹出窗口，选择“快进”的方式就可以了</p>\n<h2 id=\"提交更改\"><a href=\"#提交更改\" class=\"headerlink\" title=\"提交更改\"></a>提交更改</h2><ul>\n<li><p>点亮来更改和新增的标识，来显示文件，如图：<br><img src=\"./images/1574504592931.png\" alt=\"enter description here\"></p>\n</li>\n<li><p>选择自己的更改项，点提交并推送就行<br><img src=\"./images/1574504634973.png\" alt=\"enter description here\"></p>\n</li>\n</ul>\n<p><img src=\"./images/1574504645523.png\" alt=\"enter description here\"></p>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h2><ol>\n<li>提交前先点一下拉取，获取到最新的代码</li>\n<li>如果发现显示有问题，右击仓库窗口里的项目来刷新一下，如：<br><img src=\"./images/1574504738524.png\" alt=\"enter description here\"></li>\n</ol>\n"},{"title":"Shader Variant","_content":"\n#### multi_compile与shader_feature\n\nmulti_compile与shader_feature可在shader中定义宏。两者区别如下图所示：\n\n|              | multi_compile           | shader_feature           |\n| ------------ | ----------------------- | ------------------------ |\n| 定义方式     | #pragma multi_compile A | #pragma shader_feature A |\n| 宏的适用范围 | 大多数shader            | 一般仅针对shader自身     |\n| 变体的生成   | 生成所有的变体          | 可自定义生成何种变体     |\n| 默认定义的宏 | 默认定义首个宏          | 默认定义首个宏           |\n\n\n1. 定义方式\n定义方式中值得注意的是，#pragma shader_feature A其实是 #pragma shader_feature _ A的简写，下划线表示未定义宏(nokeyword)。因此此时shader其实对应了两个变体，一个是nokeyword，一个是定义了宏A的。\n而#pragma multi_compile A并不存在简写这一说，所以shader此时只对应A这个变体。若要表示未定义任何变体，则应写为 #pragma multi_compile __ A。\n\n2. 宏的适用范围\nmulti_compile定义的宏，如#pragma multi_compile_fog，#pragma multi_compile_fwdbase等，基本上适用于大部分shader，与shader自身所带的属性无关。\nshader_feature定义的宏多用于针对shader自身的属性。比如shader中有_NormalMap这个属性(Property)，便可通过#pragma shader_feature _NormalMap来定义宏，用来实现这个shader在material有无_NormalMap时可进行不同的处理。\n\n3. 变体的生成\n#pragma multi_compile A B C\n#pragma multi_compile D E\n则此时会生成 A D、A E、B D、B E、C D、C E这6中变体。\nshader_feature要生成何种变体可用shader variant collection进行自定义设置。\n\n4. 默认定义的宏\n当material中的keywords无法对应shader所生成的变体时，Unity便会默认定义宏定义语句中的首个宏，并运行相应的变体来为这个material进行渲染。\nmulti_compile与shader_feature都默认定义首个宏。\n\n#### 如何控制项目中Shader变体的生成\n\n| 生成方式                                              | 优点                                             | 缺点                                                                                                                       |\n| ----------------------------------------------------- | ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |\n| shader与material打在一个包中                          | 变体根据material中的keywords自动生成             | 多个不同的material包中可能存在相同的shader变体，造成资源冗余，若在程序运行时动态改变material的keyword其变体可能并没有被生成 |\n| Shader单独打包，使用multi_compile定义全部宏           | 全部变体都被生成，不会发生需要的变体未生成的情况 |                                                                                                                          生成的变体数量庞大，严重浪费资源   |\n| Shader单独打包，shader_feature与multi_compile结合使用 | 能够有效控制变体数量                             |                                                                                                                            如何确定哪些变体需要生成，容易遗漏需要生成的变体|\n\n\n#### Shader编写规范\n\n1. 建议使用shader_feature时将定义语句写成完整模式，并且不要在一个语句中定义多个宏。\n完整模式：#pragma shader_feature _ A，不建议写成#pragma shader_feature A。\n不建议在一个语句中定义多个宏，如： #pragma shader_feature _ A B C，若一定要定义多个宏，请务必将其写成完整模式，不使用完整模式在切换shader时可能会与想要的效果不一致，具体原因尚未测得。\n\n2. 若在shader中使用shader_feature，请为这个shader指定一个CustomEditor\n每个使用shader_feature来定义Keyword的shader都需要再末尾加个 CusomEditor “xxxx”，并在代码中实现类xxxx(需继承自UnityEditor.ShaderGUI)，用来对Keywords定义进行设定。\n这么做是因为Material中的部分Keyword是由shader中的属性(Properties)所控制的。比如shader中含有_NormalMap的属性并且定义了与_NormalMap相关的Keyword，这个Keyword需要在Material含有NormalMap时添加，不含NormalMap时移除。这个功能可由自定义的CustomEidtor实现。\n具体如何写这个CustomEditor类可参考Unity builtin_shaders\\Editor\\StandardShaderGUI.cs。该文件可去Unity官网下载，下载时选择内置着色器即可。","source":"_posts/Shader Variant.md","raw":"---\ntitle: Shader Variant\ncategories:\n- Unity\n---\n\n#### multi_compile与shader_feature\n\nmulti_compile与shader_feature可在shader中定义宏。两者区别如下图所示：\n\n|              | multi_compile           | shader_feature           |\n| ------------ | ----------------------- | ------------------------ |\n| 定义方式     | #pragma multi_compile A | #pragma shader_feature A |\n| 宏的适用范围 | 大多数shader            | 一般仅针对shader自身     |\n| 变体的生成   | 生成所有的变体          | 可自定义生成何种变体     |\n| 默认定义的宏 | 默认定义首个宏          | 默认定义首个宏           |\n\n\n1. 定义方式\n定义方式中值得注意的是，#pragma shader_feature A其实是 #pragma shader_feature _ A的简写，下划线表示未定义宏(nokeyword)。因此此时shader其实对应了两个变体，一个是nokeyword，一个是定义了宏A的。\n而#pragma multi_compile A并不存在简写这一说，所以shader此时只对应A这个变体。若要表示未定义任何变体，则应写为 #pragma multi_compile __ A。\n\n2. 宏的适用范围\nmulti_compile定义的宏，如#pragma multi_compile_fog，#pragma multi_compile_fwdbase等，基本上适用于大部分shader，与shader自身所带的属性无关。\nshader_feature定义的宏多用于针对shader自身的属性。比如shader中有_NormalMap这个属性(Property)，便可通过#pragma shader_feature _NormalMap来定义宏，用来实现这个shader在material有无_NormalMap时可进行不同的处理。\n\n3. 变体的生成\n#pragma multi_compile A B C\n#pragma multi_compile D E\n则此时会生成 A D、A E、B D、B E、C D、C E这6中变体。\nshader_feature要生成何种变体可用shader variant collection进行自定义设置。\n\n4. 默认定义的宏\n当material中的keywords无法对应shader所生成的变体时，Unity便会默认定义宏定义语句中的首个宏，并运行相应的变体来为这个material进行渲染。\nmulti_compile与shader_feature都默认定义首个宏。\n\n#### 如何控制项目中Shader变体的生成\n\n| 生成方式                                              | 优点                                             | 缺点                                                                                                                       |\n| ----------------------------------------------------- | ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |\n| shader与material打在一个包中                          | 变体根据material中的keywords自动生成             | 多个不同的material包中可能存在相同的shader变体，造成资源冗余，若在程序运行时动态改变material的keyword其变体可能并没有被生成 |\n| Shader单独打包，使用multi_compile定义全部宏           | 全部变体都被生成，不会发生需要的变体未生成的情况 |                                                                                                                          生成的变体数量庞大，严重浪费资源   |\n| Shader单独打包，shader_feature与multi_compile结合使用 | 能够有效控制变体数量                             |                                                                                                                            如何确定哪些变体需要生成，容易遗漏需要生成的变体|\n\n\n#### Shader编写规范\n\n1. 建议使用shader_feature时将定义语句写成完整模式，并且不要在一个语句中定义多个宏。\n完整模式：#pragma shader_feature _ A，不建议写成#pragma shader_feature A。\n不建议在一个语句中定义多个宏，如： #pragma shader_feature _ A B C，若一定要定义多个宏，请务必将其写成完整模式，不使用完整模式在切换shader时可能会与想要的效果不一致，具体原因尚未测得。\n\n2. 若在shader中使用shader_feature，请为这个shader指定一个CustomEditor\n每个使用shader_feature来定义Keyword的shader都需要再末尾加个 CusomEditor “xxxx”，并在代码中实现类xxxx(需继承自UnityEditor.ShaderGUI)，用来对Keywords定义进行设定。\n这么做是因为Material中的部分Keyword是由shader中的属性(Properties)所控制的。比如shader中含有_NormalMap的属性并且定义了与_NormalMap相关的Keyword，这个Keyword需要在Material含有NormalMap时添加，不含NormalMap时移除。这个功能可由自定义的CustomEidtor实现。\n具体如何写这个CustomEditor类可参考Unity builtin_shaders\\Editor\\StandardShaderGUI.cs。该文件可去Unity官网下载，下载时选择内置着色器即可。","slug":"Shader Variant","published":1,"date":"2020-09-08T03:23:20.715Z","updated":"2020-09-08T03:23:20.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10k002e4wf0nfqjqqhz","content":"<h4 id=\"multi-compile与shader-feature\"><a href=\"#multi-compile与shader-feature\" class=\"headerlink\" title=\"multi_compile与shader_feature\"></a>multi_compile与shader_feature</h4><p>multi_compile与shader_feature可在shader中定义宏。两者区别如下图所示：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>multi_compile</th>\n<th>shader_feature</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义方式</td>\n<td>#pragma multi_compile A</td>\n<td>#pragma shader_feature A</td>\n</tr>\n<tr>\n<td>宏的适用范围</td>\n<td>大多数shader</td>\n<td>一般仅针对shader自身</td>\n</tr>\n<tr>\n<td>变体的生成</td>\n<td>生成所有的变体</td>\n<td>可自定义生成何种变体</td>\n</tr>\n<tr>\n<td>默认定义的宏</td>\n<td>默认定义首个宏</td>\n<td>默认定义首个宏</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>定义方式<br>定义方式中值得注意的是，#pragma shader_feature A其实是 #pragma shader_feature _ A的简写，下划线表示未定义宏(nokeyword)。因此此时shader其实对应了两个变体，一个是nokeyword，一个是定义了宏A的。<br>而#pragma multi_compile A并不存在简写这一说，所以shader此时只对应A这个变体。若要表示未定义任何变体，则应写为 #pragma multi_compile __ A。</p>\n</li>\n<li><p>宏的适用范围<br>multi_compile定义的宏，如#pragma multi_compile_fog，#pragma multi_compile_fwdbase等，基本上适用于大部分shader，与shader自身所带的属性无关。<br>shader_feature定义的宏多用于针对shader自身的属性。比如shader中有_NormalMap这个属性(Property)，便可通过#pragma shader_feature _NormalMap来定义宏，用来实现这个shader在material有无_NormalMap时可进行不同的处理。</p>\n</li>\n<li><p>变体的生成<br>#pragma multi_compile A B C<br>#pragma multi_compile D E<br>则此时会生成 A D、A E、B D、B E、C D、C E这6中变体。<br>shader_feature要生成何种变体可用shader variant collection进行自定义设置。</p>\n</li>\n<li><p>默认定义的宏<br>当material中的keywords无法对应shader所生成的变体时，Unity便会默认定义宏定义语句中的首个宏，并运行相应的变体来为这个material进行渲染。<br>multi_compile与shader_feature都默认定义首个宏。</p>\n</li>\n</ol>\n<h4 id=\"如何控制项目中Shader变体的生成\"><a href=\"#如何控制项目中Shader变体的生成\" class=\"headerlink\" title=\"如何控制项目中Shader变体的生成\"></a>如何控制项目中Shader变体的生成</h4><table>\n<thead>\n<tr>\n<th>生成方式</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>shader与material打在一个包中</td>\n<td>变体根据material中的keywords自动生成</td>\n<td>多个不同的material包中可能存在相同的shader变体，造成资源冗余，若在程序运行时动态改变material的keyword其变体可能并没有被生成</td>\n</tr>\n<tr>\n<td>Shader单独打包，使用multi_compile定义全部宏</td>\n<td>全部变体都被生成，不会发生需要的变体未生成的情况</td>\n<td>生成的变体数量庞大，严重浪费资源</td>\n</tr>\n<tr>\n<td>Shader单独打包，shader_feature与multi_compile结合使用</td>\n<td>能够有效控制变体数量</td>\n<td>如何确定哪些变体需要生成，容易遗漏需要生成的变体</td>\n</tr>\n</tbody></table>\n<h4 id=\"Shader编写规范\"><a href=\"#Shader编写规范\" class=\"headerlink\" title=\"Shader编写规范\"></a>Shader编写规范</h4><ol>\n<li><p>建议使用shader_feature时将定义语句写成完整模式，并且不要在一个语句中定义多个宏。<br>完整模式：#pragma shader_feature _ A，不建议写成#pragma shader_feature A。<br>不建议在一个语句中定义多个宏，如： #pragma shader_feature _ A B C，若一定要定义多个宏，请务必将其写成完整模式，不使用完整模式在切换shader时可能会与想要的效果不一致，具体原因尚未测得。</p>\n</li>\n<li><p>若在shader中使用shader_feature，请为这个shader指定一个CustomEditor<br>每个使用shader_feature来定义Keyword的shader都需要再末尾加个 CusomEditor “xxxx”，并在代码中实现类xxxx(需继承自UnityEditor.ShaderGUI)，用来对Keywords定义进行设定。<br>这么做是因为Material中的部分Keyword是由shader中的属性(Properties)所控制的。比如shader中含有_NormalMap的属性并且定义了与_NormalMap相关的Keyword，这个Keyword需要在Material含有NormalMap时添加，不含NormalMap时移除。这个功能可由自定义的CustomEidtor实现。<br>具体如何写这个CustomEditor类可参考Unity builtin_shaders\\Editor\\StandardShaderGUI.cs。该文件可去Unity官网下载，下载时选择内置着色器即可。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"multi-compile与shader-feature\"><a href=\"#multi-compile与shader-feature\" class=\"headerlink\" title=\"multi_compile与shader_feature\"></a>multi_compile与shader_feature</h4><p>multi_compile与shader_feature可在shader中定义宏。两者区别如下图所示：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>multi_compile</th>\n<th>shader_feature</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义方式</td>\n<td>#pragma multi_compile A</td>\n<td>#pragma shader_feature A</td>\n</tr>\n<tr>\n<td>宏的适用范围</td>\n<td>大多数shader</td>\n<td>一般仅针对shader自身</td>\n</tr>\n<tr>\n<td>变体的生成</td>\n<td>生成所有的变体</td>\n<td>可自定义生成何种变体</td>\n</tr>\n<tr>\n<td>默认定义的宏</td>\n<td>默认定义首个宏</td>\n<td>默认定义首个宏</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>定义方式<br>定义方式中值得注意的是，#pragma shader_feature A其实是 #pragma shader_feature _ A的简写，下划线表示未定义宏(nokeyword)。因此此时shader其实对应了两个变体，一个是nokeyword，一个是定义了宏A的。<br>而#pragma multi_compile A并不存在简写这一说，所以shader此时只对应A这个变体。若要表示未定义任何变体，则应写为 #pragma multi_compile __ A。</p>\n</li>\n<li><p>宏的适用范围<br>multi_compile定义的宏，如#pragma multi_compile_fog，#pragma multi_compile_fwdbase等，基本上适用于大部分shader，与shader自身所带的属性无关。<br>shader_feature定义的宏多用于针对shader自身的属性。比如shader中有_NormalMap这个属性(Property)，便可通过#pragma shader_feature _NormalMap来定义宏，用来实现这个shader在material有无_NormalMap时可进行不同的处理。</p>\n</li>\n<li><p>变体的生成<br>#pragma multi_compile A B C<br>#pragma multi_compile D E<br>则此时会生成 A D、A E、B D、B E、C D、C E这6中变体。<br>shader_feature要生成何种变体可用shader variant collection进行自定义设置。</p>\n</li>\n<li><p>默认定义的宏<br>当material中的keywords无法对应shader所生成的变体时，Unity便会默认定义宏定义语句中的首个宏，并运行相应的变体来为这个material进行渲染。<br>multi_compile与shader_feature都默认定义首个宏。</p>\n</li>\n</ol>\n<h4 id=\"如何控制项目中Shader变体的生成\"><a href=\"#如何控制项目中Shader变体的生成\" class=\"headerlink\" title=\"如何控制项目中Shader变体的生成\"></a>如何控制项目中Shader变体的生成</h4><table>\n<thead>\n<tr>\n<th>生成方式</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>shader与material打在一个包中</td>\n<td>变体根据material中的keywords自动生成</td>\n<td>多个不同的material包中可能存在相同的shader变体，造成资源冗余，若在程序运行时动态改变material的keyword其变体可能并没有被生成</td>\n</tr>\n<tr>\n<td>Shader单独打包，使用multi_compile定义全部宏</td>\n<td>全部变体都被生成，不会发生需要的变体未生成的情况</td>\n<td>生成的变体数量庞大，严重浪费资源</td>\n</tr>\n<tr>\n<td>Shader单独打包，shader_feature与multi_compile结合使用</td>\n<td>能够有效控制变体数量</td>\n<td>如何确定哪些变体需要生成，容易遗漏需要生成的变体</td>\n</tr>\n</tbody></table>\n<h4 id=\"Shader编写规范\"><a href=\"#Shader编写规范\" class=\"headerlink\" title=\"Shader编写规范\"></a>Shader编写规范</h4><ol>\n<li><p>建议使用shader_feature时将定义语句写成完整模式，并且不要在一个语句中定义多个宏。<br>完整模式：#pragma shader_feature _ A，不建议写成#pragma shader_feature A。<br>不建议在一个语句中定义多个宏，如： #pragma shader_feature _ A B C，若一定要定义多个宏，请务必将其写成完整模式，不使用完整模式在切换shader时可能会与想要的效果不一致，具体原因尚未测得。</p>\n</li>\n<li><p>若在shader中使用shader_feature，请为这个shader指定一个CustomEditor<br>每个使用shader_feature来定义Keyword的shader都需要再末尾加个 CusomEditor “xxxx”，并在代码中实现类xxxx(需继承自UnityEditor.ShaderGUI)，用来对Keywords定义进行设定。<br>这么做是因为Material中的部分Keyword是由shader中的属性(Properties)所控制的。比如shader中含有_NormalMap的属性并且定义了与_NormalMap相关的Keyword，这个Keyword需要在Material含有NormalMap时添加，不含NormalMap时移除。这个功能可由自定义的CustomEidtor实现。<br>具体如何写这个CustomEditor类可参考Unity builtin_shaders\\Editor\\StandardShaderGUI.cs。该文件可去Unity官网下载，下载时选择内置着色器即可。</p>\n</li>\n</ol>\n"},{"title":"UI系统制作流程","_content":"\n\t\t\t* [一、准备UI预制](#一-准备ui预制)\n\t\t\t* [二、控制脚本](#二-控制脚本)\n\t\t\t* [三、UI系统的对象池](#三-ui系统的对象池)\n\t\t\t* [三、配入UI表](#三-配入ui表)\n\t\t\t* [四、窗口的显示或关闭](#四-窗口的显示或关闭)\n\n#### 一、准备UI预制\n先准备好效果图和资源图集\n* 1.新建空场景，在目录下建好资源图集\n* 2.找到 ***LoginUI.prefab*** ， 施入场景后，Unpack prefab completed完全解除关联\n* 3.清空根结点的Animator组件和Reference Collector组件，并改名， 以 #Name#UI 的方式\n* 4.清空Panel下所有内容，让结构保持为Bg, Panel两个一级子结点\n*  *5.复制Bg结点，放入美术做好的效果图\n* 5.根据UGUI规则完成预制制作\n* 6.根结点添加Reference Collector Group组件\n* 7.完成后交由特效师添加动画\n* 8.将资源放入Addressable Groups的UI组里，右键使用Simplify Addressable Name, 将名字简化\n\n#### 二、控制脚本\n1.创建： 在Hotfix 建立文件夹，名字以功能命名，建立Compoents文件夹，新建控制脚本，命名以   UI#Name#Window的方式，如LoginUI，脚本名应为UILoginWindow.cs\n2.类的规则以 UIClickWindow.cs为参考。\n3.必须有的构造，以指明加载需要的预制名\n```csharp\npublic UIClickWindow():base()\n{\n\tmPrefabName = #Name#;//TODO\n}\n```\n4.必须重写有如下函数：\n```csharp\n/// <summary>\n/// 界面资源加载完成， 一会用于获取各预制及组件，每次新建UI预制将调用\n/// </summary>\nprotected virtual void InitUI()\n\n/// <summary>\n/// 界面显示，一般处理每次显示需要即时更新的逻辑，每次setActive将调用\n/// </summary>\nprotected virtual void ResetUI()\n\n/// <summary>\n/// 界面关闭，隐藏时调用的，一般与ResetUI放置成对的逻辑\n/// </summary>\nprotected virtual void HideUI()\n\n/// <summary>\n/// 界面资源销毁，在预制将销毁时调用与InitUI成对。\n/// </summary>\nprotected virtual void UnInitUI()\n```\n\n5. 可选的函数\n```csharp\n/// <summary>\n/// 界面Update更新\n/// </summary>\npublic virtual void Update()\n```\n#### 三、UI系统的对象池\n1.命名池子模板对象的key于头部，如：\n```csharp\nprivate const string TaskItemTemplate = \"UICarnivalWindow_TaskItemTemplate\";\nprivate const string NormalCardItemTemplate = \"UICarnivalWindow_NormalCardItemTemplate\";\nprivate const string HighlightCardItemTemplate = \"UICarnivalWindow_HighlightCardItemTemplate\";\n```\n2.添加对象为模板，让底层创建一个以模板为基的池子\n```csharp\nAddTemplate(NormalCardItemTemplate, normalItemObj);\nAddTemplate(HighlightCardItemTemplate, highlightItemObj);\nAddTemplate(TaskItemTemplate, taskItemObj);\n```\n\n3.获取： 仅获取一个对象\n\n```csharp\nGetTemplateInstance(string name, Transform parent, bool isActive)\n```\n传入1.定义的模板名字，父对象，是否隐藏就决定获取出来后是否立即隐藏。\n\n4.定义对应模板对象的控制类\n* 必须继承UIBaseComponent类\n* 继承覆写函数：\n```csharp\n///初始化函数，每次设置预制时都将会自动调用一次\npublic virtual void InitObjs()\n\n//销毁时调用\npublic virtual void Dispose() \n```\n5.获取: 获取一个带对象控制器的类对象（将同时生成一个对象放在类的Root）\n\n```csharp\nGetTemplateComponent<T>(string name, Transform parent, bool isActive) where T : UIBaseComponent\n```\n传入1.定义的模板名字，父对象，是否隐藏就决定获取出来后是否立即隐藏。\n\n6.回收\n* 回收预制：`FreeTemplateInstance(NormalCardItemTemplate);`\n* 回收预制管理类，不会回收预制：`FreeTemplateComponent(NormalCardItemTemplate);`\n所以一般两个需要成对调用，如：\n```csharp\n FreeTemplateInstance(NormalCardItemTemplate);\nFreeTemplateComponent(NormalCardItemTemplate);\nFreeTemplateInstance(HighlightCardItemTemplate);\nFreeTemplateComponent(HighlightCardItemTemplate);\nFreeTemplateInstance(TaskItemTemplate);\nFreeTemplateComponent(TaskItemTemplate);\n```\n\n７.销毁池子\n* 使用UIBaseWindow自带函数销毁单个模板的池子\n```csharp\n/// 移除模板\nvoid RemoveTemplate(string name)\n```\nWindow在销毁时将调用DestroyAllTemplates() 先回收所有的预制，再清空池子。**因此一般不需要在逻辑里手动移除池子.**\n\n#### 三、配入UI表\n\n1.找到资源表 fgame_ui_config.elsx 按表内的说明配置UI的参数\n2.导表\n\n#### 四、窗口的显示或关闭\n\n* 使用UIManager提供的函数显示或关闭一个Window，如：\n\n```csharp\n//同步函数显示一个Window\nUIManager.Instance.ShowWindowSync(\"UIClickWindow\");\n//异步函数\nawait UIManager.Instance.ShowWindow(\"UIClickWindow\");\n\n//关闭窗口\nUIManager.Instance.CloseWindow(\"UIClickWindow\");\n\n```\n","source":"_posts/UI系统制作流程.md","raw":"---\ntitle: UI系统制作流程\ncategories:\n- 公司\ntags: \n---\n\n\t\t\t* [一、准备UI预制](#一-准备ui预制)\n\t\t\t* [二、控制脚本](#二-控制脚本)\n\t\t\t* [三、UI系统的对象池](#三-ui系统的对象池)\n\t\t\t* [三、配入UI表](#三-配入ui表)\n\t\t\t* [四、窗口的显示或关闭](#四-窗口的显示或关闭)\n\n#### 一、准备UI预制\n先准备好效果图和资源图集\n* 1.新建空场景，在目录下建好资源图集\n* 2.找到 ***LoginUI.prefab*** ， 施入场景后，Unpack prefab completed完全解除关联\n* 3.清空根结点的Animator组件和Reference Collector组件，并改名， 以 #Name#UI 的方式\n* 4.清空Panel下所有内容，让结构保持为Bg, Panel两个一级子结点\n*  *5.复制Bg结点，放入美术做好的效果图\n* 5.根据UGUI规则完成预制制作\n* 6.根结点添加Reference Collector Group组件\n* 7.完成后交由特效师添加动画\n* 8.将资源放入Addressable Groups的UI组里，右键使用Simplify Addressable Name, 将名字简化\n\n#### 二、控制脚本\n1.创建： 在Hotfix 建立文件夹，名字以功能命名，建立Compoents文件夹，新建控制脚本，命名以   UI#Name#Window的方式，如LoginUI，脚本名应为UILoginWindow.cs\n2.类的规则以 UIClickWindow.cs为参考。\n3.必须有的构造，以指明加载需要的预制名\n```csharp\npublic UIClickWindow():base()\n{\n\tmPrefabName = #Name#;//TODO\n}\n```\n4.必须重写有如下函数：\n```csharp\n/// <summary>\n/// 界面资源加载完成， 一会用于获取各预制及组件，每次新建UI预制将调用\n/// </summary>\nprotected virtual void InitUI()\n\n/// <summary>\n/// 界面显示，一般处理每次显示需要即时更新的逻辑，每次setActive将调用\n/// </summary>\nprotected virtual void ResetUI()\n\n/// <summary>\n/// 界面关闭，隐藏时调用的，一般与ResetUI放置成对的逻辑\n/// </summary>\nprotected virtual void HideUI()\n\n/// <summary>\n/// 界面资源销毁，在预制将销毁时调用与InitUI成对。\n/// </summary>\nprotected virtual void UnInitUI()\n```\n\n5. 可选的函数\n```csharp\n/// <summary>\n/// 界面Update更新\n/// </summary>\npublic virtual void Update()\n```\n#### 三、UI系统的对象池\n1.命名池子模板对象的key于头部，如：\n```csharp\nprivate const string TaskItemTemplate = \"UICarnivalWindow_TaskItemTemplate\";\nprivate const string NormalCardItemTemplate = \"UICarnivalWindow_NormalCardItemTemplate\";\nprivate const string HighlightCardItemTemplate = \"UICarnivalWindow_HighlightCardItemTemplate\";\n```\n2.添加对象为模板，让底层创建一个以模板为基的池子\n```csharp\nAddTemplate(NormalCardItemTemplate, normalItemObj);\nAddTemplate(HighlightCardItemTemplate, highlightItemObj);\nAddTemplate(TaskItemTemplate, taskItemObj);\n```\n\n3.获取： 仅获取一个对象\n\n```csharp\nGetTemplateInstance(string name, Transform parent, bool isActive)\n```\n传入1.定义的模板名字，父对象，是否隐藏就决定获取出来后是否立即隐藏。\n\n4.定义对应模板对象的控制类\n* 必须继承UIBaseComponent类\n* 继承覆写函数：\n```csharp\n///初始化函数，每次设置预制时都将会自动调用一次\npublic virtual void InitObjs()\n\n//销毁时调用\npublic virtual void Dispose() \n```\n5.获取: 获取一个带对象控制器的类对象（将同时生成一个对象放在类的Root）\n\n```csharp\nGetTemplateComponent<T>(string name, Transform parent, bool isActive) where T : UIBaseComponent\n```\n传入1.定义的模板名字，父对象，是否隐藏就决定获取出来后是否立即隐藏。\n\n6.回收\n* 回收预制：`FreeTemplateInstance(NormalCardItemTemplate);`\n* 回收预制管理类，不会回收预制：`FreeTemplateComponent(NormalCardItemTemplate);`\n所以一般两个需要成对调用，如：\n```csharp\n FreeTemplateInstance(NormalCardItemTemplate);\nFreeTemplateComponent(NormalCardItemTemplate);\nFreeTemplateInstance(HighlightCardItemTemplate);\nFreeTemplateComponent(HighlightCardItemTemplate);\nFreeTemplateInstance(TaskItemTemplate);\nFreeTemplateComponent(TaskItemTemplate);\n```\n\n７.销毁池子\n* 使用UIBaseWindow自带函数销毁单个模板的池子\n```csharp\n/// 移除模板\nvoid RemoveTemplate(string name)\n```\nWindow在销毁时将调用DestroyAllTemplates() 先回收所有的预制，再清空池子。**因此一般不需要在逻辑里手动移除池子.**\n\n#### 三、配入UI表\n\n1.找到资源表 fgame_ui_config.elsx 按表内的说明配置UI的参数\n2.导表\n\n#### 四、窗口的显示或关闭\n\n* 使用UIManager提供的函数显示或关闭一个Window，如：\n\n```csharp\n//同步函数显示一个Window\nUIManager.Instance.ShowWindowSync(\"UIClickWindow\");\n//异步函数\nawait UIManager.Instance.ShowWindow(\"UIClickWindow\");\n\n//关闭窗口\nUIManager.Instance.CloseWindow(\"UIClickWindow\");\n\n```\n","slug":"UI系统制作流程","published":1,"date":"2020-09-08T03:23:20.716Z","updated":"2020-09-08T03:23:20.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10m002h4wf0apq4d50v","content":"<pre><code>        * [一、准备UI预制](#一-准备ui预制)\n        * [二、控制脚本](#二-控制脚本)\n        * [三、UI系统的对象池](#三-ui系统的对象池)\n        * [三、配入UI表](#三-配入ui表)\n        * [四、窗口的显示或关闭](#四-窗口的显示或关闭)</code></pre><h4 id=\"一、准备UI预制\"><a href=\"#一、准备UI预制\" class=\"headerlink\" title=\"一、准备UI预制\"></a>一、准备UI预制</h4><p>先准备好效果图和资源图集</p>\n<ul>\n<li>1.新建空场景，在目录下建好资源图集</li>\n<li>2.找到 <strong><em>LoginUI.prefab</em></strong> ， 施入场景后，Unpack prefab completed完全解除关联</li>\n<li>3.清空根结点的Animator组件和Reference Collector组件，并改名， 以 #Name#UI 的方式</li>\n<li>4.清空Panel下所有内容，让结构保持为Bg, Panel两个一级子结点</li>\n<li>*5.复制Bg结点，放入美术做好的效果图</li>\n<li>5.根据UGUI规则完成预制制作</li>\n<li>6.根结点添加Reference Collector Group组件</li>\n<li>7.完成后交由特效师添加动画</li>\n<li>8.将资源放入Addressable Groups的UI组里，右键使用Simplify Addressable Name, 将名字简化</li>\n</ul>\n<h4 id=\"二、控制脚本\"><a href=\"#二、控制脚本\" class=\"headerlink\" title=\"二、控制脚本\"></a>二、控制脚本</h4><p>1.创建： 在Hotfix 建立文件夹，名字以功能命名，建立Compoents文件夹，新建控制脚本，命名以   UI#Name#Window的方式，如LoginUI，脚本名应为UILoginWindow.cs<br>2.类的规则以 UIClickWindow.cs为参考。<br>3.必须有的构造，以指明加载需要的预制名</p>\n<pre><code class=\"csharp\">public UIClickWindow():base()\n{\n    mPrefabName = #Name#;//TODO\n}</code></pre>\n<p>4.必须重写有如下函数：</p>\n<pre><code class=\"csharp\">/// &lt;summary&gt;\n/// 界面资源加载完成， 一会用于获取各预制及组件，每次新建UI预制将调用\n/// &lt;/summary&gt;\nprotected virtual void InitUI()\n\n/// &lt;summary&gt;\n/// 界面显示，一般处理每次显示需要即时更新的逻辑，每次setActive将调用\n/// &lt;/summary&gt;\nprotected virtual void ResetUI()\n\n/// &lt;summary&gt;\n/// 界面关闭，隐藏时调用的，一般与ResetUI放置成对的逻辑\n/// &lt;/summary&gt;\nprotected virtual void HideUI()\n\n/// &lt;summary&gt;\n/// 界面资源销毁，在预制将销毁时调用与InitUI成对。\n/// &lt;/summary&gt;\nprotected virtual void UnInitUI()</code></pre>\n<ol start=\"5\">\n<li>可选的函数<pre><code class=\"csharp\">/// &lt;summary&gt;\n/// 界面Update更新\n/// &lt;/summary&gt;\npublic virtual void Update()</code></pre>\n<h4 id=\"三、UI系统的对象池\"><a href=\"#三、UI系统的对象池\" class=\"headerlink\" title=\"三、UI系统的对象池\"></a>三、UI系统的对象池</h4></li>\n<li>命名池子模板对象的key于头部，如：<pre><code class=\"csharp\">private const string TaskItemTemplate = &quot;UICarnivalWindow_TaskItemTemplate&quot;;\nprivate const string NormalCardItemTemplate = &quot;UICarnivalWindow_NormalCardItemTemplate&quot;;\nprivate const string HighlightCardItemTemplate = &quot;UICarnivalWindow_HighlightCardItemTemplate&quot;;</code></pre>\n</li>\n<li>添加对象为模板，让底层创建一个以模板为基的池子<pre><code class=\"csharp\">AddTemplate(NormalCardItemTemplate, normalItemObj);\nAddTemplate(HighlightCardItemTemplate, highlightItemObj);\nAddTemplate(TaskItemTemplate, taskItemObj);</code></pre>\n</li>\n</ol>\n<p>3.获取： 仅获取一个对象</p>\n<pre><code class=\"csharp\">GetTemplateInstance(string name, Transform parent, bool isActive)</code></pre>\n<p>传入1.定义的模板名字，父对象，是否隐藏就决定获取出来后是否立即隐藏。</p>\n<p>4.定义对应模板对象的控制类</p>\n<ul>\n<li>必须继承UIBaseComponent类</li>\n<li>继承覆写函数：<pre><code class=\"csharp\">///初始化函数，每次设置预制时都将会自动调用一次\npublic virtual void InitObjs()\n</code></pre>\n</li>\n</ul>\n<p>//销毁时调用<br>public virtual void Dispose() </p>\n<pre><code>5.获取: 获取一个带对象控制器的类对象（将同时生成一个对象放在类的Root）\n\n```csharp\nGetTemplateComponent&lt;T&gt;(string name, Transform parent, bool isActive) where T : UIBaseComponent</code></pre><p>传入1.定义的模板名字，父对象，是否隐藏就决定获取出来后是否立即隐藏。</p>\n<p>6.回收</p>\n<ul>\n<li>回收预制：<code>FreeTemplateInstance(NormalCardItemTemplate);</code></li>\n<li>回收预制管理类，不会回收预制：<code>FreeTemplateComponent(NormalCardItemTemplate);</code><br>所以一般两个需要成对调用，如：<pre><code class=\"csharp\">FreeTemplateInstance(NormalCardItemTemplate);\nFreeTemplateComponent(NormalCardItemTemplate);\nFreeTemplateInstance(HighlightCardItemTemplate);\nFreeTemplateComponent(HighlightCardItemTemplate);\nFreeTemplateInstance(TaskItemTemplate);\nFreeTemplateComponent(TaskItemTemplate);</code></pre>\n</li>\n</ul>\n<p>７.销毁池子</p>\n<ul>\n<li>使用UIBaseWindow自带函数销毁单个模板的池子<pre><code class=\"csharp\">/// 移除模板\nvoid RemoveTemplate(string name)</code></pre>\nWindow在销毁时将调用DestroyAllTemplates() 先回收所有的预制，再清空池子。<strong>因此一般不需要在逻辑里手动移除池子.</strong></li>\n</ul>\n<h4 id=\"三、配入UI表\"><a href=\"#三、配入UI表\" class=\"headerlink\" title=\"三、配入UI表\"></a>三、配入UI表</h4><p>1.找到资源表 fgame_ui_config.elsx 按表内的说明配置UI的参数<br>2.导表</p>\n<h4 id=\"四、窗口的显示或关闭\"><a href=\"#四、窗口的显示或关闭\" class=\"headerlink\" title=\"四、窗口的显示或关闭\"></a>四、窗口的显示或关闭</h4><ul>\n<li>使用UIManager提供的函数显示或关闭一个Window，如：</li>\n</ul>\n<pre><code class=\"csharp\">//同步函数显示一个Window\nUIManager.Instance.ShowWindowSync(&quot;UIClickWindow&quot;);\n//异步函数\nawait UIManager.Instance.ShowWindow(&quot;UIClickWindow&quot;);\n\n//关闭窗口\nUIManager.Instance.CloseWindow(&quot;UIClickWindow&quot;);\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>        * [一、准备UI预制](#一-准备ui预制)\n        * [二、控制脚本](#二-控制脚本)\n        * [三、UI系统的对象池](#三-ui系统的对象池)\n        * [三、配入UI表](#三-配入ui表)\n        * [四、窗口的显示或关闭](#四-窗口的显示或关闭)</code></pre><h4 id=\"一、准备UI预制\"><a href=\"#一、准备UI预制\" class=\"headerlink\" title=\"一、准备UI预制\"></a>一、准备UI预制</h4><p>先准备好效果图和资源图集</p>\n<ul>\n<li>1.新建空场景，在目录下建好资源图集</li>\n<li>2.找到 <strong><em>LoginUI.prefab</em></strong> ， 施入场景后，Unpack prefab completed完全解除关联</li>\n<li>3.清空根结点的Animator组件和Reference Collector组件，并改名， 以 #Name#UI 的方式</li>\n<li>4.清空Panel下所有内容，让结构保持为Bg, Panel两个一级子结点</li>\n<li>*5.复制Bg结点，放入美术做好的效果图</li>\n<li>5.根据UGUI规则完成预制制作</li>\n<li>6.根结点添加Reference Collector Group组件</li>\n<li>7.完成后交由特效师添加动画</li>\n<li>8.将资源放入Addressable Groups的UI组里，右键使用Simplify Addressable Name, 将名字简化</li>\n</ul>\n<h4 id=\"二、控制脚本\"><a href=\"#二、控制脚本\" class=\"headerlink\" title=\"二、控制脚本\"></a>二、控制脚本</h4><p>1.创建： 在Hotfix 建立文件夹，名字以功能命名，建立Compoents文件夹，新建控制脚本，命名以   UI#Name#Window的方式，如LoginUI，脚本名应为UILoginWindow.cs<br>2.类的规则以 UIClickWindow.cs为参考。<br>3.必须有的构造，以指明加载需要的预制名</p>\n<pre><code class=\"csharp\">public UIClickWindow():base()\n{\n    mPrefabName = #Name#;//TODO\n}</code></pre>\n<p>4.必须重写有如下函数：</p>\n<pre><code class=\"csharp\">/// &lt;summary&gt;\n/// 界面资源加载完成， 一会用于获取各预制及组件，每次新建UI预制将调用\n/// &lt;/summary&gt;\nprotected virtual void InitUI()\n\n/// &lt;summary&gt;\n/// 界面显示，一般处理每次显示需要即时更新的逻辑，每次setActive将调用\n/// &lt;/summary&gt;\nprotected virtual void ResetUI()\n\n/// &lt;summary&gt;\n/// 界面关闭，隐藏时调用的，一般与ResetUI放置成对的逻辑\n/// &lt;/summary&gt;\nprotected virtual void HideUI()\n\n/// &lt;summary&gt;\n/// 界面资源销毁，在预制将销毁时调用与InitUI成对。\n/// &lt;/summary&gt;\nprotected virtual void UnInitUI()</code></pre>\n<ol start=\"5\">\n<li>可选的函数<pre><code class=\"csharp\">/// &lt;summary&gt;\n/// 界面Update更新\n/// &lt;/summary&gt;\npublic virtual void Update()</code></pre>\n<h4 id=\"三、UI系统的对象池\"><a href=\"#三、UI系统的对象池\" class=\"headerlink\" title=\"三、UI系统的对象池\"></a>三、UI系统的对象池</h4></li>\n<li>命名池子模板对象的key于头部，如：<pre><code class=\"csharp\">private const string TaskItemTemplate = &quot;UICarnivalWindow_TaskItemTemplate&quot;;\nprivate const string NormalCardItemTemplate = &quot;UICarnivalWindow_NormalCardItemTemplate&quot;;\nprivate const string HighlightCardItemTemplate = &quot;UICarnivalWindow_HighlightCardItemTemplate&quot;;</code></pre>\n</li>\n<li>添加对象为模板，让底层创建一个以模板为基的池子<pre><code class=\"csharp\">AddTemplate(NormalCardItemTemplate, normalItemObj);\nAddTemplate(HighlightCardItemTemplate, highlightItemObj);\nAddTemplate(TaskItemTemplate, taskItemObj);</code></pre>\n</li>\n</ol>\n<p>3.获取： 仅获取一个对象</p>\n<pre><code class=\"csharp\">GetTemplateInstance(string name, Transform parent, bool isActive)</code></pre>\n<p>传入1.定义的模板名字，父对象，是否隐藏就决定获取出来后是否立即隐藏。</p>\n<p>4.定义对应模板对象的控制类</p>\n<ul>\n<li>必须继承UIBaseComponent类</li>\n<li>继承覆写函数：<pre><code class=\"csharp\">///初始化函数，每次设置预制时都将会自动调用一次\npublic virtual void InitObjs()\n</code></pre>\n</li>\n</ul>\n<p>//销毁时调用<br>public virtual void Dispose() </p>\n<pre><code>5.获取: 获取一个带对象控制器的类对象（将同时生成一个对象放在类的Root）\n\n```csharp\nGetTemplateComponent&lt;T&gt;(string name, Transform parent, bool isActive) where T : UIBaseComponent</code></pre><p>传入1.定义的模板名字，父对象，是否隐藏就决定获取出来后是否立即隐藏。</p>\n<p>6.回收</p>\n<ul>\n<li>回收预制：<code>FreeTemplateInstance(NormalCardItemTemplate);</code></li>\n<li>回收预制管理类，不会回收预制：<code>FreeTemplateComponent(NormalCardItemTemplate);</code><br>所以一般两个需要成对调用，如：<pre><code class=\"csharp\">FreeTemplateInstance(NormalCardItemTemplate);\nFreeTemplateComponent(NormalCardItemTemplate);\nFreeTemplateInstance(HighlightCardItemTemplate);\nFreeTemplateComponent(HighlightCardItemTemplate);\nFreeTemplateInstance(TaskItemTemplate);\nFreeTemplateComponent(TaskItemTemplate);</code></pre>\n</li>\n</ul>\n<p>７.销毁池子</p>\n<ul>\n<li>使用UIBaseWindow自带函数销毁单个模板的池子<pre><code class=\"csharp\">/// 移除模板\nvoid RemoveTemplate(string name)</code></pre>\nWindow在销毁时将调用DestroyAllTemplates() 先回收所有的预制，再清空池子。<strong>因此一般不需要在逻辑里手动移除池子.</strong></li>\n</ul>\n<h4 id=\"三、配入UI表\"><a href=\"#三、配入UI表\" class=\"headerlink\" title=\"三、配入UI表\"></a>三、配入UI表</h4><p>1.找到资源表 fgame_ui_config.elsx 按表内的说明配置UI的参数<br>2.导表</p>\n<h4 id=\"四、窗口的显示或关闭\"><a href=\"#四、窗口的显示或关闭\" class=\"headerlink\" title=\"四、窗口的显示或关闭\"></a>四、窗口的显示或关闭</h4><ul>\n<li>使用UIManager提供的函数显示或关闭一个Window，如：</li>\n</ul>\n<pre><code class=\"csharp\">//同步函数显示一个Window\nUIManager.Instance.ShowWindowSync(&quot;UIClickWindow&quot;);\n//异步函数\nawait UIManager.Instance.ShowWindow(&quot;UIClickWindow&quot;);\n\n//关闭窗口\nUIManager.Instance.CloseWindow(&quot;UIClickWindow&quot;);\n</code></pre>\n"},{"title":"Twisted  介绍","_content":"\n## Twisted\n\n\n### Python Twisted介绍\nTwisted是用Python实现的基于事件驱动的网络引擎框架。Twisted诞生于2000年初，在当时的网络游戏开发者看来，无论他们使用哪种语言，手中都鲜有可兼顾扩展性及跨平台的网络库。Twisted的作者试图在当时现有的环境下开发游戏，这一步走的非常艰难，他们迫切地需要一个可扩展性高、基于事件驱动、跨平台的网络开发框架，为此他们决定自己实现一个，并从那些之前的游戏和网络应用程序的开发者中学习，汲取他们的经验教训。\n\nTwisted支持许多常见的传输及应用层协议，包括TCP、UDP、SSL/TLS、HTTP、IMAP、SSH、IRC以及FTP。就像python一样，Twisted也具有“内置电池”（batteries-included）的特点。Twisted对于其支持的所有协议都带有客户端和服务器实现，同时附带有基于命令行的工具，使得配置和部署产品级的Twisted应用变得非常方便。\n\n### 为什么需要Twisted\n2000年时，Twisted的作者Glyph正在开发一个名为Twisted Reality的基于文本方式的多人在线游戏。这个游戏采用Java开发，里面尽是一堆线程——每个连接就有3个线程处理。处理输入的线程会在读操作上阻塞，处理输出的线程将在一些写操作上阻塞，还有一个“逻辑”线程将在等待定时器超时或者事件入队列时休眠。随着玩家们在虚拟世界中移动并交互时，线程出现死锁，缓存被污染，程序中的加锁逻辑几乎从来就没对过——采用多线程使得整个软件变得复杂、漏洞百出而且极难扩展。\n\n为了寻求其他的解决方案，作者发现了Python，特别是Python中用于对流式对象比如socket和pipe进行多路I/O复用的select模块（UNIX规范第3版（SUSv3）描述了select）。那时，Java并没有提供操作系统的select接口或者任何其他的异步I/O API（针对非阻塞式I/O的包java.nio已经在J2SE 1.4中加入了，2002年发布）。通过用Python中的select模块快速搭建起游戏的原型，这迅速降低了程序的复杂度，并且比多线程版本要更加可靠。\n\nGlyph迅速转向了Python、select以及基于事件驱动的编程。他使用Python的select模块为游戏编写了客户端和服务器。但他想要的还不止于此。从根本上说，他希望能将网络行为转变为对游戏中的对象的方法调用。如果你能在游戏中收取邮件会怎样，就像Nethack mailer这种守护进程一样？如果游戏中的每位玩家都拥有一个主页呢？Glyph发现他需要优秀的IMAP以及HTTP客户端和服务器的Python实现，而这些都要采用select。\n\n他首先转向了Medusa，这是一个在90年代中期开发的平台，在这里可以采用Python中的asyncore模块来编写网络服务。asyncore是一个异步化处理socket的模块，在操作系统的select API之上构建了一个调度器和回调接口。\n\n这对于Glyph来说是个激动人心的发现，但Medusa有两个缺点：\n1. 这个项目到2001年就不再维护了，那正是glyph开发Twisted Reality的时候。\n2. asyncore只是对socket的一个薄封装层，应用程序的编写者仍然需要直接操作socket。这意味着程序可移植性的担子仍然落在程序员自己身上。此外，那时asyncore对Windows的支持还有问题，Glyph希望能在Windows上运行一个带有图形用户界面的客户端。\nGlyph需要自己实现一个网络引擎平台，而且他意识到Twisted Reality已经打开了问题的大门，这和他的游戏一样有趣。\n\n随着时间的推移，Twisted Reality这个游戏就演化成了Twisted网络引擎平台。它可以做到当时Python中已有的网络平台所无法做到的事情：\n+ 使用基于事件驱动的编程模型，而不是多线程模型。\n+ 跨平台：为主流操作系统平台暴露出的事件通知系统提供统一的接口。\n+ “内置电池”的能力：提供流行的应用层协议实现，因此Twisted马上就可为开发人员所用。\n+ 符合RFC规范，已经通过健壮的测试套件证明了其一致性。\n+ 能很容易的配合多个网络协议一起使用。\n+ 可扩展。\n\n### Twisted架构概览\nTwisted是一个事件驱动型的网络引擎。由于事件驱动编程模型在Twisted的设计哲学中占有重要的地位，因此这里有必要花点时间来回顾一下究竟事件驱动意味着什么。\n\n事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。\n\n在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。\n\n在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。\n\n在事件驱动版本的程序中，3个任务**交错执行**，但仍然在一个单独的线程控制中。当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。\n\n当我们面对如下的环境时，事件驱动模型通常是一个好的选择：\n\n程序中有许多任务，而且…\n1. 任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…\n2. 在等待事件到来时，某些任务会阻塞。\n3. 当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。\n\n网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。\n\n###### **重用已有的应用**\n在Twisted创建之前就已经有了许多针对多种流行的网络协议的客户端和服务器实现了。为什么Glyph不直接用Apache、IRCd、BIND、OpenSSH或者任何其他已有的应用，而要为Twisted从头开始重新实现各个协议的客户端和服务器呢？\n\n问题在于所有这些已有的实现都存在有从头写起的网络层代码，通常都是C代码。而应用层代码直接同网络层耦合在一起，这使得它们非常难以以库的形式来复用。当要一起使用这些组件时，如果希望在多个协议中暴露相同的数据，则它们必须以黑盒的形式来看待，这使得开发者根本没机会重用代码。此外，服务器和客户端的实现通常是分离的，彼此之间不共享代码。要扩展这些应用，维护跨平台的客户端-服务器兼容性的难度本不至于这么大。\n\nTwisted中的客户端和服务器是用Python开发的，采用了一致性的接口。这使得开发新的客户端和服务器变得很容易实现，可以在客户端和服务器之间共享代码，在协议之间共享应用逻辑，以及对某个实现的代码做测试。\n\n###### **React模式**\nTwisted实现了设计模式中的反应堆（reactor）模式，这种模式在单线程环境中调度多个事件源产生的事件到它们各自的事件处理例程中去。\n\nTwisted的核心就是reactor事件循环。Reactor可以感知网络、文件系统以及定时器事件。它等待然后处理这些事件，从特定于平台的行为中抽象出来，并提供统一的接口，使得在网络协议栈的任何位置对事件做出响应都变得简单。\n\n基本上reactor完成的任务就是：\n\n```python\nwhile True:\n    timeout = time_until_next_timed_event()\n    events = wait_for_events(timeout)\n    events += timed_events_until(now())\n    for event in events:\n        event.process()\n```\n\nTwisted目前在所有平台上的默认reactor都是基于poll API的（UNIX规范第3版（SUSv3）中描述）。此外，Twisted还支持一些特定于平台的高容量多路复用API。这些reactor包括基于FreeBSD中kqueue机制的KQueue reactor，支持epoll接口的系统（目前是Linux 2.6）中的epoll reactor，以及基于Windows下的输入输出完成端口的IOCP reactor。\n\n在实现轮询的相关细节中，Twisted需要考虑的包括：\n\n+ 网络和文件系统的限制\n+ 缓冲行为\n+ 如何检测连接丢失\n+ 出现错误时的返回值\n\nTwisted的reactor实现同时也考虑了正确使用底层的非阻塞式API，并正确处理各种边界情况。由于Python中没有暴露出IOCP API，因此Twisted需要维护自己的实现。\n\n###### **管理回调链**\n\n回调是事件驱动编程模型中的基础，也是reactor通知应用程序事件已经处理完成的方式。随着程序规模不断扩大，基于事件驱动的程序需要同时处理事件处理成功和出错的情况，这使得程序变得越来越复杂。若没有注册一个合适的回调，程序就会阻塞，因为这个事件处理的过程绝不会发生。出现错误时需要通过应用程序的不同层次从网络栈向上传递回调链。\n\n下面是两段Python伪码，分别是同步和异步模式下获取URL的玩具代码。让我们相互比较一下这两个版本，看看基于事件驱动的程序有什么缺陷：\n\n以同步的方式获取URL：\n\n```python\nimport getPage\n\ndef processPage(page):\n    print page\n\ndef logError(error):\n    print error\n\ndef finishProcessing(value):\n    print \"Shutting down...\"\n    exit(0)\n\nurl = \"http://google.com\"\ntry:\n    page = getPage(url)\n    processPage(page)\nexcept Error, e:\n    logError(error)\nfinally:\n    finishProcessing()\n```\n以异步的方式获取URL：\n\n```python\nfrom twisted.internet import reactor\nimport getPage\n\ndef processPage(page):\n    print page\n    finishProcessing()\n\ndef logError(error):\n    print error\n    finishProcessing()\n\ndef finishProcessing(value):\n    print \"Shutting down...\"\n    reactor.stop()\n\nurl = \"http://google.com\"\n# getPage takes: url, \n# success callback, error callback\ngetPage(url, processPage, logError)\n\nreactor.run()\n```\n\n在异步版的URL获取器中，reactor.run()启动reactor事件循环。在同步和异步版程序中，我们假定getPage函数处理获取页面的工作。如果获取成功就调用processPage，如果尝试获取页面时出现了Exception（异常），logError就得到调用。无论哪种情况，最后都要调用finishProcessing。\n\n异步版中的logError回调正对应于同步版中的try/except块。对processPage的回调对应于else块，无条件回调的finishProcessing就对应于finally块。\n\n在同步版中，代码结构直接显示出有一个try/except块，logError和processPage这两者间只会取其一调用一次，而finishProcessing总是会被调用一次。在异步版中需要由程序员自己负责正确调用成功和失败情况下的回调链。如果由于编程错误，在processPage或者logError的回调链之后没有调用finishProcessing，reactor事件循环将永远不会停止，程序就会卡住。\n\n这个玩具式的例子告诉我们在开发Twisted的头几年里这种复杂性令程序员感到非常沮丧。而Twisted应对这种复杂性的方式是新增一个称为Deferred（延迟）的对象。\n\n###### Deferreds\nDeferred对象以抽象化的方式表达了一种思想，即结果还尚不存在。它同样能够帮助管理产生这个结果所需要的回调链。当从函数中返回时，Deferred对象承诺在某个时刻函数将产生一个结果。返回的Deferred对象中包含所有注册到事件上的回调引用，因此在函数间只需要传递这一个对象即可，跟踪这个对象比单独管理所有的回调要简单的多。\n\nDeferred对象包含一对回调链，一个是针对操作成功的回调，一个是针对操作失败的回调。初始状态下Deferred对象的两条链都为空。在事件处理的过程中，每个阶段都为其添加处理成功的回调和处理失败的回调。当一个异步结果到来时，Deferred对象就被“激活”，那么处理成功的回调和处理失败的回调就可以以合适的方式按照它们添加进来的顺序依次得到调用。\n\n异步版URL获取器采用Deferred对象后的代码如下：\n\n```python\nfrom twisted.internet import reactor\nimport getPage\n\ndef processPage(page):\n    print page\n\ndef logError(error):\n    print error\n\ndef finishProcessing(value):\n    print \"Shutting down...\"\n    reactor.stop()\n\nurl = \"http://google.com\"\ndeferred = getPage(url) # getPage returns a Deferred\ndeferred.addCallbacks(success, failure)\ndeferred.addBoth(stop)\n\nreactor.run()\n```\n\n在这个版本中调用的事件处理函数与之前相同，但它们都注册到了一个单独的Deferred对象上，而不是分散在代码各处再以参数形式传递给getPage。\n\nDeferred对象创建时包含两个添加回调的阶段。第一阶段，addCallbacks将 processPage和logError添加到它们各自归属的回调链中。然后addBoth再将finishProcessing同时添加到这两个回调链上。用图解的方式来看，回调链应该如图所示：\n![Deferred 流程示例](/img/1570783134086.png)\n\nDeferred对象只能被激活一次，如果试图重复激活将引发一个异常。这使得Deferred对象的语义相当接近于同步版中的try/except块。从而让异步事件的处理能更容易推断，避免由于针对单个事件的回调调用多了一个或少了一个而产生微妙的bug。\n\n理解Deferred对象对于理解Twisted程序的执行流是非常重要的。然而当使用Twisted为我们提供的针对网络协议的高层抽象时，通常情况下我们完全不需要直接使用Deferred对象。\n\nDeferred对象所包含的抽象概念是非常强大的，这种思想已经被许多其他的事件驱动平台所借用，包括jQuery、Dojo和Mochikit。\n\n\n###### Transports\nTransports代表网络中两个通信结点之间的连接。Transports负责描述连接的细节，比如连接是面向流式的还是面向数据报的，流控以及可靠性。TCP、UDP和Unix套接字可作为transports的例子。它们被设计为“满足最小功能单元，同时具有最大程度的可复用性”，而且从协议实现中分离出来，这让许多协议可以采用相同类型的传输。Transports实现了ITransports接口，它包含如下的方法：\n\n>write                   以非阻塞的方式按顺序依次将数据写到物理连接上\nwriteSequence           将一个字符串列表写到物理连接上\nloseConnection          将所有挂起的数据写入，然后关闭连接\ngetPeer                 取得连接中对端的地址信息\ngetHost                 取得连接中本端的地址信息\n\n将transports从协议中分离出来也使得对这两个层次的测试变得更加简单。可以通过简单地写入一个字符串来模拟传输，用这种方式来检查。\n\n###### Protocols\n\nProtocols描述了如何以异步的方式处理网络中的事件。HTTP、DNS以及IMAP是应用层协议中的例子。Protocols实现了IProtocol接口，它包含如下的方法：\n>makeConnection               在transport对象和服务器之间建立一条连接\nconnectionMade               连接建立起来后调用\ndataReceived                 接收数据时调用\nconnectionLost               关闭连接时调用\n\n我们最好以一个例子来说明reactor、protocols以及transports这三者之间的关系。以下是完整的echo服务器和客户端的实现，首先来看看服务器部分：\n\n```python\nfrom twisted.internet import protocol, reactor\n\nclass Echo(protocol.Protocol):\n    def dataReceived(self, data):\n        # As soon as any data is received, write it back\n        self.transport.write(data)\n\nclass EchoFactory(protocol.Factory):\n    def buildProtocol(self, addr):\n        return Echo()\n\nreactor.listenTCP(8000, EchoFactory())\nreactor.run()\n```\n接着是客户端部分：\n\n```python\nfrom twisted.internet import reactor, protocol\n\nclass EchoClient(protocol.Protocol):\n    def connectionMade(self):\n        self.transport.write(\"hello, world!\")\n\ndef dataReceived(self, data):\n    print \"Server said:\", data\n        self.transport.loseConnection()\n\ndef connectionLost(self, reason):\n    print \"connection lost\"\n\nclass EchoFactory(protocol.ClientFactory):\n    def buildProtocol(self, addr):\n        return EchoClient()\n\ndef clientConnectionFailed(self, connector, reason):\n    print \"Connection failed - goodbye!\"\n        reactor.stop()\n\ndef clientConnectionLost(self, connector, reason):\n    print \"Connection lost - goodbye!\"\n        reactor.stop()\n\nreactor.connectTCP(\"localhost\", 8000, EchoFactory())\nreactor.run()\n```\n运行服务器端脚本将启动一个TCP服务器，监听端口8000上的连接。服务器采用的是Echo协议，数据经TCP transport对象写出。运行客户端脚本将对服务器发起一个TCP连接，回显服务器端的回应然后终止连接并停止reactor事件循环。这里的Factory用来对连接的双方生成protocol对象实例。两端的通信是异步的，connectTCP负责注册回调函数到reactor事件循环中，当socket上有数据可读时通知回调处理。\n\n###### Applications\nTwisted是用来创建具有可扩展性、跨平台的网络服务器和客户端的引擎。在生产环境中，以标准化的方式简化部署这些应用的过程对于Twisted这种被广泛采用的平台来说是非常重要的一环。为此，Twisted开发了一套应用程序基础组件，采用可重用、可配置的方式来部署Twisted应用。这种方式使程序员避免堆砌千篇一律的代码来将应用程序同已有的工具整合在一起，这包括精灵化进程（daemonization）、日志处理、使用自定义的reactor循环、对代码做性能剖析等。\n\n应用程序基础组件包含4个主要部分：服务（Service）、应用（Application）、配置管理（通过TAC文件和插件）以及twistd命令行程序。为了说明这个基础组件，我们将上一节的Echo服务器转变成一个应用。\n\n+ **Service**\nService就是IService接口下实现的可以启动和停止的组件。Twisted自带有TCP、FTP、HTTP、SSH、DNS等服务以及其他协议的实现。其中许多Service都可以注册到单独的应用中。IService接口的核心是：\n>startService    启动服务。可能包含加载配置数据，设定数据库连接或者监听某个端口\nstopService     关闭服务。可能包含将状态保存到磁盘，关闭数据库连接或者停止监听端口\n\n我们的Echo服务使用TCP协议，因此我们可以使用Twisted中IService接口下默认的TCPServer实现。\n\n+ **Application**\nApplication是处于最顶层的Service，代表了整个Twisted应用程序。Service需要将其自身同Application注册，然后就可以用下面我们将介绍的部署工具twistd搜索并运行应用程序。我们将创建一个可以同Echo Service注册的Echo应用。\n+ **TAC文件**\n当在一个普通的Python文件中管理Twisted应用程序时，需要由开发者负责编写启动和停止reactor事件循环以及配置应用程序的代码。在Twisted的基础组件中，协议的实现都是在一个模块中完成的，需要使用到这些协议的Service可以注册到一个Twisted应用程序配置文件中（TAC文件）去，这样reactor事件循环和程序配置就可以由外部组件来进行管理。\n\n要将我们的Echo服务器转变成一个Echo应用，我们可以按照以下几个简单的步骤来完成：\n\n1. 将Echo服务器的Protocol部分移到它们自己所归属的模块中去。\n\n2. 在TAC文件中：\n\n\t1. 创建一个Echo应用。\n\t2. 创建一个TCPServer的Service实例，它将使用我们的EchoFactory，然后同前面创建的应用完成注册。\n\t\n管理reactor事件循环的代码将由twistd来负责，我们下面会对此进行讨论。这样，应用程序的代码就变成这样了：\necho.py文件：\n\n```python\nfrom twisted.internet import protocol, reactor\n\nclass Echo(protocol.Protocol):\n    def dataReceived(self, data):\n        self.transport.write(data)\n\nclass EchoFactory(protocol.Factory):\n    def buildProtocol(self, addr):\n        return Echo()\n```\n\n+ **twistd**\ntwistd（读作“twist-dee”）是一个跨平台的用来部署Twisted应用程序的工具。它执行TAC文件并负责处理启动和停止应用程序。作为Twisted在网络编程中具有“内置电池”能力的一部分，twistd自带有一些非常有用的配置标志，包括将应用程序转变为守护进程、定义日志文件的路径、设定特权级别、在chroot下运行、使用非默认的reactor，甚至是在profiler下运行应用程序。\n\n我们可以像这样运行这个Echo服务应用：\n\n```python\n$ twistd –y echo_server.tac\n```\n\n在这个简单的例子里，twistd将这个应用程序作为守护进程来启动，日志记录在twistd.log文件中。启动和停止应用后，日志文件内容如下：\n\n```python\n2011-11-19 22:23:07-0500 [-] Log opened.\n2011-11-19 22:23:07-0500 [-] twistd 11.0.0 (/usr/bin/python 2.7.1) starting up.\n2011-11-19 22:23:07-0500 [-] reactor class: twisted.internet.selectreactor.SelectReactor.\n2011-11-19 22:23:07-0500 [-] echo.EchoFactory starting on 8000\n2011-11-19 22:23:07-0500 [-] Starting factory <echo.EchoFactory instance at 0x12d8670>\n2011-11-19 22:23:20-0500 [-] Received SIGTERM, shutting down.\n2011-11-19 22:23:20-0500 [-] (TCP Port 8000 Closed)\n2011-11-19 22:23:20-0500 [-] Stopping factory <echo.EchoFactory instance at 0x12d8670>\n2011-11-19 22:23:20-0500 [-] Main loop terminated.\n2011-11-19 22:23:20-0500 [-] Server Shut Down.\n```\n\n通过使用Twisted框架中的基础组件来运行服务，这么做使得开发人员能够不用再编写类似守护进程和记录日志这样的冗余代码了。这同样也为部署应用程序建立了一个标准的命令行接口。\n\n###### Plugins\n\n对于运行Twisted应用程序的方法，除了基于TAC文件外还有一种可选的方法，这就是插件系统。TAC系统可以很方便的将Twisted预定义的服务同应用程序配置文件注册，而插件系统能够方便的将用户自定义的服务注册为twistd工具的子命令，然后扩展应用程序的命令行接口。\n\n在使用插件系统时：\n\n1. 由于只有plugin API需要保持稳定，这使得第三方开发者能很容易地扩展软件。\n\n2. 插件发现能力已经集成到系统中了。插件可以在程序首次运行时加载并保存，每次程序启动时会重新触发插件发现过程，或者也可以在程序运行期间反复轮询新插件，这使得在程序已经启动后我们还可以判断是否有新的插件安装上了。\n\n当使用Twisted插件系统来扩展软件时，我们要做的就是创建IPlugin接口下实现的对象并将它们放到一个特定的位置中，这里插件系统知道该如何去找到它们。\n\n我们已经将Echo服务转换为一个Twisted应用程序了，而将其转换为一个Twisted插件也是非常简单直接的。在我们之前的Echo模块中，除了包含有Echo协议和EchoFactory的定义之外，现在我们还要添加一个名为twistd的目录，其中还包含着一个名为plugins的子目录，这里正是我们需要定义echo插件的地方。通过这个插件，我们可以启动一个echo服务，并将需要使用的端口号作为参数指定给twistd工具。\n\n```python\nfrom zope.interface import implements\n\nfrom twisted.python import usage\nfrom twisted.plugin import IPlugin\nfrom twisted.application.service import IServiceMaker\nfrom twisted.application import internet\n\nfrom echo import EchoFactory\n\nclass Options(usage.Options):\n    optParameters = [[\"port\", \"p\", 8000, \"The port number to listen on.\"]]\n\nclass EchoServiceMaker(object):\n    implements(IServiceMaker, IPlugin)\n    tapname = \"echo\"\n    description = \"A TCP-based echo server.\"\n    options = Options\n\ndef makeService(self, options):\n    \"\"\"\n    Construct a TCPServer from a factory defined in myproject.\n    \"\"\"\n    return internet.TCPServer(int(options[\"port\"]), EchoFactory())\n\nserviceMaker = EchoServiceMaker()\n```\n\n现在，我们的Echo服务器将作为一个服务选项出现在twistd –help的输出中。运行twistd echo –port=1235将在端口1235上启动一个Echo服务器。\n\nTwisted还带有一个可拔插的针对服务器端认证的模块twisted.cred，插件系统常见的用途就是为应用程序添加一个认证模式。我们可以使用twisted.cred中现成的AuthOptionMixin类来添加针对各种认证的命令行支持，或者是添加新的认证类型。比如，我们可以使用插件系统来添加基于本地Unix密码数据库或者是基于LDAP服务器的认证方式。\n\ntwistd工具中附带有许多Twisted所支持的协议插件，只用一条单独的命令就可以完成启动服务器的工作了。这里有一些通过twistd启动服务器的例子：\n\n```python\ntwistd web –port 8080 –path .\n```\n\n这条命令将在8080端口启动一个HTTP服务器，在当前目录中负责处理静态和动态页面请求。\n\n```python\ntwistd dns –p 5553 –hosts-file=hosts\n```\n\n\n这条命令在端口5553上启动一个DNS服务器，解析指定的文件hosts中的域名，这个文件的内容格式同/etc/hosts一样。\n\n```python\nsudo twistd conch –p tcp:2222\n```\n\n这条命令在端口2222上启动一个SSH服务器。ssh的密钥必须独立设定。\n\n```python\ntwistd mail –E –H localhost –d localhost=emails\n```\n\n这条命令启动一个ESMTP POP3服务器，为本地主机接收邮件并保存到指定的emails目录下。\n\n我们可以方便的通过twistd来搭建一个用于测试客户端功能的服务器，但它同样是可装载的、产品级的服务器实现。\n\n在部署应用程序的方式上，Twisted通过TAC文件、插件以及命令行工具twistd的部署方式已经获得了成功。但是有趣的是，对于大多数大型Twisted应用程序来说，部署它们仍然需要重写一些这类管理和监控组件；Twisted的架构并没有对系统管理员的需求呈现出太多的友好性。这也反映了一个事实，那就是对于系统管理员来说Twisted历来就没有太多架构可言，而这些系统管理员才是部署和维护应用程序的专家。在这方面，Twisted在未来架构设计的决策上需要更积极的征求这类专家级用户的反馈意见。\n\n[本文内容引用自此处](https://www.cnblogs.com/xianguang/p/7027661.html)","source":"_posts/Twisted  介绍.md","raw":"---\ntitle: Twisted  介绍\ncategories:\n- Python\ntags: \n- Python\n- Core Programming\n- Note\n---\n\n## Twisted\n\n\n### Python Twisted介绍\nTwisted是用Python实现的基于事件驱动的网络引擎框架。Twisted诞生于2000年初，在当时的网络游戏开发者看来，无论他们使用哪种语言，手中都鲜有可兼顾扩展性及跨平台的网络库。Twisted的作者试图在当时现有的环境下开发游戏，这一步走的非常艰难，他们迫切地需要一个可扩展性高、基于事件驱动、跨平台的网络开发框架，为此他们决定自己实现一个，并从那些之前的游戏和网络应用程序的开发者中学习，汲取他们的经验教训。\n\nTwisted支持许多常见的传输及应用层协议，包括TCP、UDP、SSL/TLS、HTTP、IMAP、SSH、IRC以及FTP。就像python一样，Twisted也具有“内置电池”（batteries-included）的特点。Twisted对于其支持的所有协议都带有客户端和服务器实现，同时附带有基于命令行的工具，使得配置和部署产品级的Twisted应用变得非常方便。\n\n### 为什么需要Twisted\n2000年时，Twisted的作者Glyph正在开发一个名为Twisted Reality的基于文本方式的多人在线游戏。这个游戏采用Java开发，里面尽是一堆线程——每个连接就有3个线程处理。处理输入的线程会在读操作上阻塞，处理输出的线程将在一些写操作上阻塞，还有一个“逻辑”线程将在等待定时器超时或者事件入队列时休眠。随着玩家们在虚拟世界中移动并交互时，线程出现死锁，缓存被污染，程序中的加锁逻辑几乎从来就没对过——采用多线程使得整个软件变得复杂、漏洞百出而且极难扩展。\n\n为了寻求其他的解决方案，作者发现了Python，特别是Python中用于对流式对象比如socket和pipe进行多路I/O复用的select模块（UNIX规范第3版（SUSv3）描述了select）。那时，Java并没有提供操作系统的select接口或者任何其他的异步I/O API（针对非阻塞式I/O的包java.nio已经在J2SE 1.4中加入了，2002年发布）。通过用Python中的select模块快速搭建起游戏的原型，这迅速降低了程序的复杂度，并且比多线程版本要更加可靠。\n\nGlyph迅速转向了Python、select以及基于事件驱动的编程。他使用Python的select模块为游戏编写了客户端和服务器。但他想要的还不止于此。从根本上说，他希望能将网络行为转变为对游戏中的对象的方法调用。如果你能在游戏中收取邮件会怎样，就像Nethack mailer这种守护进程一样？如果游戏中的每位玩家都拥有一个主页呢？Glyph发现他需要优秀的IMAP以及HTTP客户端和服务器的Python实现，而这些都要采用select。\n\n他首先转向了Medusa，这是一个在90年代中期开发的平台，在这里可以采用Python中的asyncore模块来编写网络服务。asyncore是一个异步化处理socket的模块，在操作系统的select API之上构建了一个调度器和回调接口。\n\n这对于Glyph来说是个激动人心的发现，但Medusa有两个缺点：\n1. 这个项目到2001年就不再维护了，那正是glyph开发Twisted Reality的时候。\n2. asyncore只是对socket的一个薄封装层，应用程序的编写者仍然需要直接操作socket。这意味着程序可移植性的担子仍然落在程序员自己身上。此外，那时asyncore对Windows的支持还有问题，Glyph希望能在Windows上运行一个带有图形用户界面的客户端。\nGlyph需要自己实现一个网络引擎平台，而且他意识到Twisted Reality已经打开了问题的大门，这和他的游戏一样有趣。\n\n随着时间的推移，Twisted Reality这个游戏就演化成了Twisted网络引擎平台。它可以做到当时Python中已有的网络平台所无法做到的事情：\n+ 使用基于事件驱动的编程模型，而不是多线程模型。\n+ 跨平台：为主流操作系统平台暴露出的事件通知系统提供统一的接口。\n+ “内置电池”的能力：提供流行的应用层协议实现，因此Twisted马上就可为开发人员所用。\n+ 符合RFC规范，已经通过健壮的测试套件证明了其一致性。\n+ 能很容易的配合多个网络协议一起使用。\n+ 可扩展。\n\n### Twisted架构概览\nTwisted是一个事件驱动型的网络引擎。由于事件驱动编程模型在Twisted的设计哲学中占有重要的地位，因此这里有必要花点时间来回顾一下究竟事件驱动意味着什么。\n\n事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。\n\n在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。\n\n在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。\n\n在事件驱动版本的程序中，3个任务**交错执行**，但仍然在一个单独的线程控制中。当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。\n\n当我们面对如下的环境时，事件驱动模型通常是一个好的选择：\n\n程序中有许多任务，而且…\n1. 任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…\n2. 在等待事件到来时，某些任务会阻塞。\n3. 当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。\n\n网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。\n\n###### **重用已有的应用**\n在Twisted创建之前就已经有了许多针对多种流行的网络协议的客户端和服务器实现了。为什么Glyph不直接用Apache、IRCd、BIND、OpenSSH或者任何其他已有的应用，而要为Twisted从头开始重新实现各个协议的客户端和服务器呢？\n\n问题在于所有这些已有的实现都存在有从头写起的网络层代码，通常都是C代码。而应用层代码直接同网络层耦合在一起，这使得它们非常难以以库的形式来复用。当要一起使用这些组件时，如果希望在多个协议中暴露相同的数据，则它们必须以黑盒的形式来看待，这使得开发者根本没机会重用代码。此外，服务器和客户端的实现通常是分离的，彼此之间不共享代码。要扩展这些应用，维护跨平台的客户端-服务器兼容性的难度本不至于这么大。\n\nTwisted中的客户端和服务器是用Python开发的，采用了一致性的接口。这使得开发新的客户端和服务器变得很容易实现，可以在客户端和服务器之间共享代码，在协议之间共享应用逻辑，以及对某个实现的代码做测试。\n\n###### **React模式**\nTwisted实现了设计模式中的反应堆（reactor）模式，这种模式在单线程环境中调度多个事件源产生的事件到它们各自的事件处理例程中去。\n\nTwisted的核心就是reactor事件循环。Reactor可以感知网络、文件系统以及定时器事件。它等待然后处理这些事件，从特定于平台的行为中抽象出来，并提供统一的接口，使得在网络协议栈的任何位置对事件做出响应都变得简单。\n\n基本上reactor完成的任务就是：\n\n```python\nwhile True:\n    timeout = time_until_next_timed_event()\n    events = wait_for_events(timeout)\n    events += timed_events_until(now())\n    for event in events:\n        event.process()\n```\n\nTwisted目前在所有平台上的默认reactor都是基于poll API的（UNIX规范第3版（SUSv3）中描述）。此外，Twisted还支持一些特定于平台的高容量多路复用API。这些reactor包括基于FreeBSD中kqueue机制的KQueue reactor，支持epoll接口的系统（目前是Linux 2.6）中的epoll reactor，以及基于Windows下的输入输出完成端口的IOCP reactor。\n\n在实现轮询的相关细节中，Twisted需要考虑的包括：\n\n+ 网络和文件系统的限制\n+ 缓冲行为\n+ 如何检测连接丢失\n+ 出现错误时的返回值\n\nTwisted的reactor实现同时也考虑了正确使用底层的非阻塞式API，并正确处理各种边界情况。由于Python中没有暴露出IOCP API，因此Twisted需要维护自己的实现。\n\n###### **管理回调链**\n\n回调是事件驱动编程模型中的基础，也是reactor通知应用程序事件已经处理完成的方式。随着程序规模不断扩大，基于事件驱动的程序需要同时处理事件处理成功和出错的情况，这使得程序变得越来越复杂。若没有注册一个合适的回调，程序就会阻塞，因为这个事件处理的过程绝不会发生。出现错误时需要通过应用程序的不同层次从网络栈向上传递回调链。\n\n下面是两段Python伪码，分别是同步和异步模式下获取URL的玩具代码。让我们相互比较一下这两个版本，看看基于事件驱动的程序有什么缺陷：\n\n以同步的方式获取URL：\n\n```python\nimport getPage\n\ndef processPage(page):\n    print page\n\ndef logError(error):\n    print error\n\ndef finishProcessing(value):\n    print \"Shutting down...\"\n    exit(0)\n\nurl = \"http://google.com\"\ntry:\n    page = getPage(url)\n    processPage(page)\nexcept Error, e:\n    logError(error)\nfinally:\n    finishProcessing()\n```\n以异步的方式获取URL：\n\n```python\nfrom twisted.internet import reactor\nimport getPage\n\ndef processPage(page):\n    print page\n    finishProcessing()\n\ndef logError(error):\n    print error\n    finishProcessing()\n\ndef finishProcessing(value):\n    print \"Shutting down...\"\n    reactor.stop()\n\nurl = \"http://google.com\"\n# getPage takes: url, \n# success callback, error callback\ngetPage(url, processPage, logError)\n\nreactor.run()\n```\n\n在异步版的URL获取器中，reactor.run()启动reactor事件循环。在同步和异步版程序中，我们假定getPage函数处理获取页面的工作。如果获取成功就调用processPage，如果尝试获取页面时出现了Exception（异常），logError就得到调用。无论哪种情况，最后都要调用finishProcessing。\n\n异步版中的logError回调正对应于同步版中的try/except块。对processPage的回调对应于else块，无条件回调的finishProcessing就对应于finally块。\n\n在同步版中，代码结构直接显示出有一个try/except块，logError和processPage这两者间只会取其一调用一次，而finishProcessing总是会被调用一次。在异步版中需要由程序员自己负责正确调用成功和失败情况下的回调链。如果由于编程错误，在processPage或者logError的回调链之后没有调用finishProcessing，reactor事件循环将永远不会停止，程序就会卡住。\n\n这个玩具式的例子告诉我们在开发Twisted的头几年里这种复杂性令程序员感到非常沮丧。而Twisted应对这种复杂性的方式是新增一个称为Deferred（延迟）的对象。\n\n###### Deferreds\nDeferred对象以抽象化的方式表达了一种思想，即结果还尚不存在。它同样能够帮助管理产生这个结果所需要的回调链。当从函数中返回时，Deferred对象承诺在某个时刻函数将产生一个结果。返回的Deferred对象中包含所有注册到事件上的回调引用，因此在函数间只需要传递这一个对象即可，跟踪这个对象比单独管理所有的回调要简单的多。\n\nDeferred对象包含一对回调链，一个是针对操作成功的回调，一个是针对操作失败的回调。初始状态下Deferred对象的两条链都为空。在事件处理的过程中，每个阶段都为其添加处理成功的回调和处理失败的回调。当一个异步结果到来时，Deferred对象就被“激活”，那么处理成功的回调和处理失败的回调就可以以合适的方式按照它们添加进来的顺序依次得到调用。\n\n异步版URL获取器采用Deferred对象后的代码如下：\n\n```python\nfrom twisted.internet import reactor\nimport getPage\n\ndef processPage(page):\n    print page\n\ndef logError(error):\n    print error\n\ndef finishProcessing(value):\n    print \"Shutting down...\"\n    reactor.stop()\n\nurl = \"http://google.com\"\ndeferred = getPage(url) # getPage returns a Deferred\ndeferred.addCallbacks(success, failure)\ndeferred.addBoth(stop)\n\nreactor.run()\n```\n\n在这个版本中调用的事件处理函数与之前相同，但它们都注册到了一个单独的Deferred对象上，而不是分散在代码各处再以参数形式传递给getPage。\n\nDeferred对象创建时包含两个添加回调的阶段。第一阶段，addCallbacks将 processPage和logError添加到它们各自归属的回调链中。然后addBoth再将finishProcessing同时添加到这两个回调链上。用图解的方式来看，回调链应该如图所示：\n![Deferred 流程示例](/img/1570783134086.png)\n\nDeferred对象只能被激活一次，如果试图重复激活将引发一个异常。这使得Deferred对象的语义相当接近于同步版中的try/except块。从而让异步事件的处理能更容易推断，避免由于针对单个事件的回调调用多了一个或少了一个而产生微妙的bug。\n\n理解Deferred对象对于理解Twisted程序的执行流是非常重要的。然而当使用Twisted为我们提供的针对网络协议的高层抽象时，通常情况下我们完全不需要直接使用Deferred对象。\n\nDeferred对象所包含的抽象概念是非常强大的，这种思想已经被许多其他的事件驱动平台所借用，包括jQuery、Dojo和Mochikit。\n\n\n###### Transports\nTransports代表网络中两个通信结点之间的连接。Transports负责描述连接的细节，比如连接是面向流式的还是面向数据报的，流控以及可靠性。TCP、UDP和Unix套接字可作为transports的例子。它们被设计为“满足最小功能单元，同时具有最大程度的可复用性”，而且从协议实现中分离出来，这让许多协议可以采用相同类型的传输。Transports实现了ITransports接口，它包含如下的方法：\n\n>write                   以非阻塞的方式按顺序依次将数据写到物理连接上\nwriteSequence           将一个字符串列表写到物理连接上\nloseConnection          将所有挂起的数据写入，然后关闭连接\ngetPeer                 取得连接中对端的地址信息\ngetHost                 取得连接中本端的地址信息\n\n将transports从协议中分离出来也使得对这两个层次的测试变得更加简单。可以通过简单地写入一个字符串来模拟传输，用这种方式来检查。\n\n###### Protocols\n\nProtocols描述了如何以异步的方式处理网络中的事件。HTTP、DNS以及IMAP是应用层协议中的例子。Protocols实现了IProtocol接口，它包含如下的方法：\n>makeConnection               在transport对象和服务器之间建立一条连接\nconnectionMade               连接建立起来后调用\ndataReceived                 接收数据时调用\nconnectionLost               关闭连接时调用\n\n我们最好以一个例子来说明reactor、protocols以及transports这三者之间的关系。以下是完整的echo服务器和客户端的实现，首先来看看服务器部分：\n\n```python\nfrom twisted.internet import protocol, reactor\n\nclass Echo(protocol.Protocol):\n    def dataReceived(self, data):\n        # As soon as any data is received, write it back\n        self.transport.write(data)\n\nclass EchoFactory(protocol.Factory):\n    def buildProtocol(self, addr):\n        return Echo()\n\nreactor.listenTCP(8000, EchoFactory())\nreactor.run()\n```\n接着是客户端部分：\n\n```python\nfrom twisted.internet import reactor, protocol\n\nclass EchoClient(protocol.Protocol):\n    def connectionMade(self):\n        self.transport.write(\"hello, world!\")\n\ndef dataReceived(self, data):\n    print \"Server said:\", data\n        self.transport.loseConnection()\n\ndef connectionLost(self, reason):\n    print \"connection lost\"\n\nclass EchoFactory(protocol.ClientFactory):\n    def buildProtocol(self, addr):\n        return EchoClient()\n\ndef clientConnectionFailed(self, connector, reason):\n    print \"Connection failed - goodbye!\"\n        reactor.stop()\n\ndef clientConnectionLost(self, connector, reason):\n    print \"Connection lost - goodbye!\"\n        reactor.stop()\n\nreactor.connectTCP(\"localhost\", 8000, EchoFactory())\nreactor.run()\n```\n运行服务器端脚本将启动一个TCP服务器，监听端口8000上的连接。服务器采用的是Echo协议，数据经TCP transport对象写出。运行客户端脚本将对服务器发起一个TCP连接，回显服务器端的回应然后终止连接并停止reactor事件循环。这里的Factory用来对连接的双方生成protocol对象实例。两端的通信是异步的，connectTCP负责注册回调函数到reactor事件循环中，当socket上有数据可读时通知回调处理。\n\n###### Applications\nTwisted是用来创建具有可扩展性、跨平台的网络服务器和客户端的引擎。在生产环境中，以标准化的方式简化部署这些应用的过程对于Twisted这种被广泛采用的平台来说是非常重要的一环。为此，Twisted开发了一套应用程序基础组件，采用可重用、可配置的方式来部署Twisted应用。这种方式使程序员避免堆砌千篇一律的代码来将应用程序同已有的工具整合在一起，这包括精灵化进程（daemonization）、日志处理、使用自定义的reactor循环、对代码做性能剖析等。\n\n应用程序基础组件包含4个主要部分：服务（Service）、应用（Application）、配置管理（通过TAC文件和插件）以及twistd命令行程序。为了说明这个基础组件，我们将上一节的Echo服务器转变成一个应用。\n\n+ **Service**\nService就是IService接口下实现的可以启动和停止的组件。Twisted自带有TCP、FTP、HTTP、SSH、DNS等服务以及其他协议的实现。其中许多Service都可以注册到单独的应用中。IService接口的核心是：\n>startService    启动服务。可能包含加载配置数据，设定数据库连接或者监听某个端口\nstopService     关闭服务。可能包含将状态保存到磁盘，关闭数据库连接或者停止监听端口\n\n我们的Echo服务使用TCP协议，因此我们可以使用Twisted中IService接口下默认的TCPServer实现。\n\n+ **Application**\nApplication是处于最顶层的Service，代表了整个Twisted应用程序。Service需要将其自身同Application注册，然后就可以用下面我们将介绍的部署工具twistd搜索并运行应用程序。我们将创建一个可以同Echo Service注册的Echo应用。\n+ **TAC文件**\n当在一个普通的Python文件中管理Twisted应用程序时，需要由开发者负责编写启动和停止reactor事件循环以及配置应用程序的代码。在Twisted的基础组件中，协议的实现都是在一个模块中完成的，需要使用到这些协议的Service可以注册到一个Twisted应用程序配置文件中（TAC文件）去，这样reactor事件循环和程序配置就可以由外部组件来进行管理。\n\n要将我们的Echo服务器转变成一个Echo应用，我们可以按照以下几个简单的步骤来完成：\n\n1. 将Echo服务器的Protocol部分移到它们自己所归属的模块中去。\n\n2. 在TAC文件中：\n\n\t1. 创建一个Echo应用。\n\t2. 创建一个TCPServer的Service实例，它将使用我们的EchoFactory，然后同前面创建的应用完成注册。\n\t\n管理reactor事件循环的代码将由twistd来负责，我们下面会对此进行讨论。这样，应用程序的代码就变成这样了：\necho.py文件：\n\n```python\nfrom twisted.internet import protocol, reactor\n\nclass Echo(protocol.Protocol):\n    def dataReceived(self, data):\n        self.transport.write(data)\n\nclass EchoFactory(protocol.Factory):\n    def buildProtocol(self, addr):\n        return Echo()\n```\n\n+ **twistd**\ntwistd（读作“twist-dee”）是一个跨平台的用来部署Twisted应用程序的工具。它执行TAC文件并负责处理启动和停止应用程序。作为Twisted在网络编程中具有“内置电池”能力的一部分，twistd自带有一些非常有用的配置标志，包括将应用程序转变为守护进程、定义日志文件的路径、设定特权级别、在chroot下运行、使用非默认的reactor，甚至是在profiler下运行应用程序。\n\n我们可以像这样运行这个Echo服务应用：\n\n```python\n$ twistd –y echo_server.tac\n```\n\n在这个简单的例子里，twistd将这个应用程序作为守护进程来启动，日志记录在twistd.log文件中。启动和停止应用后，日志文件内容如下：\n\n```python\n2011-11-19 22:23:07-0500 [-] Log opened.\n2011-11-19 22:23:07-0500 [-] twistd 11.0.0 (/usr/bin/python 2.7.1) starting up.\n2011-11-19 22:23:07-0500 [-] reactor class: twisted.internet.selectreactor.SelectReactor.\n2011-11-19 22:23:07-0500 [-] echo.EchoFactory starting on 8000\n2011-11-19 22:23:07-0500 [-] Starting factory <echo.EchoFactory instance at 0x12d8670>\n2011-11-19 22:23:20-0500 [-] Received SIGTERM, shutting down.\n2011-11-19 22:23:20-0500 [-] (TCP Port 8000 Closed)\n2011-11-19 22:23:20-0500 [-] Stopping factory <echo.EchoFactory instance at 0x12d8670>\n2011-11-19 22:23:20-0500 [-] Main loop terminated.\n2011-11-19 22:23:20-0500 [-] Server Shut Down.\n```\n\n通过使用Twisted框架中的基础组件来运行服务，这么做使得开发人员能够不用再编写类似守护进程和记录日志这样的冗余代码了。这同样也为部署应用程序建立了一个标准的命令行接口。\n\n###### Plugins\n\n对于运行Twisted应用程序的方法，除了基于TAC文件外还有一种可选的方法，这就是插件系统。TAC系统可以很方便的将Twisted预定义的服务同应用程序配置文件注册，而插件系统能够方便的将用户自定义的服务注册为twistd工具的子命令，然后扩展应用程序的命令行接口。\n\n在使用插件系统时：\n\n1. 由于只有plugin API需要保持稳定，这使得第三方开发者能很容易地扩展软件。\n\n2. 插件发现能力已经集成到系统中了。插件可以在程序首次运行时加载并保存，每次程序启动时会重新触发插件发现过程，或者也可以在程序运行期间反复轮询新插件，这使得在程序已经启动后我们还可以判断是否有新的插件安装上了。\n\n当使用Twisted插件系统来扩展软件时，我们要做的就是创建IPlugin接口下实现的对象并将它们放到一个特定的位置中，这里插件系统知道该如何去找到它们。\n\n我们已经将Echo服务转换为一个Twisted应用程序了，而将其转换为一个Twisted插件也是非常简单直接的。在我们之前的Echo模块中，除了包含有Echo协议和EchoFactory的定义之外，现在我们还要添加一个名为twistd的目录，其中还包含着一个名为plugins的子目录，这里正是我们需要定义echo插件的地方。通过这个插件，我们可以启动一个echo服务，并将需要使用的端口号作为参数指定给twistd工具。\n\n```python\nfrom zope.interface import implements\n\nfrom twisted.python import usage\nfrom twisted.plugin import IPlugin\nfrom twisted.application.service import IServiceMaker\nfrom twisted.application import internet\n\nfrom echo import EchoFactory\n\nclass Options(usage.Options):\n    optParameters = [[\"port\", \"p\", 8000, \"The port number to listen on.\"]]\n\nclass EchoServiceMaker(object):\n    implements(IServiceMaker, IPlugin)\n    tapname = \"echo\"\n    description = \"A TCP-based echo server.\"\n    options = Options\n\ndef makeService(self, options):\n    \"\"\"\n    Construct a TCPServer from a factory defined in myproject.\n    \"\"\"\n    return internet.TCPServer(int(options[\"port\"]), EchoFactory())\n\nserviceMaker = EchoServiceMaker()\n```\n\n现在，我们的Echo服务器将作为一个服务选项出现在twistd –help的输出中。运行twistd echo –port=1235将在端口1235上启动一个Echo服务器。\n\nTwisted还带有一个可拔插的针对服务器端认证的模块twisted.cred，插件系统常见的用途就是为应用程序添加一个认证模式。我们可以使用twisted.cred中现成的AuthOptionMixin类来添加针对各种认证的命令行支持，或者是添加新的认证类型。比如，我们可以使用插件系统来添加基于本地Unix密码数据库或者是基于LDAP服务器的认证方式。\n\ntwistd工具中附带有许多Twisted所支持的协议插件，只用一条单独的命令就可以完成启动服务器的工作了。这里有一些通过twistd启动服务器的例子：\n\n```python\ntwistd web –port 8080 –path .\n```\n\n这条命令将在8080端口启动一个HTTP服务器，在当前目录中负责处理静态和动态页面请求。\n\n```python\ntwistd dns –p 5553 –hosts-file=hosts\n```\n\n\n这条命令在端口5553上启动一个DNS服务器，解析指定的文件hosts中的域名，这个文件的内容格式同/etc/hosts一样。\n\n```python\nsudo twistd conch –p tcp:2222\n```\n\n这条命令在端口2222上启动一个SSH服务器。ssh的密钥必须独立设定。\n\n```python\ntwistd mail –E –H localhost –d localhost=emails\n```\n\n这条命令启动一个ESMTP POP3服务器，为本地主机接收邮件并保存到指定的emails目录下。\n\n我们可以方便的通过twistd来搭建一个用于测试客户端功能的服务器，但它同样是可装载的、产品级的服务器实现。\n\n在部署应用程序的方式上，Twisted通过TAC文件、插件以及命令行工具twistd的部署方式已经获得了成功。但是有趣的是，对于大多数大型Twisted应用程序来说，部署它们仍然需要重写一些这类管理和监控组件；Twisted的架构并没有对系统管理员的需求呈现出太多的友好性。这也反映了一个事实，那就是对于系统管理员来说Twisted历来就没有太多架构可言，而这些系统管理员才是部署和维护应用程序的专家。在这方面，Twisted在未来架构设计的决策上需要更积极的征求这类专家级用户的反馈意见。\n\n[本文内容引用自此处](https://www.cnblogs.com/xianguang/p/7027661.html)","slug":"Twisted  介绍","published":1,"date":"2020-09-08T03:23:20.716Z","updated":"2020-09-08T03:23:20.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10o002m4wf06mtgo9fu","content":"<h2 id=\"Twisted\"><a href=\"#Twisted\" class=\"headerlink\" title=\"Twisted\"></a>Twisted</h2><h3 id=\"Python-Twisted介绍\"><a href=\"#Python-Twisted介绍\" class=\"headerlink\" title=\"Python Twisted介绍\"></a>Python Twisted介绍</h3><p>Twisted是用Python实现的基于事件驱动的网络引擎框架。Twisted诞生于2000年初，在当时的网络游戏开发者看来，无论他们使用哪种语言，手中都鲜有可兼顾扩展性及跨平台的网络库。Twisted的作者试图在当时现有的环境下开发游戏，这一步走的非常艰难，他们迫切地需要一个可扩展性高、基于事件驱动、跨平台的网络开发框架，为此他们决定自己实现一个，并从那些之前的游戏和网络应用程序的开发者中学习，汲取他们的经验教训。</p>\n<p>Twisted支持许多常见的传输及应用层协议，包括TCP、UDP、SSL/TLS、HTTP、IMAP、SSH、IRC以及FTP。就像python一样，Twisted也具有“内置电池”（batteries-included）的特点。Twisted对于其支持的所有协议都带有客户端和服务器实现，同时附带有基于命令行的工具，使得配置和部署产品级的Twisted应用变得非常方便。</p>\n<h3 id=\"为什么需要Twisted\"><a href=\"#为什么需要Twisted\" class=\"headerlink\" title=\"为什么需要Twisted\"></a>为什么需要Twisted</h3><p>2000年时，Twisted的作者Glyph正在开发一个名为Twisted Reality的基于文本方式的多人在线游戏。这个游戏采用Java开发，里面尽是一堆线程——每个连接就有3个线程处理。处理输入的线程会在读操作上阻塞，处理输出的线程将在一些写操作上阻塞，还有一个“逻辑”线程将在等待定时器超时或者事件入队列时休眠。随着玩家们在虚拟世界中移动并交互时，线程出现死锁，缓存被污染，程序中的加锁逻辑几乎从来就没对过——采用多线程使得整个软件变得复杂、漏洞百出而且极难扩展。</p>\n<p>为了寻求其他的解决方案，作者发现了Python，特别是Python中用于对流式对象比如socket和pipe进行多路I/O复用的select模块（UNIX规范第3版（SUSv3）描述了select）。那时，Java并没有提供操作系统的select接口或者任何其他的异步I/O API（针对非阻塞式I/O的包java.nio已经在J2SE 1.4中加入了，2002年发布）。通过用Python中的select模块快速搭建起游戏的原型，这迅速降低了程序的复杂度，并且比多线程版本要更加可靠。</p>\n<p>Glyph迅速转向了Python、select以及基于事件驱动的编程。他使用Python的select模块为游戏编写了客户端和服务器。但他想要的还不止于此。从根本上说，他希望能将网络行为转变为对游戏中的对象的方法调用。如果你能在游戏中收取邮件会怎样，就像Nethack mailer这种守护进程一样？如果游戏中的每位玩家都拥有一个主页呢？Glyph发现他需要优秀的IMAP以及HTTP客户端和服务器的Python实现，而这些都要采用select。</p>\n<p>他首先转向了Medusa，这是一个在90年代中期开发的平台，在这里可以采用Python中的asyncore模块来编写网络服务。asyncore是一个异步化处理socket的模块，在操作系统的select API之上构建了一个调度器和回调接口。</p>\n<p>这对于Glyph来说是个激动人心的发现，但Medusa有两个缺点：</p>\n<ol>\n<li>这个项目到2001年就不再维护了，那正是glyph开发Twisted Reality的时候。</li>\n<li>asyncore只是对socket的一个薄封装层，应用程序的编写者仍然需要直接操作socket。这意味着程序可移植性的担子仍然落在程序员自己身上。此外，那时asyncore对Windows的支持还有问题，Glyph希望能在Windows上运行一个带有图形用户界面的客户端。<br>Glyph需要自己实现一个网络引擎平台，而且他意识到Twisted Reality已经打开了问题的大门，这和他的游戏一样有趣。</li>\n</ol>\n<p>随着时间的推移，Twisted Reality这个游戏就演化成了Twisted网络引擎平台。它可以做到当时Python中已有的网络平台所无法做到的事情：</p>\n<ul>\n<li>使用基于事件驱动的编程模型，而不是多线程模型。</li>\n<li>跨平台：为主流操作系统平台暴露出的事件通知系统提供统一的接口。</li>\n<li>“内置电池”的能力：提供流行的应用层协议实现，因此Twisted马上就可为开发人员所用。</li>\n<li>符合RFC规范，已经通过健壮的测试套件证明了其一致性。</li>\n<li>能很容易的配合多个网络协议一起使用。</li>\n<li>可扩展。</li>\n</ul>\n<h3 id=\"Twisted架构概览\"><a href=\"#Twisted架构概览\" class=\"headerlink\" title=\"Twisted架构概览\"></a>Twisted架构概览</h3><p>Twisted是一个事件驱动型的网络引擎。由于事件驱动编程模型在Twisted的设计哲学中占有重要的地位，因此这里有必要花点时间来回顾一下究竟事件驱动意味着什么。</p>\n<p>事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。</p>\n<p>在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。</p>\n<p>在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。</p>\n<p>在事件驱动版本的程序中，3个任务<strong>交错执行</strong>，但仍然在一个单独的线程控制中。当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。</p>\n<p>当我们面对如下的环境时，事件驱动模型通常是一个好的选择：</p>\n<p>程序中有许多任务，而且…</p>\n<ol>\n<li>任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…</li>\n<li>在等待事件到来时，某些任务会阻塞。</li>\n<li>当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。</li>\n</ol>\n<p>网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。</p>\n<h6 id=\"重用已有的应用\"><a href=\"#重用已有的应用\" class=\"headerlink\" title=\"重用已有的应用\"></a><strong>重用已有的应用</strong></h6><p>在Twisted创建之前就已经有了许多针对多种流行的网络协议的客户端和服务器实现了。为什么Glyph不直接用Apache、IRCd、BIND、OpenSSH或者任何其他已有的应用，而要为Twisted从头开始重新实现各个协议的客户端和服务器呢？</p>\n<p>问题在于所有这些已有的实现都存在有从头写起的网络层代码，通常都是C代码。而应用层代码直接同网络层耦合在一起，这使得它们非常难以以库的形式来复用。当要一起使用这些组件时，如果希望在多个协议中暴露相同的数据，则它们必须以黑盒的形式来看待，这使得开发者根本没机会重用代码。此外，服务器和客户端的实现通常是分离的，彼此之间不共享代码。要扩展这些应用，维护跨平台的客户端-服务器兼容性的难度本不至于这么大。</p>\n<p>Twisted中的客户端和服务器是用Python开发的，采用了一致性的接口。这使得开发新的客户端和服务器变得很容易实现，可以在客户端和服务器之间共享代码，在协议之间共享应用逻辑，以及对某个实现的代码做测试。</p>\n<h6 id=\"React模式\"><a href=\"#React模式\" class=\"headerlink\" title=\"React模式\"></a><strong>React模式</strong></h6><p>Twisted实现了设计模式中的反应堆（reactor）模式，这种模式在单线程环境中调度多个事件源产生的事件到它们各自的事件处理例程中去。</p>\n<p>Twisted的核心就是reactor事件循环。Reactor可以感知网络、文件系统以及定时器事件。它等待然后处理这些事件，从特定于平台的行为中抽象出来，并提供统一的接口，使得在网络协议栈的任何位置对事件做出响应都变得简单。</p>\n<p>基本上reactor完成的任务就是：</p>\n<pre><code class=\"python\">while True:\n    timeout = time_until_next_timed_event()\n    events = wait_for_events(timeout)\n    events += timed_events_until(now())\n    for event in events:\n        event.process()</code></pre>\n<p>Twisted目前在所有平台上的默认reactor都是基于poll API的（UNIX规范第3版（SUSv3）中描述）。此外，Twisted还支持一些特定于平台的高容量多路复用API。这些reactor包括基于FreeBSD中kqueue机制的KQueue reactor，支持epoll接口的系统（目前是Linux 2.6）中的epoll reactor，以及基于Windows下的输入输出完成端口的IOCP reactor。</p>\n<p>在实现轮询的相关细节中，Twisted需要考虑的包括：</p>\n<ul>\n<li>网络和文件系统的限制</li>\n<li>缓冲行为</li>\n<li>如何检测连接丢失</li>\n<li>出现错误时的返回值</li>\n</ul>\n<p>Twisted的reactor实现同时也考虑了正确使用底层的非阻塞式API，并正确处理各种边界情况。由于Python中没有暴露出IOCP API，因此Twisted需要维护自己的实现。</p>\n<h6 id=\"管理回调链\"><a href=\"#管理回调链\" class=\"headerlink\" title=\"管理回调链\"></a><strong>管理回调链</strong></h6><p>回调是事件驱动编程模型中的基础，也是reactor通知应用程序事件已经处理完成的方式。随着程序规模不断扩大，基于事件驱动的程序需要同时处理事件处理成功和出错的情况，这使得程序变得越来越复杂。若没有注册一个合适的回调，程序就会阻塞，因为这个事件处理的过程绝不会发生。出现错误时需要通过应用程序的不同层次从网络栈向上传递回调链。</p>\n<p>下面是两段Python伪码，分别是同步和异步模式下获取URL的玩具代码。让我们相互比较一下这两个版本，看看基于事件驱动的程序有什么缺陷：</p>\n<p>以同步的方式获取URL：</p>\n<pre><code class=\"python\">import getPage\n\ndef processPage(page):\n    print page\n\ndef logError(error):\n    print error\n\ndef finishProcessing(value):\n    print &quot;Shutting down...&quot;\n    exit(0)\n\nurl = &quot;http://google.com&quot;\ntry:\n    page = getPage(url)\n    processPage(page)\nexcept Error, e:\n    logError(error)\nfinally:\n    finishProcessing()</code></pre>\n<p>以异步的方式获取URL：</p>\n<pre><code class=\"python\">from twisted.internet import reactor\nimport getPage\n\ndef processPage(page):\n    print page\n    finishProcessing()\n\ndef logError(error):\n    print error\n    finishProcessing()\n\ndef finishProcessing(value):\n    print &quot;Shutting down...&quot;\n    reactor.stop()\n\nurl = &quot;http://google.com&quot;\n# getPage takes: url, \n# success callback, error callback\ngetPage(url, processPage, logError)\n\nreactor.run()</code></pre>\n<p>在异步版的URL获取器中，reactor.run()启动reactor事件循环。在同步和异步版程序中，我们假定getPage函数处理获取页面的工作。如果获取成功就调用processPage，如果尝试获取页面时出现了Exception（异常），logError就得到调用。无论哪种情况，最后都要调用finishProcessing。</p>\n<p>异步版中的logError回调正对应于同步版中的try/except块。对processPage的回调对应于else块，无条件回调的finishProcessing就对应于finally块。</p>\n<p>在同步版中，代码结构直接显示出有一个try/except块，logError和processPage这两者间只会取其一调用一次，而finishProcessing总是会被调用一次。在异步版中需要由程序员自己负责正确调用成功和失败情况下的回调链。如果由于编程错误，在processPage或者logError的回调链之后没有调用finishProcessing，reactor事件循环将永远不会停止，程序就会卡住。</p>\n<p>这个玩具式的例子告诉我们在开发Twisted的头几年里这种复杂性令程序员感到非常沮丧。而Twisted应对这种复杂性的方式是新增一个称为Deferred（延迟）的对象。</p>\n<h6 id=\"Deferreds\"><a href=\"#Deferreds\" class=\"headerlink\" title=\"Deferreds\"></a>Deferreds</h6><p>Deferred对象以抽象化的方式表达了一种思想，即结果还尚不存在。它同样能够帮助管理产生这个结果所需要的回调链。当从函数中返回时，Deferred对象承诺在某个时刻函数将产生一个结果。返回的Deferred对象中包含所有注册到事件上的回调引用，因此在函数间只需要传递这一个对象即可，跟踪这个对象比单独管理所有的回调要简单的多。</p>\n<p>Deferred对象包含一对回调链，一个是针对操作成功的回调，一个是针对操作失败的回调。初始状态下Deferred对象的两条链都为空。在事件处理的过程中，每个阶段都为其添加处理成功的回调和处理失败的回调。当一个异步结果到来时，Deferred对象就被“激活”，那么处理成功的回调和处理失败的回调就可以以合适的方式按照它们添加进来的顺序依次得到调用。</p>\n<p>异步版URL获取器采用Deferred对象后的代码如下：</p>\n<pre><code class=\"python\">from twisted.internet import reactor\nimport getPage\n\ndef processPage(page):\n    print page\n\ndef logError(error):\n    print error\n\ndef finishProcessing(value):\n    print &quot;Shutting down...&quot;\n    reactor.stop()\n\nurl = &quot;http://google.com&quot;\ndeferred = getPage(url) # getPage returns a Deferred\ndeferred.addCallbacks(success, failure)\ndeferred.addBoth(stop)\n\nreactor.run()</code></pre>\n<p>在这个版本中调用的事件处理函数与之前相同，但它们都注册到了一个单独的Deferred对象上，而不是分散在代码各处再以参数形式传递给getPage。</p>\n<p>Deferred对象创建时包含两个添加回调的阶段。第一阶段，addCallbacks将 processPage和logError添加到它们各自归属的回调链中。然后addBoth再将finishProcessing同时添加到这两个回调链上。用图解的方式来看，回调链应该如图所示：<br><img src=\"/img/1570783134086.png\" alt=\"Deferred 流程示例\"></p>\n<p>Deferred对象只能被激活一次，如果试图重复激活将引发一个异常。这使得Deferred对象的语义相当接近于同步版中的try/except块。从而让异步事件的处理能更容易推断，避免由于针对单个事件的回调调用多了一个或少了一个而产生微妙的bug。</p>\n<p>理解Deferred对象对于理解Twisted程序的执行流是非常重要的。然而当使用Twisted为我们提供的针对网络协议的高层抽象时，通常情况下我们完全不需要直接使用Deferred对象。</p>\n<p>Deferred对象所包含的抽象概念是非常强大的，这种思想已经被许多其他的事件驱动平台所借用，包括jQuery、Dojo和Mochikit。</p>\n<h6 id=\"Transports\"><a href=\"#Transports\" class=\"headerlink\" title=\"Transports\"></a>Transports</h6><p>Transports代表网络中两个通信结点之间的连接。Transports负责描述连接的细节，比如连接是面向流式的还是面向数据报的，流控以及可靠性。TCP、UDP和Unix套接字可作为transports的例子。它们被设计为“满足最小功能单元，同时具有最大程度的可复用性”，而且从协议实现中分离出来，这让许多协议可以采用相同类型的传输。Transports实现了ITransports接口，它包含如下的方法：</p>\n<blockquote>\n<p>write                   以非阻塞的方式按顺序依次将数据写到物理连接上<br>writeSequence           将一个字符串列表写到物理连接上<br>loseConnection          将所有挂起的数据写入，然后关闭连接<br>getPeer                 取得连接中对端的地址信息<br>getHost                 取得连接中本端的地址信息</p>\n</blockquote>\n<p>将transports从协议中分离出来也使得对这两个层次的测试变得更加简单。可以通过简单地写入一个字符串来模拟传输，用这种方式来检查。</p>\n<h6 id=\"Protocols\"><a href=\"#Protocols\" class=\"headerlink\" title=\"Protocols\"></a>Protocols</h6><p>Protocols描述了如何以异步的方式处理网络中的事件。HTTP、DNS以及IMAP是应用层协议中的例子。Protocols实现了IProtocol接口，它包含如下的方法：</p>\n<blockquote>\n<p>makeConnection               在transport对象和服务器之间建立一条连接<br>connectionMade               连接建立起来后调用<br>dataReceived                 接收数据时调用<br>connectionLost               关闭连接时调用</p>\n</blockquote>\n<p>我们最好以一个例子来说明reactor、protocols以及transports这三者之间的关系。以下是完整的echo服务器和客户端的实现，首先来看看服务器部分：</p>\n<pre><code class=\"python\">from twisted.internet import protocol, reactor\n\nclass Echo(protocol.Protocol):\n    def dataReceived(self, data):\n        # As soon as any data is received, write it back\n        self.transport.write(data)\n\nclass EchoFactory(protocol.Factory):\n    def buildProtocol(self, addr):\n        return Echo()\n\nreactor.listenTCP(8000, EchoFactory())\nreactor.run()</code></pre>\n<p>接着是客户端部分：</p>\n<pre><code class=\"python\">from twisted.internet import reactor, protocol\n\nclass EchoClient(protocol.Protocol):\n    def connectionMade(self):\n        self.transport.write(&quot;hello, world!&quot;)\n\ndef dataReceived(self, data):\n    print &quot;Server said:&quot;, data\n        self.transport.loseConnection()\n\ndef connectionLost(self, reason):\n    print &quot;connection lost&quot;\n\nclass EchoFactory(protocol.ClientFactory):\n    def buildProtocol(self, addr):\n        return EchoClient()\n\ndef clientConnectionFailed(self, connector, reason):\n    print &quot;Connection failed - goodbye!&quot;\n        reactor.stop()\n\ndef clientConnectionLost(self, connector, reason):\n    print &quot;Connection lost - goodbye!&quot;\n        reactor.stop()\n\nreactor.connectTCP(&quot;localhost&quot;, 8000, EchoFactory())\nreactor.run()</code></pre>\n<p>运行服务器端脚本将启动一个TCP服务器，监听端口8000上的连接。服务器采用的是Echo协议，数据经TCP transport对象写出。运行客户端脚本将对服务器发起一个TCP连接，回显服务器端的回应然后终止连接并停止reactor事件循环。这里的Factory用来对连接的双方生成protocol对象实例。两端的通信是异步的，connectTCP负责注册回调函数到reactor事件循环中，当socket上有数据可读时通知回调处理。</p>\n<h6 id=\"Applications\"><a href=\"#Applications\" class=\"headerlink\" title=\"Applications\"></a>Applications</h6><p>Twisted是用来创建具有可扩展性、跨平台的网络服务器和客户端的引擎。在生产环境中，以标准化的方式简化部署这些应用的过程对于Twisted这种被广泛采用的平台来说是非常重要的一环。为此，Twisted开发了一套应用程序基础组件，采用可重用、可配置的方式来部署Twisted应用。这种方式使程序员避免堆砌千篇一律的代码来将应用程序同已有的工具整合在一起，这包括精灵化进程（daemonization）、日志处理、使用自定义的reactor循环、对代码做性能剖析等。</p>\n<p>应用程序基础组件包含4个主要部分：服务（Service）、应用（Application）、配置管理（通过TAC文件和插件）以及twistd命令行程序。为了说明这个基础组件，我们将上一节的Echo服务器转变成一个应用。</p>\n<ul>\n<li><strong>Service</strong><br>Service就是IService接口下实现的可以启动和停止的组件。Twisted自带有TCP、FTP、HTTP、SSH、DNS等服务以及其他协议的实现。其中许多Service都可以注册到单独的应用中。IService接口的核心是：<blockquote>\n<p>startService    启动服务。可能包含加载配置数据，设定数据库连接或者监听某个端口<br>stopService     关闭服务。可能包含将状态保存到磁盘，关闭数据库连接或者停止监听端口</p>\n</blockquote>\n</li>\n</ul>\n<p>我们的Echo服务使用TCP协议，因此我们可以使用Twisted中IService接口下默认的TCPServer实现。</p>\n<ul>\n<li><strong>Application</strong><br>Application是处于最顶层的Service，代表了整个Twisted应用程序。Service需要将其自身同Application注册，然后就可以用下面我们将介绍的部署工具twistd搜索并运行应用程序。我们将创建一个可以同Echo Service注册的Echo应用。</li>\n<li><strong>TAC文件</strong><br>当在一个普通的Python文件中管理Twisted应用程序时，需要由开发者负责编写启动和停止reactor事件循环以及配置应用程序的代码。在Twisted的基础组件中，协议的实现都是在一个模块中完成的，需要使用到这些协议的Service可以注册到一个Twisted应用程序配置文件中（TAC文件）去，这样reactor事件循环和程序配置就可以由外部组件来进行管理。</li>\n</ul>\n<p>要将我们的Echo服务器转变成一个Echo应用，我们可以按照以下几个简单的步骤来完成：</p>\n<ol>\n<li><p>将Echo服务器的Protocol部分移到它们自己所归属的模块中去。</p>\n</li>\n<li><p>在TAC文件中：</p>\n<ol>\n<li>创建一个Echo应用。</li>\n<li>创建一个TCPServer的Service实例，它将使用我们的EchoFactory，然后同前面创建的应用完成注册。</li>\n</ol>\n</li>\n</ol>\n<p>管理reactor事件循环的代码将由twistd来负责，我们下面会对此进行讨论。这样，应用程序的代码就变成这样了：<br>echo.py文件：</p>\n<pre><code class=\"python\">from twisted.internet import protocol, reactor\n\nclass Echo(protocol.Protocol):\n    def dataReceived(self, data):\n        self.transport.write(data)\n\nclass EchoFactory(protocol.Factory):\n    def buildProtocol(self, addr):\n        return Echo()</code></pre>\n<ul>\n<li><strong>twistd</strong><br>twistd（读作“twist-dee”）是一个跨平台的用来部署Twisted应用程序的工具。它执行TAC文件并负责处理启动和停止应用程序。作为Twisted在网络编程中具有“内置电池”能力的一部分，twistd自带有一些非常有用的配置标志，包括将应用程序转变为守护进程、定义日志文件的路径、设定特权级别、在chroot下运行、使用非默认的reactor，甚至是在profiler下运行应用程序。</li>\n</ul>\n<p>我们可以像这样运行这个Echo服务应用：</p>\n<pre><code class=\"python\">$ twistd –y echo_server.tac</code></pre>\n<p>在这个简单的例子里，twistd将这个应用程序作为守护进程来启动，日志记录在twistd.log文件中。启动和停止应用后，日志文件内容如下：</p>\n<pre><code class=\"python\">2011-11-19 22:23:07-0500 [-] Log opened.\n2011-11-19 22:23:07-0500 [-] twistd 11.0.0 (/usr/bin/python 2.7.1) starting up.\n2011-11-19 22:23:07-0500 [-] reactor class: twisted.internet.selectreactor.SelectReactor.\n2011-11-19 22:23:07-0500 [-] echo.EchoFactory starting on 8000\n2011-11-19 22:23:07-0500 [-] Starting factory &lt;echo.EchoFactory instance at 0x12d8670&gt;\n2011-11-19 22:23:20-0500 [-] Received SIGTERM, shutting down.\n2011-11-19 22:23:20-0500 [-] (TCP Port 8000 Closed)\n2011-11-19 22:23:20-0500 [-] Stopping factory &lt;echo.EchoFactory instance at 0x12d8670&gt;\n2011-11-19 22:23:20-0500 [-] Main loop terminated.\n2011-11-19 22:23:20-0500 [-] Server Shut Down.</code></pre>\n<p>通过使用Twisted框架中的基础组件来运行服务，这么做使得开发人员能够不用再编写类似守护进程和记录日志这样的冗余代码了。这同样也为部署应用程序建立了一个标准的命令行接口。</p>\n<h6 id=\"Plugins\"><a href=\"#Plugins\" class=\"headerlink\" title=\"Plugins\"></a>Plugins</h6><p>对于运行Twisted应用程序的方法，除了基于TAC文件外还有一种可选的方法，这就是插件系统。TAC系统可以很方便的将Twisted预定义的服务同应用程序配置文件注册，而插件系统能够方便的将用户自定义的服务注册为twistd工具的子命令，然后扩展应用程序的命令行接口。</p>\n<p>在使用插件系统时：</p>\n<ol>\n<li><p>由于只有plugin API需要保持稳定，这使得第三方开发者能很容易地扩展软件。</p>\n</li>\n<li><p>插件发现能力已经集成到系统中了。插件可以在程序首次运行时加载并保存，每次程序启动时会重新触发插件发现过程，或者也可以在程序运行期间反复轮询新插件，这使得在程序已经启动后我们还可以判断是否有新的插件安装上了。</p>\n</li>\n</ol>\n<p>当使用Twisted插件系统来扩展软件时，我们要做的就是创建IPlugin接口下实现的对象并将它们放到一个特定的位置中，这里插件系统知道该如何去找到它们。</p>\n<p>我们已经将Echo服务转换为一个Twisted应用程序了，而将其转换为一个Twisted插件也是非常简单直接的。在我们之前的Echo模块中，除了包含有Echo协议和EchoFactory的定义之外，现在我们还要添加一个名为twistd的目录，其中还包含着一个名为plugins的子目录，这里正是我们需要定义echo插件的地方。通过这个插件，我们可以启动一个echo服务，并将需要使用的端口号作为参数指定给twistd工具。</p>\n<pre><code class=\"python\">from zope.interface import implements\n\nfrom twisted.python import usage\nfrom twisted.plugin import IPlugin\nfrom twisted.application.service import IServiceMaker\nfrom twisted.application import internet\n\nfrom echo import EchoFactory\n\nclass Options(usage.Options):\n    optParameters = [[&quot;port&quot;, &quot;p&quot;, 8000, &quot;The port number to listen on.&quot;]]\n\nclass EchoServiceMaker(object):\n    implements(IServiceMaker, IPlugin)\n    tapname = &quot;echo&quot;\n    description = &quot;A TCP-based echo server.&quot;\n    options = Options\n\ndef makeService(self, options):\n    &quot;&quot;&quot;\n    Construct a TCPServer from a factory defined in myproject.\n    &quot;&quot;&quot;\n    return internet.TCPServer(int(options[&quot;port&quot;]), EchoFactory())\n\nserviceMaker = EchoServiceMaker()</code></pre>\n<p>现在，我们的Echo服务器将作为一个服务选项出现在twistd –help的输出中。运行twistd echo –port=1235将在端口1235上启动一个Echo服务器。</p>\n<p>Twisted还带有一个可拔插的针对服务器端认证的模块twisted.cred，插件系统常见的用途就是为应用程序添加一个认证模式。我们可以使用twisted.cred中现成的AuthOptionMixin类来添加针对各种认证的命令行支持，或者是添加新的认证类型。比如，我们可以使用插件系统来添加基于本地Unix密码数据库或者是基于LDAP服务器的认证方式。</p>\n<p>twistd工具中附带有许多Twisted所支持的协议插件，只用一条单独的命令就可以完成启动服务器的工作了。这里有一些通过twistd启动服务器的例子：</p>\n<pre><code class=\"python\">twistd web –port 8080 –path .</code></pre>\n<p>这条命令将在8080端口启动一个HTTP服务器，在当前目录中负责处理静态和动态页面请求。</p>\n<pre><code class=\"python\">twistd dns –p 5553 –hosts-file=hosts</code></pre>\n<p>这条命令在端口5553上启动一个DNS服务器，解析指定的文件hosts中的域名，这个文件的内容格式同/etc/hosts一样。</p>\n<pre><code class=\"python\">sudo twistd conch –p tcp:2222</code></pre>\n<p>这条命令在端口2222上启动一个SSH服务器。ssh的密钥必须独立设定。</p>\n<pre><code class=\"python\">twistd mail –E –H localhost –d localhost=emails</code></pre>\n<p>这条命令启动一个ESMTP POP3服务器，为本地主机接收邮件并保存到指定的emails目录下。</p>\n<p>我们可以方便的通过twistd来搭建一个用于测试客户端功能的服务器，但它同样是可装载的、产品级的服务器实现。</p>\n<p>在部署应用程序的方式上，Twisted通过TAC文件、插件以及命令行工具twistd的部署方式已经获得了成功。但是有趣的是，对于大多数大型Twisted应用程序来说，部署它们仍然需要重写一些这类管理和监控组件；Twisted的架构并没有对系统管理员的需求呈现出太多的友好性。这也反映了一个事实，那就是对于系统管理员来说Twisted历来就没有太多架构可言，而这些系统管理员才是部署和维护应用程序的专家。在这方面，Twisted在未来架构设计的决策上需要更积极的征求这类专家级用户的反馈意见。</p>\n<p><a href=\"https://www.cnblogs.com/xianguang/p/7027661.html\">本文内容引用自此处</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Twisted\"><a href=\"#Twisted\" class=\"headerlink\" title=\"Twisted\"></a>Twisted</h2><h3 id=\"Python-Twisted介绍\"><a href=\"#Python-Twisted介绍\" class=\"headerlink\" title=\"Python Twisted介绍\"></a>Python Twisted介绍</h3><p>Twisted是用Python实现的基于事件驱动的网络引擎框架。Twisted诞生于2000年初，在当时的网络游戏开发者看来，无论他们使用哪种语言，手中都鲜有可兼顾扩展性及跨平台的网络库。Twisted的作者试图在当时现有的环境下开发游戏，这一步走的非常艰难，他们迫切地需要一个可扩展性高、基于事件驱动、跨平台的网络开发框架，为此他们决定自己实现一个，并从那些之前的游戏和网络应用程序的开发者中学习，汲取他们的经验教训。</p>\n<p>Twisted支持许多常见的传输及应用层协议，包括TCP、UDP、SSL/TLS、HTTP、IMAP、SSH、IRC以及FTP。就像python一样，Twisted也具有“内置电池”（batteries-included）的特点。Twisted对于其支持的所有协议都带有客户端和服务器实现，同时附带有基于命令行的工具，使得配置和部署产品级的Twisted应用变得非常方便。</p>\n<h3 id=\"为什么需要Twisted\"><a href=\"#为什么需要Twisted\" class=\"headerlink\" title=\"为什么需要Twisted\"></a>为什么需要Twisted</h3><p>2000年时，Twisted的作者Glyph正在开发一个名为Twisted Reality的基于文本方式的多人在线游戏。这个游戏采用Java开发，里面尽是一堆线程——每个连接就有3个线程处理。处理输入的线程会在读操作上阻塞，处理输出的线程将在一些写操作上阻塞，还有一个“逻辑”线程将在等待定时器超时或者事件入队列时休眠。随着玩家们在虚拟世界中移动并交互时，线程出现死锁，缓存被污染，程序中的加锁逻辑几乎从来就没对过——采用多线程使得整个软件变得复杂、漏洞百出而且极难扩展。</p>\n<p>为了寻求其他的解决方案，作者发现了Python，特别是Python中用于对流式对象比如socket和pipe进行多路I/O复用的select模块（UNIX规范第3版（SUSv3）描述了select）。那时，Java并没有提供操作系统的select接口或者任何其他的异步I/O API（针对非阻塞式I/O的包java.nio已经在J2SE 1.4中加入了，2002年发布）。通过用Python中的select模块快速搭建起游戏的原型，这迅速降低了程序的复杂度，并且比多线程版本要更加可靠。</p>\n<p>Glyph迅速转向了Python、select以及基于事件驱动的编程。他使用Python的select模块为游戏编写了客户端和服务器。但他想要的还不止于此。从根本上说，他希望能将网络行为转变为对游戏中的对象的方法调用。如果你能在游戏中收取邮件会怎样，就像Nethack mailer这种守护进程一样？如果游戏中的每位玩家都拥有一个主页呢？Glyph发现他需要优秀的IMAP以及HTTP客户端和服务器的Python实现，而这些都要采用select。</p>\n<p>他首先转向了Medusa，这是一个在90年代中期开发的平台，在这里可以采用Python中的asyncore模块来编写网络服务。asyncore是一个异步化处理socket的模块，在操作系统的select API之上构建了一个调度器和回调接口。</p>\n<p>这对于Glyph来说是个激动人心的发现，但Medusa有两个缺点：</p>\n<ol>\n<li>这个项目到2001年就不再维护了，那正是glyph开发Twisted Reality的时候。</li>\n<li>asyncore只是对socket的一个薄封装层，应用程序的编写者仍然需要直接操作socket。这意味着程序可移植性的担子仍然落在程序员自己身上。此外，那时asyncore对Windows的支持还有问题，Glyph希望能在Windows上运行一个带有图形用户界面的客户端。<br>Glyph需要自己实现一个网络引擎平台，而且他意识到Twisted Reality已经打开了问题的大门，这和他的游戏一样有趣。</li>\n</ol>\n<p>随着时间的推移，Twisted Reality这个游戏就演化成了Twisted网络引擎平台。它可以做到当时Python中已有的网络平台所无法做到的事情：</p>\n<ul>\n<li>使用基于事件驱动的编程模型，而不是多线程模型。</li>\n<li>跨平台：为主流操作系统平台暴露出的事件通知系统提供统一的接口。</li>\n<li>“内置电池”的能力：提供流行的应用层协议实现，因此Twisted马上就可为开发人员所用。</li>\n<li>符合RFC规范，已经通过健壮的测试套件证明了其一致性。</li>\n<li>能很容易的配合多个网络协议一起使用。</li>\n<li>可扩展。</li>\n</ul>\n<h3 id=\"Twisted架构概览\"><a href=\"#Twisted架构概览\" class=\"headerlink\" title=\"Twisted架构概览\"></a>Twisted架构概览</h3><p>Twisted是一个事件驱动型的网络引擎。由于事件驱动编程模型在Twisted的设计哲学中占有重要的地位，因此这里有必要花点时间来回顾一下究竟事件驱动意味着什么。</p>\n<p>事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。</p>\n<p>在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。</p>\n<p>在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。</p>\n<p>在事件驱动版本的程序中，3个任务<strong>交错执行</strong>，但仍然在一个单独的线程控制中。当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。</p>\n<p>当我们面对如下的环境时，事件驱动模型通常是一个好的选择：</p>\n<p>程序中有许多任务，而且…</p>\n<ol>\n<li>任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…</li>\n<li>在等待事件到来时，某些任务会阻塞。</li>\n<li>当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。</li>\n</ol>\n<p>网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。</p>\n<h6 id=\"重用已有的应用\"><a href=\"#重用已有的应用\" class=\"headerlink\" title=\"重用已有的应用\"></a><strong>重用已有的应用</strong></h6><p>在Twisted创建之前就已经有了许多针对多种流行的网络协议的客户端和服务器实现了。为什么Glyph不直接用Apache、IRCd、BIND、OpenSSH或者任何其他已有的应用，而要为Twisted从头开始重新实现各个协议的客户端和服务器呢？</p>\n<p>问题在于所有这些已有的实现都存在有从头写起的网络层代码，通常都是C代码。而应用层代码直接同网络层耦合在一起，这使得它们非常难以以库的形式来复用。当要一起使用这些组件时，如果希望在多个协议中暴露相同的数据，则它们必须以黑盒的形式来看待，这使得开发者根本没机会重用代码。此外，服务器和客户端的实现通常是分离的，彼此之间不共享代码。要扩展这些应用，维护跨平台的客户端-服务器兼容性的难度本不至于这么大。</p>\n<p>Twisted中的客户端和服务器是用Python开发的，采用了一致性的接口。这使得开发新的客户端和服务器变得很容易实现，可以在客户端和服务器之间共享代码，在协议之间共享应用逻辑，以及对某个实现的代码做测试。</p>\n<h6 id=\"React模式\"><a href=\"#React模式\" class=\"headerlink\" title=\"React模式\"></a><strong>React模式</strong></h6><p>Twisted实现了设计模式中的反应堆（reactor）模式，这种模式在单线程环境中调度多个事件源产生的事件到它们各自的事件处理例程中去。</p>\n<p>Twisted的核心就是reactor事件循环。Reactor可以感知网络、文件系统以及定时器事件。它等待然后处理这些事件，从特定于平台的行为中抽象出来，并提供统一的接口，使得在网络协议栈的任何位置对事件做出响应都变得简单。</p>\n<p>基本上reactor完成的任务就是：</p>\n<pre><code class=\"python\">while True:\n    timeout = time_until_next_timed_event()\n    events = wait_for_events(timeout)\n    events += timed_events_until(now())\n    for event in events:\n        event.process()</code></pre>\n<p>Twisted目前在所有平台上的默认reactor都是基于poll API的（UNIX规范第3版（SUSv3）中描述）。此外，Twisted还支持一些特定于平台的高容量多路复用API。这些reactor包括基于FreeBSD中kqueue机制的KQueue reactor，支持epoll接口的系统（目前是Linux 2.6）中的epoll reactor，以及基于Windows下的输入输出完成端口的IOCP reactor。</p>\n<p>在实现轮询的相关细节中，Twisted需要考虑的包括：</p>\n<ul>\n<li>网络和文件系统的限制</li>\n<li>缓冲行为</li>\n<li>如何检测连接丢失</li>\n<li>出现错误时的返回值</li>\n</ul>\n<p>Twisted的reactor实现同时也考虑了正确使用底层的非阻塞式API，并正确处理各种边界情况。由于Python中没有暴露出IOCP API，因此Twisted需要维护自己的实现。</p>\n<h6 id=\"管理回调链\"><a href=\"#管理回调链\" class=\"headerlink\" title=\"管理回调链\"></a><strong>管理回调链</strong></h6><p>回调是事件驱动编程模型中的基础，也是reactor通知应用程序事件已经处理完成的方式。随着程序规模不断扩大，基于事件驱动的程序需要同时处理事件处理成功和出错的情况，这使得程序变得越来越复杂。若没有注册一个合适的回调，程序就会阻塞，因为这个事件处理的过程绝不会发生。出现错误时需要通过应用程序的不同层次从网络栈向上传递回调链。</p>\n<p>下面是两段Python伪码，分别是同步和异步模式下获取URL的玩具代码。让我们相互比较一下这两个版本，看看基于事件驱动的程序有什么缺陷：</p>\n<p>以同步的方式获取URL：</p>\n<pre><code class=\"python\">import getPage\n\ndef processPage(page):\n    print page\n\ndef logError(error):\n    print error\n\ndef finishProcessing(value):\n    print &quot;Shutting down...&quot;\n    exit(0)\n\nurl = &quot;http://google.com&quot;\ntry:\n    page = getPage(url)\n    processPage(page)\nexcept Error, e:\n    logError(error)\nfinally:\n    finishProcessing()</code></pre>\n<p>以异步的方式获取URL：</p>\n<pre><code class=\"python\">from twisted.internet import reactor\nimport getPage\n\ndef processPage(page):\n    print page\n    finishProcessing()\n\ndef logError(error):\n    print error\n    finishProcessing()\n\ndef finishProcessing(value):\n    print &quot;Shutting down...&quot;\n    reactor.stop()\n\nurl = &quot;http://google.com&quot;\n# getPage takes: url, \n# success callback, error callback\ngetPage(url, processPage, logError)\n\nreactor.run()</code></pre>\n<p>在异步版的URL获取器中，reactor.run()启动reactor事件循环。在同步和异步版程序中，我们假定getPage函数处理获取页面的工作。如果获取成功就调用processPage，如果尝试获取页面时出现了Exception（异常），logError就得到调用。无论哪种情况，最后都要调用finishProcessing。</p>\n<p>异步版中的logError回调正对应于同步版中的try/except块。对processPage的回调对应于else块，无条件回调的finishProcessing就对应于finally块。</p>\n<p>在同步版中，代码结构直接显示出有一个try/except块，logError和processPage这两者间只会取其一调用一次，而finishProcessing总是会被调用一次。在异步版中需要由程序员自己负责正确调用成功和失败情况下的回调链。如果由于编程错误，在processPage或者logError的回调链之后没有调用finishProcessing，reactor事件循环将永远不会停止，程序就会卡住。</p>\n<p>这个玩具式的例子告诉我们在开发Twisted的头几年里这种复杂性令程序员感到非常沮丧。而Twisted应对这种复杂性的方式是新增一个称为Deferred（延迟）的对象。</p>\n<h6 id=\"Deferreds\"><a href=\"#Deferreds\" class=\"headerlink\" title=\"Deferreds\"></a>Deferreds</h6><p>Deferred对象以抽象化的方式表达了一种思想，即结果还尚不存在。它同样能够帮助管理产生这个结果所需要的回调链。当从函数中返回时，Deferred对象承诺在某个时刻函数将产生一个结果。返回的Deferred对象中包含所有注册到事件上的回调引用，因此在函数间只需要传递这一个对象即可，跟踪这个对象比单独管理所有的回调要简单的多。</p>\n<p>Deferred对象包含一对回调链，一个是针对操作成功的回调，一个是针对操作失败的回调。初始状态下Deferred对象的两条链都为空。在事件处理的过程中，每个阶段都为其添加处理成功的回调和处理失败的回调。当一个异步结果到来时，Deferred对象就被“激活”，那么处理成功的回调和处理失败的回调就可以以合适的方式按照它们添加进来的顺序依次得到调用。</p>\n<p>异步版URL获取器采用Deferred对象后的代码如下：</p>\n<pre><code class=\"python\">from twisted.internet import reactor\nimport getPage\n\ndef processPage(page):\n    print page\n\ndef logError(error):\n    print error\n\ndef finishProcessing(value):\n    print &quot;Shutting down...&quot;\n    reactor.stop()\n\nurl = &quot;http://google.com&quot;\ndeferred = getPage(url) # getPage returns a Deferred\ndeferred.addCallbacks(success, failure)\ndeferred.addBoth(stop)\n\nreactor.run()</code></pre>\n<p>在这个版本中调用的事件处理函数与之前相同，但它们都注册到了一个单独的Deferred对象上，而不是分散在代码各处再以参数形式传递给getPage。</p>\n<p>Deferred对象创建时包含两个添加回调的阶段。第一阶段，addCallbacks将 processPage和logError添加到它们各自归属的回调链中。然后addBoth再将finishProcessing同时添加到这两个回调链上。用图解的方式来看，回调链应该如图所示：<br><img src=\"/img/1570783134086.png\" alt=\"Deferred 流程示例\"></p>\n<p>Deferred对象只能被激活一次，如果试图重复激活将引发一个异常。这使得Deferred对象的语义相当接近于同步版中的try/except块。从而让异步事件的处理能更容易推断，避免由于针对单个事件的回调调用多了一个或少了一个而产生微妙的bug。</p>\n<p>理解Deferred对象对于理解Twisted程序的执行流是非常重要的。然而当使用Twisted为我们提供的针对网络协议的高层抽象时，通常情况下我们完全不需要直接使用Deferred对象。</p>\n<p>Deferred对象所包含的抽象概念是非常强大的，这种思想已经被许多其他的事件驱动平台所借用，包括jQuery、Dojo和Mochikit。</p>\n<h6 id=\"Transports\"><a href=\"#Transports\" class=\"headerlink\" title=\"Transports\"></a>Transports</h6><p>Transports代表网络中两个通信结点之间的连接。Transports负责描述连接的细节，比如连接是面向流式的还是面向数据报的，流控以及可靠性。TCP、UDP和Unix套接字可作为transports的例子。它们被设计为“满足最小功能单元，同时具有最大程度的可复用性”，而且从协议实现中分离出来，这让许多协议可以采用相同类型的传输。Transports实现了ITransports接口，它包含如下的方法：</p>\n<blockquote>\n<p>write                   以非阻塞的方式按顺序依次将数据写到物理连接上<br>writeSequence           将一个字符串列表写到物理连接上<br>loseConnection          将所有挂起的数据写入，然后关闭连接<br>getPeer                 取得连接中对端的地址信息<br>getHost                 取得连接中本端的地址信息</p>\n</blockquote>\n<p>将transports从协议中分离出来也使得对这两个层次的测试变得更加简单。可以通过简单地写入一个字符串来模拟传输，用这种方式来检查。</p>\n<h6 id=\"Protocols\"><a href=\"#Protocols\" class=\"headerlink\" title=\"Protocols\"></a>Protocols</h6><p>Protocols描述了如何以异步的方式处理网络中的事件。HTTP、DNS以及IMAP是应用层协议中的例子。Protocols实现了IProtocol接口，它包含如下的方法：</p>\n<blockquote>\n<p>makeConnection               在transport对象和服务器之间建立一条连接<br>connectionMade               连接建立起来后调用<br>dataReceived                 接收数据时调用<br>connectionLost               关闭连接时调用</p>\n</blockquote>\n<p>我们最好以一个例子来说明reactor、protocols以及transports这三者之间的关系。以下是完整的echo服务器和客户端的实现，首先来看看服务器部分：</p>\n<pre><code class=\"python\">from twisted.internet import protocol, reactor\n\nclass Echo(protocol.Protocol):\n    def dataReceived(self, data):\n        # As soon as any data is received, write it back\n        self.transport.write(data)\n\nclass EchoFactory(protocol.Factory):\n    def buildProtocol(self, addr):\n        return Echo()\n\nreactor.listenTCP(8000, EchoFactory())\nreactor.run()</code></pre>\n<p>接着是客户端部分：</p>\n<pre><code class=\"python\">from twisted.internet import reactor, protocol\n\nclass EchoClient(protocol.Protocol):\n    def connectionMade(self):\n        self.transport.write(&quot;hello, world!&quot;)\n\ndef dataReceived(self, data):\n    print &quot;Server said:&quot;, data\n        self.transport.loseConnection()\n\ndef connectionLost(self, reason):\n    print &quot;connection lost&quot;\n\nclass EchoFactory(protocol.ClientFactory):\n    def buildProtocol(self, addr):\n        return EchoClient()\n\ndef clientConnectionFailed(self, connector, reason):\n    print &quot;Connection failed - goodbye!&quot;\n        reactor.stop()\n\ndef clientConnectionLost(self, connector, reason):\n    print &quot;Connection lost - goodbye!&quot;\n        reactor.stop()\n\nreactor.connectTCP(&quot;localhost&quot;, 8000, EchoFactory())\nreactor.run()</code></pre>\n<p>运行服务器端脚本将启动一个TCP服务器，监听端口8000上的连接。服务器采用的是Echo协议，数据经TCP transport对象写出。运行客户端脚本将对服务器发起一个TCP连接，回显服务器端的回应然后终止连接并停止reactor事件循环。这里的Factory用来对连接的双方生成protocol对象实例。两端的通信是异步的，connectTCP负责注册回调函数到reactor事件循环中，当socket上有数据可读时通知回调处理。</p>\n<h6 id=\"Applications\"><a href=\"#Applications\" class=\"headerlink\" title=\"Applications\"></a>Applications</h6><p>Twisted是用来创建具有可扩展性、跨平台的网络服务器和客户端的引擎。在生产环境中，以标准化的方式简化部署这些应用的过程对于Twisted这种被广泛采用的平台来说是非常重要的一环。为此，Twisted开发了一套应用程序基础组件，采用可重用、可配置的方式来部署Twisted应用。这种方式使程序员避免堆砌千篇一律的代码来将应用程序同已有的工具整合在一起，这包括精灵化进程（daemonization）、日志处理、使用自定义的reactor循环、对代码做性能剖析等。</p>\n<p>应用程序基础组件包含4个主要部分：服务（Service）、应用（Application）、配置管理（通过TAC文件和插件）以及twistd命令行程序。为了说明这个基础组件，我们将上一节的Echo服务器转变成一个应用。</p>\n<ul>\n<li><strong>Service</strong><br>Service就是IService接口下实现的可以启动和停止的组件。Twisted自带有TCP、FTP、HTTP、SSH、DNS等服务以及其他协议的实现。其中许多Service都可以注册到单独的应用中。IService接口的核心是：<blockquote>\n<p>startService    启动服务。可能包含加载配置数据，设定数据库连接或者监听某个端口<br>stopService     关闭服务。可能包含将状态保存到磁盘，关闭数据库连接或者停止监听端口</p>\n</blockquote>\n</li>\n</ul>\n<p>我们的Echo服务使用TCP协议，因此我们可以使用Twisted中IService接口下默认的TCPServer实现。</p>\n<ul>\n<li><strong>Application</strong><br>Application是处于最顶层的Service，代表了整个Twisted应用程序。Service需要将其自身同Application注册，然后就可以用下面我们将介绍的部署工具twistd搜索并运行应用程序。我们将创建一个可以同Echo Service注册的Echo应用。</li>\n<li><strong>TAC文件</strong><br>当在一个普通的Python文件中管理Twisted应用程序时，需要由开发者负责编写启动和停止reactor事件循环以及配置应用程序的代码。在Twisted的基础组件中，协议的实现都是在一个模块中完成的，需要使用到这些协议的Service可以注册到一个Twisted应用程序配置文件中（TAC文件）去，这样reactor事件循环和程序配置就可以由外部组件来进行管理。</li>\n</ul>\n<p>要将我们的Echo服务器转变成一个Echo应用，我们可以按照以下几个简单的步骤来完成：</p>\n<ol>\n<li><p>将Echo服务器的Protocol部分移到它们自己所归属的模块中去。</p>\n</li>\n<li><p>在TAC文件中：</p>\n<ol>\n<li>创建一个Echo应用。</li>\n<li>创建一个TCPServer的Service实例，它将使用我们的EchoFactory，然后同前面创建的应用完成注册。</li>\n</ol>\n</li>\n</ol>\n<p>管理reactor事件循环的代码将由twistd来负责，我们下面会对此进行讨论。这样，应用程序的代码就变成这样了：<br>echo.py文件：</p>\n<pre><code class=\"python\">from twisted.internet import protocol, reactor\n\nclass Echo(protocol.Protocol):\n    def dataReceived(self, data):\n        self.transport.write(data)\n\nclass EchoFactory(protocol.Factory):\n    def buildProtocol(self, addr):\n        return Echo()</code></pre>\n<ul>\n<li><strong>twistd</strong><br>twistd（读作“twist-dee”）是一个跨平台的用来部署Twisted应用程序的工具。它执行TAC文件并负责处理启动和停止应用程序。作为Twisted在网络编程中具有“内置电池”能力的一部分，twistd自带有一些非常有用的配置标志，包括将应用程序转变为守护进程、定义日志文件的路径、设定特权级别、在chroot下运行、使用非默认的reactor，甚至是在profiler下运行应用程序。</li>\n</ul>\n<p>我们可以像这样运行这个Echo服务应用：</p>\n<pre><code class=\"python\">$ twistd –y echo_server.tac</code></pre>\n<p>在这个简单的例子里，twistd将这个应用程序作为守护进程来启动，日志记录在twistd.log文件中。启动和停止应用后，日志文件内容如下：</p>\n<pre><code class=\"python\">2011-11-19 22:23:07-0500 [-] Log opened.\n2011-11-19 22:23:07-0500 [-] twistd 11.0.0 (/usr/bin/python 2.7.1) starting up.\n2011-11-19 22:23:07-0500 [-] reactor class: twisted.internet.selectreactor.SelectReactor.\n2011-11-19 22:23:07-0500 [-] echo.EchoFactory starting on 8000\n2011-11-19 22:23:07-0500 [-] Starting factory &lt;echo.EchoFactory instance at 0x12d8670&gt;\n2011-11-19 22:23:20-0500 [-] Received SIGTERM, shutting down.\n2011-11-19 22:23:20-0500 [-] (TCP Port 8000 Closed)\n2011-11-19 22:23:20-0500 [-] Stopping factory &lt;echo.EchoFactory instance at 0x12d8670&gt;\n2011-11-19 22:23:20-0500 [-] Main loop terminated.\n2011-11-19 22:23:20-0500 [-] Server Shut Down.</code></pre>\n<p>通过使用Twisted框架中的基础组件来运行服务，这么做使得开发人员能够不用再编写类似守护进程和记录日志这样的冗余代码了。这同样也为部署应用程序建立了一个标准的命令行接口。</p>\n<h6 id=\"Plugins\"><a href=\"#Plugins\" class=\"headerlink\" title=\"Plugins\"></a>Plugins</h6><p>对于运行Twisted应用程序的方法，除了基于TAC文件外还有一种可选的方法，这就是插件系统。TAC系统可以很方便的将Twisted预定义的服务同应用程序配置文件注册，而插件系统能够方便的将用户自定义的服务注册为twistd工具的子命令，然后扩展应用程序的命令行接口。</p>\n<p>在使用插件系统时：</p>\n<ol>\n<li><p>由于只有plugin API需要保持稳定，这使得第三方开发者能很容易地扩展软件。</p>\n</li>\n<li><p>插件发现能力已经集成到系统中了。插件可以在程序首次运行时加载并保存，每次程序启动时会重新触发插件发现过程，或者也可以在程序运行期间反复轮询新插件，这使得在程序已经启动后我们还可以判断是否有新的插件安装上了。</p>\n</li>\n</ol>\n<p>当使用Twisted插件系统来扩展软件时，我们要做的就是创建IPlugin接口下实现的对象并将它们放到一个特定的位置中，这里插件系统知道该如何去找到它们。</p>\n<p>我们已经将Echo服务转换为一个Twisted应用程序了，而将其转换为一个Twisted插件也是非常简单直接的。在我们之前的Echo模块中，除了包含有Echo协议和EchoFactory的定义之外，现在我们还要添加一个名为twistd的目录，其中还包含着一个名为plugins的子目录，这里正是我们需要定义echo插件的地方。通过这个插件，我们可以启动一个echo服务，并将需要使用的端口号作为参数指定给twistd工具。</p>\n<pre><code class=\"python\">from zope.interface import implements\n\nfrom twisted.python import usage\nfrom twisted.plugin import IPlugin\nfrom twisted.application.service import IServiceMaker\nfrom twisted.application import internet\n\nfrom echo import EchoFactory\n\nclass Options(usage.Options):\n    optParameters = [[&quot;port&quot;, &quot;p&quot;, 8000, &quot;The port number to listen on.&quot;]]\n\nclass EchoServiceMaker(object):\n    implements(IServiceMaker, IPlugin)\n    tapname = &quot;echo&quot;\n    description = &quot;A TCP-based echo server.&quot;\n    options = Options\n\ndef makeService(self, options):\n    &quot;&quot;&quot;\n    Construct a TCPServer from a factory defined in myproject.\n    &quot;&quot;&quot;\n    return internet.TCPServer(int(options[&quot;port&quot;]), EchoFactory())\n\nserviceMaker = EchoServiceMaker()</code></pre>\n<p>现在，我们的Echo服务器将作为一个服务选项出现在twistd –help的输出中。运行twistd echo –port=1235将在端口1235上启动一个Echo服务器。</p>\n<p>Twisted还带有一个可拔插的针对服务器端认证的模块twisted.cred，插件系统常见的用途就是为应用程序添加一个认证模式。我们可以使用twisted.cred中现成的AuthOptionMixin类来添加针对各种认证的命令行支持，或者是添加新的认证类型。比如，我们可以使用插件系统来添加基于本地Unix密码数据库或者是基于LDAP服务器的认证方式。</p>\n<p>twistd工具中附带有许多Twisted所支持的协议插件，只用一条单独的命令就可以完成启动服务器的工作了。这里有一些通过twistd启动服务器的例子：</p>\n<pre><code class=\"python\">twistd web –port 8080 –path .</code></pre>\n<p>这条命令将在8080端口启动一个HTTP服务器，在当前目录中负责处理静态和动态页面请求。</p>\n<pre><code class=\"python\">twistd dns –p 5553 –hosts-file=hosts</code></pre>\n<p>这条命令在端口5553上启动一个DNS服务器，解析指定的文件hosts中的域名，这个文件的内容格式同/etc/hosts一样。</p>\n<pre><code class=\"python\">sudo twistd conch –p tcp:2222</code></pre>\n<p>这条命令在端口2222上启动一个SSH服务器。ssh的密钥必须独立设定。</p>\n<pre><code class=\"python\">twistd mail –E –H localhost –d localhost=emails</code></pre>\n<p>这条命令启动一个ESMTP POP3服务器，为本地主机接收邮件并保存到指定的emails目录下。</p>\n<p>我们可以方便的通过twistd来搭建一个用于测试客户端功能的服务器，但它同样是可装载的、产品级的服务器实现。</p>\n<p>在部署应用程序的方式上，Twisted通过TAC文件、插件以及命令行工具twistd的部署方式已经获得了成功。但是有趣的是，对于大多数大型Twisted应用程序来说，部署它们仍然需要重写一些这类管理和监控组件；Twisted的架构并没有对系统管理员的需求呈现出太多的友好性。这也反映了一个事实，那就是对于系统管理员来说Twisted历来就没有太多架构可言，而这些系统管理员才是部署和维护应用程序的专家。在这方面，Twisted在未来架构设计的决策上需要更积极的征求这类专家级用户的反馈意见。</p>\n<p><a href=\"https://www.cnblogs.com/xianguang/p/7027661.html\">本文内容引用自此处</a></p>\n"},{"title":"VS Code最佳插件","_content":"## 1.视图类的插件\n\n### Material Theme && Material Theme Icon\n\n\n### Prettier - code formatter\n\n### Bracket Pair Colorizer 2\n\n> 显示bracket的section.\n\n### indent-rainbow\n\n>彩虹式的显示缩进\n\n## 2. 功能类插件\n\n### Auto Rename Tag\n\n> 改一个tag自动变相联的tag头\n\n### REST Client\n\n> 测试后台接口\n\n![GET与POST测试](/img/1577068784300.png)\n\n### CSS Pick\n\n>自动从HTML中选择出CSS\n\n### HTML CSS Support\n\n> 自动提示CSS及补全HTML\n\n### Live Sass Compiler\n\n> 根据当前的CSS，自动生成CSS文件。\n\n### Live Server\n> 显示内置浏览器窗口","source":"_posts/VS Code最佳插件.md","raw":"---\ntitle: VS Code最佳插件\ncategories:\n- 杂项资料\ntags: \n- Note\n---\n## 1.视图类的插件\n\n### Material Theme && Material Theme Icon\n\n\n### Prettier - code formatter\n\n### Bracket Pair Colorizer 2\n\n> 显示bracket的section.\n\n### indent-rainbow\n\n>彩虹式的显示缩进\n\n## 2. 功能类插件\n\n### Auto Rename Tag\n\n> 改一个tag自动变相联的tag头\n\n### REST Client\n\n> 测试后台接口\n\n![GET与POST测试](/img/1577068784300.png)\n\n### CSS Pick\n\n>自动从HTML中选择出CSS\n\n### HTML CSS Support\n\n> 自动提示CSS及补全HTML\n\n### Live Sass Compiler\n\n> 根据当前的CSS，自动生成CSS文件。\n\n### Live Server\n> 显示内置浏览器窗口","slug":"VS Code最佳插件","published":1,"date":"2020-09-08T03:23:20.716Z","updated":"2020-09-08T03:23:20.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10p002p4wf0e4lqeig5","content":"<h2 id=\"1-视图类的插件\"><a href=\"#1-视图类的插件\" class=\"headerlink\" title=\"1.视图类的插件\"></a>1.视图类的插件</h2><h3 id=\"Material-Theme-amp-amp-Material-Theme-Icon\"><a href=\"#Material-Theme-amp-amp-Material-Theme-Icon\" class=\"headerlink\" title=\"Material Theme &amp;&amp; Material Theme Icon\"></a>Material Theme &amp;&amp; Material Theme Icon</h3><h3 id=\"Prettier-code-formatter\"><a href=\"#Prettier-code-formatter\" class=\"headerlink\" title=\"Prettier - code formatter\"></a>Prettier - code formatter</h3><h3 id=\"Bracket-Pair-Colorizer-2\"><a href=\"#Bracket-Pair-Colorizer-2\" class=\"headerlink\" title=\"Bracket Pair Colorizer 2\"></a>Bracket Pair Colorizer 2</h3><blockquote>\n<p>显示bracket的section.</p>\n</blockquote>\n<h3 id=\"indent-rainbow\"><a href=\"#indent-rainbow\" class=\"headerlink\" title=\"indent-rainbow\"></a>indent-rainbow</h3><blockquote>\n<p>彩虹式的显示缩进</p>\n</blockquote>\n<h2 id=\"2-功能类插件\"><a href=\"#2-功能类插件\" class=\"headerlink\" title=\"2. 功能类插件\"></a>2. 功能类插件</h2><h3 id=\"Auto-Rename-Tag\"><a href=\"#Auto-Rename-Tag\" class=\"headerlink\" title=\"Auto Rename Tag\"></a>Auto Rename Tag</h3><blockquote>\n<p>改一个tag自动变相联的tag头</p>\n</blockquote>\n<h3 id=\"REST-Client\"><a href=\"#REST-Client\" class=\"headerlink\" title=\"REST Client\"></a>REST Client</h3><blockquote>\n<p>测试后台接口</p>\n</blockquote>\n<p><img src=\"/img/1577068784300.png\" alt=\"GET与POST测试\"></p>\n<h3 id=\"CSS-Pick\"><a href=\"#CSS-Pick\" class=\"headerlink\" title=\"CSS Pick\"></a>CSS Pick</h3><blockquote>\n<p>自动从HTML中选择出CSS</p>\n</blockquote>\n<h3 id=\"HTML-CSS-Support\"><a href=\"#HTML-CSS-Support\" class=\"headerlink\" title=\"HTML CSS Support\"></a>HTML CSS Support</h3><blockquote>\n<p>自动提示CSS及补全HTML</p>\n</blockquote>\n<h3 id=\"Live-Sass-Compiler\"><a href=\"#Live-Sass-Compiler\" class=\"headerlink\" title=\"Live Sass Compiler\"></a>Live Sass Compiler</h3><blockquote>\n<p>根据当前的CSS，自动生成CSS文件。</p>\n</blockquote>\n<h3 id=\"Live-Server\"><a href=\"#Live-Server\" class=\"headerlink\" title=\"Live Server\"></a>Live Server</h3><blockquote>\n<p>显示内置浏览器窗口</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-视图类的插件\"><a href=\"#1-视图类的插件\" class=\"headerlink\" title=\"1.视图类的插件\"></a>1.视图类的插件</h2><h3 id=\"Material-Theme-amp-amp-Material-Theme-Icon\"><a href=\"#Material-Theme-amp-amp-Material-Theme-Icon\" class=\"headerlink\" title=\"Material Theme &amp;&amp; Material Theme Icon\"></a>Material Theme &amp;&amp; Material Theme Icon</h3><h3 id=\"Prettier-code-formatter\"><a href=\"#Prettier-code-formatter\" class=\"headerlink\" title=\"Prettier - code formatter\"></a>Prettier - code formatter</h3><h3 id=\"Bracket-Pair-Colorizer-2\"><a href=\"#Bracket-Pair-Colorizer-2\" class=\"headerlink\" title=\"Bracket Pair Colorizer 2\"></a>Bracket Pair Colorizer 2</h3><blockquote>\n<p>显示bracket的section.</p>\n</blockquote>\n<h3 id=\"indent-rainbow\"><a href=\"#indent-rainbow\" class=\"headerlink\" title=\"indent-rainbow\"></a>indent-rainbow</h3><blockquote>\n<p>彩虹式的显示缩进</p>\n</blockquote>\n<h2 id=\"2-功能类插件\"><a href=\"#2-功能类插件\" class=\"headerlink\" title=\"2. 功能类插件\"></a>2. 功能类插件</h2><h3 id=\"Auto-Rename-Tag\"><a href=\"#Auto-Rename-Tag\" class=\"headerlink\" title=\"Auto Rename Tag\"></a>Auto Rename Tag</h3><blockquote>\n<p>改一个tag自动变相联的tag头</p>\n</blockquote>\n<h3 id=\"REST-Client\"><a href=\"#REST-Client\" class=\"headerlink\" title=\"REST Client\"></a>REST Client</h3><blockquote>\n<p>测试后台接口</p>\n</blockquote>\n<p><img src=\"/img/1577068784300.png\" alt=\"GET与POST测试\"></p>\n<h3 id=\"CSS-Pick\"><a href=\"#CSS-Pick\" class=\"headerlink\" title=\"CSS Pick\"></a>CSS Pick</h3><blockquote>\n<p>自动从HTML中选择出CSS</p>\n</blockquote>\n<h3 id=\"HTML-CSS-Support\"><a href=\"#HTML-CSS-Support\" class=\"headerlink\" title=\"HTML CSS Support\"></a>HTML CSS Support</h3><blockquote>\n<p>自动提示CSS及补全HTML</p>\n</blockquote>\n<h3 id=\"Live-Sass-Compiler\"><a href=\"#Live-Sass-Compiler\" class=\"headerlink\" title=\"Live Sass Compiler\"></a>Live Sass Compiler</h3><blockquote>\n<p>根据当前的CSS，自动生成CSS文件。</p>\n</blockquote>\n<h3 id=\"Live-Server\"><a href=\"#Live-Server\" class=\"headerlink\" title=\"Live Server\"></a>Live Server</h3><blockquote>\n<p>显示内置浏览器窗口</p>\n</blockquote>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2020-09-08T03:23:20.716Z","updated":"2020-09-08T03:23:20.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10r002u4wf098tn2n3r","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"Python Note 2","_content":"# Python Note 2\n\nPython中每一个数据类型实际上都是一个类。\n\n+ ### Function definition\n+ As python recommended, left two blank lines after function\n\n```python\ndef greet_user():\n    print(\"GO\")\n    print(\"Hi THERE!\")\n\n\ngreet_user()\n```\n\n+ ### Function parameters\n\n```python\ndef greet_user(name):\n    print(f\"GO:{name}\")\n    print(\"Hi THERE!\")\n\n\ngreet_user(\"John\")\ngreet_user() #Error, no parameter\n\ndef greet_user2(first_name,second_name):\n    print(f\"GO:{first_name} {second_name}\")\n    print(\"Hi THERE!\")\n\n\ngreet_user2(\"John\",\"Smith\")\ngreet_user2(second_name=\"John\",first_name=\"Smith\") #使用keyword形式作为参数，\ngreet_user2(second_name=\"John\",\"Smith\") #错误，混合情况必须先用position形式再用keyword形式\n```\n\n+ ### Funtion Returns\n+ By default, python return none.\n\n```python\ndef square(number):\n\treturn number * number\n\n\nresult = square(3)\nprint(result)\n```\n\n+ ### Error Handling\n+ try except\n\n```python\ntry:\n\tday = int(input(\"input day:\"))\n\tincome = 2000 / day\n\tprint(day)\nexcept ZeroDivisionError:\n\tprint(\"day can't be zero\")\nexcept ValueError:\n\tprint(\"Invalid input\")\n```\n\n+ ### Comments\n+ User comment to explain why and how, not what!\n\n+ ### UML 复习\n+ 线->空心菱形：表示聚合关系\n+ 实心箭头<-实线：表示父子类关系\n+ 实心箭头<-虚线：表示接口实现关系","source":"_posts/python_2.md","raw":"---\ntitle: Python Note 2\ncategories:\n- Python\ntags: \n- Python\n- Note\n---\n# Python Note 2\n\nPython中每一个数据类型实际上都是一个类。\n\n+ ### Function definition\n+ As python recommended, left two blank lines after function\n\n```python\ndef greet_user():\n    print(\"GO\")\n    print(\"Hi THERE!\")\n\n\ngreet_user()\n```\n\n+ ### Function parameters\n\n```python\ndef greet_user(name):\n    print(f\"GO:{name}\")\n    print(\"Hi THERE!\")\n\n\ngreet_user(\"John\")\ngreet_user() #Error, no parameter\n\ndef greet_user2(first_name,second_name):\n    print(f\"GO:{first_name} {second_name}\")\n    print(\"Hi THERE!\")\n\n\ngreet_user2(\"John\",\"Smith\")\ngreet_user2(second_name=\"John\",first_name=\"Smith\") #使用keyword形式作为参数，\ngreet_user2(second_name=\"John\",\"Smith\") #错误，混合情况必须先用position形式再用keyword形式\n```\n\n+ ### Funtion Returns\n+ By default, python return none.\n\n```python\ndef square(number):\n\treturn number * number\n\n\nresult = square(3)\nprint(result)\n```\n\n+ ### Error Handling\n+ try except\n\n```python\ntry:\n\tday = int(input(\"input day:\"))\n\tincome = 2000 / day\n\tprint(day)\nexcept ZeroDivisionError:\n\tprint(\"day can't be zero\")\nexcept ValueError:\n\tprint(\"Invalid input\")\n```\n\n+ ### Comments\n+ User comment to explain why and how, not what!\n\n+ ### UML 复习\n+ 线->空心菱形：表示聚合关系\n+ 实心箭头<-实线：表示父子类关系\n+ 实心箭头<-虚线：表示接口实现关系","slug":"python_2","published":1,"date":"2020-09-08T03:23:20.889Z","updated":"2020-09-08T03:23:20.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10t002x4wf0foob2swm","content":"<h1 id=\"Python-Note-2\"><a href=\"#Python-Note-2\" class=\"headerlink\" title=\"Python Note 2\"></a>Python Note 2</h1><p>Python中每一个数据类型实际上都是一个类。</p>\n<ul>\n<li><h3 id=\"Function-definition\"><a href=\"#Function-definition\" class=\"headerlink\" title=\"Function definition\"></a>Function definition</h3></li>\n<li>As python recommended, left two blank lines after function</li>\n</ul>\n<pre><code class=\"python\">def greet_user():\n    print(&quot;GO&quot;)\n    print(&quot;Hi THERE!&quot;)\n\n\ngreet_user()</code></pre>\n<ul>\n<li><h3 id=\"Function-parameters\"><a href=\"#Function-parameters\" class=\"headerlink\" title=\"Function parameters\"></a>Function parameters</h3></li>\n</ul>\n<pre><code class=\"python\">def greet_user(name):\n    print(f&quot;GO:{name}&quot;)\n    print(&quot;Hi THERE!&quot;)\n\n\ngreet_user(&quot;John&quot;)\ngreet_user() #Error, no parameter\n\ndef greet_user2(first_name,second_name):\n    print(f&quot;GO:{first_name} {second_name}&quot;)\n    print(&quot;Hi THERE!&quot;)\n\n\ngreet_user2(&quot;John&quot;,&quot;Smith&quot;)\ngreet_user2(second_name=&quot;John&quot;,first_name=&quot;Smith&quot;) #使用keyword形式作为参数，\ngreet_user2(second_name=&quot;John&quot;,&quot;Smith&quot;) #错误，混合情况必须先用position形式再用keyword形式</code></pre>\n<ul>\n<li><h3 id=\"Funtion-Returns\"><a href=\"#Funtion-Returns\" class=\"headerlink\" title=\"Funtion Returns\"></a>Funtion Returns</h3></li>\n<li>By default, python return none.</li>\n</ul>\n<pre><code class=\"python\">def square(number):\n    return number * number\n\n\nresult = square(3)\nprint(result)</code></pre>\n<ul>\n<li><h3 id=\"Error-Handling\"><a href=\"#Error-Handling\" class=\"headerlink\" title=\"Error Handling\"></a>Error Handling</h3></li>\n<li>try except</li>\n</ul>\n<pre><code class=\"python\">try:\n    day = int(input(&quot;input day:&quot;))\n    income = 2000 / day\n    print(day)\nexcept ZeroDivisionError:\n    print(&quot;day can&#39;t be zero&quot;)\nexcept ValueError:\n    print(&quot;Invalid input&quot;)</code></pre>\n<ul>\n<li><h3 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h3></li>\n<li><p>User comment to explain why and how, not what!</p>\n</li>\n<li><h3 id=\"UML-复习\"><a href=\"#UML-复习\" class=\"headerlink\" title=\"UML 复习\"></a>UML 复习</h3></li>\n<li><p>线-&gt;空心菱形：表示聚合关系</p>\n</li>\n<li><p>实心箭头&lt;-实线：表示父子类关系</p>\n</li>\n<li><p>实心箭头&lt;-虚线：表示接口实现关系</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python-Note-2\"><a href=\"#Python-Note-2\" class=\"headerlink\" title=\"Python Note 2\"></a>Python Note 2</h1><p>Python中每一个数据类型实际上都是一个类。</p>\n<ul>\n<li><h3 id=\"Function-definition\"><a href=\"#Function-definition\" class=\"headerlink\" title=\"Function definition\"></a>Function definition</h3></li>\n<li>As python recommended, left two blank lines after function</li>\n</ul>\n<pre><code class=\"python\">def greet_user():\n    print(&quot;GO&quot;)\n    print(&quot;Hi THERE!&quot;)\n\n\ngreet_user()</code></pre>\n<ul>\n<li><h3 id=\"Function-parameters\"><a href=\"#Function-parameters\" class=\"headerlink\" title=\"Function parameters\"></a>Function parameters</h3></li>\n</ul>\n<pre><code class=\"python\">def greet_user(name):\n    print(f&quot;GO:{name}&quot;)\n    print(&quot;Hi THERE!&quot;)\n\n\ngreet_user(&quot;John&quot;)\ngreet_user() #Error, no parameter\n\ndef greet_user2(first_name,second_name):\n    print(f&quot;GO:{first_name} {second_name}&quot;)\n    print(&quot;Hi THERE!&quot;)\n\n\ngreet_user2(&quot;John&quot;,&quot;Smith&quot;)\ngreet_user2(second_name=&quot;John&quot;,first_name=&quot;Smith&quot;) #使用keyword形式作为参数，\ngreet_user2(second_name=&quot;John&quot;,&quot;Smith&quot;) #错误，混合情况必须先用position形式再用keyword形式</code></pre>\n<ul>\n<li><h3 id=\"Funtion-Returns\"><a href=\"#Funtion-Returns\" class=\"headerlink\" title=\"Funtion Returns\"></a>Funtion Returns</h3></li>\n<li>By default, python return none.</li>\n</ul>\n<pre><code class=\"python\">def square(number):\n    return number * number\n\n\nresult = square(3)\nprint(result)</code></pre>\n<ul>\n<li><h3 id=\"Error-Handling\"><a href=\"#Error-Handling\" class=\"headerlink\" title=\"Error Handling\"></a>Error Handling</h3></li>\n<li>try except</li>\n</ul>\n<pre><code class=\"python\">try:\n    day = int(input(&quot;input day:&quot;))\n    income = 2000 / day\n    print(day)\nexcept ZeroDivisionError:\n    print(&quot;day can&#39;t be zero&quot;)\nexcept ValueError:\n    print(&quot;Invalid input&quot;)</code></pre>\n<ul>\n<li><h3 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h3></li>\n<li><p>User comment to explain why and how, not what!</p>\n</li>\n<li><h3 id=\"UML-复习\"><a href=\"#UML-复习\" class=\"headerlink\" title=\"UML 复习\"></a>UML 复习</h3></li>\n<li><p>线-&gt;空心菱形：表示聚合关系</p>\n</li>\n<li><p>实心箭头&lt;-实线：表示父子类关系</p>\n</li>\n<li><p>实心箭头&lt;-虚线：表示接口实现关系</p>\n</li>\n</ul>\n"},{"title":"力扣刷题记录","_content":"\n[toc]\n\n## 1. 两数之和\n* 1. Two Sum\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/two-sum\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n>示例:\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n```c++\n vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> result;\n        map<int, int> numsMap;\n        \n        for (int i = 0; i < nums.size(); i++)\n        {\n            int left = target - nums[i];\n\n            if (numsMap.count(left) > 0) {\n                result.push_back(numsMap[left]);\n                result.push_back(i);\n                break;\n            }\n            numsMap[nums[i]] = i;\n        }\n\n        return result;\n    }\n```\n\n## 2.两数相加\n* 2. Add Two Numbers\n \n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/add-two-numbers\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n>示例：\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n``` c++\n ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* head = new ListNode(-1);//存放结果的链表\n        ListNode* h = head;//移动指针\n        int sum = 0;//每个位的加和结果\n        bool carry = false;//进位标志\n        while (l1 != NULL || l2 != NULL)\n        {\n            sum = 0;\n            if (l1 != NULL)\n            {\n                sum += l1->val;\n                l1 = l1->next;\n            }\n            if (l2 != NULL)\n            {\n                sum += l2->val;\n                l2 = l2->next;\n            }\n            if (carry)\n                sum++;\n            h->next = new ListNode(sum % 10);\n            h = h->next;\n            carry = sum >= 10 ? true : false;\n        }\n        if (carry)\n        {\n            h->next = new ListNode(1);\n        }\n        ListNode* ptrDelete = head;\n        head = head->next;\n        delete ptrDelete;\n\n        return head;\n    }\n```\n\n## 3.无重复字符的最长子串\n * 3. Longest Substring Without Repeating Characters\n   \n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n>示例 1:\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n\n>输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n\n>输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n``` c++\nint lengthOfLongestSubstring(string s) {\n        map<char, int> posMap;\n        int ans = 0;\n        int start = 0;\n        int end = 0;\n\n        while (end < s.length()) {\n            char cur = s[end];\n            if (posMap.count(cur) > 0) {\n                start = max(posMap[cur],start);\n            }\n            ans = max(end - start + 1, ans);\n            posMap[cur] = end + 1;\n            end += 1;\n        }\n\n        return ans;\n    }\n```\n\n## 4. 寻找两个正序数组的中位数\n* 4. Median of Two Sorted Arrays\n  \n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。\n进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？\n\n\n>示例 1：\n输入：nums1 = [1,3], nums2 = [2]\n输出：2.00000\n解释：合并数组 = [1,2,3] ，中位数 2\n示例 2：\n输入：nums1 = [1,2], nums2 = [3,4]\n输出：2.50000\n解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n示例 3：\n输入：nums1 = [0,0], nums2 = [0,0]\n输出：0.00000\n示例 4：\n输入：nums1 = [], nums2 = [1]\n输出：1.00000\n示例 5：\n输入：nums1 = [2], nums2 = []\n输出：2.00000\n\n``` c++\nint getKthElement(const vector<int>& nums1, const vector<int>& nums2, int k) {\n        int m = nums1.size();\n        int n = nums2.size();\n        int index1 = 0, index2 = 0;\n\n        while (true) {\n            //处理边界\n            if (index1 == m)\n                return nums2[index2 + k -1];\n\n            if (index2 == n)\n                return nums1[index1 + k - 1];\n\n            if (k == 1)\n                return min(nums1[index1], nums2[index2]);\n\n            //* 正式处理，查找两个二序列表中第K大的数 *//\n\n            //拿出两个数组 k/2 -1位的数\n            int nIndex1 = min(index1 + k / 2 - 1, m-1);\n            int nIndex2 = min(index2 + k / 2 - 1,n-1);\n\n            //数组二大！数组一的[0]-[k/2-1]被移去算法范围\n            if (nums1[nIndex1] <= nums2[nIndex2]) {\n                k -= nIndex1 + 1 - index1;//个数已经比较完，继续剩下的数的比较\n                index1 = nIndex1 + 1;\n            }\n            else{//相关\n                k -= nIndex2 + 1 - index2;//个数已经比较完，继续剩下的数的比较\n                index2 = nIndex2 + 1;\n            }\n        }\n    }\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int total = nums1.size() + nums2.size();\n\n        if (total % 2 == 1) {\n            //奇数个\n            return getKthElement(nums1, nums2, (total+1) / 2);\n        }\n        else {\n            //偶数个\n            return (getKthElement(nums1, nums2, (total / 2)) + getKthElement(nums1, nums2, total/2 +1)) / 2.0;\n        }\n    }\n```\n\n## 5. 最长回文子串\n* 5. Longest Palindromic Substring\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n示例 1：\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n示例 2：\n输入: \"cbbd\"\n输出: \"bb\"\n\n\n\n> 暴力解法：\n\n``` c++\nbool validatePalindrome(string s, int i, int j) {\n\twhile (i < j) {\n\t\tif (s[i] != s[j]) {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t\tj--;\n\t}\n\treturn true;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n\t\n\tif (s == \"\" || s.length() < 2)\n\t\treturn s;\n\n\tint begin = 0;\n\tint maxLen = 1;\n\tfor (int i = 0; i < s.length()-1; i++)\n\t{\n\t\tfor (int j = i+1; j < s.length(); j++)\n\t\t{\n\t\t\tif (((j - i + 1) > maxLen) && validatePalindrome(s, i, j)) {\n\t\t\t\tmaxLen = (j - i + 1);\n\t\t\t\tbegin = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn s.substr(begin, maxLen);\n}\n```\n> 中心扩散法\n\n``` c++\nint expandAroundCenter(string s, int left, int right) {\n\tint len = s.length();\n\tint i = left;\n\tint j = right;\n\twhile (i >= 0 && j < len) {\n\t\tif (s[i] == s[j]) {\n\t\t\ti--;\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn j - i +1 - 2;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n\tif (s == \"\" || s.length() < 2)\n\t\treturn s;\n\n\tint begin = 0;\n\tint maxLen = 1;\n\tfor (int i = 0; i < s.length() - 1; i++)\n\t{\n\t\tint oddLen = expandAroundCenter(s, i, i);\n\t\tint eveLen = expandAroundCenter(s, i, i+1);\n\n\t\tint curMaxLen = max(oddLen, eveLen);\n\t\tif (curMaxLen > maxLen) {\n\t\t\tmaxLen = curMaxLen;\n\t\t\tbegin = i - (curMaxLen - 1) / 2;\n\t\t}\n\t}\n\n\treturn s.substr(begin, maxLen);\n\n}\n```\n> 动态规划\n\n``` c++\nstring QuestionHandler::longestPalindrome(string s) {\n\tif (s == \"\" || s.length() < 2)\n\t\treturn s;\n\n\tint len = s.length();\n\tint begin = 0;\n\tint maxLen = 1;\n\tvector<vector<int>> dp(len, vector<int>(len));\n\tfor (int j = 1; j < len; j++) {\n\t\tfor (int i = 0; i < j; i++) {\n\t\t\tif (s[i] != s[j]) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (j - i < 3) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dp[i][j] && (j - i + 1) > maxLen) {\n\t\t\t\tmaxLen = j - i + 1;\n\t\t\t\tbegin = i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn s.substr(begin, maxLen);\n}\n```\n\n![动态规划解法](/img/1603943631534.png)\n\n> Manacher算法 - O(n)\n\n``` c++\nint expand(const string& s, int left, int right) {\n\twhile (left >= 0 && right < s.size() && s[left] == s[right]) {\n\t\t--left;\n\t\t++right;\n\t}\n\treturn (right - left - 2) / 2;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n\tint start = 0, end = -1;\n\tstring t = \"#\";\n\tfor (char c : s) {\n\t\tt += c;\n\t\tt += '#';\n\t}\n\tt += '#';\n\ts = t;\n\n\tvector<int> arm_len;\n\tint right = -1, j = -1;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tint cur_arm_len;\n\t\tif (right >= i) {\n\t\t\tint i_sym = j * 2 - i;\n\t\t\tint min_arm_len = min(arm_len[i_sym], right - i);\n\t\t\tcur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);\n\t\t}\n\t\telse {\n\t\t\tcur_arm_len = expand(s, i, i);\n\t\t}\n\t\tarm_len.push_back(cur_arm_len);\n\t\tif (i + cur_arm_len > right) {\n\t\t\tj = i;\n\t\t\tright = i + cur_arm_len;\n\t\t}\n\t\tif (cur_arm_len * 2 + 1 > end - start) {\n\t\t\tstart = i - cur_arm_len;\n\t\t\tend = i + cur_arm_len;\n\t\t}\n\t}\n\n\tstring ans;\n\tfor (int i = start; i <= end; ++i) {\n\t\tif (s[i] != '#') {\n\t\t\tans += s[i];\n\t\t}\n\t}\n\treturn ans;\n}\n```\n\n## 6.Z 字形变换\n* 6. ZigZag Conversion\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/zigzag-conversion\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例 1:\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n示例 2:\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n解释:\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n\n``` c++\n  string convert(string s, int numRows) {\n        if (numRows == 1) return s;\n\n        int rowIdx = 0;\n        vector<string> rowStrs(numRows);\n        bool goingDown = false;\n        for (char c : s) {\n            rowStrs[rowIdx] += c;\n            if (rowIdx == 0 || rowIdx == numRows - 1) goingDown = !goingDown;\n            rowIdx += goingDown ? 1 : -1;\n        }\n\n        string result;\n        for (string row : rowStrs) result += row;\n        return result;\n    }\n```\n\n## 7. 整数反转\n* 7. Reverse Integer\n \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/reverse-integer\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例 1:\n输入: 123\n输出: 321\n 示例 2:\n输入: -123\n输出: -321\n示例 3:\n输入: 120\n输出: 21\n\n``` c++\n  int reverse(int x) {\n         int ans = 0;\n        while (x != 0) {\n            if (ans > 214748364 || ans < -214748364) {\n                return 0;\n            }\n            ans = ans*10 + x % 10;\n            x /= 10;\n        }\n\n        return ans;\n    }\n```\n\n## 8. 字符串转换整数 (atoi)\n* 8. String to Integer (atoi)\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/string-to-integer-atoi\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>请你来实现一个 atoi 函数，使其能将字符串转换成整数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：\n如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。\n假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。\n该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0 。\n提示：\n本题中的空白字符只包括空格字符 ' ' 。\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n\n>示例 1:\n输入: \"42\"\n输出: 42\n示例 2:\n输入: \"   -42\"\n输出: -42\n解释: 第一个非空白字符为 '-', 它是一个负号。\n     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n示例 3:\n输入: \"4193 with words\"\n输出: 4193\n解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。\n示例 4:\n输入: \"words and 987\"\n输出: 0\n解释: 第一个非空字符是 'w', 但它不是数字或正、负号。\n     因此无法执行有效的转换。\n示例 5:\n输入: \"-91283472332\"\n输出: -2147483648\n解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 \n     因此返回 INT_MIN (−231) 。\n\t \n``` c++\nclass Automaton {\n    string state = \"start\";\n    unordered_map<string, vector<string>> table = {\n        {\"start\", {\"start\", \"signed\", \"in_number\", \"end\"}},\n        {\"signed\", {\"end\", \"end\", \"in_number\", \"end\"}},\n        {\"in_number\", {\"end\", \"end\", \"in_number\", \"end\"}},\n        {\"end\", {\"end\", \"end\", \"end\", \"end\"}}\n    };\n\n    int get_col(char c) {\n        if (isspace(c)) return 0;\n        if (c == '+' or c == '-') return 1;\n        if (isdigit(c)) return 2;\n        return 3;\n    }\npublic:\n    int sign = 1;\n    long long ans = 0;\n\n    void get(char c) {\n        state = table[state][get_col(c)];\n        if (state == \"in_number\") {\n            ans = ans * 10 + c - '0';\n            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);\n        }\n        else if (state == \"signed\")\n            sign = c == '+' ? 1 : -1;\n    }\n};\n\nint myAtoi(string s) {\n         Automaton automaton;\n        for (char c : s)\n            automaton.get(c);\n        return automaton.sign * automaton.ans;\n    }\n```\n\n## 9.回文数\n* 9. Palindrome Number\n  \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/palindrome-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n示例 1:\n输入: 121\n输出: true\n示例 2:\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3:\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n``` c++\n bool isPalindrome(int x) {\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        //后半段与前半段对比\n        int revertedNumber = 0;\n        while (x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        return x == revertedNumber || x == revertedNumber / 10;\n    }\n```\n\n## 10. 正则表达式匹配\n* 10. Regular Expression Matching\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/regular-expression-matching\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n\n> '.' 匹配任意单个字符\n'\\*' 匹配零个或多个前面的那一个元素\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n\n \n>示例 1：\n输入：s = \"aa\" p = \"a\"\n输出：false\n解释：\"a\" 无法匹配 \"aa\" 整个字符串。\n\n>示例 2:\n输入：s = \"aa\" p = \"a*\"\n输出：true\n解释：因为 '\\*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n\n>示例 3：\n输入：s = \"ab\" p = \".\\*\"\n输出：true\n解释：\".\\*\" 表示可匹配零个或多个（'\\*'）任意字符（'.'）。\n\n>示例 4：\n输入：s = \"aab\" p = \"c\\*a\\*b\"\n输出：true\n解释：因为 '\\*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n>示例 5：\n输入：s = \"mississippi\" p = \"mis\\*is\\*p\\*.\"\n输出：false\n\n``` c++\nbool isMatch(string s, string p) {\n\t// dp[i][j]表示str[1:i]和pattern[1:j]能否匹配，为0表示无法匹配，为1表示可以匹配\n//\n// 分析状态转移方程\n//   对于dp[i][j]，如果str[i]与p[j]相同或者p[j]为.，则dp[i][j] = dp[i-1][j-1]，即与s[1:i-1]和p[1:j-1]的匹配情况相同\n//   如果p[j]为*，则表示这个字符可以联合p[j-1]使用来匹配当前的s[i](这个选择可做可不做，但我们尽量去匹配字符串)\n//   考虑p[j]为*，如果p前一个字符为.，显然可以用一次.*组合匹配到s[i]，如果p前一个字符p[j-1]不为.并且不与s[i]相同，则不能使用\n//   综合考虑，若p[j]=='*'\n//   1. 不选择替换，使用0次*，dp[i][j] = dp[i][j-2]\n//   2. 当p[j-1]为.或者与s[i]相同时，可以使用一次替换，则dp[i][j] = dp[i-1][j]\n//   两者求或 (因为我们尽可能去匹配字符串，所以只要有一种情况匹配成功，则匹配成功)\n// 初始化主要考虑p去匹配一个空串的情况，和上面类似的分析过程即可得出结论\n\n\t//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配\n\tvector<vector<bool>> dp(s.size() + 1, vector<bool>(p.size() + 1));\n\tdp[0][0] = true;\n\n\t//s 的前 0 个是否能被 p 的前 j 个匹配\n\tfor (size_t j = 1; j < p.size(); ++j)\n\t{\n\t\tif (p[j] == '*')\n\t\t{\n\t\t\tdp[0][j + 1] = dp[0][j - 1];\n\t\t}\n\t}\n\n\tfor (size_t i = 0; i < s.size(); ++i)\n\t{\n\t\tfor (size_t j = 0; j < p.size(); ++j)\n\t\t{\n\t\t\tif (s[i] == p[j] || p[j] == '.')//匹配单个字符  \n\t\t\t{\n\t\t\t\tdp[i + 1][j + 1] = dp[i][j];\n\t\t\t}\n\t\t\telse if (p[j] == '*' && j > 0)\n\t\t\t{\n\t\t\t\tif (s[i] != p[j - 1] && p[j - 1] != '.')//前一对字符匹配\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j + 1] = dp[i + 1][j - 1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j + 1] = dp[i][j + 1] || //*表示匹配超过一个字符(s[i]、s[i-1]和p[j-1])\n\t\t\t\t\t\t//dp[i + 1][j] || //*表示只匹配一个字符（s[i]和p[j-1]）\n\t\t\t\t\t\tdp[i + 1][j - 1];//*表示0个匹配\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[s.size()][p.size()];\n}\n```\n\n\n\n## 11. 盛最多水的容器\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/container-with-most-water\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n说明：你不能倾斜容器，且 n 的值至少为 2。\n\n>示例：\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n\n``` c++\nint maxArea(vector<int>& height) {\n        int n = height.size();\n        if (n < 2)\n            return 0;\n\n        int maxVolume = 0;\n        int left = 0;\n        int right = n - 1;\n        \n        while(left < right){\n            //取左端与右端\n            int lh = height[left];\n            int rh = height[right];\n\n            //计算体积\n            int vol = min(lh, rh) * (right-left);\n            //设置最大体积\n            maxVolume = max(maxVolume, vol);\n\n            //哪端的指针移动，取决于哪根柱子更低\n            left += (lh <= rh) ? 1 : 0;\n            right -= (lh > rh) ? 1 : 0;\n\n            cout << \"left:\"<<left<<\",right:\"<<right<<endl;\n        }\n\n\n        return maxVolume;\n    }\n```\n## 17. 电话号码的字母组合\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n![17](/img/1604578953107.png)\n\n>示例:\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n说明:\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n``` c++\n  vector<string> letterCombinations(string digits) {\n        map<int,vector<char>> numsMap;\n        numsMap.insert(map< int, vector<char>>::value_type(2, vector<char>{'a', 'b', 'c'}));\n        numsMap.insert(map< int, vector<char>>::value_type(3, vector<char>{'d', 'e', 'f'}));\n        numsMap.insert(map< int, vector<char>>::value_type(4, vector<char>{'g', 'h', 'i'}));\n        numsMap.insert(map< int, vector<char>>::value_type(5, vector<char>{'j', 'k', 'l'}));\n        numsMap.insert(map< int, vector<char>>::value_type(6, vector<char>{'m', 'n', 'o'}));\n        numsMap.insert(map< int, vector<char>>::value_type(7, vector<char>{'p', 'q', 'r','s'}));\n        numsMap.insert(map< int, vector<char>>::value_type(8, vector<char>{'t', 'u', 'v'}));\n        numsMap.insert(map< int, vector<char>>::value_type(9, vector<char>{'w', 'x', 'y','z'}));\n\n        /*输入：\"23\"\n            输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].*/\n        map<string, int> resultMap;\n        vector<string> result;\n        \n        for (int i = 0; i < digits.size(); i++) {\n            int v = digits[i] - '0';\n            if (numsMap.count(v) == 0) {\n                result.clear();\n                break;\n            }\n            vector<char> curChars = numsMap[v];\n            if (i > 0) {\n                vector<string> tmpList;\n                for(string val : result) {\n                    for (char c : curChars) {\n                        tmpList.push_back(val + c);\n                    }\n                }\n                result.clear();\n                result = tmpList;\n            }\n            else {\n                for (auto it = curChars.begin(); it != curChars.end(); it++) {\n                  \tchar v = *it;\n\t\t\t\t    result.push_back(string (1,v));\n                }\n            }\n        }\n\n        return result;\n    }\n```\n\n## 15.三数之和\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/3sum\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n\n>示例：\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n``` c++\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());   // -4  -1  -1  0  1  2\n        vector<vector<int>> res;\n        for(int i=0; i<nums.size(); i++){\n            if(i > 0 && nums[i] == nums[i-1]){\n                continue;\n            }\n            int j = i+1, k = nums.size() -1;\n            while(j < k){\n                if(j > i+1 && nums[j] == nums[j-1]){\n                    j++;\n                    continue;\n                }\n                if(k < nums.size()-1 && nums[k] == nums[k+1]){\n                    k--;\n                    continue;\n                }\n                if(nums[j] + nums[k] > -1*nums[i]){\n                    k--;\n                }else if(nums[j] + nums[k] < -1*nums[i]){\n                    j++;\n                }else{\n                    res.push_back({nums[i], nums[j], nums[k]});\n                    j++, k--;\n                }\n            }\n        }\n        return res;\n    }\n```\n\n## 19.删除链表的倒数第N个节点\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n示例：\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n说明：\n给定的 n 保证是有效的。\n进阶：\n你能尝试使用一趟扫描实现吗？\n\n``` c++\n  ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* pre = NULL;\n\n        for (int i = 0; i < n; i++)\n        {\n            fast = fast->next;\n        }\n\n        while (fast != NULL) {\n            pre = slow;\n            slow = slow->next;\n            fast = fast->next;\n        }\n        \n        if (pre != NULL) {\n            pre->next = slow->next;\n            return head;\n        }\n        else {\n            return head->next;\n        }\n\n    }\n\t\n```\n\n## 20. 有效的括号\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-parentheses\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n有效字符串需满足：\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n注意空字符串可被认为是有效字符串。\n\n>示例 1:\n输入: \"()\"\n输出: true\n示例 2:\n输入: \"()[]{}\"\n输出: true\n示例 3:\n输入: \"(]\"\n输出: false\n示例 4:\n输入: \"([)]\"\n输出: false\n示例 5:\n输入: \"{[]}\"\n输出: true\n\n``` c++\n bool isValid(string s) {\n        map<char, char> cMap = {\n            {']','['},\n            {'}','{'},\n            {')','('},\n        };\n\n        if (s.size() % 2 == 1)//奇数必然不对\n            return false;\n\n        stack<char> cs;\n        for (char c : s) {\n            if (cMap.count(c)) {\n                if (cs.empty() || cs.top() != cMap[c]) {\n                    return false;\n                }\n                cs.pop();\n            }\n            else {\n                cs.push(c);\n            }\n        }\n        return cs.size() == 0;\n    }\n```\n\n## 22. 括号生成\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/generate-parentheses\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n>示例：\n输入：n = 3\n输出：[\n       \"((()))\",\n       \"(()())\",\n       \"(())()\",\n       \"()(())\",\n       \"()()()\"\n     ]\n\n\n``` c++\n void LoopGetParanthesis(vector<string> & result,string str,int left, int right) {\n        if (left == 0 && right == 0) {\n            result.push_back(str);\n            return;\n        }\n        \n        //左右括号数相等，则只用左括号\n        if (left == right) {\n            LoopGetParanthesis(result, str + \"(\", left - 1, right);\n        }\n        else if(left < right){\n            if (left > 0) {\n                LoopGetParanthesis(result, str + \"(\", left-1, right);\n            }\n            LoopGetParanthesis(result, str + \")\", left, right - 1);\n        }\n    }\n    vector<string> generateParenthesis(int n) {\n        vector<string> result;\n        string str = \"\";\n        LoopGetParanthesis(result, str, n, n);\n\n        return result;\n    }\n```\n\n## 26.删除排序数组中的重复项\n* 26. Remove Duplicates from Sorted Array\n \n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n>示例 1:\n给定数组 nums = [1,1,2], \n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n你不需要考虑数组中超出新长度后面的元素。\n\n>示例 2:\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n你不需要考虑数组中超出新长度后面的元素。\n\n``` c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size() ==0) return 0;\n        int thumb = 0;\n        \n        for(int i = 1;i < nums.size(); i++){\n            if(nums[i] != nums[thumb]){\n                thumb ++;\n                nums[thumb] = nums[i];\n            }\n        }\n        return thumb+1;\n    }\n};\n```\n\n## 27. 移除元素\n* 27. Remove Element\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-element\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n>示例 1:\n给定 nums = [3,2,2,3], val = 3,\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n你不需要考虑数组中超出新长度后面的元素。\n\n>示例 2:\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n注意这五个元素可为任意顺序。\n你不需要考虑数组中超出新长度后面的元素。\n\n``` c++\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int thumb = 0;\n        for(int i = 0; i < nums.size(); i++){\n            if(nums[i] != val){\n                nums[thumb] = nums[i];\n                thumb ++;\n            }\n        }\n        return thumb;\n    }\n};\n```\n\n## 28. 实现 strStr()\n* 28. Implement strStr()\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/implement-strstr\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n\n>示例 1:\n输入: haystack = \"hello\", needle = \"ll\"\n输出: 2\n\n>示例 2:\n输入: haystack = \"aaaaa\", needle = \"bba\"\n输出: -1\n\n``` python\nclass Solution:\n    def strStr(self, source: str, target: str) -> int:\n        if source == target:\n            return 0\n\n        source_len = len(source)\n        target_len = len(target)\n\n        if target_len > source_len:\n            return -1\n\n        for i in range(source_len):\n            target_index = i + target_len\n            if target_index > source_len:\n                continue\n            if source[i:target_index] == target:\n                return i\n\n        return -1\n```\n\n## 29. 两数相除\n* 29. Divide Two Integers\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/divide-two-integers\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n返回被除数 dividend 除以除数 divisor 得到的商。\n整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n\n \n>示例 1:\n输入: dividend = 10, divisor = 3\n输出: 3\n解释: 10/3 = truncate(3.33333..) = truncate(3) = 3\n\n>示例 2:\n输入: dividend = 7, divisor = -3\n输出: -2\n解释: 7/-3 = truncate(-2.33333..) = -2\n \n\n>提示：\n被除数和除数均为 32 位有符号整数。\n除数不为 0。\n假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。\n\n``` python\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n        if abs_dividend < abs_divisor:\n            return 0\n\n        is_neg = 0\n        if abs(dividend + divisor) != abs_dividend + abs_divisor:\n            is_neg = 1\n        ans = 0\n\n        for i in range(31, -1, -1):\n            print('abs_dividend >> %d : %d, %d, '% (i, abs_dividend >> i, abs_divisor))\n\n            if abs_dividend >> i >= abs_divisor:\n                ans += 1 << i\n                abs_dividend -= abs_divisor << i\n                print('good value: %d, %d'%(ans, abs_dividend))\n\n        if is_neg and ans >= 2 ** 31:\n            return -2 ** 31\n        elif ans >= 2 ** 31:\n            return 2 ** 31 - 1\n        elif is_neg:\n            return -ans\n        else:\n            return ans\n```\n\n## 30. 串联所有单词的子串\n* 30. Substring with Concatenation of All Words\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。\n\n\n>示例 1：\n输入：\n  s = \"barfoothefoobarman\",\n  words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n\n>示例 2：\n输入：\n  s = \"wordgoodgoodgoodbestword\",\n  words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n\n``` python\nclass Solution(object):\n    def findSubstring(self, s, words):\n        from collections import Counter\n        if not s or not words:return []\n        one_word = len(words[0])\n        all_len = len(words) * one_word\n        n = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0, n - all_len + 1):\n            tmp = s[i:i+all_len]\n            c_tmp = []\n            for j in range(0, all_len, one_word):\n                c_tmp.append(tmp[j:j+one_word])\n            if Counter(c_tmp) == words:\n                res.append(i)\n        return res\n```\n\n\n## 41. 缺失的第一个正数\n* 41. First Missing Positive\n \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/first-missing-positive\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。\n\n>示例 1:\n输入: [1,2,0]\n输出: 3\n\n>示例 2:\n输入: [3,4,-1,1]\n输出: 2\n\n>示例 3:\n输入: [7,8,9,11,12]\n输出: 1\n \n\n>提示：\n你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。\n\n``` c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n         // 总长\n        int n = nums.size();\n        // 1. 全部元素没有1，返回1\n        bool noOne = true;\n        for(int i = 0; i < nums.size();i++){\n            if(nums[i] == 1)\n            {\n                noOne = false;\n                break;\n            }\n        }\n        if(noOne){\n            return 1;\n        }\n\n        //2. 只有一个元素，且为[1]，则返回2\n        if(n == 1)\n        {\n            return 2;\n        }\n\n        //3. 去<= 0与 > 总数的数，将其设为1\n        for(int i = 0; i < n;i++){\n            if(i == n-1){\n                cout << nums[i] << endl;\n            }\n            if(nums[i] < 1 || nums[i] > n){\n                nums[i] = 1;\n            }\n        }\n  \n\n        //4.遍历，当值 == 总数。第一个值设为负数. 当值 <= 总数，以值为下标设置为负值. 特别的，当值为总数时，将第一个值为负值！\n         for(int i = 0; i < n; i++){\n             int a = abs(nums[i]);\n             if(a == n){\n                 nums[0] = - abs(nums[0]);\n             }else{\n                nums[a] = - abs(nums[a]);\n             }\n         }\n\n        for(int v: nums){\n            cout << v << \",\";\n        }\n        cout << endl;\n\n        //5.遍历最新的数组中，发现有大于0，此索引就是丢失的最小正数\n        for(int i = 1; i < n;i++){\n            if(nums[i] > 0){\n                return i;\n            }\n        }\n\n        //6.5如果没有找到，第一值取出来如果是正数，则数为正数N\n        if(nums[0] > 0){\n            return n;\n        }\n\n        //7.如果以上走完了，返回n+1\n        return n+1;\n    }\n};\n```\n\n## 42. 接雨水\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/trapping-rain-water\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n\n![接雨水](/img/1604063667003.png)\n\n>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n示例 2：\n输入：height = [4,2,0,3,2,5]\n输出：9\n\n``` c++\n  int trap(vector<int>& height) {\n        int left = 0, right = height.size() - 1;\n        int ans = 0;\n        int left_max = 0, right_max = 0;\n        while (left < right) {\n            //情况1：左比右低，只有当左边最高柱比当前柱要高，则这个落差必定是能装水的。\n            if (height[left] < height[right]) {\n                height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);\n                ++left;\n            }\n            else {//情况2：右比左低，只有当右边最高柱比当前柱要高，则这个落差必定是能装水的。\n                height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);\n                --right;\n            }\n        }\n        return ans;\n    }\n```\n## 51. N皇后 & 52. N皇后 II\n* 51. N-Queens\n* 52. N-Queens II\n \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/n-queens\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n![8皇后的一种解法](/img/1601178139148.png)\n\n>51. 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n>52. 给定一个整数 n，返回 n 皇后不同的解决方案的数量。\n\n\n``` python\nclass NQueen:\n    def __init__(self):\n        self.count = 0\n\n    def do_nqueen(self, n):\n        empty_sign = \"[O]\"\n        queen_sign = \"[1]\"\n        # 所有数组起点都以0开始\n\n        # 1.定义所有解的容器，二维数组，第二维代表一个完整的解\n        ans = []\n\n        # 2.递归函数dfs\n        def dfs(nums, row):\n            # 如果找的行数与n相等了，说明已经找完了，得到一个解！\n            if row == n:\n                ans.append(nums[:]) # 注意不可用ans.append(nums)\n                return\n            # 逐列进行尝试，列的总数为n\n            for i in range(n):\n                # 每进行到一列，标记当前行皇后位置为此列\n                nums[row] = i\n                # 往下递归找到，一直找到底，找不到底循环会返回到此处！\n                if valid(nums, row):\n                    # print(\"当前找到第%d行的第%d列，此值可放皇后！\"%(row, i))\n                    dfs(nums, row+1)\n                else:\n                    pass\n                    # print(\"当前找到第%d行的第%d列，不可放，回溯\"%(row, i))\n\n        # 3.检查函数valid\n        def valid(nums, row):\n            # 只找前面行的点， 皇后攻击规则，同列同行 和 对角线元素表示\n            for r in range(row):\n                if abs(nums[r] - nums[row]) == abs(r - row) or nums[r] == nums[row]:\n                    return False\n            return True\n\n        # 4.执行, 从第0行开始找n数组长度中的位置\n        dfs([None for _ in range(n)], 0)\n\n        def get_row_list(row_val, count):\n            result = []\n            for i in range(count):\n                if i == row_val:\n                    result.append(queen_sign)\n                else:\n                    result.append(empty_sign)\n            return result\n\n\n        # 5.结果画出来\n        result = [[] for _ in range(len(ans))]\n        for i in range(len(ans)):\n            for col in ans[i]:\n                result[i].append(\"\".join(get_row_list(col, n)))\n\n        return result\n\n\nmyqueen = NQueen()\nresult = myqueen.do_nqueen(4)\nprint(\"解有%d个\"%len(result))\nfor r in result:\n    r = str(r)\n    print(r+\"\\n\\n\")\n```\n\n## 75. 颜色分类\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sort-colors\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n注意:\n不能使用代码库中的排序函数来解决这道题。\n示例:\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n进阶：\n一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n``` c++\n void sortColors(vector<int>& nums) {\n       int n = nums.size();\n        int slow0 = 0, fast = 0, slow2 = n - 1;\n\n        while (fast <= slow2) {\n            while (fast <= slow2 && nums[fast] == 2) {\n                //当当前快指针为2时，移至结尾。如果换完后的nums[fast]还是2？则继续换\n                nums[fast] = nums[slow2];\n                nums[slow2--] = 2;\n            }\n            \n            if (nums[fast] == 0) {\n                nums[fast] = nums[slow0];\n                nums[slow0++] = 0;\n            }\n            fast++;\n        }\n    }\n```\n\n## 76.最小覆盖子串\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-window-substring\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。\n示例：\n输入：S = \"ADOBECODEBANC\", T = \"ABC\"\n输出：\"BANC\"\n\n>提示：\n如果 S 中不存这样的子串，则返回空字符串 \"\"。\n如果 S 中存在这样的子串，我们保证它是唯一的答案。\n\n```c++\n string minWindow(string s, string t) {\n        if(s == t) return s;\n\n        map<char, int> need, window;\n        int tLen = t.length();//目标字符串\n        int sLen = s.length();\n        if (tLen == 0 || sLen == 0) return \"\";\n        if (sLen < tLen )\n            return \"\";\n\n        //先把t中的字符放到need表中，计数\n        for (int i = 0; i < tLen; i++) {\n            char c = t[i];\n            need[c] = ((need.count(c) == 0)?0:need[c]) + 1;\n        }\n\n        int left = 0, right = 0;\n        int len = INT32_MAX, start = 0;\n        int valid = 0; //已经匹配成功的字符种类数（非字符个数）\n\n        //当右指针去到字符串末尾前\n        while (right < sLen) {\n            char c = s[right];\n            right++;//右指针向右滑\n\n            //如果右指针现在滑到的字符是目标字符串的一个，那么更新窗口中的数据\n            if (need.count(c) > 0) {\n                window[c] = ((window.count(c) == 0)?0:window[c]) + 1;\n                if (window[c] == (need[c])) {\n                    valid++;\n                }\n            }\n\n            //窗口开始从左边收缩\n            while (valid == need.size()) {\n                if (right - left < len) {\n                    start = left;\n                    len = right - left;\n                }\n                \n                char d = s[left];\n                left++;\n\n                if (need.count(d) > 0) {\n                    if (window[d] == (need[d])) {\n                        valid--;\n                    }\n                    window[d] = window[d] - 1;\n                }\n            }\n        }\n        return len == INT32_MAX ? \"\" : s.substr(start, len);\n    }\n```\n\n## 80. 删除排序数组中的重复项 II\n* 80. Remove Duplicates from Sorted Array II\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n>示例 1:\n给定 nums = [1,1,1,2,2,3],\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n你不需要考虑数组中超出新长度后面的元素。\n\n>示例 2:\n给定 nums = [0,0,1,1,1,1,2,3,3],\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n你不需要考虑数组中超出新长度后面的元素。\n\n>说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n\n``` c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n      int i = 0;\n        for (int n : nums) {\n            if (i < 2 || n > nums[i-2]) nums[i++] = n;\n        }\n        return i;\n    }\n};\n```\n\n## 127. 单词接龙\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/word-ladder\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：\n每次转换只能改变一个字母。\n转换过程中的中间单词必须是字典中的单词。\n\n >说明:\n如果不存在这样的转换序列，返回 0。\n所有单词具有相同的长度。\n所有单词只由小写字母组成。\n字典中不存在重复的单词。\n你可以假设 beginWord 和 endWord 是非空的，且二者不相同。\n\n>示例 1:\n输入:\nbeginWord = \"hit\",\nendWord = \"cog\",\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n输出: 5\n解释: 一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\n     返回它的长度 5。\n示例 2:\n输入:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n输出: 0\n解释: endWord \"cog\" 不在字典中，所以无法进行转换。\n\n``` c++\nclass Solution {\n    unordered_map<string, int> wordId;\n    vector<vector<int>> edge;\n    int nodeNum = 0;\n\n    void addWord(string& word) {\n        if (!wordId.count(word)) {\n            wordId[word] = nodeNum++;\n            edge.emplace_back();\n        }\n    }\n\n    void addEdge(string& word) {\n        addWord(word);\n        int id1 = wordId[word];\n        for (char& it : word) {\n            char tmp = it;\n            it = '*';\n            addWord(word);\n            int id2 = wordId[word];\n            edge[id1].push_back(id2);\n            edge[id2].push_back(id1);\n            it = tmp;\n        }\n    }\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        for (string& word : wordList) {\n            addEdge(word);\n        }\n        addEdge(beginWord);\n        if (!wordId.count(endWord)) {\n            return 0;\n        }\n        vector<int> dis(nodeNum, INT_MAX);\n        int beginId = wordId[beginWord], endId = wordId[endWord];\n        dis[beginId] = 0;\n\n        queue<int> que;\n        que.push(beginId);\n        while (!que.empty()) {\n            int x = que.front();\n            que.pop();\n            if (x == endId) {\n                return dis[endId] / 2 + 1;\n            }\n            for (int& it : edge[x]) {\n                if (dis[it] == INT_MAX) {\n                    dis[it] = dis[x] + 1;\n                    que.push(it);\n                }\n            }\n        }\n        return 0;\n    }\n\n};\n```\n\n## 129.求根到叶子节点数字之和\n* 129. Sum Root to Leaf Numbers\n* \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。\n例如，从根到叶子节点路径 1->2->3 代表数字 123。\n计算从根到叶子节点生成的所有数字之和。\n说明: 叶子节点是指没有子节点的节点。\n\n示例 1:\n输入: [1,2,3]\n    1\n   / \\\n  2   3\n输出: 25\n解释:\n从根到叶子节点路径 1->2 代表数字 12.\n从根到叶子节点路径 1->3 代表数字 13.\n因此，数字总和 = 12 + 13 = 25.\n示例 2:\n\n输入: [4,9,0,5,1]\n    4\n   / \\\n  9   0\n / \\\n5   1\n输出: 1026\n解释:\n从根到叶子节点路径 4->9->5 代表数字 495.\n从根到叶子节点路径 4->9->1 代表数字 491.\n从根到叶子节点路径 4->0 代表数字 40.\n因此，数字总和 = 495 + 491 + 40 = 1026.\n\n``` c++\nint bfs_sum(TreeNode* root) {\n\tif(root == NULL)\n\t\treturn 0;\n\tint sum = 0;\n\tqueue<TreeNode*> q;\n\tqueue<int> qn;\n\n\tq.push(root);\n\tqn.push(root->val);\n\n\twhile (!q.empty()) {\n\t\tTreeNode* node = q.front();\n\t\tint nodeVal = qn.front();\n\t\tq.pop();\n\t\tqn.pop();\n\n\t\tif ((node->left == NULL) && (node->right == NULL)) {\n\t\t\tsum += nodeVal;\n\t\t}\n\t\telse {\n\t\t\tif (node->left != NULL) {\n\t\t\t\tq.push(node->left);\n\t\t\t\tqn.push(nodeVal * 10 + node->left->val);\n\t\t\t}\n\t\t\tif (node->right != NULL) {\n\t\t\t\tq.push(node->right);\n\t\t\t\tqn.push(nodeVal * 10 + node->right->val);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint dfs_sum(TreeNode* node, int prevSum) {\n\tif(node == NULL)\n\t\treturn 0;\n\n\tint sum = prevSum * 10 + node->val;\n\t//左右都没有值 \n\tif ((node->left == NULL) &&(node->right == NULL)) {\n\t\treturn sum;\n\t}\n\telse {\n\t\tsum = dfs_sum(node->left, sum) + dfs_sum(node->right, sum);\n\t}\n\n\treturn sum;\n}\n\nint sumNumbers(TreeNode* root) {\n\t\t//return dfs_sum(root, 0);\n\treturn bfs_sum(root);\n}\n```\n## 141. 环形链表\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/linked-list-cycle\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个链表，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n\n>进阶\n你能用 O(1)（即，常量）内存解决此问题吗？\n\n>输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n``` c++\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n       ListNode* slow = head;\n        ListNode* fast = head->next;\n        while (slow != fast) {\n            if (fast == NULL || fast->next == NULL)\n            {\n                return false;\n            }\n                \n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return true;\n    }\n```\n\n## 142. 环形链表 II\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/linked-list-cycle-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\n\n>输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n``` c++\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while(fast != NULL){\n            if(fast->next == NULL)\n                return nullptr;\n\n            slow = slow->next;\n            fast = fast->next->next;\n\n            if(slow == fast){\n                ListNode * ptr = head;\n                while(ptr != slow){\n                    ptr = ptr->next;\n                    slow = slow->next;\n                }\n                return ptr;\n            }\n        }\n        return nullptr;\n\n    }\n```\n\n## 144. 二叉树的前序遍历\n* 144. Binary Tree Preorder Traversal\n  \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个二叉树，返回它的 前序 遍历。\n\n>示例:\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n输出: [1,2,3]\n\n``` c++\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> result;\n        if(root == NULL)\n            return result;\n        \n        stack<TreeNode> ss;\n        ss.push(*root);\n        \n        while(!ss.empty()){\n            TreeNode cur = ss.top();\n            ss.pop();\n\n            result.push_back(cur.val);\n\n            if(cur.right != NULL){\n                ss.push(*cur.right);\n            }\n            if(cur.left != NULL){\n                ss.push(*cur.left);\n            }\n        }\n        return result;\n    }\n```\n\n## 189. 旋转数组\n* 189. Rotate Array\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/rotate-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。\n\n>示例 1:\n输入: [1,2,3,4,5,6,7] 和 k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n\n>示例 2:\n输入: [-1,-100,3,99] 和 k = 2\n输出: [3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n\n>说明:\n尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n要求使用空间复杂度为 O(1) 的 原地 算法。\n\n``` c++\nclass Solution {\npublic:\n    void reverse(vector<int>& nums, int start, int end){\n        for(int i = start,j = end; i < j; i++,j--){\n            int ftmp = nums[j];\n            nums[j] = nums[i];\n            nums[i] = ftmp;\n        }\n    }\n\n    void rotate(vector<int>& nums, int k) {\n        if(k > nums.size()){\n            k %= nums.size();\n        }\n        \n        reverse(nums, 0, nums.size()-k-1);\n        reverse(nums, nums.size()-k, nums.size()-1);\n        reverse(nums, 0, nums.size()-1);\n    }\n};\n\n```\n\n## 234. 回文链表\n\n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/palindrome-linked-list/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>请判断一个链表是否为回文链表。\n示例 1:\n输入: 1->2\n输出: false\n示例 2:\n输入: 1->2->2->1\n输出: true\n\n``` c++\nListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr != nullptr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n\n    ListNode* endOfFirstHalf(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (fast->next != nullptr && fast->next->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n    bool isPalindrome(ListNode* head) {\n        if(head == NULL)\n            return true;\n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode* firstHalfEnd = endOfFirstHalf(head);\n        ListNode* secondHalfStart = reverseList(firstHalfEnd->next);\n\n        // 判断是否回文\n        ListNode* p1 = head;\n        ListNode* p2 = secondHalfStart;\n        bool result = true;\n        while (result && p2 != nullptr) {\n            if (p1->val != p2->val) {\n                result = false;\n            }\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n\n        // 还原链表并返回结果\n        firstHalfEnd->next = reverseList(secondHalfStart);\n        return result;\n    }\n```\n\n## 283. 移动零\n\n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/move-zeroes/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n``` c++\n void moveZeroes(vector<int>& nums) {\n       for (int lastNonZeroFoundAt = 0, cur = 0; cur < nums.size(); cur++) {\n            if (nums[cur] != 0) {\n                swap(nums[lastNonZeroFoundAt], nums[cur]);\n                lastNonZeroFoundAt++;\n            }\n        }\n    }\n```\n\n## 287. 寻找重复数\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-the-duplicate-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n示例 1:\n输入: [1,3,4,2,2]\n输出: 2\n示例 2:\n输入: [3,1,3,4,2]\n输出: 3\n说明：\n\n>不能更改原数组（假设数组是只读的）。\n只能使用额外的 O(1) 的空间。\n时间复杂度小于 O(n2) 。\n数组中只有一个重复的数字，但它可能不止重复出现一次。\n\n``` c++\n int findDuplicate(vector<int>& nums) {\n        int slow = 0, fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        slow = 0;\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return slow;\n    }\n```\n\n## 299. 猜数字游戏\n* 299. Bulls and Cows\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/bulls-and-cows\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：\n你写出一个秘密数字，并请朋友猜这个数字是多少。\n朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。\n朋友根据提示继续猜，直到猜出秘密数字。\n请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。\n\n>xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。\n>yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。\n请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。\n\n \n\n>示例 1:\n输入: secret = \"1807\", guess = \"7810\"\n输出: \"1A3B\"\n解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。\n\n>示例 2:\n输入: secret = \"1123\", guess = \"0111\"\n输出: \"1A1B\"\n解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。\n\n>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等\n\n``` c++\nclass Solution {\npublic:\n    string getHint(string secret, string guess) {\n        int bulls = 0;\n        int cows = 0;\n        int ds[10]{0};\n        int dg[10]{0};\n        for(int i = 0; i < secret.size(); i++){\n            int x = secret[i] - '0';\n            int y = guess[i] - '0';\n            if(secret[i] == guess[i]){\n                bulls ++;    \n            }\n            ds[x] ++;\n            dg[y] ++;\n        }\n\n        //算出相同元素总数，当然减掉之前算好的cows\n        for(int i = 0;i < 10;i++){\n            cows += min(ds[i],dg[i]);\n        }\n        cows -= bulls;\n        ostringstream oss;\n        oss << bulls << \"A\" << cows << \"B\" ;\n        return oss.str();\n    }\n\n};  \n```\n\n## 463. 岛屿的周长\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/island-perimeter\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。\n网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n\n>示例 :\n输入:\n[[0,1,0,0],\n [1,1,1,0],\n [0,1,0,0],\n [1,1,0,0]]\n输出: 16\n\n``` c++\nclass Solution {\n    constexpr static int dx[4] = {0, 1, 0, -1};\n    constexpr static int dy[4] = {1, 0, -1, 0};\npublic:\n    int islandPerimeter(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j]) {\n                    int cnt = 0;\n                    for (int k = 0; k < 4; ++k) {\n                        int tx = i + dx[k];\n                        int ty = j + dy[k];\n                        if (tx < 0 || tx >= n || ty < 0 || ty >= m || !grid[tx][ty]) {\n                            cnt += 1;\n                        }\n                    }\n                    ans += cnt;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n\n## 1207.独一无二的出现次数\n* 1207. Unique Number of Occurrences\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/unique-number-of-occurrences\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。\n如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。\n\n>示例 1：\n输入：arr = [1,2,2,1,1,3]\n输出：true\n解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。\n示例 2：\n输入：arr = [1,2]\n输出：false\n示例 3：\n输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]\n输出：true\n\n``` c++\nbool uniqueOccurrences(vector<int>& arr) {\n\tmap<int, int> posMap;\n\tfor (int i = 0; i < arr.size(); i++)\n\t{\n\t\tposMap[arr[i]] += 1;\n\t}\n\n\tset<int> uniqueSet;\n\tfor (const auto& item : posMap)\n\t{\n\t\tuniqueSet.insert(item.second);\n\t}\n\n\treturn posMap.size() == uniqueSet.size();\n}\n```\n\n\n","source":"_posts/力扣刷题记录.md","raw":"---\ntitle: 力扣刷题记录\ncategories:\n- 算法\n---\n\n[toc]\n\n## 1. 两数之和\n* 1. Two Sum\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/two-sum\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n>示例:\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n```c++\n vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> result;\n        map<int, int> numsMap;\n        \n        for (int i = 0; i < nums.size(); i++)\n        {\n            int left = target - nums[i];\n\n            if (numsMap.count(left) > 0) {\n                result.push_back(numsMap[left]);\n                result.push_back(i);\n                break;\n            }\n            numsMap[nums[i]] = i;\n        }\n\n        return result;\n    }\n```\n\n## 2.两数相加\n* 2. Add Two Numbers\n \n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/add-two-numbers\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n>示例：\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n``` c++\n ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* head = new ListNode(-1);//存放结果的链表\n        ListNode* h = head;//移动指针\n        int sum = 0;//每个位的加和结果\n        bool carry = false;//进位标志\n        while (l1 != NULL || l2 != NULL)\n        {\n            sum = 0;\n            if (l1 != NULL)\n            {\n                sum += l1->val;\n                l1 = l1->next;\n            }\n            if (l2 != NULL)\n            {\n                sum += l2->val;\n                l2 = l2->next;\n            }\n            if (carry)\n                sum++;\n            h->next = new ListNode(sum % 10);\n            h = h->next;\n            carry = sum >= 10 ? true : false;\n        }\n        if (carry)\n        {\n            h->next = new ListNode(1);\n        }\n        ListNode* ptrDelete = head;\n        head = head->next;\n        delete ptrDelete;\n\n        return head;\n    }\n```\n\n## 3.无重复字符的最长子串\n * 3. Longest Substring Without Repeating Characters\n   \n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n>示例 1:\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n\n>输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n\n>输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n``` c++\nint lengthOfLongestSubstring(string s) {\n        map<char, int> posMap;\n        int ans = 0;\n        int start = 0;\n        int end = 0;\n\n        while (end < s.length()) {\n            char cur = s[end];\n            if (posMap.count(cur) > 0) {\n                start = max(posMap[cur],start);\n            }\n            ans = max(end - start + 1, ans);\n            posMap[cur] = end + 1;\n            end += 1;\n        }\n\n        return ans;\n    }\n```\n\n## 4. 寻找两个正序数组的中位数\n* 4. Median of Two Sorted Arrays\n  \n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。\n进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？\n\n\n>示例 1：\n输入：nums1 = [1,3], nums2 = [2]\n输出：2.00000\n解释：合并数组 = [1,2,3] ，中位数 2\n示例 2：\n输入：nums1 = [1,2], nums2 = [3,4]\n输出：2.50000\n解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n示例 3：\n输入：nums1 = [0,0], nums2 = [0,0]\n输出：0.00000\n示例 4：\n输入：nums1 = [], nums2 = [1]\n输出：1.00000\n示例 5：\n输入：nums1 = [2], nums2 = []\n输出：2.00000\n\n``` c++\nint getKthElement(const vector<int>& nums1, const vector<int>& nums2, int k) {\n        int m = nums1.size();\n        int n = nums2.size();\n        int index1 = 0, index2 = 0;\n\n        while (true) {\n            //处理边界\n            if (index1 == m)\n                return nums2[index2 + k -1];\n\n            if (index2 == n)\n                return nums1[index1 + k - 1];\n\n            if (k == 1)\n                return min(nums1[index1], nums2[index2]);\n\n            //* 正式处理，查找两个二序列表中第K大的数 *//\n\n            //拿出两个数组 k/2 -1位的数\n            int nIndex1 = min(index1 + k / 2 - 1, m-1);\n            int nIndex2 = min(index2 + k / 2 - 1,n-1);\n\n            //数组二大！数组一的[0]-[k/2-1]被移去算法范围\n            if (nums1[nIndex1] <= nums2[nIndex2]) {\n                k -= nIndex1 + 1 - index1;//个数已经比较完，继续剩下的数的比较\n                index1 = nIndex1 + 1;\n            }\n            else{//相关\n                k -= nIndex2 + 1 - index2;//个数已经比较完，继续剩下的数的比较\n                index2 = nIndex2 + 1;\n            }\n        }\n    }\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int total = nums1.size() + nums2.size();\n\n        if (total % 2 == 1) {\n            //奇数个\n            return getKthElement(nums1, nums2, (total+1) / 2);\n        }\n        else {\n            //偶数个\n            return (getKthElement(nums1, nums2, (total / 2)) + getKthElement(nums1, nums2, total/2 +1)) / 2.0;\n        }\n    }\n```\n\n## 5. 最长回文子串\n* 5. Longest Palindromic Substring\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n示例 1：\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n示例 2：\n输入: \"cbbd\"\n输出: \"bb\"\n\n\n\n> 暴力解法：\n\n``` c++\nbool validatePalindrome(string s, int i, int j) {\n\twhile (i < j) {\n\t\tif (s[i] != s[j]) {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t\tj--;\n\t}\n\treturn true;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n\t\n\tif (s == \"\" || s.length() < 2)\n\t\treturn s;\n\n\tint begin = 0;\n\tint maxLen = 1;\n\tfor (int i = 0; i < s.length()-1; i++)\n\t{\n\t\tfor (int j = i+1; j < s.length(); j++)\n\t\t{\n\t\t\tif (((j - i + 1) > maxLen) && validatePalindrome(s, i, j)) {\n\t\t\t\tmaxLen = (j - i + 1);\n\t\t\t\tbegin = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn s.substr(begin, maxLen);\n}\n```\n> 中心扩散法\n\n``` c++\nint expandAroundCenter(string s, int left, int right) {\n\tint len = s.length();\n\tint i = left;\n\tint j = right;\n\twhile (i >= 0 && j < len) {\n\t\tif (s[i] == s[j]) {\n\t\t\ti--;\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn j - i +1 - 2;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n\tif (s == \"\" || s.length() < 2)\n\t\treturn s;\n\n\tint begin = 0;\n\tint maxLen = 1;\n\tfor (int i = 0; i < s.length() - 1; i++)\n\t{\n\t\tint oddLen = expandAroundCenter(s, i, i);\n\t\tint eveLen = expandAroundCenter(s, i, i+1);\n\n\t\tint curMaxLen = max(oddLen, eveLen);\n\t\tif (curMaxLen > maxLen) {\n\t\t\tmaxLen = curMaxLen;\n\t\t\tbegin = i - (curMaxLen - 1) / 2;\n\t\t}\n\t}\n\n\treturn s.substr(begin, maxLen);\n\n}\n```\n> 动态规划\n\n``` c++\nstring QuestionHandler::longestPalindrome(string s) {\n\tif (s == \"\" || s.length() < 2)\n\t\treturn s;\n\n\tint len = s.length();\n\tint begin = 0;\n\tint maxLen = 1;\n\tvector<vector<int>> dp(len, vector<int>(len));\n\tfor (int j = 1; j < len; j++) {\n\t\tfor (int i = 0; i < j; i++) {\n\t\t\tif (s[i] != s[j]) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (j - i < 3) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dp[i][j] && (j - i + 1) > maxLen) {\n\t\t\t\tmaxLen = j - i + 1;\n\t\t\t\tbegin = i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn s.substr(begin, maxLen);\n}\n```\n\n![动态规划解法](/img/1603943631534.png)\n\n> Manacher算法 - O(n)\n\n``` c++\nint expand(const string& s, int left, int right) {\n\twhile (left >= 0 && right < s.size() && s[left] == s[right]) {\n\t\t--left;\n\t\t++right;\n\t}\n\treturn (right - left - 2) / 2;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n\tint start = 0, end = -1;\n\tstring t = \"#\";\n\tfor (char c : s) {\n\t\tt += c;\n\t\tt += '#';\n\t}\n\tt += '#';\n\ts = t;\n\n\tvector<int> arm_len;\n\tint right = -1, j = -1;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tint cur_arm_len;\n\t\tif (right >= i) {\n\t\t\tint i_sym = j * 2 - i;\n\t\t\tint min_arm_len = min(arm_len[i_sym], right - i);\n\t\t\tcur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);\n\t\t}\n\t\telse {\n\t\t\tcur_arm_len = expand(s, i, i);\n\t\t}\n\t\tarm_len.push_back(cur_arm_len);\n\t\tif (i + cur_arm_len > right) {\n\t\t\tj = i;\n\t\t\tright = i + cur_arm_len;\n\t\t}\n\t\tif (cur_arm_len * 2 + 1 > end - start) {\n\t\t\tstart = i - cur_arm_len;\n\t\t\tend = i + cur_arm_len;\n\t\t}\n\t}\n\n\tstring ans;\n\tfor (int i = start; i <= end; ++i) {\n\t\tif (s[i] != '#') {\n\t\t\tans += s[i];\n\t\t}\n\t}\n\treturn ans;\n}\n```\n\n## 6.Z 字形变换\n* 6. ZigZag Conversion\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/zigzag-conversion\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例 1:\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n示例 2:\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n解释:\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n\n``` c++\n  string convert(string s, int numRows) {\n        if (numRows == 1) return s;\n\n        int rowIdx = 0;\n        vector<string> rowStrs(numRows);\n        bool goingDown = false;\n        for (char c : s) {\n            rowStrs[rowIdx] += c;\n            if (rowIdx == 0 || rowIdx == numRows - 1) goingDown = !goingDown;\n            rowIdx += goingDown ? 1 : -1;\n        }\n\n        string result;\n        for (string row : rowStrs) result += row;\n        return result;\n    }\n```\n\n## 7. 整数反转\n* 7. Reverse Integer\n \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/reverse-integer\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例 1:\n输入: 123\n输出: 321\n 示例 2:\n输入: -123\n输出: -321\n示例 3:\n输入: 120\n输出: 21\n\n``` c++\n  int reverse(int x) {\n         int ans = 0;\n        while (x != 0) {\n            if (ans > 214748364 || ans < -214748364) {\n                return 0;\n            }\n            ans = ans*10 + x % 10;\n            x /= 10;\n        }\n\n        return ans;\n    }\n```\n\n## 8. 字符串转换整数 (atoi)\n* 8. String to Integer (atoi)\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/string-to-integer-atoi\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>请你来实现一个 atoi 函数，使其能将字符串转换成整数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：\n如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。\n假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。\n该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0 。\n提示：\n本题中的空白字符只包括空格字符 ' ' 。\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n\n>示例 1:\n输入: \"42\"\n输出: 42\n示例 2:\n输入: \"   -42\"\n输出: -42\n解释: 第一个非空白字符为 '-', 它是一个负号。\n     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n示例 3:\n输入: \"4193 with words\"\n输出: 4193\n解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。\n示例 4:\n输入: \"words and 987\"\n输出: 0\n解释: 第一个非空字符是 'w', 但它不是数字或正、负号。\n     因此无法执行有效的转换。\n示例 5:\n输入: \"-91283472332\"\n输出: -2147483648\n解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 \n     因此返回 INT_MIN (−231) 。\n\t \n``` c++\nclass Automaton {\n    string state = \"start\";\n    unordered_map<string, vector<string>> table = {\n        {\"start\", {\"start\", \"signed\", \"in_number\", \"end\"}},\n        {\"signed\", {\"end\", \"end\", \"in_number\", \"end\"}},\n        {\"in_number\", {\"end\", \"end\", \"in_number\", \"end\"}},\n        {\"end\", {\"end\", \"end\", \"end\", \"end\"}}\n    };\n\n    int get_col(char c) {\n        if (isspace(c)) return 0;\n        if (c == '+' or c == '-') return 1;\n        if (isdigit(c)) return 2;\n        return 3;\n    }\npublic:\n    int sign = 1;\n    long long ans = 0;\n\n    void get(char c) {\n        state = table[state][get_col(c)];\n        if (state == \"in_number\") {\n            ans = ans * 10 + c - '0';\n            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);\n        }\n        else if (state == \"signed\")\n            sign = c == '+' ? 1 : -1;\n    }\n};\n\nint myAtoi(string s) {\n         Automaton automaton;\n        for (char c : s)\n            automaton.get(c);\n        return automaton.sign * automaton.ans;\n    }\n```\n\n## 9.回文数\n* 9. Palindrome Number\n  \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/palindrome-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n示例 1:\n输入: 121\n输出: true\n示例 2:\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3:\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n``` c++\n bool isPalindrome(int x) {\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        //后半段与前半段对比\n        int revertedNumber = 0;\n        while (x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        return x == revertedNumber || x == revertedNumber / 10;\n    }\n```\n\n## 10. 正则表达式匹配\n* 10. Regular Expression Matching\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/regular-expression-matching\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n\n> '.' 匹配任意单个字符\n'\\*' 匹配零个或多个前面的那一个元素\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n\n \n>示例 1：\n输入：s = \"aa\" p = \"a\"\n输出：false\n解释：\"a\" 无法匹配 \"aa\" 整个字符串。\n\n>示例 2:\n输入：s = \"aa\" p = \"a*\"\n输出：true\n解释：因为 '\\*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n\n>示例 3：\n输入：s = \"ab\" p = \".\\*\"\n输出：true\n解释：\".\\*\" 表示可匹配零个或多个（'\\*'）任意字符（'.'）。\n\n>示例 4：\n输入：s = \"aab\" p = \"c\\*a\\*b\"\n输出：true\n解释：因为 '\\*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n>示例 5：\n输入：s = \"mississippi\" p = \"mis\\*is\\*p\\*.\"\n输出：false\n\n``` c++\nbool isMatch(string s, string p) {\n\t// dp[i][j]表示str[1:i]和pattern[1:j]能否匹配，为0表示无法匹配，为1表示可以匹配\n//\n// 分析状态转移方程\n//   对于dp[i][j]，如果str[i]与p[j]相同或者p[j]为.，则dp[i][j] = dp[i-1][j-1]，即与s[1:i-1]和p[1:j-1]的匹配情况相同\n//   如果p[j]为*，则表示这个字符可以联合p[j-1]使用来匹配当前的s[i](这个选择可做可不做，但我们尽量去匹配字符串)\n//   考虑p[j]为*，如果p前一个字符为.，显然可以用一次.*组合匹配到s[i]，如果p前一个字符p[j-1]不为.并且不与s[i]相同，则不能使用\n//   综合考虑，若p[j]=='*'\n//   1. 不选择替换，使用0次*，dp[i][j] = dp[i][j-2]\n//   2. 当p[j-1]为.或者与s[i]相同时，可以使用一次替换，则dp[i][j] = dp[i-1][j]\n//   两者求或 (因为我们尽可能去匹配字符串，所以只要有一种情况匹配成功，则匹配成功)\n// 初始化主要考虑p去匹配一个空串的情况，和上面类似的分析过程即可得出结论\n\n\t//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配\n\tvector<vector<bool>> dp(s.size() + 1, vector<bool>(p.size() + 1));\n\tdp[0][0] = true;\n\n\t//s 的前 0 个是否能被 p 的前 j 个匹配\n\tfor (size_t j = 1; j < p.size(); ++j)\n\t{\n\t\tif (p[j] == '*')\n\t\t{\n\t\t\tdp[0][j + 1] = dp[0][j - 1];\n\t\t}\n\t}\n\n\tfor (size_t i = 0; i < s.size(); ++i)\n\t{\n\t\tfor (size_t j = 0; j < p.size(); ++j)\n\t\t{\n\t\t\tif (s[i] == p[j] || p[j] == '.')//匹配单个字符  \n\t\t\t{\n\t\t\t\tdp[i + 1][j + 1] = dp[i][j];\n\t\t\t}\n\t\t\telse if (p[j] == '*' && j > 0)\n\t\t\t{\n\t\t\t\tif (s[i] != p[j - 1] && p[j - 1] != '.')//前一对字符匹配\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j + 1] = dp[i + 1][j - 1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j + 1] = dp[i][j + 1] || //*表示匹配超过一个字符(s[i]、s[i-1]和p[j-1])\n\t\t\t\t\t\t//dp[i + 1][j] || //*表示只匹配一个字符（s[i]和p[j-1]）\n\t\t\t\t\t\tdp[i + 1][j - 1];//*表示0个匹配\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[s.size()][p.size()];\n}\n```\n\n\n\n## 11. 盛最多水的容器\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/container-with-most-water\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n说明：你不能倾斜容器，且 n 的值至少为 2。\n\n>示例：\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n\n``` c++\nint maxArea(vector<int>& height) {\n        int n = height.size();\n        if (n < 2)\n            return 0;\n\n        int maxVolume = 0;\n        int left = 0;\n        int right = n - 1;\n        \n        while(left < right){\n            //取左端与右端\n            int lh = height[left];\n            int rh = height[right];\n\n            //计算体积\n            int vol = min(lh, rh) * (right-left);\n            //设置最大体积\n            maxVolume = max(maxVolume, vol);\n\n            //哪端的指针移动，取决于哪根柱子更低\n            left += (lh <= rh) ? 1 : 0;\n            right -= (lh > rh) ? 1 : 0;\n\n            cout << \"left:\"<<left<<\",right:\"<<right<<endl;\n        }\n\n\n        return maxVolume;\n    }\n```\n## 17. 电话号码的字母组合\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n![17](/img/1604578953107.png)\n\n>示例:\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n说明:\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n``` c++\n  vector<string> letterCombinations(string digits) {\n        map<int,vector<char>> numsMap;\n        numsMap.insert(map< int, vector<char>>::value_type(2, vector<char>{'a', 'b', 'c'}));\n        numsMap.insert(map< int, vector<char>>::value_type(3, vector<char>{'d', 'e', 'f'}));\n        numsMap.insert(map< int, vector<char>>::value_type(4, vector<char>{'g', 'h', 'i'}));\n        numsMap.insert(map< int, vector<char>>::value_type(5, vector<char>{'j', 'k', 'l'}));\n        numsMap.insert(map< int, vector<char>>::value_type(6, vector<char>{'m', 'n', 'o'}));\n        numsMap.insert(map< int, vector<char>>::value_type(7, vector<char>{'p', 'q', 'r','s'}));\n        numsMap.insert(map< int, vector<char>>::value_type(8, vector<char>{'t', 'u', 'v'}));\n        numsMap.insert(map< int, vector<char>>::value_type(9, vector<char>{'w', 'x', 'y','z'}));\n\n        /*输入：\"23\"\n            输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].*/\n        map<string, int> resultMap;\n        vector<string> result;\n        \n        for (int i = 0; i < digits.size(); i++) {\n            int v = digits[i] - '0';\n            if (numsMap.count(v) == 0) {\n                result.clear();\n                break;\n            }\n            vector<char> curChars = numsMap[v];\n            if (i > 0) {\n                vector<string> tmpList;\n                for(string val : result) {\n                    for (char c : curChars) {\n                        tmpList.push_back(val + c);\n                    }\n                }\n                result.clear();\n                result = tmpList;\n            }\n            else {\n                for (auto it = curChars.begin(); it != curChars.end(); it++) {\n                  \tchar v = *it;\n\t\t\t\t    result.push_back(string (1,v));\n                }\n            }\n        }\n\n        return result;\n    }\n```\n\n## 15.三数之和\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/3sum\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n\n>示例：\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n\n``` c++\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());   // -4  -1  -1  0  1  2\n        vector<vector<int>> res;\n        for(int i=0; i<nums.size(); i++){\n            if(i > 0 && nums[i] == nums[i-1]){\n                continue;\n            }\n            int j = i+1, k = nums.size() -1;\n            while(j < k){\n                if(j > i+1 && nums[j] == nums[j-1]){\n                    j++;\n                    continue;\n                }\n                if(k < nums.size()-1 && nums[k] == nums[k+1]){\n                    k--;\n                    continue;\n                }\n                if(nums[j] + nums[k] > -1*nums[i]){\n                    k--;\n                }else if(nums[j] + nums[k] < -1*nums[i]){\n                    j++;\n                }else{\n                    res.push_back({nums[i], nums[j], nums[k]});\n                    j++, k--;\n                }\n            }\n        }\n        return res;\n    }\n```\n\n## 19.删除链表的倒数第N个节点\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n示例：\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n说明：\n给定的 n 保证是有效的。\n进阶：\n你能尝试使用一趟扫描实现吗？\n\n``` c++\n  ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* pre = NULL;\n\n        for (int i = 0; i < n; i++)\n        {\n            fast = fast->next;\n        }\n\n        while (fast != NULL) {\n            pre = slow;\n            slow = slow->next;\n            fast = fast->next;\n        }\n        \n        if (pre != NULL) {\n            pre->next = slow->next;\n            return head;\n        }\n        else {\n            return head->next;\n        }\n\n    }\n\t\n```\n\n## 20. 有效的括号\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-parentheses\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n有效字符串需满足：\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n注意空字符串可被认为是有效字符串。\n\n>示例 1:\n输入: \"()\"\n输出: true\n示例 2:\n输入: \"()[]{}\"\n输出: true\n示例 3:\n输入: \"(]\"\n输出: false\n示例 4:\n输入: \"([)]\"\n输出: false\n示例 5:\n输入: \"{[]}\"\n输出: true\n\n``` c++\n bool isValid(string s) {\n        map<char, char> cMap = {\n            {']','['},\n            {'}','{'},\n            {')','('},\n        };\n\n        if (s.size() % 2 == 1)//奇数必然不对\n            return false;\n\n        stack<char> cs;\n        for (char c : s) {\n            if (cMap.count(c)) {\n                if (cs.empty() || cs.top() != cMap[c]) {\n                    return false;\n                }\n                cs.pop();\n            }\n            else {\n                cs.push(c);\n            }\n        }\n        return cs.size() == 0;\n    }\n```\n\n## 22. 括号生成\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/generate-parentheses\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n>示例：\n输入：n = 3\n输出：[\n       \"((()))\",\n       \"(()())\",\n       \"(())()\",\n       \"()(())\",\n       \"()()()\"\n     ]\n\n\n``` c++\n void LoopGetParanthesis(vector<string> & result,string str,int left, int right) {\n        if (left == 0 && right == 0) {\n            result.push_back(str);\n            return;\n        }\n        \n        //左右括号数相等，则只用左括号\n        if (left == right) {\n            LoopGetParanthesis(result, str + \"(\", left - 1, right);\n        }\n        else if(left < right){\n            if (left > 0) {\n                LoopGetParanthesis(result, str + \"(\", left-1, right);\n            }\n            LoopGetParanthesis(result, str + \")\", left, right - 1);\n        }\n    }\n    vector<string> generateParenthesis(int n) {\n        vector<string> result;\n        string str = \"\";\n        LoopGetParanthesis(result, str, n, n);\n\n        return result;\n    }\n```\n\n## 26.删除排序数组中的重复项\n* 26. Remove Duplicates from Sorted Array\n \n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n>示例 1:\n给定数组 nums = [1,1,2], \n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n你不需要考虑数组中超出新长度后面的元素。\n\n>示例 2:\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n你不需要考虑数组中超出新长度后面的元素。\n\n``` c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size() ==0) return 0;\n        int thumb = 0;\n        \n        for(int i = 1;i < nums.size(); i++){\n            if(nums[i] != nums[thumb]){\n                thumb ++;\n                nums[thumb] = nums[i];\n            }\n        }\n        return thumb+1;\n    }\n};\n```\n\n## 27. 移除元素\n* 27. Remove Element\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-element\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n>示例 1:\n给定 nums = [3,2,2,3], val = 3,\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n你不需要考虑数组中超出新长度后面的元素。\n\n>示例 2:\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n注意这五个元素可为任意顺序。\n你不需要考虑数组中超出新长度后面的元素。\n\n``` c++\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int thumb = 0;\n        for(int i = 0; i < nums.size(); i++){\n            if(nums[i] != val){\n                nums[thumb] = nums[i];\n                thumb ++;\n            }\n        }\n        return thumb;\n    }\n};\n```\n\n## 28. 实现 strStr()\n* 28. Implement strStr()\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/implement-strstr\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n\n>示例 1:\n输入: haystack = \"hello\", needle = \"ll\"\n输出: 2\n\n>示例 2:\n输入: haystack = \"aaaaa\", needle = \"bba\"\n输出: -1\n\n``` python\nclass Solution:\n    def strStr(self, source: str, target: str) -> int:\n        if source == target:\n            return 0\n\n        source_len = len(source)\n        target_len = len(target)\n\n        if target_len > source_len:\n            return -1\n\n        for i in range(source_len):\n            target_index = i + target_len\n            if target_index > source_len:\n                continue\n            if source[i:target_index] == target:\n                return i\n\n        return -1\n```\n\n## 29. 两数相除\n* 29. Divide Two Integers\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/divide-two-integers\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n返回被除数 dividend 除以除数 divisor 得到的商。\n整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n\n \n>示例 1:\n输入: dividend = 10, divisor = 3\n输出: 3\n解释: 10/3 = truncate(3.33333..) = truncate(3) = 3\n\n>示例 2:\n输入: dividend = 7, divisor = -3\n输出: -2\n解释: 7/-3 = truncate(-2.33333..) = -2\n \n\n>提示：\n被除数和除数均为 32 位有符号整数。\n除数不为 0。\n假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。\n\n``` python\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n        if abs_dividend < abs_divisor:\n            return 0\n\n        is_neg = 0\n        if abs(dividend + divisor) != abs_dividend + abs_divisor:\n            is_neg = 1\n        ans = 0\n\n        for i in range(31, -1, -1):\n            print('abs_dividend >> %d : %d, %d, '% (i, abs_dividend >> i, abs_divisor))\n\n            if abs_dividend >> i >= abs_divisor:\n                ans += 1 << i\n                abs_dividend -= abs_divisor << i\n                print('good value: %d, %d'%(ans, abs_dividend))\n\n        if is_neg and ans >= 2 ** 31:\n            return -2 ** 31\n        elif ans >= 2 ** 31:\n            return 2 ** 31 - 1\n        elif is_neg:\n            return -ans\n        else:\n            return ans\n```\n\n## 30. 串联所有单词的子串\n* 30. Substring with Concatenation of All Words\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。\n\n\n>示例 1：\n输入：\n  s = \"barfoothefoobarman\",\n  words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n\n>示例 2：\n输入：\n  s = \"wordgoodgoodgoodbestword\",\n  words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n\n``` python\nclass Solution(object):\n    def findSubstring(self, s, words):\n        from collections import Counter\n        if not s or not words:return []\n        one_word = len(words[0])\n        all_len = len(words) * one_word\n        n = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0, n - all_len + 1):\n            tmp = s[i:i+all_len]\n            c_tmp = []\n            for j in range(0, all_len, one_word):\n                c_tmp.append(tmp[j:j+one_word])\n            if Counter(c_tmp) == words:\n                res.append(i)\n        return res\n```\n\n\n## 41. 缺失的第一个正数\n* 41. First Missing Positive\n \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/first-missing-positive\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。\n\n>示例 1:\n输入: [1,2,0]\n输出: 3\n\n>示例 2:\n输入: [3,4,-1,1]\n输出: 2\n\n>示例 3:\n输入: [7,8,9,11,12]\n输出: 1\n \n\n>提示：\n你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。\n\n``` c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n         // 总长\n        int n = nums.size();\n        // 1. 全部元素没有1，返回1\n        bool noOne = true;\n        for(int i = 0; i < nums.size();i++){\n            if(nums[i] == 1)\n            {\n                noOne = false;\n                break;\n            }\n        }\n        if(noOne){\n            return 1;\n        }\n\n        //2. 只有一个元素，且为[1]，则返回2\n        if(n == 1)\n        {\n            return 2;\n        }\n\n        //3. 去<= 0与 > 总数的数，将其设为1\n        for(int i = 0; i < n;i++){\n            if(i == n-1){\n                cout << nums[i] << endl;\n            }\n            if(nums[i] < 1 || nums[i] > n){\n                nums[i] = 1;\n            }\n        }\n  \n\n        //4.遍历，当值 == 总数。第一个值设为负数. 当值 <= 总数，以值为下标设置为负值. 特别的，当值为总数时，将第一个值为负值！\n         for(int i = 0; i < n; i++){\n             int a = abs(nums[i]);\n             if(a == n){\n                 nums[0] = - abs(nums[0]);\n             }else{\n                nums[a] = - abs(nums[a]);\n             }\n         }\n\n        for(int v: nums){\n            cout << v << \",\";\n        }\n        cout << endl;\n\n        //5.遍历最新的数组中，发现有大于0，此索引就是丢失的最小正数\n        for(int i = 1; i < n;i++){\n            if(nums[i] > 0){\n                return i;\n            }\n        }\n\n        //6.5如果没有找到，第一值取出来如果是正数，则数为正数N\n        if(nums[0] > 0){\n            return n;\n        }\n\n        //7.如果以上走完了，返回n+1\n        return n+1;\n    }\n};\n```\n\n## 42. 接雨水\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/trapping-rain-water\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n\n![接雨水](/img/1604063667003.png)\n\n>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n示例 2：\n输入：height = [4,2,0,3,2,5]\n输出：9\n\n``` c++\n  int trap(vector<int>& height) {\n        int left = 0, right = height.size() - 1;\n        int ans = 0;\n        int left_max = 0, right_max = 0;\n        while (left < right) {\n            //情况1：左比右低，只有当左边最高柱比当前柱要高，则这个落差必定是能装水的。\n            if (height[left] < height[right]) {\n                height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);\n                ++left;\n            }\n            else {//情况2：右比左低，只有当右边最高柱比当前柱要高，则这个落差必定是能装水的。\n                height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);\n                --right;\n            }\n        }\n        return ans;\n    }\n```\n## 51. N皇后 & 52. N皇后 II\n* 51. N-Queens\n* 52. N-Queens II\n \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/n-queens\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n![8皇后的一种解法](/img/1601178139148.png)\n\n>51. 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n>52. 给定一个整数 n，返回 n 皇后不同的解决方案的数量。\n\n\n``` python\nclass NQueen:\n    def __init__(self):\n        self.count = 0\n\n    def do_nqueen(self, n):\n        empty_sign = \"[O]\"\n        queen_sign = \"[1]\"\n        # 所有数组起点都以0开始\n\n        # 1.定义所有解的容器，二维数组，第二维代表一个完整的解\n        ans = []\n\n        # 2.递归函数dfs\n        def dfs(nums, row):\n            # 如果找的行数与n相等了，说明已经找完了，得到一个解！\n            if row == n:\n                ans.append(nums[:]) # 注意不可用ans.append(nums)\n                return\n            # 逐列进行尝试，列的总数为n\n            for i in range(n):\n                # 每进行到一列，标记当前行皇后位置为此列\n                nums[row] = i\n                # 往下递归找到，一直找到底，找不到底循环会返回到此处！\n                if valid(nums, row):\n                    # print(\"当前找到第%d行的第%d列，此值可放皇后！\"%(row, i))\n                    dfs(nums, row+1)\n                else:\n                    pass\n                    # print(\"当前找到第%d行的第%d列，不可放，回溯\"%(row, i))\n\n        # 3.检查函数valid\n        def valid(nums, row):\n            # 只找前面行的点， 皇后攻击规则，同列同行 和 对角线元素表示\n            for r in range(row):\n                if abs(nums[r] - nums[row]) == abs(r - row) or nums[r] == nums[row]:\n                    return False\n            return True\n\n        # 4.执行, 从第0行开始找n数组长度中的位置\n        dfs([None for _ in range(n)], 0)\n\n        def get_row_list(row_val, count):\n            result = []\n            for i in range(count):\n                if i == row_val:\n                    result.append(queen_sign)\n                else:\n                    result.append(empty_sign)\n            return result\n\n\n        # 5.结果画出来\n        result = [[] for _ in range(len(ans))]\n        for i in range(len(ans)):\n            for col in ans[i]:\n                result[i].append(\"\".join(get_row_list(col, n)))\n\n        return result\n\n\nmyqueen = NQueen()\nresult = myqueen.do_nqueen(4)\nprint(\"解有%d个\"%len(result))\nfor r in result:\n    r = str(r)\n    print(r+\"\\n\\n\")\n```\n\n## 75. 颜色分类\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sort-colors\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n注意:\n不能使用代码库中的排序函数来解决这道题。\n示例:\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n进阶：\n一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n``` c++\n void sortColors(vector<int>& nums) {\n       int n = nums.size();\n        int slow0 = 0, fast = 0, slow2 = n - 1;\n\n        while (fast <= slow2) {\n            while (fast <= slow2 && nums[fast] == 2) {\n                //当当前快指针为2时，移至结尾。如果换完后的nums[fast]还是2？则继续换\n                nums[fast] = nums[slow2];\n                nums[slow2--] = 2;\n            }\n            \n            if (nums[fast] == 0) {\n                nums[fast] = nums[slow0];\n                nums[slow0++] = 0;\n            }\n            fast++;\n        }\n    }\n```\n\n## 76.最小覆盖子串\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-window-substring\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。\n示例：\n输入：S = \"ADOBECODEBANC\", T = \"ABC\"\n输出：\"BANC\"\n\n>提示：\n如果 S 中不存这样的子串，则返回空字符串 \"\"。\n如果 S 中存在这样的子串，我们保证它是唯一的答案。\n\n```c++\n string minWindow(string s, string t) {\n        if(s == t) return s;\n\n        map<char, int> need, window;\n        int tLen = t.length();//目标字符串\n        int sLen = s.length();\n        if (tLen == 0 || sLen == 0) return \"\";\n        if (sLen < tLen )\n            return \"\";\n\n        //先把t中的字符放到need表中，计数\n        for (int i = 0; i < tLen; i++) {\n            char c = t[i];\n            need[c] = ((need.count(c) == 0)?0:need[c]) + 1;\n        }\n\n        int left = 0, right = 0;\n        int len = INT32_MAX, start = 0;\n        int valid = 0; //已经匹配成功的字符种类数（非字符个数）\n\n        //当右指针去到字符串末尾前\n        while (right < sLen) {\n            char c = s[right];\n            right++;//右指针向右滑\n\n            //如果右指针现在滑到的字符是目标字符串的一个，那么更新窗口中的数据\n            if (need.count(c) > 0) {\n                window[c] = ((window.count(c) == 0)?0:window[c]) + 1;\n                if (window[c] == (need[c])) {\n                    valid++;\n                }\n            }\n\n            //窗口开始从左边收缩\n            while (valid == need.size()) {\n                if (right - left < len) {\n                    start = left;\n                    len = right - left;\n                }\n                \n                char d = s[left];\n                left++;\n\n                if (need.count(d) > 0) {\n                    if (window[d] == (need[d])) {\n                        valid--;\n                    }\n                    window[d] = window[d] - 1;\n                }\n            }\n        }\n        return len == INT32_MAX ? \"\" : s.substr(start, len);\n    }\n```\n\n## 80. 删除排序数组中的重复项 II\n* 80. Remove Duplicates from Sorted Array II\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n>示例 1:\n给定 nums = [1,1,1,2,2,3],\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n你不需要考虑数组中超出新长度后面的元素。\n\n>示例 2:\n给定 nums = [0,0,1,1,1,1,2,3,3],\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n你不需要考虑数组中超出新长度后面的元素。\n\n>说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n\n``` c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n      int i = 0;\n        for (int n : nums) {\n            if (i < 2 || n > nums[i-2]) nums[i++] = n;\n        }\n        return i;\n    }\n};\n```\n\n## 127. 单词接龙\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/word-ladder\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：\n每次转换只能改变一个字母。\n转换过程中的中间单词必须是字典中的单词。\n\n >说明:\n如果不存在这样的转换序列，返回 0。\n所有单词具有相同的长度。\n所有单词只由小写字母组成。\n字典中不存在重复的单词。\n你可以假设 beginWord 和 endWord 是非空的，且二者不相同。\n\n>示例 1:\n输入:\nbeginWord = \"hit\",\nendWord = \"cog\",\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n输出: 5\n解释: 一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\n     返回它的长度 5。\n示例 2:\n输入:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n输出: 0\n解释: endWord \"cog\" 不在字典中，所以无法进行转换。\n\n``` c++\nclass Solution {\n    unordered_map<string, int> wordId;\n    vector<vector<int>> edge;\n    int nodeNum = 0;\n\n    void addWord(string& word) {\n        if (!wordId.count(word)) {\n            wordId[word] = nodeNum++;\n            edge.emplace_back();\n        }\n    }\n\n    void addEdge(string& word) {\n        addWord(word);\n        int id1 = wordId[word];\n        for (char& it : word) {\n            char tmp = it;\n            it = '*';\n            addWord(word);\n            int id2 = wordId[word];\n            edge[id1].push_back(id2);\n            edge[id2].push_back(id1);\n            it = tmp;\n        }\n    }\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        for (string& word : wordList) {\n            addEdge(word);\n        }\n        addEdge(beginWord);\n        if (!wordId.count(endWord)) {\n            return 0;\n        }\n        vector<int> dis(nodeNum, INT_MAX);\n        int beginId = wordId[beginWord], endId = wordId[endWord];\n        dis[beginId] = 0;\n\n        queue<int> que;\n        que.push(beginId);\n        while (!que.empty()) {\n            int x = que.front();\n            que.pop();\n            if (x == endId) {\n                return dis[endId] / 2 + 1;\n            }\n            for (int& it : edge[x]) {\n                if (dis[it] == INT_MAX) {\n                    dis[it] = dis[x] + 1;\n                    que.push(it);\n                }\n            }\n        }\n        return 0;\n    }\n\n};\n```\n\n## 129.求根到叶子节点数字之和\n* 129. Sum Root to Leaf Numbers\n* \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。\n例如，从根到叶子节点路径 1->2->3 代表数字 123。\n计算从根到叶子节点生成的所有数字之和。\n说明: 叶子节点是指没有子节点的节点。\n\n示例 1:\n输入: [1,2,3]\n    1\n   / \\\n  2   3\n输出: 25\n解释:\n从根到叶子节点路径 1->2 代表数字 12.\n从根到叶子节点路径 1->3 代表数字 13.\n因此，数字总和 = 12 + 13 = 25.\n示例 2:\n\n输入: [4,9,0,5,1]\n    4\n   / \\\n  9   0\n / \\\n5   1\n输出: 1026\n解释:\n从根到叶子节点路径 4->9->5 代表数字 495.\n从根到叶子节点路径 4->9->1 代表数字 491.\n从根到叶子节点路径 4->0 代表数字 40.\n因此，数字总和 = 495 + 491 + 40 = 1026.\n\n``` c++\nint bfs_sum(TreeNode* root) {\n\tif(root == NULL)\n\t\treturn 0;\n\tint sum = 0;\n\tqueue<TreeNode*> q;\n\tqueue<int> qn;\n\n\tq.push(root);\n\tqn.push(root->val);\n\n\twhile (!q.empty()) {\n\t\tTreeNode* node = q.front();\n\t\tint nodeVal = qn.front();\n\t\tq.pop();\n\t\tqn.pop();\n\n\t\tif ((node->left == NULL) && (node->right == NULL)) {\n\t\t\tsum += nodeVal;\n\t\t}\n\t\telse {\n\t\t\tif (node->left != NULL) {\n\t\t\t\tq.push(node->left);\n\t\t\t\tqn.push(nodeVal * 10 + node->left->val);\n\t\t\t}\n\t\t\tif (node->right != NULL) {\n\t\t\t\tq.push(node->right);\n\t\t\t\tqn.push(nodeVal * 10 + node->right->val);\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\nint dfs_sum(TreeNode* node, int prevSum) {\n\tif(node == NULL)\n\t\treturn 0;\n\n\tint sum = prevSum * 10 + node->val;\n\t//左右都没有值 \n\tif ((node->left == NULL) &&(node->right == NULL)) {\n\t\treturn sum;\n\t}\n\telse {\n\t\tsum = dfs_sum(node->left, sum) + dfs_sum(node->right, sum);\n\t}\n\n\treturn sum;\n}\n\nint sumNumbers(TreeNode* root) {\n\t\t//return dfs_sum(root, 0);\n\treturn bfs_sum(root);\n}\n```\n## 141. 环形链表\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/linked-list-cycle\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个链表，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n\n>进阶\n你能用 O(1)（即，常量）内存解决此问题吗？\n\n>输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n``` c++\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n       ListNode* slow = head;\n        ListNode* fast = head->next;\n        while (slow != fast) {\n            if (fast == NULL || fast->next == NULL)\n            {\n                return false;\n            }\n                \n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return true;\n    }\n```\n\n## 142. 环形链表 II\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/linked-list-cycle-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\n\n>输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n``` c++\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while(fast != NULL){\n            if(fast->next == NULL)\n                return nullptr;\n\n            slow = slow->next;\n            fast = fast->next->next;\n\n            if(slow == fast){\n                ListNode * ptr = head;\n                while(ptr != slow){\n                    ptr = ptr->next;\n                    slow = slow->next;\n                }\n                return ptr;\n            }\n        }\n        return nullptr;\n\n    }\n```\n\n## 144. 二叉树的前序遍历\n* 144. Binary Tree Preorder Traversal\n  \n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个二叉树，返回它的 前序 遍历。\n\n>示例:\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n输出: [1,2,3]\n\n``` c++\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> result;\n        if(root == NULL)\n            return result;\n        \n        stack<TreeNode> ss;\n        ss.push(*root);\n        \n        while(!ss.empty()){\n            TreeNode cur = ss.top();\n            ss.pop();\n\n            result.push_back(cur.val);\n\n            if(cur.right != NULL){\n                ss.push(*cur.right);\n            }\n            if(cur.left != NULL){\n                ss.push(*cur.left);\n            }\n        }\n        return result;\n    }\n```\n\n## 189. 旋转数组\n* 189. Rotate Array\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/rotate-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。\n\n>示例 1:\n输入: [1,2,3,4,5,6,7] 和 k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n\n>示例 2:\n输入: [-1,-100,3,99] 和 k = 2\n输出: [3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n\n>说明:\n尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n要求使用空间复杂度为 O(1) 的 原地 算法。\n\n``` c++\nclass Solution {\npublic:\n    void reverse(vector<int>& nums, int start, int end){\n        for(int i = start,j = end; i < j; i++,j--){\n            int ftmp = nums[j];\n            nums[j] = nums[i];\n            nums[i] = ftmp;\n        }\n    }\n\n    void rotate(vector<int>& nums, int k) {\n        if(k > nums.size()){\n            k %= nums.size();\n        }\n        \n        reverse(nums, 0, nums.size()-k-1);\n        reverse(nums, nums.size()-k, nums.size()-1);\n        reverse(nums, 0, nums.size()-1);\n    }\n};\n\n```\n\n## 234. 回文链表\n\n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/palindrome-linked-list/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>请判断一个链表是否为回文链表。\n示例 1:\n输入: 1->2\n输出: false\n示例 2:\n输入: 1->2->2->1\n输出: true\n\n``` c++\nListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr != nullptr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n\n    ListNode* endOfFirstHalf(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (fast->next != nullptr && fast->next->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n    bool isPalindrome(ListNode* head) {\n        if(head == NULL)\n            return true;\n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode* firstHalfEnd = endOfFirstHalf(head);\n        ListNode* secondHalfStart = reverseList(firstHalfEnd->next);\n\n        // 判断是否回文\n        ListNode* p1 = head;\n        ListNode* p2 = secondHalfStart;\n        bool result = true;\n        while (result && p2 != nullptr) {\n            if (p1->val != p2->val) {\n                result = false;\n            }\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n\n        // 还原链表并返回结果\n        firstHalfEnd->next = reverseList(secondHalfStart);\n        return result;\n    }\n```\n\n## 283. 移动零\n\n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/move-zeroes/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n``` c++\n void moveZeroes(vector<int>& nums) {\n       for (int lastNonZeroFoundAt = 0, cur = 0; cur < nums.size(); cur++) {\n            if (nums[cur] != 0) {\n                swap(nums[lastNonZeroFoundAt], nums[cur]);\n                lastNonZeroFoundAt++;\n            }\n        }\n    }\n```\n\n## 287. 寻找重复数\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-the-duplicate-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n示例 1:\n输入: [1,3,4,2,2]\n输出: 2\n示例 2:\n输入: [3,1,3,4,2]\n输出: 3\n说明：\n\n>不能更改原数组（假设数组是只读的）。\n只能使用额外的 O(1) 的空间。\n时间复杂度小于 O(n2) 。\n数组中只有一个重复的数字，但它可能不止重复出现一次。\n\n``` c++\n int findDuplicate(vector<int>& nums) {\n        int slow = 0, fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        slow = 0;\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return slow;\n    }\n```\n\n## 299. 猜数字游戏\n* 299. Bulls and Cows\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/bulls-and-cows\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：\n你写出一个秘密数字，并请朋友猜这个数字是多少。\n朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。\n朋友根据提示继续猜，直到猜出秘密数字。\n请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。\n\n>xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。\n>yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。\n请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。\n\n \n\n>示例 1:\n输入: secret = \"1807\", guess = \"7810\"\n输出: \"1A3B\"\n解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。\n\n>示例 2:\n输入: secret = \"1123\", guess = \"0111\"\n输出: \"1A1B\"\n解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。\n\n>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等\n\n``` c++\nclass Solution {\npublic:\n    string getHint(string secret, string guess) {\n        int bulls = 0;\n        int cows = 0;\n        int ds[10]{0};\n        int dg[10]{0};\n        for(int i = 0; i < secret.size(); i++){\n            int x = secret[i] - '0';\n            int y = guess[i] - '0';\n            if(secret[i] == guess[i]){\n                bulls ++;    \n            }\n            ds[x] ++;\n            dg[y] ++;\n        }\n\n        //算出相同元素总数，当然减掉之前算好的cows\n        for(int i = 0;i < 10;i++){\n            cows += min(ds[i],dg[i]);\n        }\n        cows -= bulls;\n        ostringstream oss;\n        oss << bulls << \"A\" << cows << \"B\" ;\n        return oss.str();\n    }\n\n};  \n```\n\n## 463. 岛屿的周长\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/island-perimeter\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。\n网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n\n>示例 :\n输入:\n[[0,1,0,0],\n [1,1,1,0],\n [0,1,0,0],\n [1,1,0,0]]\n输出: 16\n\n``` c++\nclass Solution {\n    constexpr static int dx[4] = {0, 1, 0, -1};\n    constexpr static int dy[4] = {1, 0, -1, 0};\npublic:\n    int islandPerimeter(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j]) {\n                    int cnt = 0;\n                    for (int k = 0; k < 4; ++k) {\n                        int tx = i + dx[k];\n                        int ty = j + dy[k];\n                        if (tx < 0 || tx >= n || ty < 0 || ty >= m || !grid[tx][ty]) {\n                            cnt += 1;\n                        }\n                    }\n                    ans += cnt;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n\n## 1207.独一无二的出现次数\n* 1207. Unique Number of Occurrences\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/unique-number-of-occurrences\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。\n如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。\n\n>示例 1：\n输入：arr = [1,2,2,1,1,3]\n输出：true\n解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。\n示例 2：\n输入：arr = [1,2]\n输出：false\n示例 3：\n输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]\n输出：true\n\n``` c++\nbool uniqueOccurrences(vector<int>& arr) {\n\tmap<int, int> posMap;\n\tfor (int i = 0; i < arr.size(); i++)\n\t{\n\t\tposMap[arr[i]] += 1;\n\t}\n\n\tset<int> uniqueSet;\n\tfor (const auto& item : posMap)\n\t{\n\t\tuniqueSet.insert(item.second);\n\t}\n\n\treturn posMap.size() == uniqueSet.size();\n}\n```\n\n\n","slug":"力扣刷题记录","published":1,"date":"2020-11-05T12:26:18.542Z","updated":"2020-11-05T12:26:18.542Z","_id":"ckgssh10v00324wf0xzpb5ud5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>[toc]</p>\n<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a>1. 两数之和</h2><ul>\n<li><ol>\n<li>Two Sum</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/two-sum\">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>\n</blockquote>\n<blockquote>\n<p>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>\n</blockquote>\n<pre><code class=\"c++\"> vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; result;\n        map&lt;int, int&gt; numsMap;\n\n        for (int i = 0; i &lt; nums.size(); i++)\n        {\n            int left = target - nums[i];\n\n            if (numsMap.count(left) &gt; 0) {\n                result.push_back(numsMap[left]);\n                result.push_back(i);\n                break;\n            }\n            numsMap[nums[i]] = i;\n        }\n\n        return result;\n    }</code></pre>\n<h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2.两数相加\"></a>2.两数相加</h2><ul>\n<li><ol start=\"2\">\n<li>Add Two Numbers</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/add-two-numbers\">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n</li>\n</ul>\n<blockquote>\n<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n</blockquote>\n<blockquote>\n<p>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>\n</blockquote>\n<pre><code class=\"c++\"> ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* head = new ListNode(-1);//存放结果的链表\n        ListNode* h = head;//移动指针\n        int sum = 0;//每个位的加和结果\n        bool carry = false;//进位标志\n        while (l1 != NULL || l2 != NULL)\n        {\n            sum = 0;\n            if (l1 != NULL)\n            {\n                sum += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2 != NULL)\n            {\n                sum += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            if (carry)\n                sum++;\n            h-&gt;next = new ListNode(sum % 10);\n            h = h-&gt;next;\n            carry = sum &gt;= 10 ? true : false;\n        }\n        if (carry)\n        {\n            h-&gt;next = new ListNode(1);\n        }\n        ListNode* ptrDelete = head;\n        head = head-&gt;next;\n        delete ptrDelete;\n\n        return head;\n    }</code></pre>\n<h2 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3.无重复字符的最长子串\"></a>3.无重复字符的最长子串</h2><ul>\n<li><ol start=\"3\">\n<li>Longest Substring Without Repeating Characters</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n</li>\n</ul>\n<blockquote>\n<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>\n</blockquote>\n<blockquote>\n<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>\n</blockquote>\n<blockquote>\n<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>\n</blockquote>\n<pre><code class=\"c++\">int lengthOfLongestSubstring(string s) {\n        map&lt;char, int&gt; posMap;\n        int ans = 0;\n        int start = 0;\n        int end = 0;\n\n        while (end &lt; s.length()) {\n            char cur = s[end];\n            if (posMap.count(cur) &gt; 0) {\n                start = max(posMap[cur],start);\n            }\n            ans = max(end - start + 1, ans);\n            posMap[cur] = end + 1;\n            end += 1;\n        }\n\n        return ans;\n    }</code></pre>\n<h2 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4. 寻找两个正序数组的中位数\"></a>4. 寻找两个正序数组的中位数</h2><ul>\n<li><ol start=\"4\">\n<li>Median of Two Sorted Arrays</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays\">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n</li>\n</ul>\n<blockquote>\n<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>\n</blockquote>\n<blockquote>\n<p>示例 1：<br>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：<br>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br>示例 3：<br>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000<br>示例 4：<br>输入：nums1 = [], nums2 = [1]<br>输出：1.00000<br>示例 5：<br>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p>\n</blockquote>\n<pre><code class=\"c++\">int getKthElement(const vector&lt;int&gt;&amp; nums1, const vector&lt;int&gt;&amp; nums2, int k) {\n        int m = nums1.size();\n        int n = nums2.size();\n        int index1 = 0, index2 = 0;\n\n        while (true) {\n            //处理边界\n            if (index1 == m)\n                return nums2[index2 + k -1];\n\n            if (index2 == n)\n                return nums1[index1 + k - 1];\n\n            if (k == 1)\n                return min(nums1[index1], nums2[index2]);\n\n            //* 正式处理，查找两个二序列表中第K大的数 *//\n\n            //拿出两个数组 k/2 -1位的数\n            int nIndex1 = min(index1 + k / 2 - 1, m-1);\n            int nIndex2 = min(index2 + k / 2 - 1,n-1);\n\n            //数组二大！数组一的[0]-[k/2-1]被移去算法范围\n            if (nums1[nIndex1] &lt;= nums2[nIndex2]) {\n                k -= nIndex1 + 1 - index1;//个数已经比较完，继续剩下的数的比较\n                index1 = nIndex1 + 1;\n            }\n            else{//相关\n                k -= nIndex2 + 1 - index2;//个数已经比较完，继续剩下的数的比较\n                index2 = nIndex2 + 1;\n            }\n        }\n    }\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        int total = nums1.size() + nums2.size();\n\n        if (total % 2 == 1) {\n            //奇数个\n            return getKthElement(nums1, nums2, (total+1) / 2);\n        }\n        else {\n            //偶数个\n            return (getKthElement(nums1, nums2, (total / 2)) + getKthElement(nums1, nums2, total/2 +1)) / 2.0;\n        }\n    }</code></pre>\n<h2 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5. 最长回文子串\"></a>5. 最长回文子串</h2><ul>\n<li><ol start=\"5\">\n<li>Longest Palindromic Substring</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring\">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p>\n</blockquote>\n<blockquote>\n<p>暴力解法：</p>\n</blockquote>\n<pre><code class=\"c++\">bool validatePalindrome(string s, int i, int j) {\n    while (i &lt; j) {\n        if (s[i] != s[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n\n    if (s == &quot;&quot; || s.length() &lt; 2)\n        return s;\n\n    int begin = 0;\n    int maxLen = 1;\n    for (int i = 0; i &lt; s.length()-1; i++)\n    {\n        for (int j = i+1; j &lt; s.length(); j++)\n        {\n            if (((j - i + 1) &gt; maxLen) &amp;&amp; validatePalindrome(s, i, j)) {\n                maxLen = (j - i + 1);\n                begin = i;\n            }\n        }\n    }\n    return s.substr(begin, maxLen);\n}</code></pre>\n<blockquote>\n<p>中心扩散法</p>\n</blockquote>\n<pre><code class=\"c++\">int expandAroundCenter(string s, int left, int right) {\n    int len = s.length();\n    int i = left;\n    int j = right;\n    while (i &gt;= 0 &amp;&amp; j &lt; len) {\n        if (s[i] == s[j]) {\n            i--;\n            j++;\n        }\n        else {\n            break;\n        }\n    }\n\n    return j - i +1 - 2;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n    if (s == &quot;&quot; || s.length() &lt; 2)\n        return s;\n\n    int begin = 0;\n    int maxLen = 1;\n    for (int i = 0; i &lt; s.length() - 1; i++)\n    {\n        int oddLen = expandAroundCenter(s, i, i);\n        int eveLen = expandAroundCenter(s, i, i+1);\n\n        int curMaxLen = max(oddLen, eveLen);\n        if (curMaxLen &gt; maxLen) {\n            maxLen = curMaxLen;\n            begin = i - (curMaxLen - 1) / 2;\n        }\n    }\n\n    return s.substr(begin, maxLen);\n\n}</code></pre>\n<blockquote>\n<p>动态规划</p>\n</blockquote>\n<pre><code class=\"c++\">string QuestionHandler::longestPalindrome(string s) {\n    if (s == &quot;&quot; || s.length() &lt; 2)\n        return s;\n\n    int len = s.length();\n    int begin = 0;\n    int maxLen = 1;\n    vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));\n    for (int j = 1; j &lt; len; j++) {\n        for (int i = 0; i &lt; j; i++) {\n            if (s[i] != s[j]) {\n                dp[i][j] = 0;\n            }\n            else {\n                if (j - i &lt; 3) {\n                    dp[i][j] = 1;\n                }\n                else {\n                    dp[i][j] = dp[i + 1][j - 1];\n                }\n            }\n\n            if (dp[i][j] &amp;&amp; (j - i + 1) &gt; maxLen) {\n                maxLen = j - i + 1;\n                begin = i;\n            }\n        }\n    }\n\n    return s.substr(begin, maxLen);\n}</code></pre>\n<p><img src=\"/img/1603943631534.png\" alt=\"动态规划解法\"></p>\n<blockquote>\n<p>Manacher算法 - O(n)</p>\n</blockquote>\n<pre><code class=\"c++\">int expand(const string&amp; s, int left, int right) {\n    while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) {\n        --left;\n        ++right;\n    }\n    return (right - left - 2) / 2;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n    int start = 0, end = -1;\n    string t = &quot;#&quot;;\n    for (char c : s) {\n        t += c;\n        t += &#39;#&#39;;\n    }\n    t += &#39;#&#39;;\n    s = t;\n\n    vector&lt;int&gt; arm_len;\n    int right = -1, j = -1;\n    for (int i = 0; i &lt; s.size(); ++i) {\n        int cur_arm_len;\n        if (right &gt;= i) {\n            int i_sym = j * 2 - i;\n            int min_arm_len = min(arm_len[i_sym], right - i);\n            cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);\n        }\n        else {\n            cur_arm_len = expand(s, i, i);\n        }\n        arm_len.push_back(cur_arm_len);\n        if (i + cur_arm_len &gt; right) {\n            j = i;\n            right = i + cur_arm_len;\n        }\n        if (cur_arm_len * 2 + 1 &gt; end - start) {\n            start = i - cur_arm_len;\n            end = i + cur_arm_len;\n        }\n    }\n\n    string ans;\n    for (int i = start; i &lt;= end; ++i) {\n        if (s[i] != &#39;#&#39;) {\n            ans += s[i];\n        }\n    }\n    return ans;\n}</code></pre>\n<h2 id=\"6-Z-字形变换\"><a href=\"#6-Z-字形变换\" class=\"headerlink\" title=\"6.Z 字形变换\"></a>6.Z 字形变换</h2><ul>\n<li><ol start=\"6\">\n<li>ZigZag Conversion</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/zigzag-conversion\">https://leetcode-cn.com/problems/zigzag-conversion</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L   C   I   R<br>E T O E S I I G<br>E   D   H   N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。<br>请你实现这个将字符串进行指定行数变换的函数：<br>string convert(string s, int numRows);<br>示例 1:<br>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”<br>示例 2:<br>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L     D     R<br>E   O E   I I<br>E C   I H   N<br>T     S     G</p>\n</blockquote>\n<pre><code class=\"c++\">  string convert(string s, int numRows) {\n        if (numRows == 1) return s;\n\n        int rowIdx = 0;\n        vector&lt;string&gt; rowStrs(numRows);\n        bool goingDown = false;\n        for (char c : s) {\n            rowStrs[rowIdx] += c;\n            if (rowIdx == 0 || rowIdx == numRows - 1) goingDown = !goingDown;\n            rowIdx += goingDown ? 1 : -1;\n        }\n\n        string result;\n        for (string row : rowStrs) result += row;\n        return result;\n    }</code></pre>\n<h2 id=\"7-整数反转\"><a href=\"#7-整数反转\" class=\"headerlink\" title=\"7. 整数反转\"></a>7. 整数反转</h2><ul>\n<li><ol start=\"7\">\n<li>Reverse Integer</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/reverse-integer\">https://leetcode-cn.com/problems/reverse-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>示例 1:<br>输入: 123<br>输出: 321<br> 示例 2:<br>输入: -123<br>输出: -321<br>示例 3:<br>输入: 120<br>输出: 21</p>\n</blockquote>\n<pre><code class=\"c++\">  int reverse(int x) {\n         int ans = 0;\n        while (x != 0) {\n            if (ans &gt; 214748364 || ans &lt; -214748364) {\n                return 0;\n            }\n            ans = ans*10 + x % 10;\n            x /= 10;\n        }\n\n        return ans;\n    }</code></pre>\n<h2 id=\"8-字符串转换整数-atoi\"><a href=\"#8-字符串转换整数-atoi\" class=\"headerlink\" title=\"8. 字符串转换整数 (atoi)\"></a>8. 字符串转换整数 (atoi)</h2><ul>\n<li><ol start=\"8\">\n<li>String to Integer (atoi)</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi\">https://leetcode-cn.com/problems/string-to-integer-atoi</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br>提示：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: “42”<br>输出: 42<br>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p>\n</blockquote>\n<pre><code class=\"c++\">class Automaton {\n    string state = &quot;start&quot;;\n    unordered_map&lt;string, vector&lt;string&gt;&gt; table = {\n        {&quot;start&quot;, {&quot;start&quot;, &quot;signed&quot;, &quot;in_number&quot;, &quot;end&quot;}},\n        {&quot;signed&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;}},\n        {&quot;in_number&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;}},\n        {&quot;end&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;end&quot;, &quot;end&quot;}}\n    };\n\n    int get_col(char c) {\n        if (isspace(c)) return 0;\n        if (c == &#39;+&#39; or c == &#39;-&#39;) return 1;\n        if (isdigit(c)) return 2;\n        return 3;\n    }\npublic:\n    int sign = 1;\n    long long ans = 0;\n\n    void get(char c) {\n        state = table[state][get_col(c)];\n        if (state == &quot;in_number&quot;) {\n            ans = ans * 10 + c - &#39;0&#39;;\n            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);\n        }\n        else if (state == &quot;signed&quot;)\n            sign = c == &#39;+&#39; ? 1 : -1;\n    }\n};\n\nint myAtoi(string s) {\n         Automaton automaton;\n        for (char c : s)\n            automaton.get(c);\n        return automaton.sign * automaton.ans;\n    }</code></pre>\n<h2 id=\"9-回文数\"><a href=\"#9-回文数\" class=\"headerlink\" title=\"9.回文数\"></a>9.回文数</h2><ul>\n<li><ol start=\"9\">\n<li>Palindrome Number</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/palindrome-number\">https://leetcode-cn.com/problems/palindrome-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>示例 1:<br>输入: 121<br>输出: true<br>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>\n</blockquote>\n<pre><code class=\"c++\"> bool isPalindrome(int x) {\n        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {\n            return false;\n        }\n        //后半段与前半段对比\n        int revertedNumber = 0;\n        while (x &gt; revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        return x == revertedNumber || x == revertedNumber / 10;\n    }</code></pre>\n<h2 id=\"10-正则表达式匹配\"><a href=\"#10-正则表达式匹配\" class=\"headerlink\" title=\"10. 正则表达式匹配\"></a>10. 正则表达式匹配</h2><ul>\n<li><ol start=\"10\">\n<li>Regular Expression Matching</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/regular-expression-matching\">https://leetcode-cn.com/problems/regular-expression-matching</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>\n<blockquote>\n<p>‘.’ 匹配任意单个字符<br>‘*‘ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>\n</blockquote>\n<blockquote>\n<p>示例 1：<br>输入：s = “aa” p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入：s = “aa” p = “a*”<br>输出：true<br>解释：因为 ‘*‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>\n</blockquote>\n<blockquote>\n<p>示例 3：<br>输入：s = “ab” p = “.*“<br>输出：true<br>解释：”.*“ 表示可匹配零个或多个（’*‘）任意字符（’.’）。</p>\n</blockquote>\n<blockquote>\n<p>示例 4：<br>输入：s = “aab” p = “c*a*b”<br>输出：true<br>解释：因为 ‘*‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>\n</blockquote>\n<blockquote>\n<p>示例 5：<br>输入：s = “mississippi” p = “mis*is*p*.”<br>输出：false</p>\n</blockquote>\n<pre><code class=\"c++\">bool isMatch(string s, string p) {\n    // dp[i][j]表示str[1:i]和pattern[1:j]能否匹配，为0表示无法匹配，为1表示可以匹配\n//\n// 分析状态转移方程\n//   对于dp[i][j]，如果str[i]与p[j]相同或者p[j]为.，则dp[i][j] = dp[i-1][j-1]，即与s[1:i-1]和p[1:j-1]的匹配情况相同\n//   如果p[j]为*，则表示这个字符可以联合p[j-1]使用来匹配当前的s[i](这个选择可做可不做，但我们尽量去匹配字符串)\n//   考虑p[j]为*，如果p前一个字符为.，显然可以用一次.*组合匹配到s[i]，如果p前一个字符p[j-1]不为.并且不与s[i]相同，则不能使用\n//   综合考虑，若p[j]==&#39;*&#39;\n//   1. 不选择替换，使用0次*，dp[i][j] = dp[i][j-2]\n//   2. 当p[j-1]为.或者与s[i]相同时，可以使用一次替换，则dp[i][j] = dp[i-1][j]\n//   两者求或 (因为我们尽可能去匹配字符串，所以只要有一种情况匹配成功，则匹配成功)\n// 初始化主要考虑p去匹配一个空串的情况，和上面类似的分析过程即可得出结论\n\n    //dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配\n    vector&lt;vector&lt;bool&gt;&gt; dp(s.size() + 1, vector&lt;bool&gt;(p.size() + 1));\n    dp[0][0] = true;\n\n    //s 的前 0 个是否能被 p 的前 j 个匹配\n    for (size_t j = 1; j &lt; p.size(); ++j)\n    {\n        if (p[j] == &#39;*&#39;)\n        {\n            dp[0][j + 1] = dp[0][j - 1];\n        }\n    }\n\n    for (size_t i = 0; i &lt; s.size(); ++i)\n    {\n        for (size_t j = 0; j &lt; p.size(); ++j)\n        {\n            if (s[i] == p[j] || p[j] == &#39;.&#39;)//匹配单个字符  \n            {\n                dp[i + 1][j + 1] = dp[i][j];\n            }\n            else if (p[j] == &#39;*&#39; &amp;&amp; j &gt; 0)\n            {\n                if (s[i] != p[j - 1] &amp;&amp; p[j - 1] != &#39;.&#39;)//前一对字符匹配\n                {\n                    dp[i + 1][j + 1] = dp[i + 1][j - 1];\n                }\n                else\n                {\n                    dp[i + 1][j + 1] = dp[i][j + 1] || //*表示匹配超过一个字符(s[i]、s[i-1]和p[j-1])\n                        //dp[i + 1][j] || //*表示只匹配一个字符（s[i]和p[j-1]）\n                        dp[i + 1][j - 1];//*表示0个匹配\n                }\n\n            }\n        }\n    }\n\n    return dp[s.size()][p.size()];\n}</code></pre>\n<h2 id=\"11-盛最多水的容器\"><a href=\"#11-盛最多水的容器\" class=\"headerlink\" title=\"11. 盛最多水的容器\"></a>11. 盛最多水的容器</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/container-with-most-water\">https://leetcode-cn.com/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。</p>\n</blockquote>\n<blockquote>\n<p>示例：<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p>\n</blockquote>\n<pre><code class=\"c++\">int maxArea(vector&lt;int&gt;&amp; height) {\n        int n = height.size();\n        if (n &lt; 2)\n            return 0;\n\n        int maxVolume = 0;\n        int left = 0;\n        int right = n - 1;\n\n        while(left &lt; right){\n            //取左端与右端\n            int lh = height[left];\n            int rh = height[right];\n\n            //计算体积\n            int vol = min(lh, rh) * (right-left);\n            //设置最大体积\n            maxVolume = max(maxVolume, vol);\n\n            //哪端的指针移动，取决于哪根柱子更低\n            left += (lh &lt;= rh) ? 1 : 0;\n            right -= (lh &gt; rh) ? 1 : 0;\n\n            cout &lt;&lt; &quot;left:&quot;&lt;&lt;left&lt;&lt;&quot;,right:&quot;&lt;&lt;right&lt;&lt;endl;\n        }\n\n\n        return maxVolume;\n    }</code></pre>\n<h2 id=\"17-电话号码的字母组合\"><a href=\"#17-电话号码的字母组合\" class=\"headerlink\" title=\"17. 电话号码的字母组合\"></a>17. 电话号码的字母组合</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number\">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n</blockquote>\n<p><img src=\"/img/1604578953107.png\" alt=\"17\"></p>\n<blockquote>\n<p>示例:<br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>\n</blockquote>\n<pre><code class=\"c++\">  vector&lt;string&gt; letterCombinations(string digits) {\n        map&lt;int,vector&lt;char&gt;&gt; numsMap;\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(2, vector&lt;char&gt;{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(3, vector&lt;char&gt;{&#39;d&#39;, &#39;e&#39;, &#39;f&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(4, vector&lt;char&gt;{&#39;g&#39;, &#39;h&#39;, &#39;i&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(5, vector&lt;char&gt;{&#39;j&#39;, &#39;k&#39;, &#39;l&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(6, vector&lt;char&gt;{&#39;m&#39;, &#39;n&#39;, &#39;o&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(7, vector&lt;char&gt;{&#39;p&#39;, &#39;q&#39;, &#39;r&#39;,&#39;s&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(8, vector&lt;char&gt;{&#39;t&#39;, &#39;u&#39;, &#39;v&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(9, vector&lt;char&gt;{&#39;w&#39;, &#39;x&#39;, &#39;y&#39;,&#39;z&#39;}));\n\n        /*输入：&quot;23&quot;\n            输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].*/\n        map&lt;string, int&gt; resultMap;\n        vector&lt;string&gt; result;\n\n        for (int i = 0; i &lt; digits.size(); i++) {\n            int v = digits[i] - &#39;0&#39;;\n            if (numsMap.count(v) == 0) {\n                result.clear();\n                break;\n            }\n            vector&lt;char&gt; curChars = numsMap[v];\n            if (i &gt; 0) {\n                vector&lt;string&gt; tmpList;\n                for(string val : result) {\n                    for (char c : curChars) {\n                        tmpList.push_back(val + c);\n                    }\n                }\n                result.clear();\n                result = tmpList;\n            }\n            else {\n                for (auto it = curChars.begin(); it != curChars.end(); it++) {\n                      char v = *it;\n                    result.push_back(string (1,v));\n                }\n            }\n        }\n\n        return result;\n    }</code></pre>\n<h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15.三数之和\"></a>15.三数之和</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/3sum\">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>\n</blockquote>\n<blockquote>\n<p>示例：<br>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>\n</blockquote>\n<pre><code class=\"c++\">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());   // -4  -1  -1  0  1  2\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for(int i=0; i&lt;nums.size(); i++){\n            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]){\n                continue;\n            }\n            int j = i+1, k = nums.size() -1;\n            while(j &lt; k){\n                if(j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]){\n                    j++;\n                    continue;\n                }\n                if(k &lt; nums.size()-1 &amp;&amp; nums[k] == nums[k+1]){\n                    k--;\n                    continue;\n                }\n                if(nums[j] + nums[k] &gt; -1*nums[i]){\n                    k--;\n                }else if(nums[j] + nums[k] &lt; -1*nums[i]){\n                    j++;\n                }else{\n                    res.push_back({nums[i], nums[j], nums[k]});\n                    j++, k--;\n                }\n            }\n        }\n        return res;\n    }</code></pre>\n<h2 id=\"19-删除链表的倒数第N个节点\"><a href=\"#19-删除链表的倒数第N个节点\" class=\"headerlink\" title=\"19.删除链表的倒数第N个节点\"></a>19.删除链表的倒数第N个节点</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list\">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：<br>给定的 n 保证是有效的。<br>进阶：<br>你能尝试使用一趟扫描实现吗？</p>\n</blockquote>\n<pre><code class=\"c++\">  ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* pre = NULL;\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            fast = fast-&gt;next;\n        }\n\n        while (fast != NULL) {\n            pre = slow;\n            slow = slow-&gt;next;\n            fast = fast-&gt;next;\n        }\n\n        if (pre != NULL) {\n            pre-&gt;next = slow-&gt;next;\n            return head;\n        }\n        else {\n            return head-&gt;next;\n        }\n\n    }\n</code></pre>\n<h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a>20. 有效的括号</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/valid-parentheses\">https://leetcode-cn.com/problems/valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: “()”<br>输出: true<br>示例 2:<br>输入: “()[]{}”<br>输出: true<br>示例 3:<br>输入: “(]”<br>输出: false<br>示例 4:<br>输入: “([)]”<br>输出: false<br>示例 5:<br>输入: “{[]}”<br>输出: true</p>\n</blockquote>\n<pre><code class=\"c++\"> bool isValid(string s) {\n        map&lt;char, char&gt; cMap = {\n            {&#39;]&#39;,&#39;[&#39;},\n            {&#39;}&#39;,&#39;{&#39;},\n            {&#39;)&#39;,&#39;(&#39;},\n        };\n\n        if (s.size() % 2 == 1)//奇数必然不对\n            return false;\n\n        stack&lt;char&gt; cs;\n        for (char c : s) {\n            if (cMap.count(c)) {\n                if (cs.empty() || cs.top() != cMap[c]) {\n                    return false;\n                }\n                cs.pop();\n            }\n            else {\n                cs.push(c);\n            }\n        }\n        return cs.size() == 0;\n    }</code></pre>\n<h2 id=\"22-括号生成\"><a href=\"#22-括号生成\" class=\"headerlink\" title=\"22. 括号生成\"></a>22. 括号生成</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/generate-parentheses\">https://leetcode-cn.com/problems/generate-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>\n</blockquote>\n<blockquote>\n<p>示例：<br>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p>\n</blockquote>\n<pre><code class=\"c++\"> void LoopGetParanthesis(vector&lt;string&gt; &amp; result,string str,int left, int right) {\n        if (left == 0 &amp;&amp; right == 0) {\n            result.push_back(str);\n            return;\n        }\n\n        //左右括号数相等，则只用左括号\n        if (left == right) {\n            LoopGetParanthesis(result, str + &quot;(&quot;, left - 1, right);\n        }\n        else if(left &lt; right){\n            if (left &gt; 0) {\n                LoopGetParanthesis(result, str + &quot;(&quot;, left-1, right);\n            }\n            LoopGetParanthesis(result, str + &quot;)&quot;, left, right - 1);\n        }\n    }\n    vector&lt;string&gt; generateParenthesis(int n) {\n        vector&lt;string&gt; result;\n        string str = &quot;&quot;;\n        LoopGetParanthesis(result, str, n, n);\n\n        return result;\n    }</code></pre>\n<h2 id=\"26-删除排序数组中的重复项\"><a href=\"#26-删除排序数组中的重复项\" class=\"headerlink\" title=\"26.删除排序数组中的重复项\"></a>26.删除排序数组中的重复项</h2><ul>\n<li><ol start=\"26\">\n<li>Remove Duplicates from Sorted Array</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n</li>\n</ul>\n<blockquote>\n<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() ==0) return 0;\n        int thumb = 0;\n\n        for(int i = 1;i &lt; nums.size(); i++){\n            if(nums[i] != nums[thumb]){\n                thumb ++;\n                nums[thumb] = nums[i];\n            }\n        }\n        return thumb+1;\n    }\n};</code></pre>\n<h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h2><ul>\n<li><ol start=\"27\">\n<li>Remove Element</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-element\">https://leetcode-cn.com/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) {\n        int thumb = 0;\n        for(int i = 0; i &lt; nums.size(); i++){\n            if(nums[i] != val){\n                nums[thumb] = nums[i];\n                thumb ++;\n            }\n        }\n        return thumb;\n    }\n};</code></pre>\n<h2 id=\"28-实现-strStr\"><a href=\"#28-实现-strStr\" class=\"headerlink\" title=\"28. 实现 strStr()\"></a>28. 实现 strStr()</h2><ul>\n<li><ol start=\"28\">\n<li>Implement strStr()</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/implement-strstr\">https://leetcode-cn.com/problems/implement-strstr</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p>\n</blockquote>\n<pre><code class=\"python\">class Solution:\n    def strStr(self, source: str, target: str) -&gt; int:\n        if source == target:\n            return 0\n\n        source_len = len(source)\n        target_len = len(target)\n\n        if target_len &gt; source_len:\n            return -1\n\n        for i in range(source_len):\n            target_index = i + target_len\n            if target_index &gt; source_len:\n                continue\n            if source[i:target_index] == target:\n                return i\n\n        return -1</code></pre>\n<h2 id=\"29-两数相除\"><a href=\"#29-两数相除\" class=\"headerlink\" title=\"29. 两数相除\"></a>29. 两数相除</h2><ul>\n<li><ol start=\"29\">\n<li>Divide Two Integers</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/divide-two-integers\">https://leetcode-cn.com/problems/divide-two-integers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>返回被除数 dividend 除以除数 divisor 得到的商。<br>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: dividend = 7, divisor = -3<br>输出: -2<br>解释: 7/-3 = truncate(-2.33333..) = -2</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>\n</blockquote>\n<pre><code class=\"python\">class Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n        if abs_dividend &lt; abs_divisor:\n            return 0\n\n        is_neg = 0\n        if abs(dividend + divisor) != abs_dividend + abs_divisor:\n            is_neg = 1\n        ans = 0\n\n        for i in range(31, -1, -1):\n            print(&#39;abs_dividend &gt;&gt; %d : %d, %d, &#39;% (i, abs_dividend &gt;&gt; i, abs_divisor))\n\n            if abs_dividend &gt;&gt; i &gt;= abs_divisor:\n                ans += 1 &lt;&lt; i\n                abs_dividend -= abs_divisor &lt;&lt; i\n                print(&#39;good value: %d, %d&#39;%(ans, abs_dividend))\n\n        if is_neg and ans &gt;= 2 ** 31:\n            return -2 ** 31\n        elif ans &gt;= 2 ** 31:\n            return 2 ** 31 - 1\n        elif is_neg:\n            return -ans\n        else:\n            return ans</code></pre>\n<h2 id=\"30-串联所有单词的子串\"><a href=\"#30-串联所有单词的子串\" class=\"headerlink\" title=\"30. 串联所有单词的子串\"></a>30. 串联所有单词的子串</h2><ul>\n<li><ol start=\"30\">\n<li>Substring with Concatenation of All Words</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words\">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。<br>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p>\n</blockquote>\n<blockquote>\n<p>示例 1：<br>输入：<br>  s = “barfoothefoobarman”,<br>  words = [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。</p>\n</blockquote>\n<blockquote>\n<p>示例 2：<br>输入：<br>  s = “wordgoodgoodgoodbestword”,<br>  words = [“word”,”good”,”best”,”word”]<br>输出：[]</p>\n</blockquote>\n<pre><code class=\"python\">class Solution(object):\n    def findSubstring(self, s, words):\n        from collections import Counter\n        if not s or not words:return []\n        one_word = len(words[0])\n        all_len = len(words) * one_word\n        n = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0, n - all_len + 1):\n            tmp = s[i:i+all_len]\n            c_tmp = []\n            for j in range(0, all_len, one_word):\n                c_tmp.append(tmp[j:j+one_word])\n            if Counter(c_tmp) == words:\n                res.append(i)\n        return res</code></pre>\n<h2 id=\"41-缺失的第一个正数\"><a href=\"#41-缺失的第一个正数\" class=\"headerlink\" title=\"41. 缺失的第一个正数\"></a>41. 缺失的第一个正数</h2><ul>\n<li><ol start=\"41\">\n<li>First Missing Positive</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/first-missing-positive\">https://leetcode-cn.com/problems/first-missing-positive</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: [1,2,0]<br>输出: 3</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: [3,4,-1,1]<br>输出: 2</p>\n</blockquote>\n<blockquote>\n<p>示例 3:<br>输入: [7,8,9,11,12]<br>输出: 1</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {\n         // 总长\n        int n = nums.size();\n        // 1. 全部元素没有1，返回1\n        bool noOne = true;\n        for(int i = 0; i &lt; nums.size();i++){\n            if(nums[i] == 1)\n            {\n                noOne = false;\n                break;\n            }\n        }\n        if(noOne){\n            return 1;\n        }\n\n        //2. 只有一个元素，且为[1]，则返回2\n        if(n == 1)\n        {\n            return 2;\n        }\n\n        //3. 去&lt;= 0与 &gt; 总数的数，将其设为1\n        for(int i = 0; i &lt; n;i++){\n            if(i == n-1){\n                cout &lt;&lt; nums[i] &lt;&lt; endl;\n            }\n            if(nums[i] &lt; 1 || nums[i] &gt; n){\n                nums[i] = 1;\n            }\n        }\n\n\n        //4.遍历，当值 == 总数。第一个值设为负数. 当值 &lt;= 总数，以值为下标设置为负值. 特别的，当值为总数时，将第一个值为负值！\n         for(int i = 0; i &lt; n; i++){\n             int a = abs(nums[i]);\n             if(a == n){\n                 nums[0] = - abs(nums[0]);\n             }else{\n                nums[a] = - abs(nums[a]);\n             }\n         }\n\n        for(int v: nums){\n            cout &lt;&lt; v &lt;&lt; &quot;,&quot;;\n        }\n        cout &lt;&lt; endl;\n\n        //5.遍历最新的数组中，发现有大于0，此索引就是丢失的最小正数\n        for(int i = 1; i &lt; n;i++){\n            if(nums[i] &gt; 0){\n                return i;\n            }\n        }\n\n        //6.5如果没有找到，第一值取出来如果是正数，则数为正数N\n        if(nums[0] &gt; 0){\n            return n;\n        }\n\n        //7.如果以上走完了，返回n+1\n        return n+1;\n    }\n};</code></pre>\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. 接雨水</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/trapping-rain-water\">https://leetcode-cn.com/problems/trapping-rain-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>示例 1：</p>\n</blockquote>\n<p><img src=\"/img/1604063667003.png\" alt=\"接雨水\"></p>\n<blockquote>\n<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>示例 2：<br>输入：height = [4,2,0,3,2,5]<br>输出：9</p>\n</blockquote>\n<pre><code class=\"c++\">  int trap(vector&lt;int&gt;&amp; height) {\n        int left = 0, right = height.size() - 1;\n        int ans = 0;\n        int left_max = 0, right_max = 0;\n        while (left &lt; right) {\n            //情况1：左比右低，只有当左边最高柱比当前柱要高，则这个落差必定是能装水的。\n            if (height[left] &lt; height[right]) {\n                height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);\n                ++left;\n            }\n            else {//情况2：右比左低，只有当右边最高柱比当前柱要高，则这个落差必定是能装水的。\n                height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);\n                --right;\n            }\n        }\n        return ans;\n    }</code></pre>\n<h2 id=\"51-N皇后-amp-52-N皇后-II\"><a href=\"#51-N皇后-amp-52-N皇后-II\" class=\"headerlink\" title=\"51. N皇后 &amp; 52. N皇后 II\"></a>51. N皇后 &amp; 52. N皇后 II</h2><ul>\n<li><ol start=\"51\">\n<li>N-Queens</li>\n</ol>\n</li>\n<li><ol start=\"52\">\n<li>N-Queens II</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/n-queens\">https://leetcode-cn.com/problems/n-queens</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n</blockquote>\n<p><img src=\"/img/1601178139148.png\" alt=\"8皇后的一种解法\"></p>\n<blockquote>\n<ol start=\"51\">\n<li>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</li>\n<li>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</li>\n</ol>\n</blockquote>\n<pre><code class=\"python\">class NQueen:\n    def __init__(self):\n        self.count = 0\n\n    def do_nqueen(self, n):\n        empty_sign = &quot;[O]&quot;\n        queen_sign = &quot;[1]&quot;\n        # 所有数组起点都以0开始\n\n        # 1.定义所有解的容器，二维数组，第二维代表一个完整的解\n        ans = []\n\n        # 2.递归函数dfs\n        def dfs(nums, row):\n            # 如果找的行数与n相等了，说明已经找完了，得到一个解！\n            if row == n:\n                ans.append(nums[:]) # 注意不可用ans.append(nums)\n                return\n            # 逐列进行尝试，列的总数为n\n            for i in range(n):\n                # 每进行到一列，标记当前行皇后位置为此列\n                nums[row] = i\n                # 往下递归找到，一直找到底，找不到底循环会返回到此处！\n                if valid(nums, row):\n                    # print(&quot;当前找到第%d行的第%d列，此值可放皇后！&quot;%(row, i))\n                    dfs(nums, row+1)\n                else:\n                    pass\n                    # print(&quot;当前找到第%d行的第%d列，不可放，回溯&quot;%(row, i))\n\n        # 3.检查函数valid\n        def valid(nums, row):\n            # 只找前面行的点， 皇后攻击规则，同列同行 和 对角线元素表示\n            for r in range(row):\n                if abs(nums[r] - nums[row]) == abs(r - row) or nums[r] == nums[row]:\n                    return False\n            return True\n\n        # 4.执行, 从第0行开始找n数组长度中的位置\n        dfs([None for _ in range(n)], 0)\n\n        def get_row_list(row_val, count):\n            result = []\n            for i in range(count):\n                if i == row_val:\n                    result.append(queen_sign)\n                else:\n                    result.append(empty_sign)\n            return result\n\n\n        # 5.结果画出来\n        result = [[] for _ in range(len(ans))]\n        for i in range(len(ans)):\n            for col in ans[i]:\n                result[i].append(&quot;&quot;.join(get_row_list(col, n)))\n\n        return result\n\n\nmyqueen = NQueen()\nresult = myqueen.do_nqueen(4)\nprint(&quot;解有%d个&quot;%len(result))\nfor r in result:\n    r = str(r)\n    print(r+&quot;\\n\\n&quot;)</code></pre>\n<h2 id=\"75-颜色分类\"><a href=\"#75-颜色分类\" class=\"headerlink\" title=\"75. 颜色分类\"></a>75. 颜色分类</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/sort-colors\">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>注意:<br>不能使用代码库中的排序函数来解决这道题。<br>示例:<br>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]<br>进阶：<br>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>\n</blockquote>\n<pre><code class=\"c++\"> void sortColors(vector&lt;int&gt;&amp; nums) {\n       int n = nums.size();\n        int slow0 = 0, fast = 0, slow2 = n - 1;\n\n        while (fast &lt;= slow2) {\n            while (fast &lt;= slow2 &amp;&amp; nums[fast] == 2) {\n                //当当前快指针为2时，移至结尾。如果换完后的nums[fast]还是2？则继续换\n                nums[fast] = nums[slow2];\n                nums[slow2--] = 2;\n            }\n\n            if (nums[fast] == 0) {\n                nums[fast] = nums[slow0];\n                nums[slow0++] = 0;\n            }\n            fast++;\n        }\n    }</code></pre>\n<h2 id=\"76-最小覆盖子串\"><a href=\"#76-最小覆盖子串\" class=\"headerlink\" title=\"76.最小覆盖子串\"></a>76.最小覆盖子串</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/minimum-window-substring\">https://leetcode-cn.com/problems/minimum-window-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。<br>示例：<br>输入：S = “ADOBECODEBANC”, T = “ABC”<br>输出：”BANC”</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p>\n</blockquote>\n<pre><code class=\"c++\"> string minWindow(string s, string t) {\n        if(s == t) return s;\n\n        map&lt;char, int&gt; need, window;\n        int tLen = t.length();//目标字符串\n        int sLen = s.length();\n        if (tLen == 0 || sLen == 0) return &quot;&quot;;\n        if (sLen &lt; tLen )\n            return &quot;&quot;;\n\n        //先把t中的字符放到need表中，计数\n        for (int i = 0; i &lt; tLen; i++) {\n            char c = t[i];\n            need[c] = ((need.count(c) == 0)?0:need[c]) + 1;\n        }\n\n        int left = 0, right = 0;\n        int len = INT32_MAX, start = 0;\n        int valid = 0; //已经匹配成功的字符种类数（非字符个数）\n\n        //当右指针去到字符串末尾前\n        while (right &lt; sLen) {\n            char c = s[right];\n            right++;//右指针向右滑\n\n            //如果右指针现在滑到的字符是目标字符串的一个，那么更新窗口中的数据\n            if (need.count(c) &gt; 0) {\n                window[c] = ((window.count(c) == 0)?0:window[c]) + 1;\n                if (window[c] == (need[c])) {\n                    valid++;\n                }\n            }\n\n            //窗口开始从左边收缩\n            while (valid == need.size()) {\n                if (right - left &lt; len) {\n                    start = left;\n                    len = right - left;\n                }\n\n                char d = s[left];\n                left++;\n\n                if (need.count(d) &gt; 0) {\n                    if (window[d] == (need[d])) {\n                        valid--;\n                    }\n                    window[d] = window[d] - 1;\n                }\n            }\n        }\n        return len == INT32_MAX ? &quot;&quot; : s.substr(start, len);\n    }</code></pre>\n<h2 id=\"80-删除排序数组中的重复项-II\"><a href=\"#80-删除排序数组中的重复项-II\" class=\"headerlink\" title=\"80. 删除排序数组中的重复项 II\"></a>80. 删除排序数组中的重复项 II</h2><ul>\n<li><ol start=\"80\">\n<li>Remove Duplicates from Sorted Array II</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>给定 nums = [1,1,1,2,2,3],<br>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>给定 nums = [0,0,1,1,1,1,2,3,3],<br>函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n      int i = 0;\n        for (int n : nums) {\n            if (i &lt; 2 || n &gt; nums[i-2]) nums[i++] = n;\n        }\n        return i;\n    }\n};</code></pre>\n<h2 id=\"127-单词接龙\"><a href=\"#127-单词接龙\" class=\"headerlink\" title=\"127. 单词接龙\"></a>127. 单词接龙</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/word-ladder\">https://leetcode-cn.com/problems/word-ladder</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。</p>\n</blockquote>\n<blockquote>\n<p>说明:<br>如果不存在这样的转换序列，返回 0。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出: 5<br>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。<br>示例 2:<br>输入:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出: 0<br>解释: endWord “cog” 不在字典中，所以无法进行转换。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\n    unordered_map&lt;string, int&gt; wordId;\n    vector&lt;vector&lt;int&gt;&gt; edge;\n    int nodeNum = 0;\n\n    void addWord(string&amp; word) {\n        if (!wordId.count(word)) {\n            wordId[word] = nodeNum++;\n            edge.emplace_back();\n        }\n    }\n\n    void addEdge(string&amp; word) {\n        addWord(word);\n        int id1 = wordId[word];\n        for (char&amp; it : word) {\n            char tmp = it;\n            it = &#39;*&#39;;\n            addWord(word);\n            int id2 = wordId[word];\n            edge[id1].push_back(id2);\n            edge[id2].push_back(id1);\n            it = tmp;\n        }\n    }\npublic:\n    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        for (string&amp; word : wordList) {\n            addEdge(word);\n        }\n        addEdge(beginWord);\n        if (!wordId.count(endWord)) {\n            return 0;\n        }\n        vector&lt;int&gt; dis(nodeNum, INT_MAX);\n        int beginId = wordId[beginWord], endId = wordId[endWord];\n        dis[beginId] = 0;\n\n        queue&lt;int&gt; que;\n        que.push(beginId);\n        while (!que.empty()) {\n            int x = que.front();\n            que.pop();\n            if (x == endId) {\n                return dis[endId] / 2 + 1;\n            }\n            for (int&amp; it : edge[x]) {\n                if (dis[it] == INT_MAX) {\n                    dis[it] = dis[x] + 1;\n                    que.push(it);\n                }\n            }\n        }\n        return 0;\n    }\n\n};</code></pre>\n<h2 id=\"129-求根到叶子节点数字之和\"><a href=\"#129-求根到叶子节点数字之和\" class=\"headerlink\" title=\"129.求根到叶子节点数字之和\"></a>129.求根到叶子节点数字之和</h2><ul>\n<li><ol start=\"129\">\n<li>Sum Root to Leaf Numbers</li>\n</ol>\n</li>\n<li>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers\">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li>\n</ul>\n<blockquote>\n<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。<br>计算从根到叶子节点生成的所有数字之和。<br>说明: 叶子节点是指没有子节点的节点。</p>\n</blockquote>\n<p>示例 1:<br>输入: [1,2,3]<br>    1<br>   / <br>  2   3<br>输出: 25<br>解释:<br>从根到叶子节点路径 1-&gt;2 代表数字 12.<br>从根到叶子节点路径 1-&gt;3 代表数字 13.<br>因此，数字总和 = 12 + 13 = 25.<br>示例 2:</p>\n<p>输入: [4,9,0,5,1]<br>    4<br>   / <br>  9   0<br> / <br>5   1<br>输出: 1026<br>解释:<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>从根到叶子节点路径 4-&gt;0 代表数字 40.<br>因此，数字总和 = 495 + 491 + 40 = 1026.</p>\n<pre><code class=\"c++\">int bfs_sum(TreeNode* root) {\n    if(root == NULL)\n        return 0;\n    int sum = 0;\n    queue&lt;TreeNode*&gt; q;\n    queue&lt;int&gt; qn;\n\n    q.push(root);\n    qn.push(root-&gt;val);\n\n    while (!q.empty()) {\n        TreeNode* node = q.front();\n        int nodeVal = qn.front();\n        q.pop();\n        qn.pop();\n\n        if ((node-&gt;left == NULL) &amp;&amp; (node-&gt;right == NULL)) {\n            sum += nodeVal;\n        }\n        else {\n            if (node-&gt;left != NULL) {\n                q.push(node-&gt;left);\n                qn.push(nodeVal * 10 + node-&gt;left-&gt;val);\n            }\n            if (node-&gt;right != NULL) {\n                q.push(node-&gt;right);\n                qn.push(nodeVal * 10 + node-&gt;right-&gt;val);\n            }\n        }\n    }\n    return sum;\n}\n\nint dfs_sum(TreeNode* node, int prevSum) {\n    if(node == NULL)\n        return 0;\n\n    int sum = prevSum * 10 + node-&gt;val;\n    //左右都没有值 \n    if ((node-&gt;left == NULL) &amp;&amp;(node-&gt;right == NULL)) {\n        return sum;\n    }\n    else {\n        sum = dfs_sum(node-&gt;left, sum) + dfs_sum(node-&gt;right, sum);\n    }\n\n    return sum;\n}\n\nint sumNumbers(TreeNode* root) {\n        //return dfs_sum(root, 0);\n    return bfs_sum(root);\n}</code></pre>\n<h2 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141. 环形链表\"></a>141. 环形链表</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle\">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>\n</blockquote>\n<blockquote>\n<p>进阶<br>你能用 O(1)（即，常量）内存解决此问题吗？</p>\n</blockquote>\n<blockquote>\n<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n</blockquote>\n<pre><code class=\"c++\">    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n       ListNode* slow = head;\n        ListNode* fast = head-&gt;next;\n        while (slow != fast) {\n            if (fast == NULL || fast-&gt;next == NULL)\n            {\n                return false;\n            }\n\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n        }\n        return true;\n    }</code></pre>\n<h2 id=\"142-环形链表-II\"><a href=\"#142-环形链表-II\" class=\"headerlink\" title=\"142. 环形链表 II\"></a>142. 环形链表 II</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii\">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>\n</blockquote>\n<blockquote>\n<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n</blockquote>\n<pre><code class=\"c++\">    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while(fast != NULL){\n            if(fast-&gt;next == NULL)\n                return nullptr;\n\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if(slow == fast){\n                ListNode * ptr = head;\n                while(ptr != slow){\n                    ptr = ptr-&gt;next;\n                    slow = slow-&gt;next;\n                }\n                return ptr;\n            }\n        }\n        return nullptr;\n\n    }</code></pre>\n<h2 id=\"144-二叉树的前序遍历\"><a href=\"#144-二叉树的前序遍历\" class=\"headerlink\" title=\"144. 二叉树的前序遍历\"></a>144. 二叉树的前序遍历</h2><ul>\n<li><ol start=\"144\">\n<li>Binary Tree Preorder Traversal</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal\">https://leetcode-cn.com/problems/binary-tree-preorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个二叉树，返回它的 前序 遍历。</p>\n</blockquote>\n<blockquote>\n<p>示例:<br>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3<br>输出: [1,2,3]</p>\n</blockquote>\n<pre><code class=\"c++\">    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; result;\n        if(root == NULL)\n            return result;\n\n        stack&lt;TreeNode&gt; ss;\n        ss.push(*root);\n\n        while(!ss.empty()){\n            TreeNode cur = ss.top();\n            ss.pop();\n\n            result.push_back(cur.val);\n\n            if(cur.right != NULL){\n                ss.push(*cur.right);\n            }\n            if(cur.left != NULL){\n                ss.push(*cur.left);\n            }\n        }\n        return result;\n    }</code></pre>\n<h2 id=\"189-旋转数组\"><a href=\"#189-旋转数组\" class=\"headerlink\" title=\"189. 旋转数组\"></a>189. 旋转数组</h2><ul>\n<li><ol start=\"189\">\n<li>Rotate Array</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/rotate-array\">https://leetcode-cn.com/problems/rotate-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]</p>\n</blockquote>\n<blockquote>\n<p>说明:<br>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    void reverse(vector&lt;int&gt;&amp; nums, int start, int end){\n        for(int i = start,j = end; i &lt; j; i++,j--){\n            int ftmp = nums[j];\n            nums[j] = nums[i];\n            nums[i] = ftmp;\n        }\n    }\n\n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n        if(k &gt; nums.size()){\n            k %= nums.size();\n        }\n\n        reverse(nums, 0, nums.size()-k-1);\n        reverse(nums, nums.size()-k, nums.size()-1);\n        reverse(nums, 0, nums.size()-1);\n    }\n};\n</code></pre>\n<h2 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234. 回文链表\"></a>234. 回文链表</h2><p> 来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">https://leetcode-cn.com/problems/palindrome-linked-list/</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>请判断一个链表是否为回文链表。<br>示例 1:<br>输入: 1-&gt;2<br>输出: false<br>示例 2:<br>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p>\n</blockquote>\n<pre><code class=\"c++\">ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr != nullptr) {\n            ListNode* nextTemp = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n\n    ListNode* endOfFirstHalf(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) {\n            fast = fast-&gt;next-&gt;next;\n            slow = slow-&gt;next;\n        }\n        return slow;\n    }\n    bool isPalindrome(ListNode* head) {\n        if(head == NULL)\n            return true;\n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode* firstHalfEnd = endOfFirstHalf(head);\n        ListNode* secondHalfStart = reverseList(firstHalfEnd-&gt;next);\n\n        // 判断是否回文\n        ListNode* p1 = head;\n        ListNode* p2 = secondHalfStart;\n        bool result = true;\n        while (result &amp;&amp; p2 != nullptr) {\n            if (p1-&gt;val != p2-&gt;val) {\n                result = false;\n            }\n            p1 = p1-&gt;next;\n            p2 = p2-&gt;next;\n        }\n\n        // 还原链表并返回结果\n        firstHalfEnd-&gt;next = reverseList(secondHalfStart);\n        return result;\n    }</code></pre>\n<h2 id=\"283-移动零\"><a href=\"#283-移动零\" class=\"headerlink\" title=\"283. 移动零\"></a>283. 移动零</h2><p> 来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/move-zeroes/\">https://leetcode-cn.com/problems/move-zeroes/</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>\n</blockquote>\n<pre><code class=\"c++\"> void moveZeroes(vector&lt;int&gt;&amp; nums) {\n       for (int lastNonZeroFoundAt = 0, cur = 0; cur &lt; nums.size(); cur++) {\n            if (nums[cur] != 0) {\n                swap(nums[lastNonZeroFoundAt], nums[cur]);\n                lastNonZeroFoundAt++;\n            }\n        }\n    }</code></pre>\n<h2 id=\"287-寻找重复数\"><a href=\"#287-寻找重复数\" class=\"headerlink\" title=\"287. 寻找重复数\"></a>287. 寻找重复数</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number\">https://leetcode-cn.com/problems/find-the-duplicate-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>示例 1:<br>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:<br>输入: [3,1,3,4,2]<br>输出: 3<br>说明：</p>\n</blockquote>\n<blockquote>\n<p>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 O(1) 的空间。<br>时间复杂度小于 O(n2) 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。</p>\n</blockquote>\n<pre><code class=\"c++\"> int findDuplicate(vector&lt;int&gt;&amp; nums) {\n        int slow = 0, fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        slow = 0;\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return slow;\n    }</code></pre>\n<h2 id=\"299-猜数字游戏\"><a href=\"#299-猜数字游戏\" class=\"headerlink\" title=\"299. 猜数字游戏\"></a>299. 猜数字游戏</h2><ul>\n<li><ol start=\"299\">\n<li>Bulls and Cows</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/bulls-and-cows\">https://leetcode-cn.com/problems/bulls-and-cows</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：<br>你写出一个秘密数字，并请朋友猜这个数字是多少。<br>朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。<br>朋友根据提示继续猜，直到猜出秘密数字。<br>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。</p>\n</blockquote>\n<blockquote>\n<p>xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。<br>yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。<br>请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: secret = “1807”, guess = “7810”<br>输出: “1A3B”<br>解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: secret = “1123”, guess = “0111”<br>输出: “1A1B”<br>解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。</p>\n</blockquote>\n<blockquote>\n<p>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    string getHint(string secret, string guess) {\n        int bulls = 0;\n        int cows = 0;\n        int ds[10]{0};\n        int dg[10]{0};\n        for(int i = 0; i &lt; secret.size(); i++){\n            int x = secret[i] - &#39;0&#39;;\n            int y = guess[i] - &#39;0&#39;;\n            if(secret[i] == guess[i]){\n                bulls ++;    \n            }\n            ds[x] ++;\n            dg[y] ++;\n        }\n\n        //算出相同元素总数，当然减掉之前算好的cows\n        for(int i = 0;i &lt; 10;i++){\n            cows += min(ds[i],dg[i]);\n        }\n        cows -= bulls;\n        ostringstream oss;\n        oss &lt;&lt; bulls &lt;&lt; &quot;A&quot; &lt;&lt; cows &lt;&lt; &quot;B&quot; ;\n        return oss.str();\n    }\n\n};  </code></pre>\n<h2 id=\"463-岛屿的周长\"><a href=\"#463-岛屿的周长\" class=\"headerlink\" title=\"463. 岛屿的周长\"></a>463. 岛屿的周长</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/island-perimeter\">https://leetcode-cn.com/problems/island-perimeter</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。<br>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。<br>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>\n</blockquote>\n<blockquote>\n<p>示例 :<br>输入:<br>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]<br>输出: 16</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\n    constexpr static int dx[4] = {0, 1, 0, -1};\n    constexpr static int dy[4] = {1, 0, -1, 0};\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int n = grid.size(), m = grid[0].size();\n        int ans = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; m; ++j) {\n                if (grid[i][j]) {\n                    int cnt = 0;\n                    for (int k = 0; k &lt; 4; ++k) {\n                        int tx = i + dx[k];\n                        int ty = j + dy[k];\n                        if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || !grid[tx][ty]) {\n                            cnt += 1;\n                        }\n                    }\n                    ans += cnt;\n                }\n            }\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"1207-独一无二的出现次数\"><a href=\"#1207-独一无二的出现次数\" class=\"headerlink\" title=\"1207.独一无二的出现次数\"></a>1207.独一无二的出现次数</h2><ul>\n<li><ol start=\"1207\">\n<li>Unique Number of Occurrences</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/unique-number-of-occurrences\">https://leetcode-cn.com/problems/unique-number-of-occurrences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。<br>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p>\n</blockquote>\n<blockquote>\n<p>示例 1：<br>输入：arr = [1,2,2,1,1,3]<br>输出：true<br>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。<br>示例 2：<br>输入：arr = [1,2]<br>输出：false<br>示例 3：<br>输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]<br>输出：true</p>\n</blockquote>\n<pre><code class=\"c++\">bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {\n    map&lt;int, int&gt; posMap;\n    for (int i = 0; i &lt; arr.size(); i++)\n    {\n        posMap[arr[i]] += 1;\n    }\n\n    set&lt;int&gt; uniqueSet;\n    for (const auto&amp; item : posMap)\n    {\n        uniqueSet.insert(item.second);\n    }\n\n    return posMap.size() == uniqueSet.size();\n}</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a>1. 两数之和</h2><ul>\n<li><ol>\n<li>Two Sum</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/two-sum\">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>\n</blockquote>\n<blockquote>\n<p>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>\n</blockquote>\n<pre><code class=\"c++\"> vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        vector&lt;int&gt; result;\n        map&lt;int, int&gt; numsMap;\n\n        for (int i = 0; i &lt; nums.size(); i++)\n        {\n            int left = target - nums[i];\n\n            if (numsMap.count(left) &gt; 0) {\n                result.push_back(numsMap[left]);\n                result.push_back(i);\n                break;\n            }\n            numsMap[nums[i]] = i;\n        }\n\n        return result;\n    }</code></pre>\n<h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2.两数相加\"></a>2.两数相加</h2><ul>\n<li><ol start=\"2\">\n<li>Add Two Numbers</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/add-two-numbers\">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n</li>\n</ul>\n<blockquote>\n<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n</blockquote>\n<blockquote>\n<p>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>\n</blockquote>\n<pre><code class=\"c++\"> ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* head = new ListNode(-1);//存放结果的链表\n        ListNode* h = head;//移动指针\n        int sum = 0;//每个位的加和结果\n        bool carry = false;//进位标志\n        while (l1 != NULL || l2 != NULL)\n        {\n            sum = 0;\n            if (l1 != NULL)\n            {\n                sum += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2 != NULL)\n            {\n                sum += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            if (carry)\n                sum++;\n            h-&gt;next = new ListNode(sum % 10);\n            h = h-&gt;next;\n            carry = sum &gt;= 10 ? true : false;\n        }\n        if (carry)\n        {\n            h-&gt;next = new ListNode(1);\n        }\n        ListNode* ptrDelete = head;\n        head = head-&gt;next;\n        delete ptrDelete;\n\n        return head;\n    }</code></pre>\n<h2 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3.无重复字符的最长子串\"></a>3.无重复字符的最长子串</h2><ul>\n<li><ol start=\"3\">\n<li>Longest Substring Without Repeating Characters</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n</li>\n</ul>\n<blockquote>\n<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>\n</blockquote>\n<blockquote>\n<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>\n</blockquote>\n<blockquote>\n<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>\n</blockquote>\n<pre><code class=\"c++\">int lengthOfLongestSubstring(string s) {\n        map&lt;char, int&gt; posMap;\n        int ans = 0;\n        int start = 0;\n        int end = 0;\n\n        while (end &lt; s.length()) {\n            char cur = s[end];\n            if (posMap.count(cur) &gt; 0) {\n                start = max(posMap[cur],start);\n            }\n            ans = max(end - start + 1, ans);\n            posMap[cur] = end + 1;\n            end += 1;\n        }\n\n        return ans;\n    }</code></pre>\n<h2 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4. 寻找两个正序数组的中位数\"></a>4. 寻找两个正序数组的中位数</h2><ul>\n<li><ol start=\"4\">\n<li>Median of Two Sorted Arrays</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays\">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n</li>\n</ul>\n<blockquote>\n<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>\n</blockquote>\n<blockquote>\n<p>示例 1：<br>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：<br>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br>示例 3：<br>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000<br>示例 4：<br>输入：nums1 = [], nums2 = [1]<br>输出：1.00000<br>示例 5：<br>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p>\n</blockquote>\n<pre><code class=\"c++\">int getKthElement(const vector&lt;int&gt;&amp; nums1, const vector&lt;int&gt;&amp; nums2, int k) {\n        int m = nums1.size();\n        int n = nums2.size();\n        int index1 = 0, index2 = 0;\n\n        while (true) {\n            //处理边界\n            if (index1 == m)\n                return nums2[index2 + k -1];\n\n            if (index2 == n)\n                return nums1[index1 + k - 1];\n\n            if (k == 1)\n                return min(nums1[index1], nums2[index2]);\n\n            //* 正式处理，查找两个二序列表中第K大的数 *//\n\n            //拿出两个数组 k/2 -1位的数\n            int nIndex1 = min(index1 + k / 2 - 1, m-1);\n            int nIndex2 = min(index2 + k / 2 - 1,n-1);\n\n            //数组二大！数组一的[0]-[k/2-1]被移去算法范围\n            if (nums1[nIndex1] &lt;= nums2[nIndex2]) {\n                k -= nIndex1 + 1 - index1;//个数已经比较完，继续剩下的数的比较\n                index1 = nIndex1 + 1;\n            }\n            else{//相关\n                k -= nIndex2 + 1 - index2;//个数已经比较完，继续剩下的数的比较\n                index2 = nIndex2 + 1;\n            }\n        }\n    }\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        int total = nums1.size() + nums2.size();\n\n        if (total % 2 == 1) {\n            //奇数个\n            return getKthElement(nums1, nums2, (total+1) / 2);\n        }\n        else {\n            //偶数个\n            return (getKthElement(nums1, nums2, (total / 2)) + getKthElement(nums1, nums2, total/2 +1)) / 2.0;\n        }\n    }</code></pre>\n<h2 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5. 最长回文子串\"></a>5. 最长回文子串</h2><ul>\n<li><ol start=\"5\">\n<li>Longest Palindromic Substring</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring\">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p>\n</blockquote>\n<blockquote>\n<p>暴力解法：</p>\n</blockquote>\n<pre><code class=\"c++\">bool validatePalindrome(string s, int i, int j) {\n    while (i &lt; j) {\n        if (s[i] != s[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n\n    if (s == &quot;&quot; || s.length() &lt; 2)\n        return s;\n\n    int begin = 0;\n    int maxLen = 1;\n    for (int i = 0; i &lt; s.length()-1; i++)\n    {\n        for (int j = i+1; j &lt; s.length(); j++)\n        {\n            if (((j - i + 1) &gt; maxLen) &amp;&amp; validatePalindrome(s, i, j)) {\n                maxLen = (j - i + 1);\n                begin = i;\n            }\n        }\n    }\n    return s.substr(begin, maxLen);\n}</code></pre>\n<blockquote>\n<p>中心扩散法</p>\n</blockquote>\n<pre><code class=\"c++\">int expandAroundCenter(string s, int left, int right) {\n    int len = s.length();\n    int i = left;\n    int j = right;\n    while (i &gt;= 0 &amp;&amp; j &lt; len) {\n        if (s[i] == s[j]) {\n            i--;\n            j++;\n        }\n        else {\n            break;\n        }\n    }\n\n    return j - i +1 - 2;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n    if (s == &quot;&quot; || s.length() &lt; 2)\n        return s;\n\n    int begin = 0;\n    int maxLen = 1;\n    for (int i = 0; i &lt; s.length() - 1; i++)\n    {\n        int oddLen = expandAroundCenter(s, i, i);\n        int eveLen = expandAroundCenter(s, i, i+1);\n\n        int curMaxLen = max(oddLen, eveLen);\n        if (curMaxLen &gt; maxLen) {\n            maxLen = curMaxLen;\n            begin = i - (curMaxLen - 1) / 2;\n        }\n    }\n\n    return s.substr(begin, maxLen);\n\n}</code></pre>\n<blockquote>\n<p>动态规划</p>\n</blockquote>\n<pre><code class=\"c++\">string QuestionHandler::longestPalindrome(string s) {\n    if (s == &quot;&quot; || s.length() &lt; 2)\n        return s;\n\n    int len = s.length();\n    int begin = 0;\n    int maxLen = 1;\n    vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));\n    for (int j = 1; j &lt; len; j++) {\n        for (int i = 0; i &lt; j; i++) {\n            if (s[i] != s[j]) {\n                dp[i][j] = 0;\n            }\n            else {\n                if (j - i &lt; 3) {\n                    dp[i][j] = 1;\n                }\n                else {\n                    dp[i][j] = dp[i + 1][j - 1];\n                }\n            }\n\n            if (dp[i][j] &amp;&amp; (j - i + 1) &gt; maxLen) {\n                maxLen = j - i + 1;\n                begin = i;\n            }\n        }\n    }\n\n    return s.substr(begin, maxLen);\n}</code></pre>\n<p><img src=\"/img/1603943631534.png\" alt=\"动态规划解法\"></p>\n<blockquote>\n<p>Manacher算法 - O(n)</p>\n</blockquote>\n<pre><code class=\"c++\">int expand(const string&amp; s, int left, int right) {\n    while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) {\n        --left;\n        ++right;\n    }\n    return (right - left - 2) / 2;\n}\nstring QuestionHandler::longestPalindrome(string s) {\n    int start = 0, end = -1;\n    string t = &quot;#&quot;;\n    for (char c : s) {\n        t += c;\n        t += &#39;#&#39;;\n    }\n    t += &#39;#&#39;;\n    s = t;\n\n    vector&lt;int&gt; arm_len;\n    int right = -1, j = -1;\n    for (int i = 0; i &lt; s.size(); ++i) {\n        int cur_arm_len;\n        if (right &gt;= i) {\n            int i_sym = j * 2 - i;\n            int min_arm_len = min(arm_len[i_sym], right - i);\n            cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);\n        }\n        else {\n            cur_arm_len = expand(s, i, i);\n        }\n        arm_len.push_back(cur_arm_len);\n        if (i + cur_arm_len &gt; right) {\n            j = i;\n            right = i + cur_arm_len;\n        }\n        if (cur_arm_len * 2 + 1 &gt; end - start) {\n            start = i - cur_arm_len;\n            end = i + cur_arm_len;\n        }\n    }\n\n    string ans;\n    for (int i = start; i &lt;= end; ++i) {\n        if (s[i] != &#39;#&#39;) {\n            ans += s[i];\n        }\n    }\n    return ans;\n}</code></pre>\n<h2 id=\"6-Z-字形变换\"><a href=\"#6-Z-字形变换\" class=\"headerlink\" title=\"6.Z 字形变换\"></a>6.Z 字形变换</h2><ul>\n<li><ol start=\"6\">\n<li>ZigZag Conversion</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/zigzag-conversion\">https://leetcode-cn.com/problems/zigzag-conversion</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L   C   I   R<br>E T O E S I I G<br>E   D   H   N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。<br>请你实现这个将字符串进行指定行数变换的函数：<br>string convert(string s, int numRows);<br>示例 1:<br>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”<br>示例 2:<br>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L     D     R<br>E   O E   I I<br>E C   I H   N<br>T     S     G</p>\n</blockquote>\n<pre><code class=\"c++\">  string convert(string s, int numRows) {\n        if (numRows == 1) return s;\n\n        int rowIdx = 0;\n        vector&lt;string&gt; rowStrs(numRows);\n        bool goingDown = false;\n        for (char c : s) {\n            rowStrs[rowIdx] += c;\n            if (rowIdx == 0 || rowIdx == numRows - 1) goingDown = !goingDown;\n            rowIdx += goingDown ? 1 : -1;\n        }\n\n        string result;\n        for (string row : rowStrs) result += row;\n        return result;\n    }</code></pre>\n<h2 id=\"7-整数反转\"><a href=\"#7-整数反转\" class=\"headerlink\" title=\"7. 整数反转\"></a>7. 整数反转</h2><ul>\n<li><ol start=\"7\">\n<li>Reverse Integer</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/reverse-integer\">https://leetcode-cn.com/problems/reverse-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>示例 1:<br>输入: 123<br>输出: 321<br> 示例 2:<br>输入: -123<br>输出: -321<br>示例 3:<br>输入: 120<br>输出: 21</p>\n</blockquote>\n<pre><code class=\"c++\">  int reverse(int x) {\n         int ans = 0;\n        while (x != 0) {\n            if (ans &gt; 214748364 || ans &lt; -214748364) {\n                return 0;\n            }\n            ans = ans*10 + x % 10;\n            x /= 10;\n        }\n\n        return ans;\n    }</code></pre>\n<h2 id=\"8-字符串转换整数-atoi\"><a href=\"#8-字符串转换整数-atoi\" class=\"headerlink\" title=\"8. 字符串转换整数 (atoi)\"></a>8. 字符串转换整数 (atoi)</h2><ul>\n<li><ol start=\"8\">\n<li>String to Integer (atoi)</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi\">https://leetcode-cn.com/problems/string-to-integer-atoi</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br>提示：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: “42”<br>输出: 42<br>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p>\n</blockquote>\n<pre><code class=\"c++\">class Automaton {\n    string state = &quot;start&quot;;\n    unordered_map&lt;string, vector&lt;string&gt;&gt; table = {\n        {&quot;start&quot;, {&quot;start&quot;, &quot;signed&quot;, &quot;in_number&quot;, &quot;end&quot;}},\n        {&quot;signed&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;}},\n        {&quot;in_number&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;}},\n        {&quot;end&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;end&quot;, &quot;end&quot;}}\n    };\n\n    int get_col(char c) {\n        if (isspace(c)) return 0;\n        if (c == &#39;+&#39; or c == &#39;-&#39;) return 1;\n        if (isdigit(c)) return 2;\n        return 3;\n    }\npublic:\n    int sign = 1;\n    long long ans = 0;\n\n    void get(char c) {\n        state = table[state][get_col(c)];\n        if (state == &quot;in_number&quot;) {\n            ans = ans * 10 + c - &#39;0&#39;;\n            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);\n        }\n        else if (state == &quot;signed&quot;)\n            sign = c == &#39;+&#39; ? 1 : -1;\n    }\n};\n\nint myAtoi(string s) {\n         Automaton automaton;\n        for (char c : s)\n            automaton.get(c);\n        return automaton.sign * automaton.ans;\n    }</code></pre>\n<h2 id=\"9-回文数\"><a href=\"#9-回文数\" class=\"headerlink\" title=\"9.回文数\"></a>9.回文数</h2><ul>\n<li><ol start=\"9\">\n<li>Palindrome Number</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/palindrome-number\">https://leetcode-cn.com/problems/palindrome-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>示例 1:<br>输入: 121<br>输出: true<br>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>\n</blockquote>\n<pre><code class=\"c++\"> bool isPalindrome(int x) {\n        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {\n            return false;\n        }\n        //后半段与前半段对比\n        int revertedNumber = 0;\n        while (x &gt; revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        return x == revertedNumber || x == revertedNumber / 10;\n    }</code></pre>\n<h2 id=\"10-正则表达式匹配\"><a href=\"#10-正则表达式匹配\" class=\"headerlink\" title=\"10. 正则表达式匹配\"></a>10. 正则表达式匹配</h2><ul>\n<li><ol start=\"10\">\n<li>Regular Expression Matching</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/regular-expression-matching\">https://leetcode-cn.com/problems/regular-expression-matching</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>\n<blockquote>\n<p>‘.’ 匹配任意单个字符<br>‘*‘ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>\n</blockquote>\n<blockquote>\n<p>示例 1：<br>输入：s = “aa” p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入：s = “aa” p = “a*”<br>输出：true<br>解释：因为 ‘*‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>\n</blockquote>\n<blockquote>\n<p>示例 3：<br>输入：s = “ab” p = “.*“<br>输出：true<br>解释：”.*“ 表示可匹配零个或多个（’*‘）任意字符（’.’）。</p>\n</blockquote>\n<blockquote>\n<p>示例 4：<br>输入：s = “aab” p = “c*a*b”<br>输出：true<br>解释：因为 ‘*‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>\n</blockquote>\n<blockquote>\n<p>示例 5：<br>输入：s = “mississippi” p = “mis*is*p*.”<br>输出：false</p>\n</blockquote>\n<pre><code class=\"c++\">bool isMatch(string s, string p) {\n    // dp[i][j]表示str[1:i]和pattern[1:j]能否匹配，为0表示无法匹配，为1表示可以匹配\n//\n// 分析状态转移方程\n//   对于dp[i][j]，如果str[i]与p[j]相同或者p[j]为.，则dp[i][j] = dp[i-1][j-1]，即与s[1:i-1]和p[1:j-1]的匹配情况相同\n//   如果p[j]为*，则表示这个字符可以联合p[j-1]使用来匹配当前的s[i](这个选择可做可不做，但我们尽量去匹配字符串)\n//   考虑p[j]为*，如果p前一个字符为.，显然可以用一次.*组合匹配到s[i]，如果p前一个字符p[j-1]不为.并且不与s[i]相同，则不能使用\n//   综合考虑，若p[j]==&#39;*&#39;\n//   1. 不选择替换，使用0次*，dp[i][j] = dp[i][j-2]\n//   2. 当p[j-1]为.或者与s[i]相同时，可以使用一次替换，则dp[i][j] = dp[i-1][j]\n//   两者求或 (因为我们尽可能去匹配字符串，所以只要有一种情况匹配成功，则匹配成功)\n// 初始化主要考虑p去匹配一个空串的情况，和上面类似的分析过程即可得出结论\n\n    //dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配\n    vector&lt;vector&lt;bool&gt;&gt; dp(s.size() + 1, vector&lt;bool&gt;(p.size() + 1));\n    dp[0][0] = true;\n\n    //s 的前 0 个是否能被 p 的前 j 个匹配\n    for (size_t j = 1; j &lt; p.size(); ++j)\n    {\n        if (p[j] == &#39;*&#39;)\n        {\n            dp[0][j + 1] = dp[0][j - 1];\n        }\n    }\n\n    for (size_t i = 0; i &lt; s.size(); ++i)\n    {\n        for (size_t j = 0; j &lt; p.size(); ++j)\n        {\n            if (s[i] == p[j] || p[j] == &#39;.&#39;)//匹配单个字符  \n            {\n                dp[i + 1][j + 1] = dp[i][j];\n            }\n            else if (p[j] == &#39;*&#39; &amp;&amp; j &gt; 0)\n            {\n                if (s[i] != p[j - 1] &amp;&amp; p[j - 1] != &#39;.&#39;)//前一对字符匹配\n                {\n                    dp[i + 1][j + 1] = dp[i + 1][j - 1];\n                }\n                else\n                {\n                    dp[i + 1][j + 1] = dp[i][j + 1] || //*表示匹配超过一个字符(s[i]、s[i-1]和p[j-1])\n                        //dp[i + 1][j] || //*表示只匹配一个字符（s[i]和p[j-1]）\n                        dp[i + 1][j - 1];//*表示0个匹配\n                }\n\n            }\n        }\n    }\n\n    return dp[s.size()][p.size()];\n}</code></pre>\n<h2 id=\"11-盛最多水的容器\"><a href=\"#11-盛最多水的容器\" class=\"headerlink\" title=\"11. 盛最多水的容器\"></a>11. 盛最多水的容器</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/container-with-most-water\">https://leetcode-cn.com/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。</p>\n</blockquote>\n<blockquote>\n<p>示例：<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p>\n</blockquote>\n<pre><code class=\"c++\">int maxArea(vector&lt;int&gt;&amp; height) {\n        int n = height.size();\n        if (n &lt; 2)\n            return 0;\n\n        int maxVolume = 0;\n        int left = 0;\n        int right = n - 1;\n\n        while(left &lt; right){\n            //取左端与右端\n            int lh = height[left];\n            int rh = height[right];\n\n            //计算体积\n            int vol = min(lh, rh) * (right-left);\n            //设置最大体积\n            maxVolume = max(maxVolume, vol);\n\n            //哪端的指针移动，取决于哪根柱子更低\n            left += (lh &lt;= rh) ? 1 : 0;\n            right -= (lh &gt; rh) ? 1 : 0;\n\n            cout &lt;&lt; &quot;left:&quot;&lt;&lt;left&lt;&lt;&quot;,right:&quot;&lt;&lt;right&lt;&lt;endl;\n        }\n\n\n        return maxVolume;\n    }</code></pre>\n<h2 id=\"17-电话号码的字母组合\"><a href=\"#17-电话号码的字母组合\" class=\"headerlink\" title=\"17. 电话号码的字母组合\"></a>17. 电话号码的字母组合</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number\">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n</blockquote>\n<p><img src=\"/img/1604578953107.png\" alt=\"17\"></p>\n<blockquote>\n<p>示例:<br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>\n</blockquote>\n<pre><code class=\"c++\">  vector&lt;string&gt; letterCombinations(string digits) {\n        map&lt;int,vector&lt;char&gt;&gt; numsMap;\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(2, vector&lt;char&gt;{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(3, vector&lt;char&gt;{&#39;d&#39;, &#39;e&#39;, &#39;f&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(4, vector&lt;char&gt;{&#39;g&#39;, &#39;h&#39;, &#39;i&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(5, vector&lt;char&gt;{&#39;j&#39;, &#39;k&#39;, &#39;l&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(6, vector&lt;char&gt;{&#39;m&#39;, &#39;n&#39;, &#39;o&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(7, vector&lt;char&gt;{&#39;p&#39;, &#39;q&#39;, &#39;r&#39;,&#39;s&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(8, vector&lt;char&gt;{&#39;t&#39;, &#39;u&#39;, &#39;v&#39;}));\n        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(9, vector&lt;char&gt;{&#39;w&#39;, &#39;x&#39;, &#39;y&#39;,&#39;z&#39;}));\n\n        /*输入：&quot;23&quot;\n            输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].*/\n        map&lt;string, int&gt; resultMap;\n        vector&lt;string&gt; result;\n\n        for (int i = 0; i &lt; digits.size(); i++) {\n            int v = digits[i] - &#39;0&#39;;\n            if (numsMap.count(v) == 0) {\n                result.clear();\n                break;\n            }\n            vector&lt;char&gt; curChars = numsMap[v];\n            if (i &gt; 0) {\n                vector&lt;string&gt; tmpList;\n                for(string val : result) {\n                    for (char c : curChars) {\n                        tmpList.push_back(val + c);\n                    }\n                }\n                result.clear();\n                result = tmpList;\n            }\n            else {\n                for (auto it = curChars.begin(); it != curChars.end(); it++) {\n                      char v = *it;\n                    result.push_back(string (1,v));\n                }\n            }\n        }\n\n        return result;\n    }</code></pre>\n<h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15.三数之和\"></a>15.三数之和</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/3sum\">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>\n</blockquote>\n<blockquote>\n<p>示例：<br>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>\n</blockquote>\n<pre><code class=\"c++\">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());   // -4  -1  -1  0  1  2\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for(int i=0; i&lt;nums.size(); i++){\n            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]){\n                continue;\n            }\n            int j = i+1, k = nums.size() -1;\n            while(j &lt; k){\n                if(j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]){\n                    j++;\n                    continue;\n                }\n                if(k &lt; nums.size()-1 &amp;&amp; nums[k] == nums[k+1]){\n                    k--;\n                    continue;\n                }\n                if(nums[j] + nums[k] &gt; -1*nums[i]){\n                    k--;\n                }else if(nums[j] + nums[k] &lt; -1*nums[i]){\n                    j++;\n                }else{\n                    res.push_back({nums[i], nums[j], nums[k]});\n                    j++, k--;\n                }\n            }\n        }\n        return res;\n    }</code></pre>\n<h2 id=\"19-删除链表的倒数第N个节点\"><a href=\"#19-删除链表的倒数第N个节点\" class=\"headerlink\" title=\"19.删除链表的倒数第N个节点\"></a>19.删除链表的倒数第N个节点</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list\">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：<br>给定的 n 保证是有效的。<br>进阶：<br>你能尝试使用一趟扫描实现吗？</p>\n</blockquote>\n<pre><code class=\"c++\">  ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* pre = NULL;\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            fast = fast-&gt;next;\n        }\n\n        while (fast != NULL) {\n            pre = slow;\n            slow = slow-&gt;next;\n            fast = fast-&gt;next;\n        }\n\n        if (pre != NULL) {\n            pre-&gt;next = slow-&gt;next;\n            return head;\n        }\n        else {\n            return head-&gt;next;\n        }\n\n    }\n</code></pre>\n<h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a>20. 有效的括号</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/valid-parentheses\">https://leetcode-cn.com/problems/valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: “()”<br>输出: true<br>示例 2:<br>输入: “()[]{}”<br>输出: true<br>示例 3:<br>输入: “(]”<br>输出: false<br>示例 4:<br>输入: “([)]”<br>输出: false<br>示例 5:<br>输入: “{[]}”<br>输出: true</p>\n</blockquote>\n<pre><code class=\"c++\"> bool isValid(string s) {\n        map&lt;char, char&gt; cMap = {\n            {&#39;]&#39;,&#39;[&#39;},\n            {&#39;}&#39;,&#39;{&#39;},\n            {&#39;)&#39;,&#39;(&#39;},\n        };\n\n        if (s.size() % 2 == 1)//奇数必然不对\n            return false;\n\n        stack&lt;char&gt; cs;\n        for (char c : s) {\n            if (cMap.count(c)) {\n                if (cs.empty() || cs.top() != cMap[c]) {\n                    return false;\n                }\n                cs.pop();\n            }\n            else {\n                cs.push(c);\n            }\n        }\n        return cs.size() == 0;\n    }</code></pre>\n<h2 id=\"22-括号生成\"><a href=\"#22-括号生成\" class=\"headerlink\" title=\"22. 括号生成\"></a>22. 括号生成</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/generate-parentheses\">https://leetcode-cn.com/problems/generate-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>\n</blockquote>\n<blockquote>\n<p>示例：<br>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p>\n</blockquote>\n<pre><code class=\"c++\"> void LoopGetParanthesis(vector&lt;string&gt; &amp; result,string str,int left, int right) {\n        if (left == 0 &amp;&amp; right == 0) {\n            result.push_back(str);\n            return;\n        }\n\n        //左右括号数相等，则只用左括号\n        if (left == right) {\n            LoopGetParanthesis(result, str + &quot;(&quot;, left - 1, right);\n        }\n        else if(left &lt; right){\n            if (left &gt; 0) {\n                LoopGetParanthesis(result, str + &quot;(&quot;, left-1, right);\n            }\n            LoopGetParanthesis(result, str + &quot;)&quot;, left, right - 1);\n        }\n    }\n    vector&lt;string&gt; generateParenthesis(int n) {\n        vector&lt;string&gt; result;\n        string str = &quot;&quot;;\n        LoopGetParanthesis(result, str, n, n);\n\n        return result;\n    }</code></pre>\n<h2 id=\"26-删除排序数组中的重复项\"><a href=\"#26-删除排序数组中的重复项\" class=\"headerlink\" title=\"26.删除排序数组中的重复项\"></a>26.删除排序数组中的重复项</h2><ul>\n<li><ol start=\"26\">\n<li>Remove Duplicates from Sorted Array</li>\n</ol>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n</li>\n</ul>\n<blockquote>\n<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() ==0) return 0;\n        int thumb = 0;\n\n        for(int i = 1;i &lt; nums.size(); i++){\n            if(nums[i] != nums[thumb]){\n                thumb ++;\n                nums[thumb] = nums[i];\n            }\n        }\n        return thumb+1;\n    }\n};</code></pre>\n<h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h2><ul>\n<li><ol start=\"27\">\n<li>Remove Element</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-element\">https://leetcode-cn.com/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) {\n        int thumb = 0;\n        for(int i = 0; i &lt; nums.size(); i++){\n            if(nums[i] != val){\n                nums[thumb] = nums[i];\n                thumb ++;\n            }\n        }\n        return thumb;\n    }\n};</code></pre>\n<h2 id=\"28-实现-strStr\"><a href=\"#28-实现-strStr\" class=\"headerlink\" title=\"28. 实现 strStr()\"></a>28. 实现 strStr()</h2><ul>\n<li><ol start=\"28\">\n<li>Implement strStr()</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/implement-strstr\">https://leetcode-cn.com/problems/implement-strstr</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p>\n</blockquote>\n<pre><code class=\"python\">class Solution:\n    def strStr(self, source: str, target: str) -&gt; int:\n        if source == target:\n            return 0\n\n        source_len = len(source)\n        target_len = len(target)\n\n        if target_len &gt; source_len:\n            return -1\n\n        for i in range(source_len):\n            target_index = i + target_len\n            if target_index &gt; source_len:\n                continue\n            if source[i:target_index] == target:\n                return i\n\n        return -1</code></pre>\n<h2 id=\"29-两数相除\"><a href=\"#29-两数相除\" class=\"headerlink\" title=\"29. 两数相除\"></a>29. 两数相除</h2><ul>\n<li><ol start=\"29\">\n<li>Divide Two Integers</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/divide-two-integers\">https://leetcode-cn.com/problems/divide-two-integers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>返回被除数 dividend 除以除数 divisor 得到的商。<br>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: dividend = 7, divisor = -3<br>输出: -2<br>解释: 7/-3 = truncate(-2.33333..) = -2</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>\n</blockquote>\n<pre><code class=\"python\">class Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n        if abs_dividend &lt; abs_divisor:\n            return 0\n\n        is_neg = 0\n        if abs(dividend + divisor) != abs_dividend + abs_divisor:\n            is_neg = 1\n        ans = 0\n\n        for i in range(31, -1, -1):\n            print(&#39;abs_dividend &gt;&gt; %d : %d, %d, &#39;% (i, abs_dividend &gt;&gt; i, abs_divisor))\n\n            if abs_dividend &gt;&gt; i &gt;= abs_divisor:\n                ans += 1 &lt;&lt; i\n                abs_dividend -= abs_divisor &lt;&lt; i\n                print(&#39;good value: %d, %d&#39;%(ans, abs_dividend))\n\n        if is_neg and ans &gt;= 2 ** 31:\n            return -2 ** 31\n        elif ans &gt;= 2 ** 31:\n            return 2 ** 31 - 1\n        elif is_neg:\n            return -ans\n        else:\n            return ans</code></pre>\n<h2 id=\"30-串联所有单词的子串\"><a href=\"#30-串联所有单词的子串\" class=\"headerlink\" title=\"30. 串联所有单词的子串\"></a>30. 串联所有单词的子串</h2><ul>\n<li><ol start=\"30\">\n<li>Substring with Concatenation of All Words</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words\">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。<br>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p>\n</blockquote>\n<blockquote>\n<p>示例 1：<br>输入：<br>  s = “barfoothefoobarman”,<br>  words = [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。</p>\n</blockquote>\n<blockquote>\n<p>示例 2：<br>输入：<br>  s = “wordgoodgoodgoodbestword”,<br>  words = [“word”,”good”,”best”,”word”]<br>输出：[]</p>\n</blockquote>\n<pre><code class=\"python\">class Solution(object):\n    def findSubstring(self, s, words):\n        from collections import Counter\n        if not s or not words:return []\n        one_word = len(words[0])\n        all_len = len(words) * one_word\n        n = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0, n - all_len + 1):\n            tmp = s[i:i+all_len]\n            c_tmp = []\n            for j in range(0, all_len, one_word):\n                c_tmp.append(tmp[j:j+one_word])\n            if Counter(c_tmp) == words:\n                res.append(i)\n        return res</code></pre>\n<h2 id=\"41-缺失的第一个正数\"><a href=\"#41-缺失的第一个正数\" class=\"headerlink\" title=\"41. 缺失的第一个正数\"></a>41. 缺失的第一个正数</h2><ul>\n<li><ol start=\"41\">\n<li>First Missing Positive</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/first-missing-positive\">https://leetcode-cn.com/problems/first-missing-positive</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: [1,2,0]<br>输出: 3</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: [3,4,-1,1]<br>输出: 2</p>\n</blockquote>\n<blockquote>\n<p>示例 3:<br>输入: [7,8,9,11,12]<br>输出: 1</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {\n         // 总长\n        int n = nums.size();\n        // 1. 全部元素没有1，返回1\n        bool noOne = true;\n        for(int i = 0; i &lt; nums.size();i++){\n            if(nums[i] == 1)\n            {\n                noOne = false;\n                break;\n            }\n        }\n        if(noOne){\n            return 1;\n        }\n\n        //2. 只有一个元素，且为[1]，则返回2\n        if(n == 1)\n        {\n            return 2;\n        }\n\n        //3. 去&lt;= 0与 &gt; 总数的数，将其设为1\n        for(int i = 0; i &lt; n;i++){\n            if(i == n-1){\n                cout &lt;&lt; nums[i] &lt;&lt; endl;\n            }\n            if(nums[i] &lt; 1 || nums[i] &gt; n){\n                nums[i] = 1;\n            }\n        }\n\n\n        //4.遍历，当值 == 总数。第一个值设为负数. 当值 &lt;= 总数，以值为下标设置为负值. 特别的，当值为总数时，将第一个值为负值！\n         for(int i = 0; i &lt; n; i++){\n             int a = abs(nums[i]);\n             if(a == n){\n                 nums[0] = - abs(nums[0]);\n             }else{\n                nums[a] = - abs(nums[a]);\n             }\n         }\n\n        for(int v: nums){\n            cout &lt;&lt; v &lt;&lt; &quot;,&quot;;\n        }\n        cout &lt;&lt; endl;\n\n        //5.遍历最新的数组中，发现有大于0，此索引就是丢失的最小正数\n        for(int i = 1; i &lt; n;i++){\n            if(nums[i] &gt; 0){\n                return i;\n            }\n        }\n\n        //6.5如果没有找到，第一值取出来如果是正数，则数为正数N\n        if(nums[0] &gt; 0){\n            return n;\n        }\n\n        //7.如果以上走完了，返回n+1\n        return n+1;\n    }\n};</code></pre>\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. 接雨水</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/trapping-rain-water\">https://leetcode-cn.com/problems/trapping-rain-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>示例 1：</p>\n</blockquote>\n<p><img src=\"/img/1604063667003.png\" alt=\"接雨水\"></p>\n<blockquote>\n<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>示例 2：<br>输入：height = [4,2,0,3,2,5]<br>输出：9</p>\n</blockquote>\n<pre><code class=\"c++\">  int trap(vector&lt;int&gt;&amp; height) {\n        int left = 0, right = height.size() - 1;\n        int ans = 0;\n        int left_max = 0, right_max = 0;\n        while (left &lt; right) {\n            //情况1：左比右低，只有当左边最高柱比当前柱要高，则这个落差必定是能装水的。\n            if (height[left] &lt; height[right]) {\n                height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);\n                ++left;\n            }\n            else {//情况2：右比左低，只有当右边最高柱比当前柱要高，则这个落差必定是能装水的。\n                height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);\n                --right;\n            }\n        }\n        return ans;\n    }</code></pre>\n<h2 id=\"51-N皇后-amp-52-N皇后-II\"><a href=\"#51-N皇后-amp-52-N皇后-II\" class=\"headerlink\" title=\"51. N皇后 &amp; 52. N皇后 II\"></a>51. N皇后 &amp; 52. N皇后 II</h2><ul>\n<li><ol start=\"51\">\n<li>N-Queens</li>\n</ol>\n</li>\n<li><ol start=\"52\">\n<li>N-Queens II</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/n-queens\">https://leetcode-cn.com/problems/n-queens</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n</blockquote>\n<p><img src=\"/img/1601178139148.png\" alt=\"8皇后的一种解法\"></p>\n<blockquote>\n<ol start=\"51\">\n<li>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</li>\n<li>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</li>\n</ol>\n</blockquote>\n<pre><code class=\"python\">class NQueen:\n    def __init__(self):\n        self.count = 0\n\n    def do_nqueen(self, n):\n        empty_sign = &quot;[O]&quot;\n        queen_sign = &quot;[1]&quot;\n        # 所有数组起点都以0开始\n\n        # 1.定义所有解的容器，二维数组，第二维代表一个完整的解\n        ans = []\n\n        # 2.递归函数dfs\n        def dfs(nums, row):\n            # 如果找的行数与n相等了，说明已经找完了，得到一个解！\n            if row == n:\n                ans.append(nums[:]) # 注意不可用ans.append(nums)\n                return\n            # 逐列进行尝试，列的总数为n\n            for i in range(n):\n                # 每进行到一列，标记当前行皇后位置为此列\n                nums[row] = i\n                # 往下递归找到，一直找到底，找不到底循环会返回到此处！\n                if valid(nums, row):\n                    # print(&quot;当前找到第%d行的第%d列，此值可放皇后！&quot;%(row, i))\n                    dfs(nums, row+1)\n                else:\n                    pass\n                    # print(&quot;当前找到第%d行的第%d列，不可放，回溯&quot;%(row, i))\n\n        # 3.检查函数valid\n        def valid(nums, row):\n            # 只找前面行的点， 皇后攻击规则，同列同行 和 对角线元素表示\n            for r in range(row):\n                if abs(nums[r] - nums[row]) == abs(r - row) or nums[r] == nums[row]:\n                    return False\n            return True\n\n        # 4.执行, 从第0行开始找n数组长度中的位置\n        dfs([None for _ in range(n)], 0)\n\n        def get_row_list(row_val, count):\n            result = []\n            for i in range(count):\n                if i == row_val:\n                    result.append(queen_sign)\n                else:\n                    result.append(empty_sign)\n            return result\n\n\n        # 5.结果画出来\n        result = [[] for _ in range(len(ans))]\n        for i in range(len(ans)):\n            for col in ans[i]:\n                result[i].append(&quot;&quot;.join(get_row_list(col, n)))\n\n        return result\n\n\nmyqueen = NQueen()\nresult = myqueen.do_nqueen(4)\nprint(&quot;解有%d个&quot;%len(result))\nfor r in result:\n    r = str(r)\n    print(r+&quot;\\n\\n&quot;)</code></pre>\n<h2 id=\"75-颜色分类\"><a href=\"#75-颜色分类\" class=\"headerlink\" title=\"75. 颜色分类\"></a>75. 颜色分类</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/sort-colors\">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>注意:<br>不能使用代码库中的排序函数来解决这道题。<br>示例:<br>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]<br>进阶：<br>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>\n</blockquote>\n<pre><code class=\"c++\"> void sortColors(vector&lt;int&gt;&amp; nums) {\n       int n = nums.size();\n        int slow0 = 0, fast = 0, slow2 = n - 1;\n\n        while (fast &lt;= slow2) {\n            while (fast &lt;= slow2 &amp;&amp; nums[fast] == 2) {\n                //当当前快指针为2时，移至结尾。如果换完后的nums[fast]还是2？则继续换\n                nums[fast] = nums[slow2];\n                nums[slow2--] = 2;\n            }\n\n            if (nums[fast] == 0) {\n                nums[fast] = nums[slow0];\n                nums[slow0++] = 0;\n            }\n            fast++;\n        }\n    }</code></pre>\n<h2 id=\"76-最小覆盖子串\"><a href=\"#76-最小覆盖子串\" class=\"headerlink\" title=\"76.最小覆盖子串\"></a>76.最小覆盖子串</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/minimum-window-substring\">https://leetcode-cn.com/problems/minimum-window-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。<br>示例：<br>输入：S = “ADOBECODEBANC”, T = “ABC”<br>输出：”BANC”</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p>\n</blockquote>\n<pre><code class=\"c++\"> string minWindow(string s, string t) {\n        if(s == t) return s;\n\n        map&lt;char, int&gt; need, window;\n        int tLen = t.length();//目标字符串\n        int sLen = s.length();\n        if (tLen == 0 || sLen == 0) return &quot;&quot;;\n        if (sLen &lt; tLen )\n            return &quot;&quot;;\n\n        //先把t中的字符放到need表中，计数\n        for (int i = 0; i &lt; tLen; i++) {\n            char c = t[i];\n            need[c] = ((need.count(c) == 0)?0:need[c]) + 1;\n        }\n\n        int left = 0, right = 0;\n        int len = INT32_MAX, start = 0;\n        int valid = 0; //已经匹配成功的字符种类数（非字符个数）\n\n        //当右指针去到字符串末尾前\n        while (right &lt; sLen) {\n            char c = s[right];\n            right++;//右指针向右滑\n\n            //如果右指针现在滑到的字符是目标字符串的一个，那么更新窗口中的数据\n            if (need.count(c) &gt; 0) {\n                window[c] = ((window.count(c) == 0)?0:window[c]) + 1;\n                if (window[c] == (need[c])) {\n                    valid++;\n                }\n            }\n\n            //窗口开始从左边收缩\n            while (valid == need.size()) {\n                if (right - left &lt; len) {\n                    start = left;\n                    len = right - left;\n                }\n\n                char d = s[left];\n                left++;\n\n                if (need.count(d) &gt; 0) {\n                    if (window[d] == (need[d])) {\n                        valid--;\n                    }\n                    window[d] = window[d] - 1;\n                }\n            }\n        }\n        return len == INT32_MAX ? &quot;&quot; : s.substr(start, len);\n    }</code></pre>\n<h2 id=\"80-删除排序数组中的重复项-II\"><a href=\"#80-删除排序数组中的重复项-II\" class=\"headerlink\" title=\"80. 删除排序数组中的重复项 II\"></a>80. 删除排序数组中的重复项 II</h2><ul>\n<li><ol start=\"80\">\n<li>Remove Duplicates from Sorted Array II</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>给定 nums = [1,1,1,2,2,3],<br>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>给定 nums = [0,0,1,1,1,1,2,3,3],<br>函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<blockquote>\n<p>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n      int i = 0;\n        for (int n : nums) {\n            if (i &lt; 2 || n &gt; nums[i-2]) nums[i++] = n;\n        }\n        return i;\n    }\n};</code></pre>\n<h2 id=\"127-单词接龙\"><a href=\"#127-单词接龙\" class=\"headerlink\" title=\"127. 单词接龙\"></a>127. 单词接龙</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/word-ladder\">https://leetcode-cn.com/problems/word-ladder</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。</p>\n</blockquote>\n<blockquote>\n<p>说明:<br>如果不存在这样的转换序列，返回 0。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出: 5<br>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。<br>示例 2:<br>输入:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出: 0<br>解释: endWord “cog” 不在字典中，所以无法进行转换。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\n    unordered_map&lt;string, int&gt; wordId;\n    vector&lt;vector&lt;int&gt;&gt; edge;\n    int nodeNum = 0;\n\n    void addWord(string&amp; word) {\n        if (!wordId.count(word)) {\n            wordId[word] = nodeNum++;\n            edge.emplace_back();\n        }\n    }\n\n    void addEdge(string&amp; word) {\n        addWord(word);\n        int id1 = wordId[word];\n        for (char&amp; it : word) {\n            char tmp = it;\n            it = &#39;*&#39;;\n            addWord(word);\n            int id2 = wordId[word];\n            edge[id1].push_back(id2);\n            edge[id2].push_back(id1);\n            it = tmp;\n        }\n    }\npublic:\n    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        for (string&amp; word : wordList) {\n            addEdge(word);\n        }\n        addEdge(beginWord);\n        if (!wordId.count(endWord)) {\n            return 0;\n        }\n        vector&lt;int&gt; dis(nodeNum, INT_MAX);\n        int beginId = wordId[beginWord], endId = wordId[endWord];\n        dis[beginId] = 0;\n\n        queue&lt;int&gt; que;\n        que.push(beginId);\n        while (!que.empty()) {\n            int x = que.front();\n            que.pop();\n            if (x == endId) {\n                return dis[endId] / 2 + 1;\n            }\n            for (int&amp; it : edge[x]) {\n                if (dis[it] == INT_MAX) {\n                    dis[it] = dis[x] + 1;\n                    que.push(it);\n                }\n            }\n        }\n        return 0;\n    }\n\n};</code></pre>\n<h2 id=\"129-求根到叶子节点数字之和\"><a href=\"#129-求根到叶子节点数字之和\" class=\"headerlink\" title=\"129.求根到叶子节点数字之和\"></a>129.求根到叶子节点数字之和</h2><ul>\n<li><ol start=\"129\">\n<li>Sum Root to Leaf Numbers</li>\n</ol>\n</li>\n<li>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers\">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li>\n</ul>\n<blockquote>\n<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。<br>计算从根到叶子节点生成的所有数字之和。<br>说明: 叶子节点是指没有子节点的节点。</p>\n</blockquote>\n<p>示例 1:<br>输入: [1,2,3]<br>    1<br>   / <br>  2   3<br>输出: 25<br>解释:<br>从根到叶子节点路径 1-&gt;2 代表数字 12.<br>从根到叶子节点路径 1-&gt;3 代表数字 13.<br>因此，数字总和 = 12 + 13 = 25.<br>示例 2:</p>\n<p>输入: [4,9,0,5,1]<br>    4<br>   / <br>  9   0<br> / <br>5   1<br>输出: 1026<br>解释:<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>从根到叶子节点路径 4-&gt;0 代表数字 40.<br>因此，数字总和 = 495 + 491 + 40 = 1026.</p>\n<pre><code class=\"c++\">int bfs_sum(TreeNode* root) {\n    if(root == NULL)\n        return 0;\n    int sum = 0;\n    queue&lt;TreeNode*&gt; q;\n    queue&lt;int&gt; qn;\n\n    q.push(root);\n    qn.push(root-&gt;val);\n\n    while (!q.empty()) {\n        TreeNode* node = q.front();\n        int nodeVal = qn.front();\n        q.pop();\n        qn.pop();\n\n        if ((node-&gt;left == NULL) &amp;&amp; (node-&gt;right == NULL)) {\n            sum += nodeVal;\n        }\n        else {\n            if (node-&gt;left != NULL) {\n                q.push(node-&gt;left);\n                qn.push(nodeVal * 10 + node-&gt;left-&gt;val);\n            }\n            if (node-&gt;right != NULL) {\n                q.push(node-&gt;right);\n                qn.push(nodeVal * 10 + node-&gt;right-&gt;val);\n            }\n        }\n    }\n    return sum;\n}\n\nint dfs_sum(TreeNode* node, int prevSum) {\n    if(node == NULL)\n        return 0;\n\n    int sum = prevSum * 10 + node-&gt;val;\n    //左右都没有值 \n    if ((node-&gt;left == NULL) &amp;&amp;(node-&gt;right == NULL)) {\n        return sum;\n    }\n    else {\n        sum = dfs_sum(node-&gt;left, sum) + dfs_sum(node-&gt;right, sum);\n    }\n\n    return sum;\n}\n\nint sumNumbers(TreeNode* root) {\n        //return dfs_sum(root, 0);\n    return bfs_sum(root);\n}</code></pre>\n<h2 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141. 环形链表\"></a>141. 环形链表</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle\">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>\n</blockquote>\n<blockquote>\n<p>进阶<br>你能用 O(1)（即，常量）内存解决此问题吗？</p>\n</blockquote>\n<blockquote>\n<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n</blockquote>\n<pre><code class=\"c++\">    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n       ListNode* slow = head;\n        ListNode* fast = head-&gt;next;\n        while (slow != fast) {\n            if (fast == NULL || fast-&gt;next == NULL)\n            {\n                return false;\n            }\n\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n        }\n        return true;\n    }</code></pre>\n<h2 id=\"142-环形链表-II\"><a href=\"#142-环形链表-II\" class=\"headerlink\" title=\"142. 环形链表 II\"></a>142. 环形链表 II</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii\">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>\n</blockquote>\n<blockquote>\n<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n</blockquote>\n<pre><code class=\"c++\">    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while(fast != NULL){\n            if(fast-&gt;next == NULL)\n                return nullptr;\n\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if(slow == fast){\n                ListNode * ptr = head;\n                while(ptr != slow){\n                    ptr = ptr-&gt;next;\n                    slow = slow-&gt;next;\n                }\n                return ptr;\n            }\n        }\n        return nullptr;\n\n    }</code></pre>\n<h2 id=\"144-二叉树的前序遍历\"><a href=\"#144-二叉树的前序遍历\" class=\"headerlink\" title=\"144. 二叉树的前序遍历\"></a>144. 二叉树的前序遍历</h2><ul>\n<li><ol start=\"144\">\n<li>Binary Tree Preorder Traversal</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal\">https://leetcode-cn.com/problems/binary-tree-preorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个二叉树，返回它的 前序 遍历。</p>\n</blockquote>\n<blockquote>\n<p>示例:<br>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3<br>输出: [1,2,3]</p>\n</blockquote>\n<pre><code class=\"c++\">    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; result;\n        if(root == NULL)\n            return result;\n\n        stack&lt;TreeNode&gt; ss;\n        ss.push(*root);\n\n        while(!ss.empty()){\n            TreeNode cur = ss.top();\n            ss.pop();\n\n            result.push_back(cur.val);\n\n            if(cur.right != NULL){\n                ss.push(*cur.right);\n            }\n            if(cur.left != NULL){\n                ss.push(*cur.left);\n            }\n        }\n        return result;\n    }</code></pre>\n<h2 id=\"189-旋转数组\"><a href=\"#189-旋转数组\" class=\"headerlink\" title=\"189. 旋转数组\"></a>189. 旋转数组</h2><ul>\n<li><ol start=\"189\">\n<li>Rotate Array</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/rotate-array\">https://leetcode-cn.com/problems/rotate-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]</p>\n</blockquote>\n<blockquote>\n<p>说明:<br>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    void reverse(vector&lt;int&gt;&amp; nums, int start, int end){\n        for(int i = start,j = end; i &lt; j; i++,j--){\n            int ftmp = nums[j];\n            nums[j] = nums[i];\n            nums[i] = ftmp;\n        }\n    }\n\n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n        if(k &gt; nums.size()){\n            k %= nums.size();\n        }\n\n        reverse(nums, 0, nums.size()-k-1);\n        reverse(nums, nums.size()-k, nums.size()-1);\n        reverse(nums, 0, nums.size()-1);\n    }\n};\n</code></pre>\n<h2 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234. 回文链表\"></a>234. 回文链表</h2><p> 来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">https://leetcode-cn.com/problems/palindrome-linked-list/</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>请判断一个链表是否为回文链表。<br>示例 1:<br>输入: 1-&gt;2<br>输出: false<br>示例 2:<br>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p>\n</blockquote>\n<pre><code class=\"c++\">ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr != nullptr) {\n            ListNode* nextTemp = curr-&gt;next;\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n\n    ListNode* endOfFirstHalf(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) {\n            fast = fast-&gt;next-&gt;next;\n            slow = slow-&gt;next;\n        }\n        return slow;\n    }\n    bool isPalindrome(ListNode* head) {\n        if(head == NULL)\n            return true;\n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode* firstHalfEnd = endOfFirstHalf(head);\n        ListNode* secondHalfStart = reverseList(firstHalfEnd-&gt;next);\n\n        // 判断是否回文\n        ListNode* p1 = head;\n        ListNode* p2 = secondHalfStart;\n        bool result = true;\n        while (result &amp;&amp; p2 != nullptr) {\n            if (p1-&gt;val != p2-&gt;val) {\n                result = false;\n            }\n            p1 = p1-&gt;next;\n            p2 = p2-&gt;next;\n        }\n\n        // 还原链表并返回结果\n        firstHalfEnd-&gt;next = reverseList(secondHalfStart);\n        return result;\n    }</code></pre>\n<h2 id=\"283-移动零\"><a href=\"#283-移动零\" class=\"headerlink\" title=\"283. 移动零\"></a>283. 移动零</h2><p> 来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/move-zeroes/\">https://leetcode-cn.com/problems/move-zeroes/</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>\n</blockquote>\n<pre><code class=\"c++\"> void moveZeroes(vector&lt;int&gt;&amp; nums) {\n       for (int lastNonZeroFoundAt = 0, cur = 0; cur &lt; nums.size(); cur++) {\n            if (nums[cur] != 0) {\n                swap(nums[lastNonZeroFoundAt], nums[cur]);\n                lastNonZeroFoundAt++;\n            }\n        }\n    }</code></pre>\n<h2 id=\"287-寻找重复数\"><a href=\"#287-寻找重复数\" class=\"headerlink\" title=\"287. 寻找重复数\"></a>287. 寻找重复数</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number\">https://leetcode-cn.com/problems/find-the-duplicate-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>示例 1:<br>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:<br>输入: [3,1,3,4,2]<br>输出: 3<br>说明：</p>\n</blockquote>\n<blockquote>\n<p>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 O(1) 的空间。<br>时间复杂度小于 O(n2) 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。</p>\n</blockquote>\n<pre><code class=\"c++\"> int findDuplicate(vector&lt;int&gt;&amp; nums) {\n        int slow = 0, fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        slow = 0;\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return slow;\n    }</code></pre>\n<h2 id=\"299-猜数字游戏\"><a href=\"#299-猜数字游戏\" class=\"headerlink\" title=\"299. 猜数字游戏\"></a>299. 猜数字游戏</h2><ul>\n<li><ol start=\"299\">\n<li>Bulls and Cows</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/bulls-and-cows\">https://leetcode-cn.com/problems/bulls-and-cows</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：<br>你写出一个秘密数字，并请朋友猜这个数字是多少。<br>朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。<br>朋友根据提示继续猜，直到猜出秘密数字。<br>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。</p>\n</blockquote>\n<blockquote>\n<p>xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。<br>yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。<br>请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。</p>\n</blockquote>\n<blockquote>\n<p>示例 1:<br>输入: secret = “1807”, guess = “7810”<br>输出: “1A3B”<br>解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</p>\n</blockquote>\n<blockquote>\n<p>示例 2:<br>输入: secret = “1123”, guess = “0111”<br>输出: “1A1B”<br>解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。</p>\n</blockquote>\n<blockquote>\n<p>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\npublic:\n    string getHint(string secret, string guess) {\n        int bulls = 0;\n        int cows = 0;\n        int ds[10]{0};\n        int dg[10]{0};\n        for(int i = 0; i &lt; secret.size(); i++){\n            int x = secret[i] - &#39;0&#39;;\n            int y = guess[i] - &#39;0&#39;;\n            if(secret[i] == guess[i]){\n                bulls ++;    \n            }\n            ds[x] ++;\n            dg[y] ++;\n        }\n\n        //算出相同元素总数，当然减掉之前算好的cows\n        for(int i = 0;i &lt; 10;i++){\n            cows += min(ds[i],dg[i]);\n        }\n        cows -= bulls;\n        ostringstream oss;\n        oss &lt;&lt; bulls &lt;&lt; &quot;A&quot; &lt;&lt; cows &lt;&lt; &quot;B&quot; ;\n        return oss.str();\n    }\n\n};  </code></pre>\n<h2 id=\"463-岛屿的周长\"><a href=\"#463-岛屿的周长\" class=\"headerlink\" title=\"463. 岛屿的周长\"></a>463. 岛屿的周长</h2><p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/island-perimeter\">https://leetcode-cn.com/problems/island-perimeter</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。<br>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。<br>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>\n</blockquote>\n<blockquote>\n<p>示例 :<br>输入:<br>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]<br>输出: 16</p>\n</blockquote>\n<pre><code class=\"c++\">class Solution {\n    constexpr static int dx[4] = {0, 1, 0, -1};\n    constexpr static int dy[4] = {1, 0, -1, 0};\npublic:\n    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int n = grid.size(), m = grid[0].size();\n        int ans = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; m; ++j) {\n                if (grid[i][j]) {\n                    int cnt = 0;\n                    for (int k = 0; k &lt; 4; ++k) {\n                        int tx = i + dx[k];\n                        int ty = j + dy[k];\n                        if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || !grid[tx][ty]) {\n                            cnt += 1;\n                        }\n                    }\n                    ans += cnt;\n                }\n            }\n        }\n        return ans;\n    }\n};</code></pre>\n<h2 id=\"1207-独一无二的出现次数\"><a href=\"#1207-独一无二的出现次数\" class=\"headerlink\" title=\"1207.独一无二的出现次数\"></a>1207.独一无二的出现次数</h2><ul>\n<li><ol start=\"1207\">\n<li>Unique Number of Occurrences</li>\n</ol>\n</li>\n</ul>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/unique-number-of-occurrences\">https://leetcode-cn.com/problems/unique-number-of-occurrences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<blockquote>\n<p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。<br>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p>\n</blockquote>\n<blockquote>\n<p>示例 1：<br>输入：arr = [1,2,2,1,1,3]<br>输出：true<br>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。<br>示例 2：<br>输入：arr = [1,2]<br>输出：false<br>示例 3：<br>输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]<br>输出：true</p>\n</blockquote>\n<pre><code class=\"c++\">bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {\n    map&lt;int, int&gt; posMap;\n    for (int i = 0; i &lt; arr.size(); i++)\n    {\n        posMap[arr[i]] += 1;\n    }\n\n    set&lt;int&gt; uniqueSet;\n    for (const auto&amp; item : posMap)\n    {\n        uniqueSet.insert(item.second);\n    }\n\n    return posMap.size() == uniqueSet.size();\n}</code></pre>\n"},{"title":"Python Note 1","_content":"# Python Note 1\n\n+ 逻辑运算符的使用：\n+ and or not 会将几个值作为False ：0 None \"\" []\n\n+ 多变量赋值\n```python\nminValue, maxValue = 10 , 20\n```\n\n+ 命名规范\n+ 变量名，函数名： 小驼峰或下划线小写的形式\n+ 常量：全大写\n+ 类名：大驼峰\n\n+ 代码换行：\n+ 当一行写不完时，使用 \\ 将代码延续\n```python\nproduct  = max(100,200) \\\n\t\t\t\t\t*30\n```\n\n+ 输出：\n+ 以% 输出\n+ 字符宽度指定：\"%3d\" 右对齐数字， “%-3d”左对齐数字。换成s则为字符串。 \n+ 小数精度指定：%<field_width>.<precision>f  ，注意字符宽度将包含.\n```python\na = 10\nprint(\"%d\"%a)\nb = 100.025\nprint(\"%0.2f\"%b)\nprint(\"%-10.3f\"%b)\n```\n\n+ 自动转义的函数\n+ \"greater\".__len__() 等价于len(\"greater\")\n+ \"a\"+\"b\" 等价于\"a\".__add__(\"b\")\n+ \"e\" in \"great\" 等价于 \"great\".__contains__(\"e\")\n\n\n+ ==获取对象可用函数列表==\n+ dir(str) \n\n+ ==获取函数文档==\n+ help(str.upper)\n\n+ 以独立程序加载的python文件\n+ 使用“main”标记为模块name的名字\n```python\nif __name__ == \"__main__\"\n\tmain()\n```\n\n+ ### while结构\n 注： \"\"\"  多行string\n\n```python\nn = 0\nwhile n < 5:\n\tprint(\"\"\"\nThis is test!\nThis is test2!\nThis is test3!\n\t\"\"\")\n\tn = n + 1\n```\n\n+ ### For结构\n * 普通使用\n \n ```python\n for i in range(5):\n \tprint()\n ```\n * Use curly braces, 显示变量\n\n```python\n for i in range(5):\n \tprint(f\"i:{i}\")\n ```\n * 使用重复*个数输出字符\n\n```python\n for i in range(5):\n \tprint(f\"i:{i}\"*4)\n ```\n\n+ ### List\n+ 注意List的切片和连接运算符返回的就是一个新的数组\n* 普遍用法\n\n```python\nnames = ['John', 'Bob', 'Mosh', 'Sarah', 'Mary']\nprint(names[2:])  #Print will start from 'Mosh'''\nprint(names[:])  #Print all'\nnames[0] = 'Joh' #Change item\nprint(names)  #output\n# 2d list\nmatrix = [\n   [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nmatrix[0][-3] = 20\nprint(matrix)\n```\n\n* 编辑类\n\n```python\nnumbers = [5,2,1,7]\nnumbers.insert(-2,20)\nnumbers.remove(2)\nnumbers.append(45)\nnumbers.pop() #remove the last and return it\nprint(numbers.index(5))\nnumbers.sort()\nnumbers.reverse() #get deasc order\nif 5 in numbers:\n    print(numbers.index(5))\nnumbers2 = numbers.copy()\nnumbers.append(45)\nprint(numbers)\nprint(numbers2)\n\n#去重复\nnumbers = [5,20,1,5,7,5,6,4,5]\nuniques = []\nfor i in numbers:\n    if i not in uniques:\n        uniques.append(i)\nprint(uniques)\n```\n\n+ ### Tuple\n+ 类似于List，但不可修改\n\n```python\nnumbers = (5,20,1,5,7,5,6,4,5)\nnumbers[0] = 1 #TypeError: 'tuple' object does not support item assignment\n```\n\n+ ### Unpacking\n+ 映射数组成员\n\n```python\ncoordinates = (1,2,3)\na = coordinates[0]\nb = coordinates[1]\nc = coordinates[2]\n\n# use Unpacking feature, unpacking the tuple/list to three variable\nx, y, z = coordinates\nprint(f\"{a},{b},{c} <=> {x}, {y}, {z}\")\n```\n\n+ ### Dictionary\n\n```python\ncustomer = {\n    \"name\": \"John\",\n    \"age\": 30,\n    \"is_verified\": True\n}\nprint(customer[\"name\"])\n# print(customer[\"Name\"]) #KeyError,don't contain\n# print(customer[\"birthdate\"])#KeyError,don't contain\nprint(customer.get(\"name\"))\nprint(customer.get(\"Name\",\"Hey\")) #Print,with default value:'Hey'\ncustomer[\"name\"] = \"AA\"\nprint(customer.get(\"name\"))\n\n#Exercise\ninput_str = str(input(\"Phone:\"))\ndigits_map = {\n    \"1\":\"One\",\n    \"2\":\"Two\",\n    \"3\":\"Three\",\n    \"4\":\"Four\",\n}\noutput = ''\nfor s in input_str:\n    output += digits_map.get(s,\"\") + \" \"\n\nprint(output)\n```\n+ [mac]ctrl+cmd+space>> to show emojis\n\n+ ### 函数\n+ 注释：\n+ 三个引号的注释，意为文档注释，使用help函数时显示\n+ 无返回函数，默认返回为None\n\n+ 递归函数：\n+ 输出的小技巧：使用“ ” * 递归序号的形式生成缩进的日志，这样就有一个层级的输出结构了。\n\n+ 函数之中也可嵌套函数！\n\n+ 高阶函数：filter函数与map函数，reduce函数\n+ map将第二个列表中的值放到第一个参数的函数中逐个执行。最后把结果映射成map出来\n+ filter将把第二个列表中的值逐个放到第一个参数的函数中进行运算得出 True的放到一个结果里。\n+ reduce函数是每一个参数是一个带双参的函数，第一个参为下一项，第二参为上一次的结果。\n```python\ndef is_no_zero(v):\n    if v != 0:\n        return True\n    return False\n\noldlist = [5,0,3,5,0,8,6,4,0,3,9,1]\n\nnewlist = list(filter(is_no_zero, oldlist))\nnewlist = list(map(str, oldlist))\nprint(newlist)\n\nimport  functools\noldlist = [5,0,3,5,0,8,6,4,0,3,9,1]\nresult = functools.reduce(lambda x,y:x+y, oldlist)\nprint(result)\n```\n\n+ lambda做内联函数\n```python\n# lambda x,y:x+y\n```\n\n\n+ 使用pickle 读写对象\n+ 文件读写类型如：\n模式\t描述\nt\t文本模式 (默认)。\nx\t写模式，新建一个文件，如果该文件已存在则会报错。\nb\t二进制模式。\n\\+\t打开一个文件进行更新(可读可写)。\nU\t通用换行模式（不推荐）。\nr\t以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。\nrb\t以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。\nr+\t打开一个文件用于读写。文件指针将会放在文件的开头。\nrb+\t以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。\nw\t打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\nwb\t以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。\nw+\t打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\nwb+\t以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。\na\t打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\nab\t以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\na+\t打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。\nab+\t以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。\n\n```python\n\nmylist = [5, 6, \"abc\", 7]\nf = open(\"myfile.txt\", \"w\")\n\nfor n in mylist:\n    print(\"写入数据：\", n)\n    pickle.dump(n, f)\n    # f.write(n)\nf.close()\n\nmylist = list()\nf = open(\"myfile.txt\", \"r\")\nwhile True:\n    try:\n        item = pickle.load(f)\n        # item = f.read()\n        mylist.append(item)\n    except EOFError:\n        f.close()\n        break\nprint(\"读出的结果：\", mylist)\n\n```\n\n+ 常用三种运算符说明\n+ //运算符执行地板除法(向下取整除),它会返回整除结果的整数部分\n```print(7//2)```\n>#3\n>这里整除后会返回3.5\n\n+ 同样的，执行取幂运算，ab会返回a的b次方\n```print(2**10)```\n\n>#1024\n+ 最后，%执行取模运算，返回除法的余数\n```python\nprint(13%7)#6\nprint(3.5%1.5)#0.5\n```\n\n+ ### 使用Profiler探测\n+ 安装Profiler库\n+ 度量算法性能。","source":"_posts/python_1.md","raw":"---\ntitle: Python Note 1\ncategories:\n- Python\ntags: \n- Python\n- Note\n---\n# Python Note 1\n\n+ 逻辑运算符的使用：\n+ and or not 会将几个值作为False ：0 None \"\" []\n\n+ 多变量赋值\n```python\nminValue, maxValue = 10 , 20\n```\n\n+ 命名规范\n+ 变量名，函数名： 小驼峰或下划线小写的形式\n+ 常量：全大写\n+ 类名：大驼峰\n\n+ 代码换行：\n+ 当一行写不完时，使用 \\ 将代码延续\n```python\nproduct  = max(100,200) \\\n\t\t\t\t\t*30\n```\n\n+ 输出：\n+ 以% 输出\n+ 字符宽度指定：\"%3d\" 右对齐数字， “%-3d”左对齐数字。换成s则为字符串。 \n+ 小数精度指定：%<field_width>.<precision>f  ，注意字符宽度将包含.\n```python\na = 10\nprint(\"%d\"%a)\nb = 100.025\nprint(\"%0.2f\"%b)\nprint(\"%-10.3f\"%b)\n```\n\n+ 自动转义的函数\n+ \"greater\".__len__() 等价于len(\"greater\")\n+ \"a\"+\"b\" 等价于\"a\".__add__(\"b\")\n+ \"e\" in \"great\" 等价于 \"great\".__contains__(\"e\")\n\n\n+ ==获取对象可用函数列表==\n+ dir(str) \n\n+ ==获取函数文档==\n+ help(str.upper)\n\n+ 以独立程序加载的python文件\n+ 使用“main”标记为模块name的名字\n```python\nif __name__ == \"__main__\"\n\tmain()\n```\n\n+ ### while结构\n 注： \"\"\"  多行string\n\n```python\nn = 0\nwhile n < 5:\n\tprint(\"\"\"\nThis is test!\nThis is test2!\nThis is test3!\n\t\"\"\")\n\tn = n + 1\n```\n\n+ ### For结构\n * 普通使用\n \n ```python\n for i in range(5):\n \tprint()\n ```\n * Use curly braces, 显示变量\n\n```python\n for i in range(5):\n \tprint(f\"i:{i}\")\n ```\n * 使用重复*个数输出字符\n\n```python\n for i in range(5):\n \tprint(f\"i:{i}\"*4)\n ```\n\n+ ### List\n+ 注意List的切片和连接运算符返回的就是一个新的数组\n* 普遍用法\n\n```python\nnames = ['John', 'Bob', 'Mosh', 'Sarah', 'Mary']\nprint(names[2:])  #Print will start from 'Mosh'''\nprint(names[:])  #Print all'\nnames[0] = 'Joh' #Change item\nprint(names)  #output\n# 2d list\nmatrix = [\n   [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nmatrix[0][-3] = 20\nprint(matrix)\n```\n\n* 编辑类\n\n```python\nnumbers = [5,2,1,7]\nnumbers.insert(-2,20)\nnumbers.remove(2)\nnumbers.append(45)\nnumbers.pop() #remove the last and return it\nprint(numbers.index(5))\nnumbers.sort()\nnumbers.reverse() #get deasc order\nif 5 in numbers:\n    print(numbers.index(5))\nnumbers2 = numbers.copy()\nnumbers.append(45)\nprint(numbers)\nprint(numbers2)\n\n#去重复\nnumbers = [5,20,1,5,7,5,6,4,5]\nuniques = []\nfor i in numbers:\n    if i not in uniques:\n        uniques.append(i)\nprint(uniques)\n```\n\n+ ### Tuple\n+ 类似于List，但不可修改\n\n```python\nnumbers = (5,20,1,5,7,5,6,4,5)\nnumbers[0] = 1 #TypeError: 'tuple' object does not support item assignment\n```\n\n+ ### Unpacking\n+ 映射数组成员\n\n```python\ncoordinates = (1,2,3)\na = coordinates[0]\nb = coordinates[1]\nc = coordinates[2]\n\n# use Unpacking feature, unpacking the tuple/list to three variable\nx, y, z = coordinates\nprint(f\"{a},{b},{c} <=> {x}, {y}, {z}\")\n```\n\n+ ### Dictionary\n\n```python\ncustomer = {\n    \"name\": \"John\",\n    \"age\": 30,\n    \"is_verified\": True\n}\nprint(customer[\"name\"])\n# print(customer[\"Name\"]) #KeyError,don't contain\n# print(customer[\"birthdate\"])#KeyError,don't contain\nprint(customer.get(\"name\"))\nprint(customer.get(\"Name\",\"Hey\")) #Print,with default value:'Hey'\ncustomer[\"name\"] = \"AA\"\nprint(customer.get(\"name\"))\n\n#Exercise\ninput_str = str(input(\"Phone:\"))\ndigits_map = {\n    \"1\":\"One\",\n    \"2\":\"Two\",\n    \"3\":\"Three\",\n    \"4\":\"Four\",\n}\noutput = ''\nfor s in input_str:\n    output += digits_map.get(s,\"\") + \" \"\n\nprint(output)\n```\n+ [mac]ctrl+cmd+space>> to show emojis\n\n+ ### 函数\n+ 注释：\n+ 三个引号的注释，意为文档注释，使用help函数时显示\n+ 无返回函数，默认返回为None\n\n+ 递归函数：\n+ 输出的小技巧：使用“ ” * 递归序号的形式生成缩进的日志，这样就有一个层级的输出结构了。\n\n+ 函数之中也可嵌套函数！\n\n+ 高阶函数：filter函数与map函数，reduce函数\n+ map将第二个列表中的值放到第一个参数的函数中逐个执行。最后把结果映射成map出来\n+ filter将把第二个列表中的值逐个放到第一个参数的函数中进行运算得出 True的放到一个结果里。\n+ reduce函数是每一个参数是一个带双参的函数，第一个参为下一项，第二参为上一次的结果。\n```python\ndef is_no_zero(v):\n    if v != 0:\n        return True\n    return False\n\noldlist = [5,0,3,5,0,8,6,4,0,3,9,1]\n\nnewlist = list(filter(is_no_zero, oldlist))\nnewlist = list(map(str, oldlist))\nprint(newlist)\n\nimport  functools\noldlist = [5,0,3,5,0,8,6,4,0,3,9,1]\nresult = functools.reduce(lambda x,y:x+y, oldlist)\nprint(result)\n```\n\n+ lambda做内联函数\n```python\n# lambda x,y:x+y\n```\n\n\n+ 使用pickle 读写对象\n+ 文件读写类型如：\n模式\t描述\nt\t文本模式 (默认)。\nx\t写模式，新建一个文件，如果该文件已存在则会报错。\nb\t二进制模式。\n\\+\t打开一个文件进行更新(可读可写)。\nU\t通用换行模式（不推荐）。\nr\t以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。\nrb\t以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。\nr+\t打开一个文件用于读写。文件指针将会放在文件的开头。\nrb+\t以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。\nw\t打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\nwb\t以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。\nw+\t打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\nwb+\t以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。\na\t打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\nab\t以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\na+\t打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。\nab+\t以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。\n\n```python\n\nmylist = [5, 6, \"abc\", 7]\nf = open(\"myfile.txt\", \"w\")\n\nfor n in mylist:\n    print(\"写入数据：\", n)\n    pickle.dump(n, f)\n    # f.write(n)\nf.close()\n\nmylist = list()\nf = open(\"myfile.txt\", \"r\")\nwhile True:\n    try:\n        item = pickle.load(f)\n        # item = f.read()\n        mylist.append(item)\n    except EOFError:\n        f.close()\n        break\nprint(\"读出的结果：\", mylist)\n\n```\n\n+ 常用三种运算符说明\n+ //运算符执行地板除法(向下取整除),它会返回整除结果的整数部分\n```print(7//2)```\n>#3\n>这里整除后会返回3.5\n\n+ 同样的，执行取幂运算，ab会返回a的b次方\n```print(2**10)```\n\n>#1024\n+ 最后，%执行取模运算，返回除法的余数\n```python\nprint(13%7)#6\nprint(3.5%1.5)#0.5\n```\n\n+ ### 使用Profiler探测\n+ 安装Profiler库\n+ 度量算法性能。","slug":"python_1","published":1,"date":"2020-09-08T03:23:20.889Z","updated":"2020-09-08T03:23:20.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh10z00354wf0ae9f5cmd","content":"<h1 id=\"Python-Note-1\"><a href=\"#Python-Note-1\" class=\"headerlink\" title=\"Python Note 1\"></a>Python Note 1</h1><ul>\n<li><p>逻辑运算符的使用：</p>\n</li>\n<li><p>and or not 会将几个值作为False ：0 None “” []</p>\n</li>\n<li><p>多变量赋值</p>\n<pre><code class=\"python\">minValue, maxValue = 10 , 20</code></pre>\n</li>\n<li><p>命名规范</p>\n</li>\n<li><p>变量名，函数名： 小驼峰或下划线小写的形式</p>\n</li>\n<li><p>常量：全大写</p>\n</li>\n<li><p>类名：大驼峰</p>\n</li>\n<li><p>代码换行：</p>\n</li>\n<li><p>当一行写不完时，使用 \\ 将代码延续</p>\n<pre><code class=\"python\">product  = max(100,200) \\\n                  *30</code></pre>\n</li>\n<li><p>输出：</p>\n</li>\n<li><p>以% 输出</p>\n</li>\n<li><p>字符宽度指定：”%3d” 右对齐数字， “%-3d”左对齐数字。换成s则为字符串。 </p>\n</li>\n<li><p>小数精度指定：%<field_width>.<precision>f  ，注意字符宽度将包含.</p>\n<pre><code class=\"python\">a = 10\nprint(&quot;%d&quot;%a)\nb = 100.025\nprint(&quot;%0.2f&quot;%b)\nprint(&quot;%-10.3f&quot;%b)</code></pre>\n</li>\n<li><p>自动转义的函数</p>\n</li>\n<li><p>“greater”.<strong>len</strong>() 等价于len(“greater”)</p>\n</li>\n<li><p>“a”+”b” 等价于”a”.<strong>add</strong>(“b”)</p>\n</li>\n<li><p>“e” in “great” 等价于 “great”.<strong>contains</strong>(“e”)</p>\n</li>\n</ul>\n<ul>\n<li><p>==获取对象可用函数列表==</p>\n</li>\n<li><p>dir(str) </p>\n</li>\n<li><p>==获取函数文档==</p>\n</li>\n<li><p>help(str.upper)</p>\n</li>\n<li><p>以独立程序加载的python文件</p>\n</li>\n<li><p>使用“main”标记为模块name的名字</p>\n<pre><code class=\"python\">if __name__ == &quot;__main__&quot;\n  main()</code></pre>\n</li>\n<li><h3 id=\"while结构\"><a href=\"#while结构\" class=\"headerlink\" title=\"while结构\"></a>while结构</h3><p>注： “””  多行string</p>\n</li>\n</ul>\n<pre><code class=\"python\">n = 0\nwhile n &lt; 5:\n    print(&quot;&quot;&quot;\nThis is test!\nThis is test2!\nThis is test3!\n    &quot;&quot;&quot;)\n    n = n + 1</code></pre>\n<ul>\n<li><h3 id=\"For结构\"><a href=\"#For结构\" class=\"headerlink\" title=\"For结构\"></a>For结构</h3><ul>\n<li>普通使用</li>\n</ul>\n<pre><code class=\"python\">for i in range(5):\n   print()</code></pre>\n<ul>\n<li>Use curly braces, 显示变量</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"python\"> for i in range(5):\n     print(f&quot;i:{i}&quot;)</code></pre>\n<ul>\n<li>使用重复*个数输出字符</li>\n</ul>\n<pre><code class=\"python\"> for i in range(5):\n     print(f&quot;i:{i}&quot;*4)</code></pre>\n<ul>\n<li><h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3></li>\n<li>注意List的切片和连接运算符返回的就是一个新的数组</li>\n</ul>\n<ul>\n<li>普遍用法</li>\n</ul>\n<pre><code class=\"python\">names = [&#39;John&#39;, &#39;Bob&#39;, &#39;Mosh&#39;, &#39;Sarah&#39;, &#39;Mary&#39;]\nprint(names[2:])  #Print will start from &#39;Mosh&#39;&#39;&#39;\nprint(names[:])  #Print all&#39;\nnames[0] = &#39;Joh&#39; #Change item\nprint(names)  #output\n# 2d list\nmatrix = [\n   [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nmatrix[0][-3] = 20\nprint(matrix)</code></pre>\n<ul>\n<li>编辑类</li>\n</ul>\n<pre><code class=\"python\">numbers = [5,2,1,7]\nnumbers.insert(-2,20)\nnumbers.remove(2)\nnumbers.append(45)\nnumbers.pop() #remove the last and return it\nprint(numbers.index(5))\nnumbers.sort()\nnumbers.reverse() #get deasc order\nif 5 in numbers:\n    print(numbers.index(5))\nnumbers2 = numbers.copy()\nnumbers.append(45)\nprint(numbers)\nprint(numbers2)\n\n#去重复\nnumbers = [5,20,1,5,7,5,6,4,5]\nuniques = []\nfor i in numbers:\n    if i not in uniques:\n        uniques.append(i)\nprint(uniques)</code></pre>\n<ul>\n<li><h3 id=\"Tuple\"><a href=\"#Tuple\" class=\"headerlink\" title=\"Tuple\"></a>Tuple</h3></li>\n<li>类似于List，但不可修改</li>\n</ul>\n<pre><code class=\"python\">numbers = (5,20,1,5,7,5,6,4,5)\nnumbers[0] = 1 #TypeError: &#39;tuple&#39; object does not support item assignment</code></pre>\n<ul>\n<li><h3 id=\"Unpacking\"><a href=\"#Unpacking\" class=\"headerlink\" title=\"Unpacking\"></a>Unpacking</h3></li>\n<li>映射数组成员</li>\n</ul>\n<pre><code class=\"python\">coordinates = (1,2,3)\na = coordinates[0]\nb = coordinates[1]\nc = coordinates[2]\n\n# use Unpacking feature, unpacking the tuple/list to three variable\nx, y, z = coordinates\nprint(f&quot;{a},{b},{c} &lt;=&gt; {x}, {y}, {z}&quot;)</code></pre>\n<ul>\n<li><h3 id=\"Dictionary\"><a href=\"#Dictionary\" class=\"headerlink\" title=\"Dictionary\"></a>Dictionary</h3></li>\n</ul>\n<pre><code class=\"python\">customer = {\n    &quot;name&quot;: &quot;John&quot;,\n    &quot;age&quot;: 30,\n    &quot;is_verified&quot;: True\n}\nprint(customer[&quot;name&quot;])\n# print(customer[&quot;Name&quot;]) #KeyError,don&#39;t contain\n# print(customer[&quot;birthdate&quot;])#KeyError,don&#39;t contain\nprint(customer.get(&quot;name&quot;))\nprint(customer.get(&quot;Name&quot;,&quot;Hey&quot;)) #Print,with default value:&#39;Hey&#39;\ncustomer[&quot;name&quot;] = &quot;AA&quot;\nprint(customer.get(&quot;name&quot;))\n\n#Exercise\ninput_str = str(input(&quot;Phone:&quot;))\ndigits_map = {\n    &quot;1&quot;:&quot;One&quot;,\n    &quot;2&quot;:&quot;Two&quot;,\n    &quot;3&quot;:&quot;Three&quot;,\n    &quot;4&quot;:&quot;Four&quot;,\n}\noutput = &#39;&#39;\nfor s in input_str:\n    output += digits_map.get(s,&quot;&quot;) + &quot; &quot;\n\nprint(output)</code></pre>\n<ul>\n<li><p>[mac]ctrl+cmd+space&gt;&gt; to show emojis</p>\n</li>\n<li><h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3></li>\n<li><p>注释：</p>\n</li>\n<li><p>三个引号的注释，意为文档注释，使用help函数时显示</p>\n</li>\n<li><p>无返回函数，默认返回为None</p>\n</li>\n<li><p>递归函数：</p>\n</li>\n<li><p>输出的小技巧：使用“ ” * 递归序号的形式生成缩进的日志，这样就有一个层级的输出结构了。</p>\n</li>\n<li><p>函数之中也可嵌套函数！</p>\n</li>\n<li><p>高阶函数：filter函数与map函数，reduce函数</p>\n</li>\n<li><p>map将第二个列表中的值放到第一个参数的函数中逐个执行。最后把结果映射成map出来</p>\n</li>\n<li><p>filter将把第二个列表中的值逐个放到第一个参数的函数中进行运算得出 True的放到一个结果里。</p>\n</li>\n<li><p>reduce函数是每一个参数是一个带双参的函数，第一个参为下一项，第二参为上一次的结果。</p>\n<pre><code class=\"python\">def is_no_zero(v):\n  if v != 0:\n      return True\n  return False\n</code></pre>\n</li>\n</ul>\n<p>oldlist = [5,0,3,5,0,8,6,4,0,3,9,1]</p>\n<p>newlist = list(filter(is_no_zero, oldlist))<br>newlist = list(map(str, oldlist))<br>print(newlist)</p>\n<p>import  functools<br>oldlist = [5,0,3,5,0,8,6,4,0,3,9,1]<br>result = functools.reduce(lambda x,y:x+y, oldlist)<br>print(result)</p>\n<pre><code>\n+ lambda做内联函数\n```python\n# lambda x,y:x+y</code></pre><ul>\n<li>使用pickle 读写对象</li>\n<li>文件读写类型如：<br>模式    描述<br>t    文本模式 (默认)。<br>x    写模式，新建一个文件，如果该文件已存在则会报错。<br>b    二进制模式。<br>+    打开一个文件进行更新(可读可写)。<br>U    通用换行模式（不推荐）。<br>r    以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。<br>rb    以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。<br>r+    打开一个文件用于读写。文件指针将会放在文件的开头。<br>rb+    以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。<br>w    打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>wb    以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。<br>w+    打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>wb+    以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。<br>a    打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>ab    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>a+    打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<br>ab+    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</li>\n</ul>\n<pre><code class=\"python\">\nmylist = [5, 6, &quot;abc&quot;, 7]\nf = open(&quot;myfile.txt&quot;, &quot;w&quot;)\n\nfor n in mylist:\n    print(&quot;写入数据：&quot;, n)\n    pickle.dump(n, f)\n    # f.write(n)\nf.close()\n\nmylist = list()\nf = open(&quot;myfile.txt&quot;, &quot;r&quot;)\nwhile True:\n    try:\n        item = pickle.load(f)\n        # item = f.read()\n        mylist.append(item)\n    except EOFError:\n        f.close()\n        break\nprint(&quot;读出的结果：&quot;, mylist)\n</code></pre>\n<ul>\n<li><p>常用三种运算符说明</p>\n</li>\n<li><p>//运算符执行地板除法(向下取整除),它会返回整除结果的整数部分<br><code>print(7//2)</code></p>\n<blockquote>\n<p>#3<br>这里整除后会返回3.5</p>\n</blockquote>\n</li>\n<li><p>同样的，执行取幂运算，ab会返回a的b次方<br><code>print(2**10)</code></p>\n</li>\n</ul>\n<blockquote>\n<p>#1024</p>\n</blockquote>\n<ul>\n<li><p>最后，%执行取模运算，返回除法的余数</p>\n<pre><code class=\"python\">print(13%7)#6\nprint(3.5%1.5)#0.5</code></pre>\n</li>\n<li><h3 id=\"使用Profiler探测\"><a href=\"#使用Profiler探测\" class=\"headerlink\" title=\"使用Profiler探测\"></a>使用Profiler探测</h3></li>\n<li><p>安装Profiler库</p>\n</li>\n<li><p>度量算法性能。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python-Note-1\"><a href=\"#Python-Note-1\" class=\"headerlink\" title=\"Python Note 1\"></a>Python Note 1</h1><ul>\n<li><p>逻辑运算符的使用：</p>\n</li>\n<li><p>and or not 会将几个值作为False ：0 None “” []</p>\n</li>\n<li><p>多变量赋值</p>\n<pre><code class=\"python\">minValue, maxValue = 10 , 20</code></pre>\n</li>\n<li><p>命名规范</p>\n</li>\n<li><p>变量名，函数名： 小驼峰或下划线小写的形式</p>\n</li>\n<li><p>常量：全大写</p>\n</li>\n<li><p>类名：大驼峰</p>\n</li>\n<li><p>代码换行：</p>\n</li>\n<li><p>当一行写不完时，使用 \\ 将代码延续</p>\n<pre><code class=\"python\">product  = max(100,200) \\\n                  *30</code></pre>\n</li>\n<li><p>输出：</p>\n</li>\n<li><p>以% 输出</p>\n</li>\n<li><p>字符宽度指定：”%3d” 右对齐数字， “%-3d”左对齐数字。换成s则为字符串。 </p>\n</li>\n<li><p>小数精度指定：%<field_width>.<precision>f  ，注意字符宽度将包含.</p>\n<pre><code class=\"python\">a = 10\nprint(&quot;%d&quot;%a)\nb = 100.025\nprint(&quot;%0.2f&quot;%b)\nprint(&quot;%-10.3f&quot;%b)</code></pre>\n</li>\n<li><p>自动转义的函数</p>\n</li>\n<li><p>“greater”.<strong>len</strong>() 等价于len(“greater”)</p>\n</li>\n<li><p>“a”+”b” 等价于”a”.<strong>add</strong>(“b”)</p>\n</li>\n<li><p>“e” in “great” 等价于 “great”.<strong>contains</strong>(“e”)</p>\n</li>\n</ul>\n<ul>\n<li><p>==获取对象可用函数列表==</p>\n</li>\n<li><p>dir(str) </p>\n</li>\n<li><p>==获取函数文档==</p>\n</li>\n<li><p>help(str.upper)</p>\n</li>\n<li><p>以独立程序加载的python文件</p>\n</li>\n<li><p>使用“main”标记为模块name的名字</p>\n<pre><code class=\"python\">if __name__ == &quot;__main__&quot;\n  main()</code></pre>\n</li>\n<li><h3 id=\"while结构\"><a href=\"#while结构\" class=\"headerlink\" title=\"while结构\"></a>while结构</h3><p>注： “””  多行string</p>\n</li>\n</ul>\n<pre><code class=\"python\">n = 0\nwhile n &lt; 5:\n    print(&quot;&quot;&quot;\nThis is test!\nThis is test2!\nThis is test3!\n    &quot;&quot;&quot;)\n    n = n + 1</code></pre>\n<ul>\n<li><h3 id=\"For结构\"><a href=\"#For结构\" class=\"headerlink\" title=\"For结构\"></a>For结构</h3><ul>\n<li>普通使用</li>\n</ul>\n<pre><code class=\"python\">for i in range(5):\n   print()</code></pre>\n<ul>\n<li>Use curly braces, 显示变量</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"python\"> for i in range(5):\n     print(f&quot;i:{i}&quot;)</code></pre>\n<ul>\n<li>使用重复*个数输出字符</li>\n</ul>\n<pre><code class=\"python\"> for i in range(5):\n     print(f&quot;i:{i}&quot;*4)</code></pre>\n<ul>\n<li><h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3></li>\n<li>注意List的切片和连接运算符返回的就是一个新的数组</li>\n</ul>\n<ul>\n<li>普遍用法</li>\n</ul>\n<pre><code class=\"python\">names = [&#39;John&#39;, &#39;Bob&#39;, &#39;Mosh&#39;, &#39;Sarah&#39;, &#39;Mary&#39;]\nprint(names[2:])  #Print will start from &#39;Mosh&#39;&#39;&#39;\nprint(names[:])  #Print all&#39;\nnames[0] = &#39;Joh&#39; #Change item\nprint(names)  #output\n# 2d list\nmatrix = [\n   [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nmatrix[0][-3] = 20\nprint(matrix)</code></pre>\n<ul>\n<li>编辑类</li>\n</ul>\n<pre><code class=\"python\">numbers = [5,2,1,7]\nnumbers.insert(-2,20)\nnumbers.remove(2)\nnumbers.append(45)\nnumbers.pop() #remove the last and return it\nprint(numbers.index(5))\nnumbers.sort()\nnumbers.reverse() #get deasc order\nif 5 in numbers:\n    print(numbers.index(5))\nnumbers2 = numbers.copy()\nnumbers.append(45)\nprint(numbers)\nprint(numbers2)\n\n#去重复\nnumbers = [5,20,1,5,7,5,6,4,5]\nuniques = []\nfor i in numbers:\n    if i not in uniques:\n        uniques.append(i)\nprint(uniques)</code></pre>\n<ul>\n<li><h3 id=\"Tuple\"><a href=\"#Tuple\" class=\"headerlink\" title=\"Tuple\"></a>Tuple</h3></li>\n<li>类似于List，但不可修改</li>\n</ul>\n<pre><code class=\"python\">numbers = (5,20,1,5,7,5,6,4,5)\nnumbers[0] = 1 #TypeError: &#39;tuple&#39; object does not support item assignment</code></pre>\n<ul>\n<li><h3 id=\"Unpacking\"><a href=\"#Unpacking\" class=\"headerlink\" title=\"Unpacking\"></a>Unpacking</h3></li>\n<li>映射数组成员</li>\n</ul>\n<pre><code class=\"python\">coordinates = (1,2,3)\na = coordinates[0]\nb = coordinates[1]\nc = coordinates[2]\n\n# use Unpacking feature, unpacking the tuple/list to three variable\nx, y, z = coordinates\nprint(f&quot;{a},{b},{c} &lt;=&gt; {x}, {y}, {z}&quot;)</code></pre>\n<ul>\n<li><h3 id=\"Dictionary\"><a href=\"#Dictionary\" class=\"headerlink\" title=\"Dictionary\"></a>Dictionary</h3></li>\n</ul>\n<pre><code class=\"python\">customer = {\n    &quot;name&quot;: &quot;John&quot;,\n    &quot;age&quot;: 30,\n    &quot;is_verified&quot;: True\n}\nprint(customer[&quot;name&quot;])\n# print(customer[&quot;Name&quot;]) #KeyError,don&#39;t contain\n# print(customer[&quot;birthdate&quot;])#KeyError,don&#39;t contain\nprint(customer.get(&quot;name&quot;))\nprint(customer.get(&quot;Name&quot;,&quot;Hey&quot;)) #Print,with default value:&#39;Hey&#39;\ncustomer[&quot;name&quot;] = &quot;AA&quot;\nprint(customer.get(&quot;name&quot;))\n\n#Exercise\ninput_str = str(input(&quot;Phone:&quot;))\ndigits_map = {\n    &quot;1&quot;:&quot;One&quot;,\n    &quot;2&quot;:&quot;Two&quot;,\n    &quot;3&quot;:&quot;Three&quot;,\n    &quot;4&quot;:&quot;Four&quot;,\n}\noutput = &#39;&#39;\nfor s in input_str:\n    output += digits_map.get(s,&quot;&quot;) + &quot; &quot;\n\nprint(output)</code></pre>\n<ul>\n<li><p>[mac]ctrl+cmd+space&gt;&gt; to show emojis</p>\n</li>\n<li><h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3></li>\n<li><p>注释：</p>\n</li>\n<li><p>三个引号的注释，意为文档注释，使用help函数时显示</p>\n</li>\n<li><p>无返回函数，默认返回为None</p>\n</li>\n<li><p>递归函数：</p>\n</li>\n<li><p>输出的小技巧：使用“ ” * 递归序号的形式生成缩进的日志，这样就有一个层级的输出结构了。</p>\n</li>\n<li><p>函数之中也可嵌套函数！</p>\n</li>\n<li><p>高阶函数：filter函数与map函数，reduce函数</p>\n</li>\n<li><p>map将第二个列表中的值放到第一个参数的函数中逐个执行。最后把结果映射成map出来</p>\n</li>\n<li><p>filter将把第二个列表中的值逐个放到第一个参数的函数中进行运算得出 True的放到一个结果里。</p>\n</li>\n<li><p>reduce函数是每一个参数是一个带双参的函数，第一个参为下一项，第二参为上一次的结果。</p>\n<pre><code class=\"python\">def is_no_zero(v):\n  if v != 0:\n      return True\n  return False\n</code></pre>\n</li>\n</ul>\n<p>oldlist = [5,0,3,5,0,8,6,4,0,3,9,1]</p>\n<p>newlist = list(filter(is_no_zero, oldlist))<br>newlist = list(map(str, oldlist))<br>print(newlist)</p>\n<p>import  functools<br>oldlist = [5,0,3,5,0,8,6,4,0,3,9,1]<br>result = functools.reduce(lambda x,y:x+y, oldlist)<br>print(result)</p>\n<pre><code>\n+ lambda做内联函数\n```python\n# lambda x,y:x+y</code></pre><ul>\n<li>使用pickle 读写对象</li>\n<li>文件读写类型如：<br>模式    描述<br>t    文本模式 (默认)。<br>x    写模式，新建一个文件，如果该文件已存在则会报错。<br>b    二进制模式。<br>+    打开一个文件进行更新(可读可写)。<br>U    通用换行模式（不推荐）。<br>r    以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。<br>rb    以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。<br>r+    打开一个文件用于读写。文件指针将会放在文件的开头。<br>rb+    以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。<br>w    打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>wb    以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。<br>w+    打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>wb+    以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。<br>a    打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>ab    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>a+    打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<br>ab+    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</li>\n</ul>\n<pre><code class=\"python\">\nmylist = [5, 6, &quot;abc&quot;, 7]\nf = open(&quot;myfile.txt&quot;, &quot;w&quot;)\n\nfor n in mylist:\n    print(&quot;写入数据：&quot;, n)\n    pickle.dump(n, f)\n    # f.write(n)\nf.close()\n\nmylist = list()\nf = open(&quot;myfile.txt&quot;, &quot;r&quot;)\nwhile True:\n    try:\n        item = pickle.load(f)\n        # item = f.read()\n        mylist.append(item)\n    except EOFError:\n        f.close()\n        break\nprint(&quot;读出的结果：&quot;, mylist)\n</code></pre>\n<ul>\n<li><p>常用三种运算符说明</p>\n</li>\n<li><p>//运算符执行地板除法(向下取整除),它会返回整除结果的整数部分<br><code>print(7//2)</code></p>\n<blockquote>\n<p>#3<br>这里整除后会返回3.5</p>\n</blockquote>\n</li>\n<li><p>同样的，执行取幂运算，ab会返回a的b次方<br><code>print(2**10)</code></p>\n</li>\n</ul>\n<blockquote>\n<p>#1024</p>\n</blockquote>\n<ul>\n<li><p>最后，%执行取模运算，返回除法的余数</p>\n<pre><code class=\"python\">print(13%7)#6\nprint(3.5%1.5)#0.5</code></pre>\n</li>\n<li><h3 id=\"使用Profiler探测\"><a href=\"#使用Profiler探测\" class=\"headerlink\" title=\"使用Profiler探测\"></a>使用Profiler探测</h3></li>\n<li><p>安装Profiler库</p>\n</li>\n<li><p>度量算法性能。</p>\n</li>\n</ul>\n"},{"title":"动态规划","_content":"\n#### DP-Dynamic Programing \n* 试用场景：\n大部分用于求最小值，最大值，最优，计数等的问题\n\n* 一般步骤：递归+记忆化\n* 1.寻找递归式：由大化小\n* 2.先写递归式，记忆重复项以优化算法复杂度。解决子问题重叠求解。\n* 3.优化为非递归： 由小到大，由大到小（记忆）。\n\n#### 面试常见类型：\n* 1.矩阵坐标型 30%\n* 2.序列型：单序列，双序列  50%\n> 单序列：LIS：longest increasing sequence 最长上升序列\n> 双序列：LCS: longest common sequence 最长公共序列\n* 3.Knapsack变种 20%\n> subset sum. 硬币类题\n* 4.区间型  <10%\n> 矩阵相乘，optimised BST.","source":"_posts/动态规划.md","raw":"---\ntitle: 动态规划\ncategories:\n- 算法\n---\n\n#### DP-Dynamic Programing \n* 试用场景：\n大部分用于求最小值，最大值，最优，计数等的问题\n\n* 一般步骤：递归+记忆化\n* 1.寻找递归式：由大化小\n* 2.先写递归式，记忆重复项以优化算法复杂度。解决子问题重叠求解。\n* 3.优化为非递归： 由小到大，由大到小（记忆）。\n\n#### 面试常见类型：\n* 1.矩阵坐标型 30%\n* 2.序列型：单序列，双序列  50%\n> 单序列：LIS：longest increasing sequence 最长上升序列\n> 双序列：LCS: longest common sequence 最长公共序列\n* 3.Knapsack变种 20%\n> subset sum. 硬币类题\n* 4.区间型  <10%\n> 矩阵相乘，optimised BST.","slug":"动态规划","published":1,"date":"2020-09-08T03:23:20.889Z","updated":"2020-09-08T03:23:20.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh111003a4wf02glht1wf","content":"<h4 id=\"DP-Dynamic-Programing\"><a href=\"#DP-Dynamic-Programing\" class=\"headerlink\" title=\"DP-Dynamic Programing\"></a>DP-Dynamic Programing</h4><ul>\n<li><p>试用场景：<br>大部分用于求最小值，最大值，最优，计数等的问题</p>\n</li>\n<li><p>一般步骤：递归+记忆化</p>\n</li>\n<li><p>1.寻找递归式：由大化小</p>\n</li>\n<li><p>2.先写递归式，记忆重复项以优化算法复杂度。解决子问题重叠求解。</p>\n</li>\n<li><p>3.优化为非递归： 由小到大，由大到小（记忆）。</p>\n</li>\n</ul>\n<h4 id=\"面试常见类型：\"><a href=\"#面试常见类型：\" class=\"headerlink\" title=\"面试常见类型：\"></a>面试常见类型：</h4><ul>\n<li>1.矩阵坐标型 30%</li>\n<li>2.序列型：单序列，双序列  50%<blockquote>\n<p>单序列：LIS：longest increasing sequence 最长上升序列<br>双序列：LCS: longest common sequence 最长公共序列</p>\n</blockquote>\n</li>\n<li>3.Knapsack变种 20%<blockquote>\n<p>subset sum. 硬币类题</p>\n</blockquote>\n</li>\n<li>4.区间型  &lt;10%<blockquote>\n<p>矩阵相乘，optimised BST.</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"DP-Dynamic-Programing\"><a href=\"#DP-Dynamic-Programing\" class=\"headerlink\" title=\"DP-Dynamic Programing\"></a>DP-Dynamic Programing</h4><ul>\n<li><p>试用场景：<br>大部分用于求最小值，最大值，最优，计数等的问题</p>\n</li>\n<li><p>一般步骤：递归+记忆化</p>\n</li>\n<li><p>1.寻找递归式：由大化小</p>\n</li>\n<li><p>2.先写递归式，记忆重复项以优化算法复杂度。解决子问题重叠求解。</p>\n</li>\n<li><p>3.优化为非递归： 由小到大，由大到小（记忆）。</p>\n</li>\n</ul>\n<h4 id=\"面试常见类型：\"><a href=\"#面试常见类型：\" class=\"headerlink\" title=\"面试常见类型：\"></a>面试常见类型：</h4><ul>\n<li>1.矩阵坐标型 30%</li>\n<li>2.序列型：单序列，双序列  50%<blockquote>\n<p>单序列：LIS：longest increasing sequence 最长上升序列<br>双序列：LCS: longest common sequence 最长公共序列</p>\n</blockquote>\n</li>\n<li>3.Knapsack变种 20%<blockquote>\n<p>subset sum. 硬币类题</p>\n</blockquote>\n</li>\n<li>4.区间型  &lt;10%<blockquote>\n<p>矩阵相乘，optimised BST.</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"内存管理","_content":"\n## 物理内存\n\n当指令不连贯时，将会产生大量的时间浪费，DOTS和ECS从这个方面优化了内存的访问性能。\n\n![DOTS的目的](/img/1578646439353.png)\n\n> 日志常见： OOM，显存大小无法分配过来的报错信息\n![移动设备的区别](/img/1578646594733.png)\n\n> 三级缓存：\n> 台式：主流在8~16MB\n> 移动端：高端如845，2M\n\n## 虚拟内存\n\n\n![虚拟内存](/img/1578646743161.png)\n> 交换内存： 当操作系统内存不够时，尝试把不用的内存(deadmemory)交换到硬盘上，从而节省出更多物理内存。\n> 为什么移动端没有内存交换：移动设备IO速度慢，存储器的可擦写次数较台式少。\n> IOS提供了把不活跃的内存压缩起来放到一个特定空间。Virtual memory 很大。\n\n\n## 内存寻址范围\n\n可简单认为64位CPU寻址范围大。\n\n## 安卓内存管理\n\n![安卓内存](/img/1578647010062.png)\n\n> Page: 一般4K一个Page\n> 回收和分配以page为单位\n> 用户态和内核态\n\n> LMK, low memeory killer\n> 分类：\n> Native： adbd等，adb的守护线程\n> System: 系统服务\n> Persistent: 电话，信息，蓝牙等等\n> Foreground: 应用\n> Perceptible: 搜索等等\n> Services： 服务，云服务等\n> Home:主界面\n> Previous: 之前上一个应用\n> Cached:　后台\n\n> 从低层开始往上杀。 Foreground其实就是闪退的表现。杀到System就重启了。\n![优化级](/img/1578651845843.png)\n\n## 安卓内存指标\n\n![内存指标](/img/1578652129043.png)\n\n> RSS: 当前APP所使用的所有内存\n> PSS: 公共库分配出来的内存\n> USS：只有自己使用的内存，一般在此处优化\n\n> procrank 指令\n\n\n\n## Unity内存管理\n\n![Unity引擎](/img/1578652476304.png)\n\n#### 1. Unity 内存按照分配方式分为：\n - Native Memory\n- Managed Memory\n- Editor & Runtime 是不同的\n    - 不止是统计看到的内存大小不同，甚至是内存分配时机和方式也不同\n    - Asset 在 Runtime 中如果不读取，是不会进内存的，但 Editor 打开就占内存。因为 Editor 不注重 Runtime 的表现，更注重编辑器中编辑时的流畅。\n\t- 但如果游戏庞大到几十个 G，如果第一次打开项目，会消耗很多时间，有的大的会几天，甚至到一周。\n\n#### 2. Unity 内存按照管理者分为：\n- 引擎管理内存，开发者一般使用不到\n- 用户管理内存（应优先考虑）\n\n#### 3. Unity 检测不到的内存\n用户分配的 native 内存\n- 自己写的 Native 插件（C++ 插件）， Unity 无法分析已经编译过的 C++ 是如何去分配和使用内存的。\n- Lua 完全由自己管理内存，Unity 无法统计到内部的使用情况。\n\n#### 4. Unity Native Memory 管理\n\nUnity 重载了所有分配内存的操作符（C++ alloc、new），使用这些重载的时候，会需要一个额外的 memory label （Profiler-shaderlab-object-memory-detail-snapshot，里面的名字就是 label：指当前内存要分配到哪一个类型池里面）\n\n- Allocator: 使用重载过的分配符去分配内存时，Allocator 会根据你的 memory label 分配到不同 Allocator 池里面，每个 Allocator 池 单独做自己的跟踪。因此当我们去 Runtime get memory label 下面的池时就可以问 Allocator，里面有多少东西 多少兆。\n- NewAsRoot: Allocator 在 NewAsRoot （Memory  “island”（没听清）） 中生成。在这个 Memory Root 下面会有很多子内存：shader：当我们加载一个 Shader 进内存的时候，会生成一个 Shader 的 root。Shader 底下有很多数据：sub shader、Pass 等会作为 memory “island” (root) 的成员去依次分配。因此当我们最后统计 Runtime 的时候，我们会统计 Root，而不会统计成员，因为太多了没法统计。\n- 及时返给unity: 因为是 C++ 的，因此当我们 delete、free 一个内存的时候会立刻返回内存给系统，与托管内存堆不一样。\n\n#### 5. 最佳实践 Native 内存\n\n- Scene\n    - Unity 是一个 C++ 引擎，所有实体最终都会反映在 C++ 上，而不是托管堆里面。因此当我们实例化一个 GameObject 的时候，在 Unity 底层会构建一个或多个 Object 来存储这个 GameObject 的信息，例如很多 Components。因此当 Scene 有过多 GameObject 的时候，Native 内存就会显著上升。\n    - 当我们看 Profiler，发现 Native 内存大量上升的时候，应先去检查 Scene。\n- Audio\n    - DSP buffer （声音的缓冲）\n        - 当一个声音要播放的时候，它需要向 CPU 去发送指令——我要播放声音。但如果声音的数据量非常小，就会造成频繁地向 CPU 发送指令，会造成 I\\O。\n        - 当 Unity 用到 FMOD 声音引擎时（Unity 底层也用到 FMOD），会有一个 Buffer，当 Buffer 填充满了，才会向 CPU 发送“我要播放声音”的指令。\n        - DSP buffer 会导致两种问题：\n            - 如果（设置的） buffer 过大，会导致声音的延迟。要填充满 buffer 是要很多声音数据的，但声音数据又没这么大，因此会导致一定的**声音延迟**。\n            - 如果 DSP buffer 太小，会导致 CPU 负担上升，满了就发，消耗增加。\n\n            [Audio](https://docs.unity3d.com/Manual/class-AudioManager.html)\n\n    - Force to mono\n        - 在导入声音的时候有一个设置，很多音效师为了声音质量，会把声音设为双声道。但 95% 的声音，左右声道放的是完全一样的数据。这导致了 1M 的声音会变成 2M，体现在包体里和内存里。因此一般对于声音不是很敏感的游戏，会建议改成 Force to mono，强制单声道。\n    - Format\n    - Compression Format（看文档，有使用建议）\n    \n\t\n - Code Size\n    - C++ 模板泛型的滥用会影响到 Code Size、打包的速度。\n- AssetBundle\n    - TypeTree\n        - Unity 的每一种类型都有很多数据结构的改变，为了对此做兼容，Unity 会在生成数据类型序列化的时候，顺便会生成 TypeTree：当前我这一个版本里用到了哪些变量，对应的数据类型是什么。在反序列化的时候，会根据 TypeTree 来进行反序列化。\n            - 如果上一个版本的类型在这个版本中没有，TypeTree 就没有它，因此不会碰到它。\n            - 如果要用一个新的类型，但在这个版本中不存在，会用一个默认值来序列化，从而保证了不会在不同的版本序列化中出错，这个就是 TypeTree 的作用。\n        - Build AssetBundle 中有开关可以关掉 TypeTree。当你确认当前 AssetBundle 的使用和 Build Unity 的版本一模一样，这时候可以把 TypeTree 关掉。\n            - 例如如果用同样的 Unity 打出来的 AssetBundle 和 APP，TypeTree 则完全可以关掉。\n        - TypeTree 好处：\n            - 内存减少。TypeTree 本身是数据，也要占内存。\n            - 包大小会减少，因为 TypeTree 会序列化到 AssetBundle 包中，以便读取。\n            - Build 和运行时会变快。源代码中可以看到，因为每一次 Serialize 东西的时候，如果发现需要 Serialize TypeTree，则会 Serialize 两次：\n                - 第一次先把 TypeTree Serialize 出来\n                - 第二次把实际的东西 Serialize 出来\n                - 反序列化也会做同样的事情，1. TypeTree 反序列化，2. 实际的东西反序列化。\n            - 因此如果确定 TypeTree 不会对兼容性造成影响，可以把它关掉。这样对 Size 大小和 Build Runtime 都会获得收益。\n\n    - 压缩方式：\n        - Lz4\n\n            [BuildCompression.LZ4](https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZ4.html)\n\n            - LZ4HC \"Chunk Based\" Compression. 非常快\n            - 和 Lzma 相比，平均压缩比率差 30%。也就是说会导致包体大一点，但是（作者说）速度能快 10 倍以上。\n        - Lzma\n\n            [BuildCompression.LZMA](https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZMA.html)\n\n            - Lzma 基本上就不要用了，因为解压和读取速度上都会比较慢。\n            - 还会占大量内存\n                - 因为是 Steam based 而不是 Chunk Based 的，因此需要一次全解压\n                - Chunk Based 可以一块一块解压\n                    - 如果发现一个文件在第 5-10 块，那么 LZ4 会依次将 第 5 6 7 8 9 10 块分别解压出来，每次（chunk 的）解压会重用之前的内存，来减少内存的峰值。\n        - 预告：中国版 Unity 会在下个版本（1月5号或2月份）推出新的功能：基于 LZ4 的 AssetBundle 加密，只支持 LZ4。\n        - Size & count\n            - AssetBundle 包打多大是很玄学的问题，但每一个 Asset 打一个 Bundle 这样不太好。\n                - 有一种减图片大小的方式，把 png 的头都提出来。因为头的色板是通用的，而数据不通用。AssetBundle 也一样，一部分是它的头，一部分是实际打包的部分。因此如果每个 Asset 都打 Bundle 会导致 AssetBundle 的头比数据还要大。\n            - 官方的建议是每个 AssetBundle 包大概 1M~2M 左右大小，考虑的是网络带宽。但现在 5G 的时候，可以考虑适当把包体加大。还是要看实际用户的情况。\n\n- Resource 文件夹（**Do not use it**. 除非在 debug 的时候）\n    - Resource 和 AssetBundle 一样，也有头来索引。Resource  在打进包的时候会做一个红黑树，来帮助 Resource 来检索资源在什么位置，\n    - 如果 Resource 非常大，那么红黑树也会非常大。\n    - 红黑树是不可卸载的。在刚开始游戏的时候就会加载进内存中，会持续对游戏造成内存压力。\n    - 会极大拖慢游戏的启动时间。因为红黑树没加载完，游戏不能启动。\n- Texture\n    - upload buffer，和声音的很像：填满多大，就向 CPU push 一次。\n    - r/w\n        - Texture 没必要就不要开 read and write。正常 Texture 读进内存，解析完了，放到 upload buffer 里后，内存里的就会 delete 掉。\n        - 但如果检测到你开了 r/w 就不会 delete 了，就会在显存和内存中各一份。\n    - Mip Maps\n        - UI 没必要开，可以省大量内存。\n    - Mesh\n        - r/w\n        - compression\n            - 有些版本 Compression 开了不如不开，内存占用可能更严重，具体需要自己试。\n    - Assets\n        - Assets 的数量实际上和 asset 整个的纹理是有关系的。（？）\n\n        [Memory Management in Unity - Unity Learn](https://learn.unity.com/tutorial/memory-management-in-unity)\n\t\t\n\t\t\n\t\t\n#### 6. Unity Managed Memory\n\n[Understanding the managed heap](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html)\n\n- VM 内存池\n    - mono 虚拟机的内存池\n    - VM 会返还内存给 OS 吗？\n        - **会**\n    - 返还条件是什么？\n        - GC 不会把内存返还给系统\n        - 内存也是以 Block 来管理的。当一个 Block 连续六次 GC 没有被访问到，这块内存才会被返还到系统。（mono runtime 基本看不到，IL2cpp runtime 可能会看到多一点）\n    - 不会频繁地分配内存，而是一次分配一大块。\n- GC 机制（BOEHM Non-generational 不分代的）\n    - GC 机制考量\n        - Throughput(（回收能力）\n            - 一次回收，会回收多少内存\n        - Pause times（暂停时长）==mark text==\n            - 进行回收的时候，对主线程的影响有多大\n        - Fragmentation（碎片化）\n            - 回收内存后，会对整体回收内存池的贡献有多少\n        - Mutator overhead（额外消耗）\n            - 回收本身有 overhead，要做很多统计、标记的工作\n        - Scalability（可扩展性）\n            - 扩展到多核、多线程会不会有 bug\n        - Protability（可移植性）\n            - 不同平台是否可以使用\n    - BOEHM\n        - Non-generational（不分代的）\n\n            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png)\n\n            - 分代是指：大块内存、小内存、超小内存是分在不同内存区域来进行管理的。还有长久内存，当有一个内存很久没动的时候会移到长久内存区域中，从而省出内存给更频繁分配的内存。\n        - Non-compacting（非压缩式）\n\n            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png)\n\n            - 当有内存被回收的时候，压缩内存会把上图空的地方重新排布。\n            - 但 Unity 的 BOEHM 不会！它是非压缩式的。空着就空着，下次要用了再填进去。\n                - 历史原因：Unity 和 Mono 合作上，Mono 并不是一直开源免费的，因此 Unity 选择不升级 Mono，与实际 Mono 版本有差距。\n                - 下一代 GC\n                    - ==Incremental GC（渐进式 GC） #F44336==\n                        - 现在如果我们要进行一次 GC，主线程被迫要停下来，遍历所有 GC Memory “island”（没听清），来决定哪些 GC 可以回收。\n                        - ==Incremental GC 把暂停主线程的事分帧做了。一点一点分析，主线程不会有峰值。总体 GC 时间不变，但会改善 GC 对主线程的卡顿影响。 #F44336==\n                    - SGen 或者升级 Boehm？\n                        - SGen 是分代的，能避免内存碎片化问题，调动策略，速度较快\n                    - IL2CPP\n                        - 现在 IL2CPP 的 GC 机制是 Unity 自己重新写的，是升级版的 Boehm\n    - Memory fragmentation 内存碎片化\n\n        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png)\n\n        - 为什么内存下降了，但总体内存池还是上升了？\n            - 因为内存太大了，内存池没地方放它，虽然有很多内存可用。（内存已被严重碎片化）\n        - 当开发者大量加载小内存，使用释放*N，例如配置表、巨大数组，GC 会涨一大截。\n            - 建议==先操作大内存，再操作小内存，以保证内存以最大效率被重复利用。 #F44336==\n    - Zombie Memory（僵尸内存）\n        - 内存泄露说法是不对的，内存只是没有任何人能够管理到，但实际上内存没有被泄露，一直在内存池中，被 zombie 掉了，这种叫 Zombie 内存。\n        - 无用内容\n            - Coding 时候或者团队配合的时候有问题，加载了一个东西进来，结果从头到尾只用了一次。\n            - 有些开发者写了队列调度策略，但是策略写的不好，导致一些他觉得会被释放的东西，没有被释放掉。\n            - 找是否有活跃度实际上并不高的内存。\n        - 没有释放\n        - 通过代码管理和性能工具分析\n    - 最佳实践\n        - Don't Null it, but Destroy it（显式用 Destory，别用 Null）\n        - Class VS Struct\n        - Pool In Pool（池中池）\n            - VM 本身有内存池，但建议开发者对高频使用的小部件，自己建一个内存池。例如子弹等。\n        - Closures and anonymous methods（闭包和匿名函数）\n            - 如果看 IL，所有匿名函数和闭包会 new 成一个 class，因此所有变量和要 new 的东西都是要占内存的。这样会导致协程。\n                - 有些开发者会在游戏开始启用一个协程，直到游戏结束才释放，这是错误的。\n                - 只要协程不被释放掉，所有内存都会在内存里。\n        - Coroutines（协程）\n            - 可看做闭包和匿名函数的一个特例\n            - 最佳实践：用的时候生产一个，不用的时候 destroy 掉。\n        - Configurations（配置表）\n            - 不要把整个配置表都扔进去，是否能通过啥来切分下配置表\n        - Singleton\n            - 慎用\n            - 游戏一开始到游戏死掉，一直在内存中。\n- UPR 工具\n\n    [Unite 2019 | Unity UPR性能报告功能介绍 - Unity Connect](https://connect.unity.com/p/unite-2019-unity-uprxing-neng-bao-gao-gong-neng-jie-shao)\n\n    - 免费，在中国增强版里","source":"_posts/内存管理.md","raw":"---\ntitle: 内存管理\ncategories:\n- Unity学习\ntags: \n- Unity学习\n---\n\n## 物理内存\n\n当指令不连贯时，将会产生大量的时间浪费，DOTS和ECS从这个方面优化了内存的访问性能。\n\n![DOTS的目的](/img/1578646439353.png)\n\n> 日志常见： OOM，显存大小无法分配过来的报错信息\n![移动设备的区别](/img/1578646594733.png)\n\n> 三级缓存：\n> 台式：主流在8~16MB\n> 移动端：高端如845，2M\n\n## 虚拟内存\n\n\n![虚拟内存](/img/1578646743161.png)\n> 交换内存： 当操作系统内存不够时，尝试把不用的内存(deadmemory)交换到硬盘上，从而节省出更多物理内存。\n> 为什么移动端没有内存交换：移动设备IO速度慢，存储器的可擦写次数较台式少。\n> IOS提供了把不活跃的内存压缩起来放到一个特定空间。Virtual memory 很大。\n\n\n## 内存寻址范围\n\n可简单认为64位CPU寻址范围大。\n\n## 安卓内存管理\n\n![安卓内存](/img/1578647010062.png)\n\n> Page: 一般4K一个Page\n> 回收和分配以page为单位\n> 用户态和内核态\n\n> LMK, low memeory killer\n> 分类：\n> Native： adbd等，adb的守护线程\n> System: 系统服务\n> Persistent: 电话，信息，蓝牙等等\n> Foreground: 应用\n> Perceptible: 搜索等等\n> Services： 服务，云服务等\n> Home:主界面\n> Previous: 之前上一个应用\n> Cached:　后台\n\n> 从低层开始往上杀。 Foreground其实就是闪退的表现。杀到System就重启了。\n![优化级](/img/1578651845843.png)\n\n## 安卓内存指标\n\n![内存指标](/img/1578652129043.png)\n\n> RSS: 当前APP所使用的所有内存\n> PSS: 公共库分配出来的内存\n> USS：只有自己使用的内存，一般在此处优化\n\n> procrank 指令\n\n\n\n## Unity内存管理\n\n![Unity引擎](/img/1578652476304.png)\n\n#### 1. Unity 内存按照分配方式分为：\n - Native Memory\n- Managed Memory\n- Editor & Runtime 是不同的\n    - 不止是统计看到的内存大小不同，甚至是内存分配时机和方式也不同\n    - Asset 在 Runtime 中如果不读取，是不会进内存的，但 Editor 打开就占内存。因为 Editor 不注重 Runtime 的表现，更注重编辑器中编辑时的流畅。\n\t- 但如果游戏庞大到几十个 G，如果第一次打开项目，会消耗很多时间，有的大的会几天，甚至到一周。\n\n#### 2. Unity 内存按照管理者分为：\n- 引擎管理内存，开发者一般使用不到\n- 用户管理内存（应优先考虑）\n\n#### 3. Unity 检测不到的内存\n用户分配的 native 内存\n- 自己写的 Native 插件（C++ 插件）， Unity 无法分析已经编译过的 C++ 是如何去分配和使用内存的。\n- Lua 完全由自己管理内存，Unity 无法统计到内部的使用情况。\n\n#### 4. Unity Native Memory 管理\n\nUnity 重载了所有分配内存的操作符（C++ alloc、new），使用这些重载的时候，会需要一个额外的 memory label （Profiler-shaderlab-object-memory-detail-snapshot，里面的名字就是 label：指当前内存要分配到哪一个类型池里面）\n\n- Allocator: 使用重载过的分配符去分配内存时，Allocator 会根据你的 memory label 分配到不同 Allocator 池里面，每个 Allocator 池 单独做自己的跟踪。因此当我们去 Runtime get memory label 下面的池时就可以问 Allocator，里面有多少东西 多少兆。\n- NewAsRoot: Allocator 在 NewAsRoot （Memory  “island”（没听清）） 中生成。在这个 Memory Root 下面会有很多子内存：shader：当我们加载一个 Shader 进内存的时候，会生成一个 Shader 的 root。Shader 底下有很多数据：sub shader、Pass 等会作为 memory “island” (root) 的成员去依次分配。因此当我们最后统计 Runtime 的时候，我们会统计 Root，而不会统计成员，因为太多了没法统计。\n- 及时返给unity: 因为是 C++ 的，因此当我们 delete、free 一个内存的时候会立刻返回内存给系统，与托管内存堆不一样。\n\n#### 5. 最佳实践 Native 内存\n\n- Scene\n    - Unity 是一个 C++ 引擎，所有实体最终都会反映在 C++ 上，而不是托管堆里面。因此当我们实例化一个 GameObject 的时候，在 Unity 底层会构建一个或多个 Object 来存储这个 GameObject 的信息，例如很多 Components。因此当 Scene 有过多 GameObject 的时候，Native 内存就会显著上升。\n    - 当我们看 Profiler，发现 Native 内存大量上升的时候，应先去检查 Scene。\n- Audio\n    - DSP buffer （声音的缓冲）\n        - 当一个声音要播放的时候，它需要向 CPU 去发送指令——我要播放声音。但如果声音的数据量非常小，就会造成频繁地向 CPU 发送指令，会造成 I\\O。\n        - 当 Unity 用到 FMOD 声音引擎时（Unity 底层也用到 FMOD），会有一个 Buffer，当 Buffer 填充满了，才会向 CPU 发送“我要播放声音”的指令。\n        - DSP buffer 会导致两种问题：\n            - 如果（设置的） buffer 过大，会导致声音的延迟。要填充满 buffer 是要很多声音数据的，但声音数据又没这么大，因此会导致一定的**声音延迟**。\n            - 如果 DSP buffer 太小，会导致 CPU 负担上升，满了就发，消耗增加。\n\n            [Audio](https://docs.unity3d.com/Manual/class-AudioManager.html)\n\n    - Force to mono\n        - 在导入声音的时候有一个设置，很多音效师为了声音质量，会把声音设为双声道。但 95% 的声音，左右声道放的是完全一样的数据。这导致了 1M 的声音会变成 2M，体现在包体里和内存里。因此一般对于声音不是很敏感的游戏，会建议改成 Force to mono，强制单声道。\n    - Format\n    - Compression Format（看文档，有使用建议）\n    \n\t\n - Code Size\n    - C++ 模板泛型的滥用会影响到 Code Size、打包的速度。\n- AssetBundle\n    - TypeTree\n        - Unity 的每一种类型都有很多数据结构的改变，为了对此做兼容，Unity 会在生成数据类型序列化的时候，顺便会生成 TypeTree：当前我这一个版本里用到了哪些变量，对应的数据类型是什么。在反序列化的时候，会根据 TypeTree 来进行反序列化。\n            - 如果上一个版本的类型在这个版本中没有，TypeTree 就没有它，因此不会碰到它。\n            - 如果要用一个新的类型，但在这个版本中不存在，会用一个默认值来序列化，从而保证了不会在不同的版本序列化中出错，这个就是 TypeTree 的作用。\n        - Build AssetBundle 中有开关可以关掉 TypeTree。当你确认当前 AssetBundle 的使用和 Build Unity 的版本一模一样，这时候可以把 TypeTree 关掉。\n            - 例如如果用同样的 Unity 打出来的 AssetBundle 和 APP，TypeTree 则完全可以关掉。\n        - TypeTree 好处：\n            - 内存减少。TypeTree 本身是数据，也要占内存。\n            - 包大小会减少，因为 TypeTree 会序列化到 AssetBundle 包中，以便读取。\n            - Build 和运行时会变快。源代码中可以看到，因为每一次 Serialize 东西的时候，如果发现需要 Serialize TypeTree，则会 Serialize 两次：\n                - 第一次先把 TypeTree Serialize 出来\n                - 第二次把实际的东西 Serialize 出来\n                - 反序列化也会做同样的事情，1. TypeTree 反序列化，2. 实际的东西反序列化。\n            - 因此如果确定 TypeTree 不会对兼容性造成影响，可以把它关掉。这样对 Size 大小和 Build Runtime 都会获得收益。\n\n    - 压缩方式：\n        - Lz4\n\n            [BuildCompression.LZ4](https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZ4.html)\n\n            - LZ4HC \"Chunk Based\" Compression. 非常快\n            - 和 Lzma 相比，平均压缩比率差 30%。也就是说会导致包体大一点，但是（作者说）速度能快 10 倍以上。\n        - Lzma\n\n            [BuildCompression.LZMA](https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZMA.html)\n\n            - Lzma 基本上就不要用了，因为解压和读取速度上都会比较慢。\n            - 还会占大量内存\n                - 因为是 Steam based 而不是 Chunk Based 的，因此需要一次全解压\n                - Chunk Based 可以一块一块解压\n                    - 如果发现一个文件在第 5-10 块，那么 LZ4 会依次将 第 5 6 7 8 9 10 块分别解压出来，每次（chunk 的）解压会重用之前的内存，来减少内存的峰值。\n        - 预告：中国版 Unity 会在下个版本（1月5号或2月份）推出新的功能：基于 LZ4 的 AssetBundle 加密，只支持 LZ4。\n        - Size & count\n            - AssetBundle 包打多大是很玄学的问题，但每一个 Asset 打一个 Bundle 这样不太好。\n                - 有一种减图片大小的方式，把 png 的头都提出来。因为头的色板是通用的，而数据不通用。AssetBundle 也一样，一部分是它的头，一部分是实际打包的部分。因此如果每个 Asset 都打 Bundle 会导致 AssetBundle 的头比数据还要大。\n            - 官方的建议是每个 AssetBundle 包大概 1M~2M 左右大小，考虑的是网络带宽。但现在 5G 的时候，可以考虑适当把包体加大。还是要看实际用户的情况。\n\n- Resource 文件夹（**Do not use it**. 除非在 debug 的时候）\n    - Resource 和 AssetBundle 一样，也有头来索引。Resource  在打进包的时候会做一个红黑树，来帮助 Resource 来检索资源在什么位置，\n    - 如果 Resource 非常大，那么红黑树也会非常大。\n    - 红黑树是不可卸载的。在刚开始游戏的时候就会加载进内存中，会持续对游戏造成内存压力。\n    - 会极大拖慢游戏的启动时间。因为红黑树没加载完，游戏不能启动。\n- Texture\n    - upload buffer，和声音的很像：填满多大，就向 CPU push 一次。\n    - r/w\n        - Texture 没必要就不要开 read and write。正常 Texture 读进内存，解析完了，放到 upload buffer 里后，内存里的就会 delete 掉。\n        - 但如果检测到你开了 r/w 就不会 delete 了，就会在显存和内存中各一份。\n    - Mip Maps\n        - UI 没必要开，可以省大量内存。\n    - Mesh\n        - r/w\n        - compression\n            - 有些版本 Compression 开了不如不开，内存占用可能更严重，具体需要自己试。\n    - Assets\n        - Assets 的数量实际上和 asset 整个的纹理是有关系的。（？）\n\n        [Memory Management in Unity - Unity Learn](https://learn.unity.com/tutorial/memory-management-in-unity)\n\t\t\n\t\t\n\t\t\n#### 6. Unity Managed Memory\n\n[Understanding the managed heap](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html)\n\n- VM 内存池\n    - mono 虚拟机的内存池\n    - VM 会返还内存给 OS 吗？\n        - **会**\n    - 返还条件是什么？\n        - GC 不会把内存返还给系统\n        - 内存也是以 Block 来管理的。当一个 Block 连续六次 GC 没有被访问到，这块内存才会被返还到系统。（mono runtime 基本看不到，IL2cpp runtime 可能会看到多一点）\n    - 不会频繁地分配内存，而是一次分配一大块。\n- GC 机制（BOEHM Non-generational 不分代的）\n    - GC 机制考量\n        - Throughput(（回收能力）\n            - 一次回收，会回收多少内存\n        - Pause times（暂停时长）==mark text==\n            - 进行回收的时候，对主线程的影响有多大\n        - Fragmentation（碎片化）\n            - 回收内存后，会对整体回收内存池的贡献有多少\n        - Mutator overhead（额外消耗）\n            - 回收本身有 overhead，要做很多统计、标记的工作\n        - Scalability（可扩展性）\n            - 扩展到多核、多线程会不会有 bug\n        - Protability（可移植性）\n            - 不同平台是否可以使用\n    - BOEHM\n        - Non-generational（不分代的）\n\n            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png)\n\n            - 分代是指：大块内存、小内存、超小内存是分在不同内存区域来进行管理的。还有长久内存，当有一个内存很久没动的时候会移到长久内存区域中，从而省出内存给更频繁分配的内存。\n        - Non-compacting（非压缩式）\n\n            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png)\n\n            - 当有内存被回收的时候，压缩内存会把上图空的地方重新排布。\n            - 但 Unity 的 BOEHM 不会！它是非压缩式的。空着就空着，下次要用了再填进去。\n                - 历史原因：Unity 和 Mono 合作上，Mono 并不是一直开源免费的，因此 Unity 选择不升级 Mono，与实际 Mono 版本有差距。\n                - 下一代 GC\n                    - ==Incremental GC（渐进式 GC） #F44336==\n                        - 现在如果我们要进行一次 GC，主线程被迫要停下来，遍历所有 GC Memory “island”（没听清），来决定哪些 GC 可以回收。\n                        - ==Incremental GC 把暂停主线程的事分帧做了。一点一点分析，主线程不会有峰值。总体 GC 时间不变，但会改善 GC 对主线程的卡顿影响。 #F44336==\n                    - SGen 或者升级 Boehm？\n                        - SGen 是分代的，能避免内存碎片化问题，调动策略，速度较快\n                    - IL2CPP\n                        - 现在 IL2CPP 的 GC 机制是 Unity 自己重新写的，是升级版的 Boehm\n    - Memory fragmentation 内存碎片化\n\n        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png)\n\n        - 为什么内存下降了，但总体内存池还是上升了？\n            - 因为内存太大了，内存池没地方放它，虽然有很多内存可用。（内存已被严重碎片化）\n        - 当开发者大量加载小内存，使用释放*N，例如配置表、巨大数组，GC 会涨一大截。\n            - 建议==先操作大内存，再操作小内存，以保证内存以最大效率被重复利用。 #F44336==\n    - Zombie Memory（僵尸内存）\n        - 内存泄露说法是不对的，内存只是没有任何人能够管理到，但实际上内存没有被泄露，一直在内存池中，被 zombie 掉了，这种叫 Zombie 内存。\n        - 无用内容\n            - Coding 时候或者团队配合的时候有问题，加载了一个东西进来，结果从头到尾只用了一次。\n            - 有些开发者写了队列调度策略，但是策略写的不好，导致一些他觉得会被释放的东西，没有被释放掉。\n            - 找是否有活跃度实际上并不高的内存。\n        - 没有释放\n        - 通过代码管理和性能工具分析\n    - 最佳实践\n        - Don't Null it, but Destroy it（显式用 Destory，别用 Null）\n        - Class VS Struct\n        - Pool In Pool（池中池）\n            - VM 本身有内存池，但建议开发者对高频使用的小部件，自己建一个内存池。例如子弹等。\n        - Closures and anonymous methods（闭包和匿名函数）\n            - 如果看 IL，所有匿名函数和闭包会 new 成一个 class，因此所有变量和要 new 的东西都是要占内存的。这样会导致协程。\n                - 有些开发者会在游戏开始启用一个协程，直到游戏结束才释放，这是错误的。\n                - 只要协程不被释放掉，所有内存都会在内存里。\n        - Coroutines（协程）\n            - 可看做闭包和匿名函数的一个特例\n            - 最佳实践：用的时候生产一个，不用的时候 destroy 掉。\n        - Configurations（配置表）\n            - 不要把整个配置表都扔进去，是否能通过啥来切分下配置表\n        - Singleton\n            - 慎用\n            - 游戏一开始到游戏死掉，一直在内存中。\n- UPR 工具\n\n    [Unite 2019 | Unity UPR性能报告功能介绍 - Unity Connect](https://connect.unity.com/p/unite-2019-unity-uprxing-neng-bao-gao-gong-neng-jie-shao)\n\n    - 免费，在中国增强版里","slug":"内存管理","published":1,"date":"2020-09-08T03:23:20.889Z","updated":"2020-09-08T03:23:20.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh113003d4wf0vsjg5owv","content":"<h2 id=\"物理内存\"><a href=\"#物理内存\" class=\"headerlink\" title=\"物理内存\"></a>物理内存</h2><p>当指令不连贯时，将会产生大量的时间浪费，DOTS和ECS从这个方面优化了内存的访问性能。</p>\n<p><img src=\"/img/1578646439353.png\" alt=\"DOTS的目的\"></p>\n<blockquote>\n<p>日志常见： OOM，显存大小无法分配过来的报错信息<br><img src=\"/img/1578646594733.png\" alt=\"移动设备的区别\"></p>\n</blockquote>\n<blockquote>\n<p>三级缓存：<br>台式：主流在8~16MB<br>移动端：高端如845，2M</p>\n</blockquote>\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p><img src=\"/img/1578646743161.png\" alt=\"虚拟内存\"></p>\n<blockquote>\n<p>交换内存： 当操作系统内存不够时，尝试把不用的内存(deadmemory)交换到硬盘上，从而节省出更多物理内存。<br>为什么移动端没有内存交换：移动设备IO速度慢，存储器的可擦写次数较台式少。<br>IOS提供了把不活跃的内存压缩起来放到一个特定空间。Virtual memory 很大。</p>\n</blockquote>\n<h2 id=\"内存寻址范围\"><a href=\"#内存寻址范围\" class=\"headerlink\" title=\"内存寻址范围\"></a>内存寻址范围</h2><p>可简单认为64位CPU寻址范围大。</p>\n<h2 id=\"安卓内存管理\"><a href=\"#安卓内存管理\" class=\"headerlink\" title=\"安卓内存管理\"></a>安卓内存管理</h2><p><img src=\"/img/1578647010062.png\" alt=\"安卓内存\"></p>\n<blockquote>\n<p>Page: 一般4K一个Page<br>回收和分配以page为单位<br>用户态和内核态</p>\n</blockquote>\n<blockquote>\n<p>LMK, low memeory killer<br>分类：<br>Native： adbd等，adb的守护线程<br>System: 系统服务<br>Persistent: 电话，信息，蓝牙等等<br>Foreground: 应用<br>Perceptible: 搜索等等<br>Services： 服务，云服务等<br>Home:主界面<br>Previous: 之前上一个应用<br>Cached:　后台</p>\n</blockquote>\n<blockquote>\n<p>从低层开始往上杀。 Foreground其实就是闪退的表现。杀到System就重启了。<br><img src=\"/img/1578651845843.png\" alt=\"优化级\"></p>\n</blockquote>\n<h2 id=\"安卓内存指标\"><a href=\"#安卓内存指标\" class=\"headerlink\" title=\"安卓内存指标\"></a>安卓内存指标</h2><p><img src=\"/img/1578652129043.png\" alt=\"内存指标\"></p>\n<blockquote>\n<p>RSS: 当前APP所使用的所有内存<br>PSS: 公共库分配出来的内存<br>USS：只有自己使用的内存，一般在此处优化</p>\n</blockquote>\n<blockquote>\n<p>procrank 指令</p>\n</blockquote>\n<h2 id=\"Unity内存管理\"><a href=\"#Unity内存管理\" class=\"headerlink\" title=\"Unity内存管理\"></a>Unity内存管理</h2><p><img src=\"/img/1578652476304.png\" alt=\"Unity引擎\"></p>\n<h4 id=\"1-Unity-内存按照分配方式分为：\"><a href=\"#1-Unity-内存按照分配方式分为：\" class=\"headerlink\" title=\"1. Unity 内存按照分配方式分为：\"></a>1. Unity 内存按照分配方式分为：</h4><ul>\n<li>Native Memory<ul>\n<li>Managed Memory</li>\n<li>Editor &amp; Runtime 是不同的<ul>\n<li>不止是统计看到的内存大小不同，甚至是内存分配时机和方式也不同</li>\n<li>Asset 在 Runtime 中如果不读取，是不会进内存的，但 Editor 打开就占内存。因为 Editor 不注重 Runtime 的表现，更注重编辑器中编辑时的流畅。</li>\n<li>但如果游戏庞大到几十个 G，如果第一次打开项目，会消耗很多时间，有的大的会几天，甚至到一周。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-Unity-内存按照管理者分为：\"><a href=\"#2-Unity-内存按照管理者分为：\" class=\"headerlink\" title=\"2. Unity 内存按照管理者分为：\"></a>2. Unity 内存按照管理者分为：</h4><ul>\n<li>引擎管理内存，开发者一般使用不到</li>\n<li>用户管理内存（应优先考虑）</li>\n</ul>\n<h4 id=\"3-Unity-检测不到的内存\"><a href=\"#3-Unity-检测不到的内存\" class=\"headerlink\" title=\"3. Unity 检测不到的内存\"></a>3. Unity 检测不到的内存</h4><p>用户分配的 native 内存</p>\n<ul>\n<li>自己写的 Native 插件（C++ 插件）， Unity 无法分析已经编译过的 C++ 是如何去分配和使用内存的。</li>\n<li>Lua 完全由自己管理内存，Unity 无法统计到内部的使用情况。</li>\n</ul>\n<h4 id=\"4-Unity-Native-Memory-管理\"><a href=\"#4-Unity-Native-Memory-管理\" class=\"headerlink\" title=\"4. Unity Native Memory 管理\"></a>4. Unity Native Memory 管理</h4><p>Unity 重载了所有分配内存的操作符（C++ alloc、new），使用这些重载的时候，会需要一个额外的 memory label （Profiler-shaderlab-object-memory-detail-snapshot，里面的名字就是 label：指当前内存要分配到哪一个类型池里面）</p>\n<ul>\n<li>Allocator: 使用重载过的分配符去分配内存时，Allocator 会根据你的 memory label 分配到不同 Allocator 池里面，每个 Allocator 池 单独做自己的跟踪。因此当我们去 Runtime get memory label 下面的池时就可以问 Allocator，里面有多少东西 多少兆。</li>\n<li>NewAsRoot: Allocator 在 NewAsRoot （Memory  “island”（没听清）） 中生成。在这个 Memory Root 下面会有很多子内存：shader：当我们加载一个 Shader 进内存的时候，会生成一个 Shader 的 root。Shader 底下有很多数据：sub shader、Pass 等会作为 memory “island” (root) 的成员去依次分配。因此当我们最后统计 Runtime 的时候，我们会统计 Root，而不会统计成员，因为太多了没法统计。</li>\n<li>及时返给unity: 因为是 C++ 的，因此当我们 delete、free 一个内存的时候会立刻返回内存给系统，与托管内存堆不一样。</li>\n</ul>\n<h4 id=\"5-最佳实践-Native-内存\"><a href=\"#5-最佳实践-Native-内存\" class=\"headerlink\" title=\"5. 最佳实践 Native 内存\"></a>5. 最佳实践 Native 内存</h4><ul>\n<li><p>Scene</p>\n<ul>\n<li>Unity 是一个 C++ 引擎，所有实体最终都会反映在 C++ 上，而不是托管堆里面。因此当我们实例化一个 GameObject 的时候，在 Unity 底层会构建一个或多个 Object 来存储这个 GameObject 的信息，例如很多 Components。因此当 Scene 有过多 GameObject 的时候，Native 内存就会显著上升。</li>\n<li>当我们看 Profiler，发现 Native 内存大量上升的时候，应先去检查 Scene。</li>\n</ul>\n</li>\n<li><p>Audio</p>\n<ul>\n<li><p>DSP buffer （声音的缓冲）</p>\n<ul>\n<li><p>当一个声音要播放的时候，它需要向 CPU 去发送指令——我要播放声音。但如果声音的数据量非常小，就会造成频繁地向 CPU 发送指令，会造成 I\\O。</p>\n</li>\n<li><p>当 Unity 用到 FMOD 声音引擎时（Unity 底层也用到 FMOD），会有一个 Buffer，当 Buffer 填充满了，才会向 CPU 发送“我要播放声音”的指令。</p>\n</li>\n<li><p>DSP buffer 会导致两种问题：</p>\n<ul>\n<li><p>如果（设置的） buffer 过大，会导致声音的延迟。要填充满 buffer 是要很多声音数据的，但声音数据又没这么大，因此会导致一定的<strong>声音延迟</strong>。</p>\n</li>\n<li><p>如果 DSP buffer 太小，会导致 CPU 负担上升，满了就发，消耗增加。</p>\n<p><a href=\"https://docs.unity3d.com/Manual/class-AudioManager.html\">Audio</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Force to mono</p>\n<ul>\n<li>在导入声音的时候有一个设置，很多音效师为了声音质量，会把声音设为双声道。但 95% 的声音，左右声道放的是完全一样的数据。这导致了 1M 的声音会变成 2M，体现在包体里和内存里。因此一般对于声音不是很敏感的游戏，会建议改成 Force to mono，强制单声道。</li>\n</ul>\n</li>\n<li><p>Format</p>\n</li>\n<li><p>Compression Format（看文档，有使用建议）</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Code Size</p>\n<ul>\n<li><p>C++ 模板泛型的滥用会影响到 Code Size、打包的速度。</p>\n<ul>\n<li>AssetBundle</li>\n</ul>\n</li>\n<li><p>TypeTree</p>\n<ul>\n<li>Unity 的每一种类型都有很多数据结构的改变，为了对此做兼容，Unity 会在生成数据类型序列化的时候，顺便会生成 TypeTree：当前我这一个版本里用到了哪些变量，对应的数据类型是什么。在反序列化的时候，会根据 TypeTree 来进行反序列化。<ul>\n<li>如果上一个版本的类型在这个版本中没有，TypeTree 就没有它，因此不会碰到它。</li>\n<li>如果要用一个新的类型，但在这个版本中不存在，会用一个默认值来序列化，从而保证了不会在不同的版本序列化中出错，这个就是 TypeTree 的作用。</li>\n</ul>\n</li>\n<li>Build AssetBundle 中有开关可以关掉 TypeTree。当你确认当前 AssetBundle 的使用和 Build Unity 的版本一模一样，这时候可以把 TypeTree 关掉。<ul>\n<li>例如如果用同样的 Unity 打出来的 AssetBundle 和 APP，TypeTree 则完全可以关掉。</li>\n</ul>\n</li>\n<li>TypeTree 好处：<ul>\n<li>内存减少。TypeTree 本身是数据，也要占内存。</li>\n<li>包大小会减少，因为 TypeTree 会序列化到 AssetBundle 包中，以便读取。</li>\n<li>Build 和运行时会变快。源代码中可以看到，因为每一次 Serialize 东西的时候，如果发现需要 Serialize TypeTree，则会 Serialize 两次：<ul>\n<li>第一次先把 TypeTree Serialize 出来</li>\n<li>第二次把实际的东西 Serialize 出来</li>\n<li>反序列化也会做同样的事情，1. TypeTree 反序列化，2. 实际的东西反序列化。</li>\n</ul>\n</li>\n<li>因此如果确定 TypeTree 不会对兼容性造成影响，可以把它关掉。这样对 Size 大小和 Build Runtime 都会获得收益。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>压缩方式：</p>\n<ul>\n<li><p>Lz4</p>\n<p>  <a href=\"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZ4.html\">BuildCompression.LZ4</a></p>\n<ul>\n<li>LZ4HC “Chunk Based” Compression. 非常快</li>\n<li>和 Lzma 相比，平均压缩比率差 30%。也就是说会导致包体大一点，但是（作者说）速度能快 10 倍以上。</li>\n</ul>\n</li>\n<li><p>Lzma</p>\n<p>  <a href=\"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZMA.html\">BuildCompression.LZMA</a></p>\n<ul>\n<li>Lzma 基本上就不要用了，因为解压和读取速度上都会比较慢。</li>\n<li>还会占大量内存<ul>\n<li>因为是 Steam based 而不是 Chunk Based 的，因此需要一次全解压</li>\n<li>Chunk Based 可以一块一块解压<ul>\n<li>如果发现一个文件在第 5-10 块，那么 LZ4 会依次将 第 5 6 7 8 9 10 块分别解压出来，每次（chunk 的）解压会重用之前的内存，来减少内存的峰值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>预告：中国版 Unity 会在下个版本（1月5号或2月份）推出新的功能：基于 LZ4 的 AssetBundle 加密，只支持 LZ4。</p>\n</li>\n<li><p>Size &amp; count</p>\n<ul>\n<li>AssetBundle 包打多大是很玄学的问题，但每一个 Asset 打一个 Bundle 这样不太好。<ul>\n<li>有一种减图片大小的方式，把 png 的头都提出来。因为头的色板是通用的，而数据不通用。AssetBundle 也一样，一部分是它的头，一部分是实际打包的部分。因此如果每个 Asset 都打 Bundle 会导致 AssetBundle 的头比数据还要大。</li>\n</ul>\n</li>\n<li>官方的建议是每个 AssetBundle 包大概 1M~2M 左右大小，考虑的是网络带宽。但现在 5G 的时候，可以考虑适当把包体加大。还是要看实际用户的情况。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Resource 文件夹（<strong>Do not use it</strong>. 除非在 debug 的时候）</p>\n<ul>\n<li>Resource 和 AssetBundle 一样，也有头来索引。Resource  在打进包的时候会做一个红黑树，来帮助 Resource 来检索资源在什么位置，</li>\n<li>如果 Resource 非常大，那么红黑树也会非常大。</li>\n<li>红黑树是不可卸载的。在刚开始游戏的时候就会加载进内存中，会持续对游戏造成内存压力。</li>\n<li>会极大拖慢游戏的启动时间。因为红黑树没加载完，游戏不能启动。</li>\n</ul>\n</li>\n<li><p>Texture</p>\n<ul>\n<li><p>upload buffer，和声音的很像：填满多大，就向 CPU push 一次。</p>\n</li>\n<li><p>r/w</p>\n<ul>\n<li>Texture 没必要就不要开 read and write。正常 Texture 读进内存，解析完了，放到 upload buffer 里后，内存里的就会 delete 掉。</li>\n<li>但如果检测到你开了 r/w 就不会 delete 了，就会在显存和内存中各一份。</li>\n</ul>\n</li>\n<li><p>Mip Maps</p>\n<ul>\n<li>UI 没必要开，可以省大量内存。</li>\n</ul>\n</li>\n<li><p>Mesh</p>\n<ul>\n<li>r/w</li>\n<li>compression<ul>\n<li>有些版本 Compression 开了不如不开，内存占用可能更严重，具体需要自己试。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Assets</p>\n<ul>\n<li><p>Assets 的数量实际上和 asset 整个的纹理是有关系的。（？）</p>\n<p><a href=\"https://learn.unity.com/tutorial/memory-management-in-unity\">Memory Management in Unity - Unity Learn</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-Unity-Managed-Memory\"><a href=\"#6-Unity-Managed-Memory\" class=\"headerlink\" title=\"6. Unity Managed Memory\"></a>6. Unity Managed Memory</h4><p><a href=\"https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html\">Understanding the managed heap</a></p>\n<ul>\n<li><p>VM 内存池</p>\n<ul>\n<li>mono 虚拟机的内存池</li>\n<li>VM 会返还内存给 OS 吗？<ul>\n<li><strong>会</strong></li>\n</ul>\n</li>\n<li>返还条件是什么？<ul>\n<li>GC 不会把内存返还给系统</li>\n<li>内存也是以 Block 来管理的。当一个 Block 连续六次 GC 没有被访问到，这块内存才会被返还到系统。（mono runtime 基本看不到，IL2cpp runtime 可能会看到多一点）</li>\n</ul>\n</li>\n<li>不会频繁地分配内存，而是一次分配一大块。</li>\n</ul>\n</li>\n<li><p>GC 机制（BOEHM Non-generational 不分代的）</p>\n<ul>\n<li><p>GC 机制考量</p>\n<ul>\n<li>Throughput(（回收能力）<ul>\n<li>一次回收，会回收多少内存</li>\n</ul>\n</li>\n<li>Pause times（暂停时长）==mark text==<ul>\n<li>进行回收的时候，对主线程的影响有多大</li>\n</ul>\n</li>\n<li>Fragmentation（碎片化）<ul>\n<li>回收内存后，会对整体回收内存池的贡献有多少</li>\n</ul>\n</li>\n<li>Mutator overhead（额外消耗）<ul>\n<li>回收本身有 overhead，要做很多统计、标记的工作</li>\n</ul>\n</li>\n<li>Scalability（可扩展性）<ul>\n<li>扩展到多核、多线程会不会有 bug</li>\n</ul>\n</li>\n<li>Protability（可移植性）<ul>\n<li>不同平台是否可以使用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>BOEHM</p>\n<ul>\n<li><p>Non-generational（不分代的）</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png\"></p>\n<ul>\n<li>分代是指：大块内存、小内存、超小内存是分在不同内存区域来进行管理的。还有长久内存，当有一个内存很久没动的时候会移到长久内存区域中，从而省出内存给更频繁分配的内存。</li>\n</ul>\n</li>\n<li><p>Non-compacting（非压缩式）</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png\"></p>\n<ul>\n<li>当有内存被回收的时候，压缩内存会把上图空的地方重新排布。</li>\n<li>但 Unity 的 BOEHM 不会！它是非压缩式的。空着就空着，下次要用了再填进去。<ul>\n<li>历史原因：Unity 和 Mono 合作上，Mono 并不是一直开源免费的，因此 Unity 选择不升级 Mono，与实际 Mono 版本有差距。</li>\n<li>下一代 GC<ul>\n<li>==Incremental GC（渐进式 GC） #F44336==<ul>\n<li>现在如果我们要进行一次 GC，主线程被迫要停下来，遍历所有 GC Memory “island”（没听清），来决定哪些 GC 可以回收。</li>\n<li>==Incremental GC 把暂停主线程的事分帧做了。一点一点分析，主线程不会有峰值。总体 GC 时间不变，但会改善 GC 对主线程的卡顿影响。 #F44336==</li>\n</ul>\n</li>\n<li>SGen 或者升级 Boehm？<ul>\n<li>SGen 是分代的，能避免内存碎片化问题，调动策略，速度较快</li>\n</ul>\n</li>\n<li>IL2CPP<ul>\n<li>现在 IL2CPP 的 GC 机制是 Unity 自己重新写的，是升级版的 Boehm</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Memory fragmentation 内存碎片化</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png\"></p>\n<ul>\n<li>为什么内存下降了，但总体内存池还是上升了？<ul>\n<li>因为内存太大了，内存池没地方放它，虽然有很多内存可用。（内存已被严重碎片化）</li>\n</ul>\n</li>\n<li>当开发者大量加载小内存，使用释放*N，例如配置表、巨大数组，GC 会涨一大截。<ul>\n<li>建议==先操作大内存，再操作小内存，以保证内存以最大效率被重复利用。 #F44336==</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Zombie Memory（僵尸内存）</p>\n<ul>\n<li>内存泄露说法是不对的，内存只是没有任何人能够管理到，但实际上内存没有被泄露，一直在内存池中，被 zombie 掉了，这种叫 Zombie 内存。</li>\n<li>无用内容<ul>\n<li>Coding 时候或者团队配合的时候有问题，加载了一个东西进来，结果从头到尾只用了一次。</li>\n<li>有些开发者写了队列调度策略，但是策略写的不好，导致一些他觉得会被释放的东西，没有被释放掉。</li>\n<li>找是否有活跃度实际上并不高的内存。</li>\n</ul>\n</li>\n<li>没有释放</li>\n<li>通过代码管理和性能工具分析</li>\n</ul>\n</li>\n<li><p>最佳实践</p>\n<ul>\n<li>Don’t Null it, but Destroy it（显式用 Destory，别用 Null）</li>\n<li>Class VS Struct</li>\n<li>Pool In Pool（池中池）<ul>\n<li>VM 本身有内存池，但建议开发者对高频使用的小部件，自己建一个内存池。例如子弹等。</li>\n</ul>\n</li>\n<li>Closures and anonymous methods（闭包和匿名函数）<ul>\n<li>如果看 IL，所有匿名函数和闭包会 new 成一个 class，因此所有变量和要 new 的东西都是要占内存的。这样会导致协程。<ul>\n<li>有些开发者会在游戏开始启用一个协程，直到游戏结束才释放，这是错误的。</li>\n<li>只要协程不被释放掉，所有内存都会在内存里。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Coroutines（协程）<ul>\n<li>可看做闭包和匿名函数的一个特例</li>\n<li>最佳实践：用的时候生产一个，不用的时候 destroy 掉。</li>\n</ul>\n</li>\n<li>Configurations（配置表）<ul>\n<li>不要把整个配置表都扔进去，是否能通过啥来切分下配置表</li>\n</ul>\n</li>\n<li>Singleton<ul>\n<li>慎用</li>\n<li>游戏一开始到游戏死掉，一直在内存中。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>UPR 工具</p>\n<p>  <a href=\"https://connect.unity.com/p/unite-2019-unity-uprxing-neng-bao-gao-gong-neng-jie-shao\">Unite 2019 | Unity UPR性能报告功能介绍 - Unity Connect</a></p>\n<ul>\n<li>免费，在中国增强版里</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"物理内存\"><a href=\"#物理内存\" class=\"headerlink\" title=\"物理内存\"></a>物理内存</h2><p>当指令不连贯时，将会产生大量的时间浪费，DOTS和ECS从这个方面优化了内存的访问性能。</p>\n<p><img src=\"/img/1578646439353.png\" alt=\"DOTS的目的\"></p>\n<blockquote>\n<p>日志常见： OOM，显存大小无法分配过来的报错信息<br><img src=\"/img/1578646594733.png\" alt=\"移动设备的区别\"></p>\n</blockquote>\n<blockquote>\n<p>三级缓存：<br>台式：主流在8~16MB<br>移动端：高端如845，2M</p>\n</blockquote>\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p><img src=\"/img/1578646743161.png\" alt=\"虚拟内存\"></p>\n<blockquote>\n<p>交换内存： 当操作系统内存不够时，尝试把不用的内存(deadmemory)交换到硬盘上，从而节省出更多物理内存。<br>为什么移动端没有内存交换：移动设备IO速度慢，存储器的可擦写次数较台式少。<br>IOS提供了把不活跃的内存压缩起来放到一个特定空间。Virtual memory 很大。</p>\n</blockquote>\n<h2 id=\"内存寻址范围\"><a href=\"#内存寻址范围\" class=\"headerlink\" title=\"内存寻址范围\"></a>内存寻址范围</h2><p>可简单认为64位CPU寻址范围大。</p>\n<h2 id=\"安卓内存管理\"><a href=\"#安卓内存管理\" class=\"headerlink\" title=\"安卓内存管理\"></a>安卓内存管理</h2><p><img src=\"/img/1578647010062.png\" alt=\"安卓内存\"></p>\n<blockquote>\n<p>Page: 一般4K一个Page<br>回收和分配以page为单位<br>用户态和内核态</p>\n</blockquote>\n<blockquote>\n<p>LMK, low memeory killer<br>分类：<br>Native： adbd等，adb的守护线程<br>System: 系统服务<br>Persistent: 电话，信息，蓝牙等等<br>Foreground: 应用<br>Perceptible: 搜索等等<br>Services： 服务，云服务等<br>Home:主界面<br>Previous: 之前上一个应用<br>Cached:　后台</p>\n</blockquote>\n<blockquote>\n<p>从低层开始往上杀。 Foreground其实就是闪退的表现。杀到System就重启了。<br><img src=\"/img/1578651845843.png\" alt=\"优化级\"></p>\n</blockquote>\n<h2 id=\"安卓内存指标\"><a href=\"#安卓内存指标\" class=\"headerlink\" title=\"安卓内存指标\"></a>安卓内存指标</h2><p><img src=\"/img/1578652129043.png\" alt=\"内存指标\"></p>\n<blockquote>\n<p>RSS: 当前APP所使用的所有内存<br>PSS: 公共库分配出来的内存<br>USS：只有自己使用的内存，一般在此处优化</p>\n</blockquote>\n<blockquote>\n<p>procrank 指令</p>\n</blockquote>\n<h2 id=\"Unity内存管理\"><a href=\"#Unity内存管理\" class=\"headerlink\" title=\"Unity内存管理\"></a>Unity内存管理</h2><p><img src=\"/img/1578652476304.png\" alt=\"Unity引擎\"></p>\n<h4 id=\"1-Unity-内存按照分配方式分为：\"><a href=\"#1-Unity-内存按照分配方式分为：\" class=\"headerlink\" title=\"1. Unity 内存按照分配方式分为：\"></a>1. Unity 内存按照分配方式分为：</h4><ul>\n<li>Native Memory<ul>\n<li>Managed Memory</li>\n<li>Editor &amp; Runtime 是不同的<ul>\n<li>不止是统计看到的内存大小不同，甚至是内存分配时机和方式也不同</li>\n<li>Asset 在 Runtime 中如果不读取，是不会进内存的，但 Editor 打开就占内存。因为 Editor 不注重 Runtime 的表现，更注重编辑器中编辑时的流畅。</li>\n<li>但如果游戏庞大到几十个 G，如果第一次打开项目，会消耗很多时间，有的大的会几天，甚至到一周。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-Unity-内存按照管理者分为：\"><a href=\"#2-Unity-内存按照管理者分为：\" class=\"headerlink\" title=\"2. Unity 内存按照管理者分为：\"></a>2. Unity 内存按照管理者分为：</h4><ul>\n<li>引擎管理内存，开发者一般使用不到</li>\n<li>用户管理内存（应优先考虑）</li>\n</ul>\n<h4 id=\"3-Unity-检测不到的内存\"><a href=\"#3-Unity-检测不到的内存\" class=\"headerlink\" title=\"3. Unity 检测不到的内存\"></a>3. Unity 检测不到的内存</h4><p>用户分配的 native 内存</p>\n<ul>\n<li>自己写的 Native 插件（C++ 插件）， Unity 无法分析已经编译过的 C++ 是如何去分配和使用内存的。</li>\n<li>Lua 完全由自己管理内存，Unity 无法统计到内部的使用情况。</li>\n</ul>\n<h4 id=\"4-Unity-Native-Memory-管理\"><a href=\"#4-Unity-Native-Memory-管理\" class=\"headerlink\" title=\"4. Unity Native Memory 管理\"></a>4. Unity Native Memory 管理</h4><p>Unity 重载了所有分配内存的操作符（C++ alloc、new），使用这些重载的时候，会需要一个额外的 memory label （Profiler-shaderlab-object-memory-detail-snapshot，里面的名字就是 label：指当前内存要分配到哪一个类型池里面）</p>\n<ul>\n<li>Allocator: 使用重载过的分配符去分配内存时，Allocator 会根据你的 memory label 分配到不同 Allocator 池里面，每个 Allocator 池 单独做自己的跟踪。因此当我们去 Runtime get memory label 下面的池时就可以问 Allocator，里面有多少东西 多少兆。</li>\n<li>NewAsRoot: Allocator 在 NewAsRoot （Memory  “island”（没听清）） 中生成。在这个 Memory Root 下面会有很多子内存：shader：当我们加载一个 Shader 进内存的时候，会生成一个 Shader 的 root。Shader 底下有很多数据：sub shader、Pass 等会作为 memory “island” (root) 的成员去依次分配。因此当我们最后统计 Runtime 的时候，我们会统计 Root，而不会统计成员，因为太多了没法统计。</li>\n<li>及时返给unity: 因为是 C++ 的，因此当我们 delete、free 一个内存的时候会立刻返回内存给系统，与托管内存堆不一样。</li>\n</ul>\n<h4 id=\"5-最佳实践-Native-内存\"><a href=\"#5-最佳实践-Native-内存\" class=\"headerlink\" title=\"5. 最佳实践 Native 内存\"></a>5. 最佳实践 Native 内存</h4><ul>\n<li><p>Scene</p>\n<ul>\n<li>Unity 是一个 C++ 引擎，所有实体最终都会反映在 C++ 上，而不是托管堆里面。因此当我们实例化一个 GameObject 的时候，在 Unity 底层会构建一个或多个 Object 来存储这个 GameObject 的信息，例如很多 Components。因此当 Scene 有过多 GameObject 的时候，Native 内存就会显著上升。</li>\n<li>当我们看 Profiler，发现 Native 内存大量上升的时候，应先去检查 Scene。</li>\n</ul>\n</li>\n<li><p>Audio</p>\n<ul>\n<li><p>DSP buffer （声音的缓冲）</p>\n<ul>\n<li><p>当一个声音要播放的时候，它需要向 CPU 去发送指令——我要播放声音。但如果声音的数据量非常小，就会造成频繁地向 CPU 发送指令，会造成 I\\O。</p>\n</li>\n<li><p>当 Unity 用到 FMOD 声音引擎时（Unity 底层也用到 FMOD），会有一个 Buffer，当 Buffer 填充满了，才会向 CPU 发送“我要播放声音”的指令。</p>\n</li>\n<li><p>DSP buffer 会导致两种问题：</p>\n<ul>\n<li><p>如果（设置的） buffer 过大，会导致声音的延迟。要填充满 buffer 是要很多声音数据的，但声音数据又没这么大，因此会导致一定的<strong>声音延迟</strong>。</p>\n</li>\n<li><p>如果 DSP buffer 太小，会导致 CPU 负担上升，满了就发，消耗增加。</p>\n<p><a href=\"https://docs.unity3d.com/Manual/class-AudioManager.html\">Audio</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Force to mono</p>\n<ul>\n<li>在导入声音的时候有一个设置，很多音效师为了声音质量，会把声音设为双声道。但 95% 的声音，左右声道放的是完全一样的数据。这导致了 1M 的声音会变成 2M，体现在包体里和内存里。因此一般对于声音不是很敏感的游戏，会建议改成 Force to mono，强制单声道。</li>\n</ul>\n</li>\n<li><p>Format</p>\n</li>\n<li><p>Compression Format（看文档，有使用建议）</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Code Size</p>\n<ul>\n<li><p>C++ 模板泛型的滥用会影响到 Code Size、打包的速度。</p>\n<ul>\n<li>AssetBundle</li>\n</ul>\n</li>\n<li><p>TypeTree</p>\n<ul>\n<li>Unity 的每一种类型都有很多数据结构的改变，为了对此做兼容，Unity 会在生成数据类型序列化的时候，顺便会生成 TypeTree：当前我这一个版本里用到了哪些变量，对应的数据类型是什么。在反序列化的时候，会根据 TypeTree 来进行反序列化。<ul>\n<li>如果上一个版本的类型在这个版本中没有，TypeTree 就没有它，因此不会碰到它。</li>\n<li>如果要用一个新的类型，但在这个版本中不存在，会用一个默认值来序列化，从而保证了不会在不同的版本序列化中出错，这个就是 TypeTree 的作用。</li>\n</ul>\n</li>\n<li>Build AssetBundle 中有开关可以关掉 TypeTree。当你确认当前 AssetBundle 的使用和 Build Unity 的版本一模一样，这时候可以把 TypeTree 关掉。<ul>\n<li>例如如果用同样的 Unity 打出来的 AssetBundle 和 APP，TypeTree 则完全可以关掉。</li>\n</ul>\n</li>\n<li>TypeTree 好处：<ul>\n<li>内存减少。TypeTree 本身是数据，也要占内存。</li>\n<li>包大小会减少，因为 TypeTree 会序列化到 AssetBundle 包中，以便读取。</li>\n<li>Build 和运行时会变快。源代码中可以看到，因为每一次 Serialize 东西的时候，如果发现需要 Serialize TypeTree，则会 Serialize 两次：<ul>\n<li>第一次先把 TypeTree Serialize 出来</li>\n<li>第二次把实际的东西 Serialize 出来</li>\n<li>反序列化也会做同样的事情，1. TypeTree 反序列化，2. 实际的东西反序列化。</li>\n</ul>\n</li>\n<li>因此如果确定 TypeTree 不会对兼容性造成影响，可以把它关掉。这样对 Size 大小和 Build Runtime 都会获得收益。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>压缩方式：</p>\n<ul>\n<li><p>Lz4</p>\n<p>  <a href=\"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZ4.html\">BuildCompression.LZ4</a></p>\n<ul>\n<li>LZ4HC “Chunk Based” Compression. 非常快</li>\n<li>和 Lzma 相比，平均压缩比率差 30%。也就是说会导致包体大一点，但是（作者说）速度能快 10 倍以上。</li>\n</ul>\n</li>\n<li><p>Lzma</p>\n<p>  <a href=\"https://docs.unity3d.com/2019.3/Documentation/ScriptReference/BuildCompression.LZMA.html\">BuildCompression.LZMA</a></p>\n<ul>\n<li>Lzma 基本上就不要用了，因为解压和读取速度上都会比较慢。</li>\n<li>还会占大量内存<ul>\n<li>因为是 Steam based 而不是 Chunk Based 的，因此需要一次全解压</li>\n<li>Chunk Based 可以一块一块解压<ul>\n<li>如果发现一个文件在第 5-10 块，那么 LZ4 会依次将 第 5 6 7 8 9 10 块分别解压出来，每次（chunk 的）解压会重用之前的内存，来减少内存的峰值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>预告：中国版 Unity 会在下个版本（1月5号或2月份）推出新的功能：基于 LZ4 的 AssetBundle 加密，只支持 LZ4。</p>\n</li>\n<li><p>Size &amp; count</p>\n<ul>\n<li>AssetBundle 包打多大是很玄学的问题，但每一个 Asset 打一个 Bundle 这样不太好。<ul>\n<li>有一种减图片大小的方式，把 png 的头都提出来。因为头的色板是通用的，而数据不通用。AssetBundle 也一样，一部分是它的头，一部分是实际打包的部分。因此如果每个 Asset 都打 Bundle 会导致 AssetBundle 的头比数据还要大。</li>\n</ul>\n</li>\n<li>官方的建议是每个 AssetBundle 包大概 1M~2M 左右大小，考虑的是网络带宽。但现在 5G 的时候，可以考虑适当把包体加大。还是要看实际用户的情况。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Resource 文件夹（<strong>Do not use it</strong>. 除非在 debug 的时候）</p>\n<ul>\n<li>Resource 和 AssetBundle 一样，也有头来索引。Resource  在打进包的时候会做一个红黑树，来帮助 Resource 来检索资源在什么位置，</li>\n<li>如果 Resource 非常大，那么红黑树也会非常大。</li>\n<li>红黑树是不可卸载的。在刚开始游戏的时候就会加载进内存中，会持续对游戏造成内存压力。</li>\n<li>会极大拖慢游戏的启动时间。因为红黑树没加载完，游戏不能启动。</li>\n</ul>\n</li>\n<li><p>Texture</p>\n<ul>\n<li><p>upload buffer，和声音的很像：填满多大，就向 CPU push 一次。</p>\n</li>\n<li><p>r/w</p>\n<ul>\n<li>Texture 没必要就不要开 read and write。正常 Texture 读进内存，解析完了，放到 upload buffer 里后，内存里的就会 delete 掉。</li>\n<li>但如果检测到你开了 r/w 就不会 delete 了，就会在显存和内存中各一份。</li>\n</ul>\n</li>\n<li><p>Mip Maps</p>\n<ul>\n<li>UI 没必要开，可以省大量内存。</li>\n</ul>\n</li>\n<li><p>Mesh</p>\n<ul>\n<li>r/w</li>\n<li>compression<ul>\n<li>有些版本 Compression 开了不如不开，内存占用可能更严重，具体需要自己试。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Assets</p>\n<ul>\n<li><p>Assets 的数量实际上和 asset 整个的纹理是有关系的。（？）</p>\n<p><a href=\"https://learn.unity.com/tutorial/memory-management-in-unity\">Memory Management in Unity - Unity Learn</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-Unity-Managed-Memory\"><a href=\"#6-Unity-Managed-Memory\" class=\"headerlink\" title=\"6. Unity Managed Memory\"></a>6. Unity Managed Memory</h4><p><a href=\"https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html\">Understanding the managed heap</a></p>\n<ul>\n<li><p>VM 内存池</p>\n<ul>\n<li>mono 虚拟机的内存池</li>\n<li>VM 会返还内存给 OS 吗？<ul>\n<li><strong>会</strong></li>\n</ul>\n</li>\n<li>返还条件是什么？<ul>\n<li>GC 不会把内存返还给系统</li>\n<li>内存也是以 Block 来管理的。当一个 Block 连续六次 GC 没有被访问到，这块内存才会被返还到系统。（mono runtime 基本看不到，IL2cpp runtime 可能会看到多一点）</li>\n</ul>\n</li>\n<li>不会频繁地分配内存，而是一次分配一大块。</li>\n</ul>\n</li>\n<li><p>GC 机制（BOEHM Non-generational 不分代的）</p>\n<ul>\n<li><p>GC 机制考量</p>\n<ul>\n<li>Throughput(（回收能力）<ul>\n<li>一次回收，会回收多少内存</li>\n</ul>\n</li>\n<li>Pause times（暂停时长）==mark text==<ul>\n<li>进行回收的时候，对主线程的影响有多大</li>\n</ul>\n</li>\n<li>Fragmentation（碎片化）<ul>\n<li>回收内存后，会对整体回收内存池的贡献有多少</li>\n</ul>\n</li>\n<li>Mutator overhead（额外消耗）<ul>\n<li>回收本身有 overhead，要做很多统计、标记的工作</li>\n</ul>\n</li>\n<li>Scalability（可扩展性）<ul>\n<li>扩展到多核、多线程会不会有 bug</li>\n</ul>\n</li>\n<li>Protability（可移植性）<ul>\n<li>不同平台是否可以使用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>BOEHM</p>\n<ul>\n<li><p>Non-generational（不分代的）</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8934bc1f-3e98-4544-b6de-6ea5b80e2850/Untitled.png\"></p>\n<ul>\n<li>分代是指：大块内存、小内存、超小内存是分在不同内存区域来进行管理的。还有长久内存，当有一个内存很久没动的时候会移到长久内存区域中，从而省出内存给更频繁分配的内存。</li>\n</ul>\n</li>\n<li><p>Non-compacting（非压缩式）</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33a4002e-f37e-4405-b9b3-815c0f43caba/Untitled.png\"></p>\n<ul>\n<li>当有内存被回收的时候，压缩内存会把上图空的地方重新排布。</li>\n<li>但 Unity 的 BOEHM 不会！它是非压缩式的。空着就空着，下次要用了再填进去。<ul>\n<li>历史原因：Unity 和 Mono 合作上，Mono 并不是一直开源免费的，因此 Unity 选择不升级 Mono，与实际 Mono 版本有差距。</li>\n<li>下一代 GC<ul>\n<li>==Incremental GC（渐进式 GC） #F44336==<ul>\n<li>现在如果我们要进行一次 GC，主线程被迫要停下来，遍历所有 GC Memory “island”（没听清），来决定哪些 GC 可以回收。</li>\n<li>==Incremental GC 把暂停主线程的事分帧做了。一点一点分析，主线程不会有峰值。总体 GC 时间不变，但会改善 GC 对主线程的卡顿影响。 #F44336==</li>\n</ul>\n</li>\n<li>SGen 或者升级 Boehm？<ul>\n<li>SGen 是分代的，能避免内存碎片化问题，调动策略，速度较快</li>\n</ul>\n</li>\n<li>IL2CPP<ul>\n<li>现在 IL2CPP 的 GC 机制是 Unity 自己重新写的，是升级版的 Boehm</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Memory fragmentation 内存碎片化</p>\n<p>  <img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png\" alt=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96caa361-8d1a-4f8e-a0b6-87d521bb7f14/Untitled.png\"></p>\n<ul>\n<li>为什么内存下降了，但总体内存池还是上升了？<ul>\n<li>因为内存太大了，内存池没地方放它，虽然有很多内存可用。（内存已被严重碎片化）</li>\n</ul>\n</li>\n<li>当开发者大量加载小内存，使用释放*N，例如配置表、巨大数组，GC 会涨一大截。<ul>\n<li>建议==先操作大内存，再操作小内存，以保证内存以最大效率被重复利用。 #F44336==</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Zombie Memory（僵尸内存）</p>\n<ul>\n<li>内存泄露说法是不对的，内存只是没有任何人能够管理到，但实际上内存没有被泄露，一直在内存池中，被 zombie 掉了，这种叫 Zombie 内存。</li>\n<li>无用内容<ul>\n<li>Coding 时候或者团队配合的时候有问题，加载了一个东西进来，结果从头到尾只用了一次。</li>\n<li>有些开发者写了队列调度策略，但是策略写的不好，导致一些他觉得会被释放的东西，没有被释放掉。</li>\n<li>找是否有活跃度实际上并不高的内存。</li>\n</ul>\n</li>\n<li>没有释放</li>\n<li>通过代码管理和性能工具分析</li>\n</ul>\n</li>\n<li><p>最佳实践</p>\n<ul>\n<li>Don’t Null it, but Destroy it（显式用 Destory，别用 Null）</li>\n<li>Class VS Struct</li>\n<li>Pool In Pool（池中池）<ul>\n<li>VM 本身有内存池，但建议开发者对高频使用的小部件，自己建一个内存池。例如子弹等。</li>\n</ul>\n</li>\n<li>Closures and anonymous methods（闭包和匿名函数）<ul>\n<li>如果看 IL，所有匿名函数和闭包会 new 成一个 class，因此所有变量和要 new 的东西都是要占内存的。这样会导致协程。<ul>\n<li>有些开发者会在游戏开始启用一个协程，直到游戏结束才释放，这是错误的。</li>\n<li>只要协程不被释放掉，所有内存都会在内存里。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Coroutines（协程）<ul>\n<li>可看做闭包和匿名函数的一个特例</li>\n<li>最佳实践：用的时候生产一个，不用的时候 destroy 掉。</li>\n</ul>\n</li>\n<li>Configurations（配置表）<ul>\n<li>不要把整个配置表都扔进去，是否能通过啥来切分下配置表</li>\n</ul>\n</li>\n<li>Singleton<ul>\n<li>慎用</li>\n<li>游戏一开始到游戏死掉，一直在内存中。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>UPR 工具</p>\n<p>  <a href=\"https://connect.unity.com/p/unite-2019-unity-uprxing-neng-bao-gao-gong-neng-jie-shao\">Unite 2019 | Unity UPR性能报告功能介绍 - Unity Connect</a></p>\n<ul>\n<li>免费，在中国增强版里</li>\n</ul>\n</li>\n</ul>\n"},{"title":"力扣刷题顺序","_content":"\n#### 概述\n![enter description here](/img/1587017641511.png)\n\n\n#### 分类总述\n\n![树的题目推荐](/img/1587018007123.png)\n![分治](/img/1587018034122.png)\n![链表](/img/1587018052146.png)\n![二叉搜索树](/img/1587018065979.png)\n![图论](/img/1587018079539.png)\n![搜索与回溯](/img/1587018086814.png)\n![二分搜索](/img/1587018118278.png)\n![双指针](/img/1587018132041.png)\n![高级](/img/1587018141563.png)\n![动态规划](/img/1587018151039.png)\n\n","source":"_posts/力扣刷题顺序.md","raw":"---\ntitle: 力扣刷题顺序\ncategories:\n- 算法\n---\n\n#### 概述\n![enter description here](/img/1587017641511.png)\n\n\n#### 分类总述\n\n![树的题目推荐](/img/1587018007123.png)\n![分治](/img/1587018034122.png)\n![链表](/img/1587018052146.png)\n![二叉搜索树](/img/1587018065979.png)\n![图论](/img/1587018079539.png)\n![搜索与回溯](/img/1587018086814.png)\n![二分搜索](/img/1587018118278.png)\n![双指针](/img/1587018132041.png)\n![高级](/img/1587018141563.png)\n![动态规划](/img/1587018151039.png)\n\n","slug":"力扣刷题顺序","published":1,"date":"2020-09-08T03:23:20.889Z","updated":"2020-09-08T03:23:20.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh119003i4wf083iha4rv","content":"<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><img src=\"/img/1587017641511.png\" alt=\"enter description here\"></p>\n<h4 id=\"分类总述\"><a href=\"#分类总述\" class=\"headerlink\" title=\"分类总述\"></a>分类总述</h4><p><img src=\"/img/1587018007123.png\" alt=\"树的题目推荐\"><br><img src=\"/img/1587018034122.png\" alt=\"分治\"><br><img src=\"/img/1587018052146.png\" alt=\"链表\"><br><img src=\"/img/1587018065979.png\" alt=\"二叉搜索树\"><br><img src=\"/img/1587018079539.png\" alt=\"图论\"><br><img src=\"/img/1587018086814.png\" alt=\"搜索与回溯\"><br><img src=\"/img/1587018118278.png\" alt=\"二分搜索\"><br><img src=\"/img/1587018132041.png\" alt=\"双指针\"><br><img src=\"/img/1587018141563.png\" alt=\"高级\"><br><img src=\"/img/1587018151039.png\" alt=\"动态规划\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><img src=\"/img/1587017641511.png\" alt=\"enter description here\"></p>\n<h4 id=\"分类总述\"><a href=\"#分类总述\" class=\"headerlink\" title=\"分类总述\"></a>分类总述</h4><p><img src=\"/img/1587018007123.png\" alt=\"树的题目推荐\"><br><img src=\"/img/1587018034122.png\" alt=\"分治\"><br><img src=\"/img/1587018052146.png\" alt=\"链表\"><br><img src=\"/img/1587018065979.png\" alt=\"二叉搜索树\"><br><img src=\"/img/1587018079539.png\" alt=\"图论\"><br><img src=\"/img/1587018086814.png\" alt=\"搜索与回溯\"><br><img src=\"/img/1587018118278.png\" alt=\"二分搜索\"><br><img src=\"/img/1587018132041.png\" alt=\"双指针\"><br><img src=\"/img/1587018141563.png\" alt=\"高级\"><br><img src=\"/img/1587018151039.png\" alt=\"动态规划\"></p>\n"},{"title":"Python Note 4","_content":"# Python Note 4\n\n### Pypi & Pip\n+ [pypi](https://pypi.org/)\n+ use as : pip install openpyxl  to install \n\n### Use openpyxl\n\n```python\nimport openpyxl as xl\nfrom openpyxl.chart import BarChart, Reference\nwb = xl.load_workbook(\"pydemo2/transactions.xlsx\")\nsheet = wb[\"Sheet1\"]\nfor row in range(2, sheet.max_row + 1):\n    cell = sheet.cell(row, 3)\n    real_val = cell.value * 0.9\n    real_val_cell = sheet.cell(row, 4)\n    real_val_cell.value = real_val\n\nvalues = Reference(sheet, min_row=2, max_row=sheet.max_row, min_col=4, max_col=4)\nchart = BarChart()\nchart.add_data(values)\nsheet.add_chart(chart, 'e2')\nwb.save('pydemo2/transactions_n2.xlsx')\n```\n\n### Machine learning\n\n+ Self-driving Cars\n+ Robotics\n+ Language Processing\n+ Vision Processing\n+ Forecasting Stock Market Trends","source":"_posts/python_4.md","raw":"---\ntitle: Python Note 4\ncategories:\n- Python\ntags: \n- Python\n- Note\n---\n# Python Note 4\n\n### Pypi & Pip\n+ [pypi](https://pypi.org/)\n+ use as : pip install openpyxl  to install \n\n### Use openpyxl\n\n```python\nimport openpyxl as xl\nfrom openpyxl.chart import BarChart, Reference\nwb = xl.load_workbook(\"pydemo2/transactions.xlsx\")\nsheet = wb[\"Sheet1\"]\nfor row in range(2, sheet.max_row + 1):\n    cell = sheet.cell(row, 3)\n    real_val = cell.value * 0.9\n    real_val_cell = sheet.cell(row, 4)\n    real_val_cell.value = real_val\n\nvalues = Reference(sheet, min_row=2, max_row=sheet.max_row, min_col=4, max_col=4)\nchart = BarChart()\nchart.add_data(values)\nsheet.add_chart(chart, 'e2')\nwb.save('pydemo2/transactions_n2.xlsx')\n```\n\n### Machine learning\n\n+ Self-driving Cars\n+ Robotics\n+ Language Processing\n+ Vision Processing\n+ Forecasting Stock Market Trends","slug":"python_4","published":1,"date":"2020-09-08T03:23:20.889Z","updated":"2020-09-08T03:23:20.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh11a003l4wf0am95udsr","content":"<h1 id=\"Python-Note-4\"><a href=\"#Python-Note-4\" class=\"headerlink\" title=\"Python Note 4\"></a>Python Note 4</h1><h3 id=\"Pypi-amp-Pip\"><a href=\"#Pypi-amp-Pip\" class=\"headerlink\" title=\"Pypi &amp; Pip\"></a>Pypi &amp; Pip</h3><ul>\n<li><a href=\"https://pypi.org/\">pypi</a></li>\n<li>use as : pip install openpyxl  to install </li>\n</ul>\n<h3 id=\"Use-openpyxl\"><a href=\"#Use-openpyxl\" class=\"headerlink\" title=\"Use openpyxl\"></a>Use openpyxl</h3><pre><code class=\"python\">import openpyxl as xl\nfrom openpyxl.chart import BarChart, Reference\nwb = xl.load_workbook(&quot;pydemo2/transactions.xlsx&quot;)\nsheet = wb[&quot;Sheet1&quot;]\nfor row in range(2, sheet.max_row + 1):\n    cell = sheet.cell(row, 3)\n    real_val = cell.value * 0.9\n    real_val_cell = sheet.cell(row, 4)\n    real_val_cell.value = real_val\n\nvalues = Reference(sheet, min_row=2, max_row=sheet.max_row, min_col=4, max_col=4)\nchart = BarChart()\nchart.add_data(values)\nsheet.add_chart(chart, &#39;e2&#39;)\nwb.save(&#39;pydemo2/transactions_n2.xlsx&#39;)</code></pre>\n<h3 id=\"Machine-learning\"><a href=\"#Machine-learning\" class=\"headerlink\" title=\"Machine learning\"></a>Machine learning</h3><ul>\n<li>Self-driving Cars</li>\n<li>Robotics</li>\n<li>Language Processing</li>\n<li>Vision Processing</li>\n<li>Forecasting Stock Market Trends</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python-Note-4\"><a href=\"#Python-Note-4\" class=\"headerlink\" title=\"Python Note 4\"></a>Python Note 4</h1><h3 id=\"Pypi-amp-Pip\"><a href=\"#Pypi-amp-Pip\" class=\"headerlink\" title=\"Pypi &amp; Pip\"></a>Pypi &amp; Pip</h3><ul>\n<li><a href=\"https://pypi.org/\">pypi</a></li>\n<li>use as : pip install openpyxl  to install </li>\n</ul>\n<h3 id=\"Use-openpyxl\"><a href=\"#Use-openpyxl\" class=\"headerlink\" title=\"Use openpyxl\"></a>Use openpyxl</h3><pre><code class=\"python\">import openpyxl as xl\nfrom openpyxl.chart import BarChart, Reference\nwb = xl.load_workbook(&quot;pydemo2/transactions.xlsx&quot;)\nsheet = wb[&quot;Sheet1&quot;]\nfor row in range(2, sheet.max_row + 1):\n    cell = sheet.cell(row, 3)\n    real_val = cell.value * 0.9\n    real_val_cell = sheet.cell(row, 4)\n    real_val_cell.value = real_val\n\nvalues = Reference(sheet, min_row=2, max_row=sheet.max_row, min_col=4, max_col=4)\nchart = BarChart()\nchart.add_data(values)\nsheet.add_chart(chart, &#39;e2&#39;)\nwb.save(&#39;pydemo2/transactions_n2.xlsx&#39;)</code></pre>\n<h3 id=\"Machine-learning\"><a href=\"#Machine-learning\" class=\"headerlink\" title=\"Machine learning\"></a>Machine learning</h3><ul>\n<li>Self-driving Cars</li>\n<li>Robotics</li>\n<li>Language Processing</li>\n<li>Vision Processing</li>\n<li>Forecasting Stock Market Trends</li>\n</ul>\n"},{"title":"客户端更换Git指南","_content":"\n## 安装Git\n\n以下网站里选择自己电脑平台，下载安装即可\nhttps://git-scm.com/downloads\n注：安装过程选择默认选项\n\n## 安装Git工具\n\n推荐使用乌龟工具，界面与之前的SVN近似，而且可以结合window文件系统。\nhttps://tortoisegit.org/download/\n\n注：安装过程选择默认选项\n\n## 装好之后设置账号信息\n\n![装好之后设置账号信息](/img/1573879504277.png)\n\n\n## 克隆服务端的项目代码\n>1.右键选择git clone. \n2.输入项目地址：http://172.16.100.8:8081/x1/client.git \n\n![克隆服务端的项目代码](/img/1573881914065.png)\n\n## 切换到自己所在的分支\n> 美术： art \n> 策划和程序： feature\n\n![切换到自己所在的分支](/img/1573883470572.png)\n\n## 【可选】用旧项目的library\n>复制原SVN的UNITY目录下的library文件夹，粘贴到已经拉下来的unity目录下。这样重打开项目不用等待太多。\n\n## 如何拉取\n![如何拉取](/img/1573881886011.png)\n\n## 如何提交\n![如何提交](/img/1573880787198.png)\n","source":"_posts/客户端更换Git指南.md","raw":"---\ntitle: 客户端更换Git指南\ncategories:\n- 公司\ntags: \n- Git\n---\n\n## 安装Git\n\n以下网站里选择自己电脑平台，下载安装即可\nhttps://git-scm.com/downloads\n注：安装过程选择默认选项\n\n## 安装Git工具\n\n推荐使用乌龟工具，界面与之前的SVN近似，而且可以结合window文件系统。\nhttps://tortoisegit.org/download/\n\n注：安装过程选择默认选项\n\n## 装好之后设置账号信息\n\n![装好之后设置账号信息](/img/1573879504277.png)\n\n\n## 克隆服务端的项目代码\n>1.右键选择git clone. \n2.输入项目地址：http://172.16.100.8:8081/x1/client.git \n\n![克隆服务端的项目代码](/img/1573881914065.png)\n\n## 切换到自己所在的分支\n> 美术： art \n> 策划和程序： feature\n\n![切换到自己所在的分支](/img/1573883470572.png)\n\n## 【可选】用旧项目的library\n>复制原SVN的UNITY目录下的library文件夹，粘贴到已经拉下来的unity目录下。这样重打开项目不用等待太多。\n\n## 如何拉取\n![如何拉取](/img/1573881886011.png)\n\n## 如何提交\n![如何提交](/img/1573880787198.png)\n","slug":"客户端更换Git指南","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh11g003q4wf0aasnkg9o","content":"<h2 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h2><p>以下网站里选择自己电脑平台，下载安装即可<br><a href=\"https://git-scm.com/downloads\">https://git-scm.com/downloads</a><br>注：安装过程选择默认选项</p>\n<h2 id=\"安装Git工具\"><a href=\"#安装Git工具\" class=\"headerlink\" title=\"安装Git工具\"></a>安装Git工具</h2><p>推荐使用乌龟工具，界面与之前的SVN近似，而且可以结合window文件系统。<br><a href=\"https://tortoisegit.org/download/\">https://tortoisegit.org/download/</a></p>\n<p>注：安装过程选择默认选项</p>\n<h2 id=\"装好之后设置账号信息\"><a href=\"#装好之后设置账号信息\" class=\"headerlink\" title=\"装好之后设置账号信息\"></a>装好之后设置账号信息</h2><p><img src=\"/img/1573879504277.png\" alt=\"装好之后设置账号信息\"></p>\n<h2 id=\"克隆服务端的项目代码\"><a href=\"#克隆服务端的项目代码\" class=\"headerlink\" title=\"克隆服务端的项目代码\"></a>克隆服务端的项目代码</h2><blockquote>\n<p>1.右键选择git clone.<br>2.输入项目地址：<a href=\"http://172.16.100.8:8081/x1/client.git\">http://172.16.100.8:8081/x1/client.git</a> </p>\n</blockquote>\n<p><img src=\"/img/1573881914065.png\" alt=\"克隆服务端的项目代码\"></p>\n<h2 id=\"切换到自己所在的分支\"><a href=\"#切换到自己所在的分支\" class=\"headerlink\" title=\"切换到自己所在的分支\"></a>切换到自己所在的分支</h2><blockquote>\n<p>美术： art<br>策划和程序： feature</p>\n</blockquote>\n<p><img src=\"/img/1573883470572.png\" alt=\"切换到自己所在的分支\"></p>\n<h2 id=\"【可选】用旧项目的library\"><a href=\"#【可选】用旧项目的library\" class=\"headerlink\" title=\"【可选】用旧项目的library\"></a>【可选】用旧项目的library</h2><blockquote>\n<p>复制原SVN的UNITY目录下的library文件夹，粘贴到已经拉下来的unity目录下。这样重打开项目不用等待太多。</p>\n</blockquote>\n<h2 id=\"如何拉取\"><a href=\"#如何拉取\" class=\"headerlink\" title=\"如何拉取\"></a>如何拉取</h2><p><img src=\"/img/1573881886011.png\" alt=\"如何拉取\"></p>\n<h2 id=\"如何提交\"><a href=\"#如何提交\" class=\"headerlink\" title=\"如何提交\"></a>如何提交</h2><p><img src=\"/img/1573880787198.png\" alt=\"如何提交\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h2><p>以下网站里选择自己电脑平台，下载安装即可<br><a href=\"https://git-scm.com/downloads\">https://git-scm.com/downloads</a><br>注：安装过程选择默认选项</p>\n<h2 id=\"安装Git工具\"><a href=\"#安装Git工具\" class=\"headerlink\" title=\"安装Git工具\"></a>安装Git工具</h2><p>推荐使用乌龟工具，界面与之前的SVN近似，而且可以结合window文件系统。<br><a href=\"https://tortoisegit.org/download/\">https://tortoisegit.org/download/</a></p>\n<p>注：安装过程选择默认选项</p>\n<h2 id=\"装好之后设置账号信息\"><a href=\"#装好之后设置账号信息\" class=\"headerlink\" title=\"装好之后设置账号信息\"></a>装好之后设置账号信息</h2><p><img src=\"/img/1573879504277.png\" alt=\"装好之后设置账号信息\"></p>\n<h2 id=\"克隆服务端的项目代码\"><a href=\"#克隆服务端的项目代码\" class=\"headerlink\" title=\"克隆服务端的项目代码\"></a>克隆服务端的项目代码</h2><blockquote>\n<p>1.右键选择git clone.<br>2.输入项目地址：<a href=\"http://172.16.100.8:8081/x1/client.git\">http://172.16.100.8:8081/x1/client.git</a> </p>\n</blockquote>\n<p><img src=\"/img/1573881914065.png\" alt=\"克隆服务端的项目代码\"></p>\n<h2 id=\"切换到自己所在的分支\"><a href=\"#切换到自己所在的分支\" class=\"headerlink\" title=\"切换到自己所在的分支\"></a>切换到自己所在的分支</h2><blockquote>\n<p>美术： art<br>策划和程序： feature</p>\n</blockquote>\n<p><img src=\"/img/1573883470572.png\" alt=\"切换到自己所在的分支\"></p>\n<h2 id=\"【可选】用旧项目的library\"><a href=\"#【可选】用旧项目的library\" class=\"headerlink\" title=\"【可选】用旧项目的library\"></a>【可选】用旧项目的library</h2><blockquote>\n<p>复制原SVN的UNITY目录下的library文件夹，粘贴到已经拉下来的unity目录下。这样重打开项目不用等待太多。</p>\n</blockquote>\n<h2 id=\"如何拉取\"><a href=\"#如何拉取\" class=\"headerlink\" title=\"如何拉取\"></a>如何拉取</h2><p><img src=\"/img/1573881886011.png\" alt=\"如何拉取\"></p>\n<h2 id=\"如何提交\"><a href=\"#如何提交\" class=\"headerlink\" title=\"如何提交\"></a>如何提交</h2><p><img src=\"/img/1573880787198.png\" alt=\"如何提交\"></p>\n"},{"title":"天天生鲜项目实例P1","_content":"\n## 相关背景概念\n\n> B2B, O2O, B2C, C2C..\n\n## 数据库设计\n![enter description here](/img/1573441070020.png)\n\n> 对数据库进行授权\n> ![enter description here](/img/1573442010455.png)\n\n> 使用后台管理\n>![enter description here](/img/1573442404015.png)\n\n\n## 项目搭建\n\n**1.一个模块对应一个APP**\n**2.将所有app归类到一个apps文件夹**\n**3.\\[可选\\]  设置一个系统路径，这样就不用注册APP时添加前缀文件夹**\n\t\n``` python\nsys.path.insert(0, os.path.join(BASE_DIR, 'apps'))\n```\n\n**4.添加templates包和static包**\n>TEMPLATES_DIR = os.path.join(BASE_DIR, 'templates')\n>TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [TEMPLATES_DIR],\n\t\t...\n> STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]\n\n\n**5.添加templates和static路径到setting**\n\n**6.配置数据库为Mysql**\n\n>   'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'dailyfresh',\n        'USER': 'root',\n        'PASSWORD':'bk102435',\n        'HOST':'39.97.170.176',\n        'PORT':3306,\n\t\n**7.设置语言**\n\n```python\nLANGUAGE_CODE = 'zh-hans'\nTIME_ZONE = 'Asia/Shanghai'\n```\n\n**8.配置项目总的urls**\n**9.为各应用创建urls**\n\n**10.数据层准备，创建db包，创建basemodel.py**\n\n**11.\\[可选\\]创建各models 或 链接现有数据库**\n\n> Inpectdb 也可针对某张表：\n> python manage.py inspectdb TableName > output.py\n> 链接： https://www.jianshu.com/p/037bd7e20a7a\n\n**12.指定django认证系统的模型**\n这样superuser的模型表就被指定到自己的user表\n> settings.py中加入 \n> AUTH_USER_MODEL = ‘user.User’\n\n###  13.  可能出现的问题\n不确定是不是使用pymysql导致的，这里会有两个问题\n*  1.现在django使用mysqlclient，而且恶心的是会在启动时自动验证版本号，pymysql最高只到0.9.3。这里根据报错直接那代码注释即可！\n*  2.makemigration出错，提示在django代码里的operations.py中的last_executed_query函数，由于python3与Python2的decode与encode函数区别，这里也需要把.decode..去掉。\n\n\n\n\n## User模块 - 注册\n\n**1.准备views函数**\n* views.py添加相应函数\nregister函数为接收跳转网页, register_handler函数接收处理及逻辑\n\n```python\ndef register():\n\tpass\ndef register_handle():\n\tpass\n```\n\n* urls.py配置对应view函数路径\n\n```python\npath('register',views.register,name='register')\npath('register_handle',views.register_handle,name='register_handle')\n```\n\n\n**2.templates里放入html信息**\n\n* 编辑表单\\<form\\>\n\t添加method,action.\n\t写法升级：\n\n```python\naction=\"{% url 'user:detail' %}\" \n```\n\n旧的写法:\n\n```python\naction = \"/user/register_handle\"\n```\n\n> 注意事项：\n> 1. 网页使用跳转，需要在urls.py中指定name:\n> 如下：所对应的地址段需要设置不同的正则\n> \n> ```python\n> path('add/', calc_views.add, name='add'),  # new\n> path('add/<int:a>/<int:b>/', calc_views.old_add2_redirect,name='add'),\n> ```\n> 2.使用shell, 用reverse测试\n> 地址反射的机制：django.urls reverse\n> 3.定义一个跳转函数来做：\n> \n> ```python\n> urls.py中加入如下：\n>  path('add/<int:a>/<int:b>/', calc_views.old_add2_redirect,name='add'),\n> path('new_add/<int:a>/<int:b>/', calc_views.add2, name='add2'),\n>\n> views.py中加入如下：\n> def old_add2_redirect(request):\n> return HttpResponseRedirect(\n>        reverse('add2', args=(a, b))\n>    )\n> 测试网址： http://127.0.0.1:8000/add/5/6/ \n> 这时最终就将跳到美术http://127.0.0.1:8000/new_add/5/6/\n> ```\n\n\n\t\n**3.使用类视图**\n\n> 1.优化去register_handle函数，使用get/post判断实现不同的跳转类型\n> 2.基于1的优化，使用类视图方式加载\n\n```python\nfrom django.views.generic import View\n\nclass RegisterView(View):\n\n    def get(self, request):\n        pass\n\n    def post(self, request):\n\t\tpass\n```\n\n**3.激活用户**\n\n1. 使用itsdangerous为网址进行加密签名\n2. 调用django.core.mail 的send_mail来发送邮件，把链接成文本发送过去\n\n```python\nfrom django.conf import settings\nfrom django.core.mail import send_mail\nimport time\n\ndef send_register_active_email(to_email, username, token):\n    '''send active email'''\n    subject = \"天天生鲜欢迎消息\"\n    message = \"\"\n    sender = settings.DEFAULT_FROM_EMAIL\n    receiver = [to_email]\n    html_message = \"<h1>%s, 欢迎你</h1>请点击下面链接激活<br/><a href=\\\"http://127.0.0.1:8000/user/active/%s\\\">http://127.0.0.1:8000/user/active/%s</a>\" % (\n    username, token, token)\n    send_mail(subject, message, sender, receiver, html_message=html_message)\n    time.sleep(5)\n```\n>也可使用Python的发email库\n\n>```python\n>  def active_email(self, email_addr, active_code):\n>      # 第三方 SMTP 服务 # 授权码：cmatkgceuuxcbddc\n>      mail_host = \"smtp.qq.com\"  # 设置服务器\n>      mail_user = \"1024037035@qq.com\"  # 用户名\n>      mail_pass = \"cmatkgceuuxcbddc\"  # 口令\n>      sender = '1024037035@qq.com'\n>      receivers = [email_addr]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱\n >       # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码\n>      try:\n>          smtp_obj = smtplib.SMTP()\n>          smtp_obj.connect(mail_host, 25)  # 25 为 SMTP 端口号\n>          smtp_obj.login(mail_user, mail_pass)\n>          smtp_obj.sendmail(sender, receivers, message.as_string())\n>          return True\n>          \"邮件发送成功\"\n>      except smtplib.SMTPException:\n >           return False\n>            \"Error: 无法发送邮件\"\n>```\n\n3. 在Url中配置激活的功能\n\n```python\npath('active/<token>',ActiveView.as_view(), name='active'),\n```\n\n4. 在views.py中写一个ActiveView的视图来处理激活\n \n```python\nclass ActiveView(View):\n    def get(self, request, token):\n        try:\n            serializer = Serializer(settings.SECRET_KEY, 3600)\n            # print(type(token))\n            token = token.encode()\n            info = serializer.loads(token)\n            user_id = info['confirm']\n            user = User.objects.get(id=user_id)\n            user.is_active = 1\n            user.save()\n\n            # 跳转到登陆页面\n            return redirect(reverse('user:login'))\n        except SignatureExpired as e:\n            # 激活链接过期\n            return HttpResponse('激活链接已过期')\n```\n\n\n**4.使用celery做为异步处理**\n\n![enter description here](/img/1574171584470.png)\n\n1.配置一个项目目录为：celery_tasks/tasks.py的文件\n2.在tasks.py写入配置如 \n\n```python\n# use celery\nfrom celery import Celery\n# create celery instance\napp = Celery('celery_tasks.tasks', broker='redis://:pwd@39.97.170.176:6379/8')\n\n# define task function\n@app.task\ndef send_register_active_email(to_email, username, token):\n\tpass\n```\n3.执行的脚本函数里写入：\n\n```python\n        # 发送邮件1\n        send_register_active_email.delay(email, username, secret_info)\n```\n\n4.在有redis的电脑上\n\n* 复制项目代码\n* 在tasks.py中加入初始化django的代码\n* \n```python\nimport os\nimport django\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dailyfresh.settings')\ndjango.setup()\n```\n* 启动worker\n\n```\ncelery -A celery_tasks.tasks worker -l info\n```\n* 启动redis , 大功告成，测试\n\n> 可能出现的问题\n> 在windows系统中：\n>  使用这种方式来启动worker: pip install eventlet -> celery -A your_app_name worker --pool=eventlet\n>  或： celery -A your_app_name worker --pool=solo -l info\n>  或：\n>  at worker side:\nset FORKED_BY_MULTIPROCESSING = 1\nthen\ncelery -A myworker worker --loglevel=info\n\n## User模块 - 登录\n\n**LoginView，使用自带的授权**\n\n授权，如果成功则会返回user对象：：\n\n```\nuser = authenticate(username=username, password=pwd)\n```\n\n登录：\n\n```python\nlogin(request, user)\n```\n\n添加URL及表单部分，参考注册流程\n\n**为减少数据库操作，使用redis存储**\n\n1.安装 django-redis\n2.settings加入如下配置即可：\n\n```python\n#Django 缓存配置\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379/9\", #服务器地址\n        \"OPTIONS\": {\n            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",\n            \"CONNECTION_POOL_KWARGS\": {\"max_connections\": 100}, # 最大连接数\n            \"PASSWORD\": \"bk102435\",\n        }\n    }\n}\n#配置session存储\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'\nSESSION_CACHE_ALIAS = 'default'\n```\n\n**把用户名记在cookie**\n\n1.登录成功时，把username字段存在cookie中\n\n```python\nresponse = redirect(reverse('goods:index'))\nremember = request.POST.get('remember')\n\nif remember == 'on':\n\tresponse.set_cookie('username', username, max_age=7*24*3600)\nelse:\n\tresponse.delete_cookie('username')\n```\n\n2.get方法中取出cookie数据\n\n```\nif 'username' in request.COOKIES:\n\tusername = request.COOKIES.get('username')\n\tchecked = 'checked'\nelse:\n\tusername = ''\n\tchecked = ''\nreturn render(request, 'login.html', {'username':username, 'checked':checked})\n```\n## User 模块 - 用户中心\n\n**从模板网页中抽象**\n\n1. 将共同部分放在一个html， 不同部分使用{% block body%}{% endblock %}\n\nbase_user_center.html:\n\n![enter description here](/img/1574937645193.png)\n\n2.在对应的功能页面继承\n\n![enter description here](/img/1574937788143.png)\n\n**使用if 做功能块显示隐藏**\n\n如上方的：\n\n![enter description here](/img/1574937430699.png)\n\n**使用官方提供的授权管理**\n\n有些页面需要登录后才能显示，如这里的用户中心页\n使用django的login_required装饰器来做\n\nhttps://docs.djangoproject.com/en/2.2/topics/auth/default/\n\n1. 当用户已登录过，将直接跳转至所需页面\n2. 当未登录，将默认跳转至/accounts/login/?next=/polls/3/.\n3. login_url可在settings.LOGIN_URL中配置 或login_url参数中配置\n4. next可在redirect_field_name参数中配置\n\n```python\nfrom django.contrib.auth.decorators import login_required\n\n@login_required(login_url='/accounts/login/')\ndef my_view(request):\n```\n\n5. 处理用户通过非登录界面过来的\n```python\n  # 处理通过跳转的请求值#\n                # 设置下一步自动跳转 #\n                next_url = request.GET.get('next', reverse('goods:index'))\n                response = redirect(reverse(next_url))\n```\n\n> 注意：需要将form表单的action设成无action，这样提交的内容将按当前内容来指定！\n\n\n6.使用Mixin优化写法\n\n* 新建utils文件夹，新建一个LoginRequireMixin类\n\n```python\nclass LoginRequiredMixin(object):\n    @classmethod\n    def as_view(cls, **initkwargs):\n        view = super(LoginRequiredMixin, cls).as_view(**initkwargs)\n        return login_required(view)\n```\n\n在所有view函数中继承\n\n```python\nclass AddressView(LoginRequiredMixin, View):\n\tpass\n```\n> Mixin的原理是，执行一个子类没有的函数，Python继承规则是第一个父类先找，找到cls所代表的类的父类，再调用其as_view\n> super(A,cls) 找到A的父类，并将cls转成父类对象！\n\n**使用官方提供的是否登录标识**\n\n\n```python\nif request.user.is_authenticated:\n    # Do something for authenticated users.\n    ...\nelse:\n    # Do something for anonymous users.\n    ...\n```\n因此在html中加入如下代码：\n\n![enter description here](/img/1574937768754.png)\n\n\n**使用官方提供的退出登录**\n\nlogout函数\n\n```html\n<a href=\"{% url 'user:logout' %}\">退出</a>\n```\n\n```python\nclass LogoutView(View):\n    def get(self, request):\n        logout(request)\n        return redirect(reverse('goods:index'))\n```\n\n**实现地址页的功能**\n\n>1.使用request.user拿到user对象\n>2.Address.objects.create/get 来操作数据库\n>3.post请求中收到后再进行操作\n>4.Post请求完毕后，在get请求中再取数据库的地址来到html\n>5.显示get请求的结果到html\n\n**抽象Model里的管理器**\n\nmodel.py里：\n\n需要继承manager\n```python\nclass AddressManager(models.Manager):\n    '''自定义模型管理器'''\n    def get_default_address(self, user):\n        #self.model: 获取self对象所在模型类\n        try:\n            address = self.get(user=user, is_default=True)\n        except self.DoesNotExist as e:\n            address = None\n        return address\n\t\t\nclass Address(BaseModel):\n    \"\"\"地址模型类\"\"\"\n    pass\n    # 在这里使用定义的管理器\n    objects = AddressManager()\n```\n\n\n> 需要使用Address.objects.get_default_address来调用。这样传入self\n\n**用户中心的历史记录显示**\n\n![enter description here](/img/1575029000281.png)\n\n参考redis资料\nhttps://django-redis-chs.readthedocs.io/zh_CN/latest/#\n1. 获取StrictRedis对象\n\t一般做法：\n\t\n\t```python\n\tfrom redis import StrictRedis\n\tsr = StrictRedis(host='127.0.0.1', port='6379', db=9)\n\t```\n\t\n\t但可以使用原生端的使用方式：\n\t\n\t```python\n\tfrom django_redis import get_redis_connection\n\tcon = get_redis_connection(\"default\")\n\t```\n2. 获取redis数据并返回界面\n\n```python\n  #获取redis数据连接\n        con = get_redis_connection(\"default\")\n        #获取数据\n        history_key = 'history_%id'%user.id\n        #拿前五个\n        sku_ids = con.lrange(history_key, 0, 4)\n```\n\n\n```python\n def get(self, request):\n        user = request.user\n        address = Address.objects.get_default_address(user)\n\n        #获取redis数据连接\n        con = get_redis_connection(\"default\")\n        #获取数据\n        history_key = 'history_%id'%user.id\n        #拿前五个\n        sku_ids = con.lrange(history_key, 0, 4)\n        #获取此ID内的物体\n        # goods_li = GoodsSKU.objects.filter(id__in=sku_ids)\n        goods_li = []\n        for id in sku_ids:\n            goods = GoodsSKU.objects.get(id=id)\n            goods_li.append(goods)\n        #数据组装\n        context = {'page': 'user',\n                   'address': address,\n                   'goods_li':goods_li}\n\n        return render(request, 'user_center_info.html', context)\n```\n\n3.在Html中配置数据，显示使用for goods, 和empty表示\n\n![enter description here](/img/1575033223646.png)\n\n\n## 分布式FastDFS文件系统\n\n![enter description here](/img/1575033366217.png)\n\n\n客户端先发请求到Tracker服务器，服务器将返回一个Storage服务器地址，客户端再上传到此Storage服务器\n\n![enter description here](/img/1575033456146.png)\n\n\n电商网站的图片数据一般不放在Django服务器，以防服务器存储器爆掉\n![enter description here](/img/1575034858096.png)\n\nFastDFS 采用hash值标识存储文件\n\n**文件上传**\n\n![enter description here](/img/1575035108391.png)\n![enter description here](/img/1575035161292.png)\n\n**文件下载**\n\n![enter description here](/img/1575035213445.png) \n\n![enter description here](/img/1575035246421.png)\n\n**安装配置**\n\n![安装](/img/1575290159935.png)\n\n![服务器配置](/img/1575290242736.png)\n\n![服务器配置](/img/1575290266752.png)\n\n![启动](/img/1575290288546.png)\n\n![安装Nginx](/img/1575290314506.png)\n\n\n**结合nginx使用，提高多人访问的效率**\n\n获取文件需要借助nginx来获取静态文件。\n\n![安装Nginx](/img/1575290314506.png)\n\n![fastdfs-nginx](/img/1575603749178.png)\n\n注： 是conf目录\n![连接fadfs与nginx](/img/1575634128185.png)\n\n![http server配置](/img/1575634466665.png)\n\n![server配置](/img/1575635246200.png)\n\n![启动](/img/1575635485238.png)\n\n上传测试: windows电脑下：\n1. 去github下下载zip，解压\n2. 把fdfs_client文件夹复制到自己conda环境下\n3. 复制远端的client.conf，修改base_path和 网址（一般不用改）\n4. 注释掉fdfs_client.sendfile这句代码在storage_client.py\n5. 写一个Python文件，一定要在自己的conda环境下！\n\n```python\nfrom fdfs_client.client import Fdfs_client\n\nclient = Fdfs_client('F:/Projects/django_env/client.conf')\nret = client.upload_by_filename('timg.jpg')\nprint(ret)\n```\n\n上传成功后：可以使用我们的 http://39.97.170.176:8888/ 做为前缀加上地址来访问图片\n![测试上传](/img/1575640031870.png)\n\n**fdfs工作流程**\n\n![fdfs工作流程](/img/1575981798051.png)\n\n\n**实现fdfs**\n\n* 写一个如下结构：\n![fdfs文件](/img/1575984532516.png)\n* storage.py中继承官方的Storage类并重写方法\n\n```python\nfrom django.core.files.storage import Storage\nfrom fdfs_client.client import Fdfs_client\nfrom django.conf import settings\n\n\nclass FDFSStorage(Storage):\n\n    def __init__(self, client_conf=None, base_url=None):\n        if client_conf is None:\n            client_conf = settings.FDFS_CLIENT_CONF\n        self.client_conf = client_conf\n\n        if base_url is None:\n            base_url = settings.FDFS_URL\n        self.base_url = base_url\n\n    def _open(self, name, mode='rb'):\n        pass\n\n    def _save(self, name, content):\n        client = Fdfs_client(self.client_conf)\n\n        # 上传文件内容\n        res = client.upload_by_buffer(content.read())\n        # return dict\n        # {\n        #     'Group name': group_name,\n        #     'Remote file_id': remote_file_id,\n        #     'Status': 'Upload successed.',\n        #     'Local file name': '',\n        #     'Uploaded size': upload_size,\n        #     'Storage IP': storage_ip\n        # } if success else None\n\n        if res.get('Status') !=  'Upload successed.':\n            # 上传失败\n            raise Exception('上传文件到DFS失败')\n\n        # 获取返回的文件ID\n        filename = res.get('Remote file_id')\n\n        # 返回文件ID\n        return filename\n\n    def exists(self, name):\n        return False\n\n\n    def url(self, name):\n        '''返回文件url'''\n        return self.base_url+name\n\n```\n\n* 最后在settings中加入\n\n```python\n#配置文件存储器\nDEFAULT_FILE_STORAGE = 'utils.fdfs.storage.FDFSStorage'\n\n#设置fdfs 的client.conf文件路径\nFDFS_CLIENT_CONF='./utils/fdfs/client.conf'\n\n#FDFS服务器地址\nFDFS_URL='http://39.97.170.176:8888/'\n```\n\n**总结**\n\n使用fdfs好处：\n1. 海量存储，存储内容易扩展\n2. 解决文件内容重复\n3. 结合nginx，提高网站提供图片的效率\n","source":"_posts/天天生鲜项目实例.md","raw":"---\ntitle: 天天生鲜项目实例P1\ncategories:\n- Python\ntags: \n- Python\n- Note\n- Django\n- 实例\n---\n\n## 相关背景概念\n\n> B2B, O2O, B2C, C2C..\n\n## 数据库设计\n![enter description here](/img/1573441070020.png)\n\n> 对数据库进行授权\n> ![enter description here](/img/1573442010455.png)\n\n> 使用后台管理\n>![enter description here](/img/1573442404015.png)\n\n\n## 项目搭建\n\n**1.一个模块对应一个APP**\n**2.将所有app归类到一个apps文件夹**\n**3.\\[可选\\]  设置一个系统路径，这样就不用注册APP时添加前缀文件夹**\n\t\n``` python\nsys.path.insert(0, os.path.join(BASE_DIR, 'apps'))\n```\n\n**4.添加templates包和static包**\n>TEMPLATES_DIR = os.path.join(BASE_DIR, 'templates')\n>TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [TEMPLATES_DIR],\n\t\t...\n> STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]\n\n\n**5.添加templates和static路径到setting**\n\n**6.配置数据库为Mysql**\n\n>   'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'dailyfresh',\n        'USER': 'root',\n        'PASSWORD':'bk102435',\n        'HOST':'39.97.170.176',\n        'PORT':3306,\n\t\n**7.设置语言**\n\n```python\nLANGUAGE_CODE = 'zh-hans'\nTIME_ZONE = 'Asia/Shanghai'\n```\n\n**8.配置项目总的urls**\n**9.为各应用创建urls**\n\n**10.数据层准备，创建db包，创建basemodel.py**\n\n**11.\\[可选\\]创建各models 或 链接现有数据库**\n\n> Inpectdb 也可针对某张表：\n> python manage.py inspectdb TableName > output.py\n> 链接： https://www.jianshu.com/p/037bd7e20a7a\n\n**12.指定django认证系统的模型**\n这样superuser的模型表就被指定到自己的user表\n> settings.py中加入 \n> AUTH_USER_MODEL = ‘user.User’\n\n###  13.  可能出现的问题\n不确定是不是使用pymysql导致的，这里会有两个问题\n*  1.现在django使用mysqlclient，而且恶心的是会在启动时自动验证版本号，pymysql最高只到0.9.3。这里根据报错直接那代码注释即可！\n*  2.makemigration出错，提示在django代码里的operations.py中的last_executed_query函数，由于python3与Python2的decode与encode函数区别，这里也需要把.decode..去掉。\n\n\n\n\n## User模块 - 注册\n\n**1.准备views函数**\n* views.py添加相应函数\nregister函数为接收跳转网页, register_handler函数接收处理及逻辑\n\n```python\ndef register():\n\tpass\ndef register_handle():\n\tpass\n```\n\n* urls.py配置对应view函数路径\n\n```python\npath('register',views.register,name='register')\npath('register_handle',views.register_handle,name='register_handle')\n```\n\n\n**2.templates里放入html信息**\n\n* 编辑表单\\<form\\>\n\t添加method,action.\n\t写法升级：\n\n```python\naction=\"{% url 'user:detail' %}\" \n```\n\n旧的写法:\n\n```python\naction = \"/user/register_handle\"\n```\n\n> 注意事项：\n> 1. 网页使用跳转，需要在urls.py中指定name:\n> 如下：所对应的地址段需要设置不同的正则\n> \n> ```python\n> path('add/', calc_views.add, name='add'),  # new\n> path('add/<int:a>/<int:b>/', calc_views.old_add2_redirect,name='add'),\n> ```\n> 2.使用shell, 用reverse测试\n> 地址反射的机制：django.urls reverse\n> 3.定义一个跳转函数来做：\n> \n> ```python\n> urls.py中加入如下：\n>  path('add/<int:a>/<int:b>/', calc_views.old_add2_redirect,name='add'),\n> path('new_add/<int:a>/<int:b>/', calc_views.add2, name='add2'),\n>\n> views.py中加入如下：\n> def old_add2_redirect(request):\n> return HttpResponseRedirect(\n>        reverse('add2', args=(a, b))\n>    )\n> 测试网址： http://127.0.0.1:8000/add/5/6/ \n> 这时最终就将跳到美术http://127.0.0.1:8000/new_add/5/6/\n> ```\n\n\n\t\n**3.使用类视图**\n\n> 1.优化去register_handle函数，使用get/post判断实现不同的跳转类型\n> 2.基于1的优化，使用类视图方式加载\n\n```python\nfrom django.views.generic import View\n\nclass RegisterView(View):\n\n    def get(self, request):\n        pass\n\n    def post(self, request):\n\t\tpass\n```\n\n**3.激活用户**\n\n1. 使用itsdangerous为网址进行加密签名\n2. 调用django.core.mail 的send_mail来发送邮件，把链接成文本发送过去\n\n```python\nfrom django.conf import settings\nfrom django.core.mail import send_mail\nimport time\n\ndef send_register_active_email(to_email, username, token):\n    '''send active email'''\n    subject = \"天天生鲜欢迎消息\"\n    message = \"\"\n    sender = settings.DEFAULT_FROM_EMAIL\n    receiver = [to_email]\n    html_message = \"<h1>%s, 欢迎你</h1>请点击下面链接激活<br/><a href=\\\"http://127.0.0.1:8000/user/active/%s\\\">http://127.0.0.1:8000/user/active/%s</a>\" % (\n    username, token, token)\n    send_mail(subject, message, sender, receiver, html_message=html_message)\n    time.sleep(5)\n```\n>也可使用Python的发email库\n\n>```python\n>  def active_email(self, email_addr, active_code):\n>      # 第三方 SMTP 服务 # 授权码：cmatkgceuuxcbddc\n>      mail_host = \"smtp.qq.com\"  # 设置服务器\n>      mail_user = \"1024037035@qq.com\"  # 用户名\n>      mail_pass = \"cmatkgceuuxcbddc\"  # 口令\n>      sender = '1024037035@qq.com'\n>      receivers = [email_addr]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱\n >       # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码\n>      try:\n>          smtp_obj = smtplib.SMTP()\n>          smtp_obj.connect(mail_host, 25)  # 25 为 SMTP 端口号\n>          smtp_obj.login(mail_user, mail_pass)\n>          smtp_obj.sendmail(sender, receivers, message.as_string())\n>          return True\n>          \"邮件发送成功\"\n>      except smtplib.SMTPException:\n >           return False\n>            \"Error: 无法发送邮件\"\n>```\n\n3. 在Url中配置激活的功能\n\n```python\npath('active/<token>',ActiveView.as_view(), name='active'),\n```\n\n4. 在views.py中写一个ActiveView的视图来处理激活\n \n```python\nclass ActiveView(View):\n    def get(self, request, token):\n        try:\n            serializer = Serializer(settings.SECRET_KEY, 3600)\n            # print(type(token))\n            token = token.encode()\n            info = serializer.loads(token)\n            user_id = info['confirm']\n            user = User.objects.get(id=user_id)\n            user.is_active = 1\n            user.save()\n\n            # 跳转到登陆页面\n            return redirect(reverse('user:login'))\n        except SignatureExpired as e:\n            # 激活链接过期\n            return HttpResponse('激活链接已过期')\n```\n\n\n**4.使用celery做为异步处理**\n\n![enter description here](/img/1574171584470.png)\n\n1.配置一个项目目录为：celery_tasks/tasks.py的文件\n2.在tasks.py写入配置如 \n\n```python\n# use celery\nfrom celery import Celery\n# create celery instance\napp = Celery('celery_tasks.tasks', broker='redis://:pwd@39.97.170.176:6379/8')\n\n# define task function\n@app.task\ndef send_register_active_email(to_email, username, token):\n\tpass\n```\n3.执行的脚本函数里写入：\n\n```python\n        # 发送邮件1\n        send_register_active_email.delay(email, username, secret_info)\n```\n\n4.在有redis的电脑上\n\n* 复制项目代码\n* 在tasks.py中加入初始化django的代码\n* \n```python\nimport os\nimport django\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dailyfresh.settings')\ndjango.setup()\n```\n* 启动worker\n\n```\ncelery -A celery_tasks.tasks worker -l info\n```\n* 启动redis , 大功告成，测试\n\n> 可能出现的问题\n> 在windows系统中：\n>  使用这种方式来启动worker: pip install eventlet -> celery -A your_app_name worker --pool=eventlet\n>  或： celery -A your_app_name worker --pool=solo -l info\n>  或：\n>  at worker side:\nset FORKED_BY_MULTIPROCESSING = 1\nthen\ncelery -A myworker worker --loglevel=info\n\n## User模块 - 登录\n\n**LoginView，使用自带的授权**\n\n授权，如果成功则会返回user对象：：\n\n```\nuser = authenticate(username=username, password=pwd)\n```\n\n登录：\n\n```python\nlogin(request, user)\n```\n\n添加URL及表单部分，参考注册流程\n\n**为减少数据库操作，使用redis存储**\n\n1.安装 django-redis\n2.settings加入如下配置即可：\n\n```python\n#Django 缓存配置\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379/9\", #服务器地址\n        \"OPTIONS\": {\n            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",\n            \"CONNECTION_POOL_KWARGS\": {\"max_connections\": 100}, # 最大连接数\n            \"PASSWORD\": \"bk102435\",\n        }\n    }\n}\n#配置session存储\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'\nSESSION_CACHE_ALIAS = 'default'\n```\n\n**把用户名记在cookie**\n\n1.登录成功时，把username字段存在cookie中\n\n```python\nresponse = redirect(reverse('goods:index'))\nremember = request.POST.get('remember')\n\nif remember == 'on':\n\tresponse.set_cookie('username', username, max_age=7*24*3600)\nelse:\n\tresponse.delete_cookie('username')\n```\n\n2.get方法中取出cookie数据\n\n```\nif 'username' in request.COOKIES:\n\tusername = request.COOKIES.get('username')\n\tchecked = 'checked'\nelse:\n\tusername = ''\n\tchecked = ''\nreturn render(request, 'login.html', {'username':username, 'checked':checked})\n```\n## User 模块 - 用户中心\n\n**从模板网页中抽象**\n\n1. 将共同部分放在一个html， 不同部分使用{% block body%}{% endblock %}\n\nbase_user_center.html:\n\n![enter description here](/img/1574937645193.png)\n\n2.在对应的功能页面继承\n\n![enter description here](/img/1574937788143.png)\n\n**使用if 做功能块显示隐藏**\n\n如上方的：\n\n![enter description here](/img/1574937430699.png)\n\n**使用官方提供的授权管理**\n\n有些页面需要登录后才能显示，如这里的用户中心页\n使用django的login_required装饰器来做\n\nhttps://docs.djangoproject.com/en/2.2/topics/auth/default/\n\n1. 当用户已登录过，将直接跳转至所需页面\n2. 当未登录，将默认跳转至/accounts/login/?next=/polls/3/.\n3. login_url可在settings.LOGIN_URL中配置 或login_url参数中配置\n4. next可在redirect_field_name参数中配置\n\n```python\nfrom django.contrib.auth.decorators import login_required\n\n@login_required(login_url='/accounts/login/')\ndef my_view(request):\n```\n\n5. 处理用户通过非登录界面过来的\n```python\n  # 处理通过跳转的请求值#\n                # 设置下一步自动跳转 #\n                next_url = request.GET.get('next', reverse('goods:index'))\n                response = redirect(reverse(next_url))\n```\n\n> 注意：需要将form表单的action设成无action，这样提交的内容将按当前内容来指定！\n\n\n6.使用Mixin优化写法\n\n* 新建utils文件夹，新建一个LoginRequireMixin类\n\n```python\nclass LoginRequiredMixin(object):\n    @classmethod\n    def as_view(cls, **initkwargs):\n        view = super(LoginRequiredMixin, cls).as_view(**initkwargs)\n        return login_required(view)\n```\n\n在所有view函数中继承\n\n```python\nclass AddressView(LoginRequiredMixin, View):\n\tpass\n```\n> Mixin的原理是，执行一个子类没有的函数，Python继承规则是第一个父类先找，找到cls所代表的类的父类，再调用其as_view\n> super(A,cls) 找到A的父类，并将cls转成父类对象！\n\n**使用官方提供的是否登录标识**\n\n\n```python\nif request.user.is_authenticated:\n    # Do something for authenticated users.\n    ...\nelse:\n    # Do something for anonymous users.\n    ...\n```\n因此在html中加入如下代码：\n\n![enter description here](/img/1574937768754.png)\n\n\n**使用官方提供的退出登录**\n\nlogout函数\n\n```html\n<a href=\"{% url 'user:logout' %}\">退出</a>\n```\n\n```python\nclass LogoutView(View):\n    def get(self, request):\n        logout(request)\n        return redirect(reverse('goods:index'))\n```\n\n**实现地址页的功能**\n\n>1.使用request.user拿到user对象\n>2.Address.objects.create/get 来操作数据库\n>3.post请求中收到后再进行操作\n>4.Post请求完毕后，在get请求中再取数据库的地址来到html\n>5.显示get请求的结果到html\n\n**抽象Model里的管理器**\n\nmodel.py里：\n\n需要继承manager\n```python\nclass AddressManager(models.Manager):\n    '''自定义模型管理器'''\n    def get_default_address(self, user):\n        #self.model: 获取self对象所在模型类\n        try:\n            address = self.get(user=user, is_default=True)\n        except self.DoesNotExist as e:\n            address = None\n        return address\n\t\t\nclass Address(BaseModel):\n    \"\"\"地址模型类\"\"\"\n    pass\n    # 在这里使用定义的管理器\n    objects = AddressManager()\n```\n\n\n> 需要使用Address.objects.get_default_address来调用。这样传入self\n\n**用户中心的历史记录显示**\n\n![enter description here](/img/1575029000281.png)\n\n参考redis资料\nhttps://django-redis-chs.readthedocs.io/zh_CN/latest/#\n1. 获取StrictRedis对象\n\t一般做法：\n\t\n\t```python\n\tfrom redis import StrictRedis\n\tsr = StrictRedis(host='127.0.0.1', port='6379', db=9)\n\t```\n\t\n\t但可以使用原生端的使用方式：\n\t\n\t```python\n\tfrom django_redis import get_redis_connection\n\tcon = get_redis_connection(\"default\")\n\t```\n2. 获取redis数据并返回界面\n\n```python\n  #获取redis数据连接\n        con = get_redis_connection(\"default\")\n        #获取数据\n        history_key = 'history_%id'%user.id\n        #拿前五个\n        sku_ids = con.lrange(history_key, 0, 4)\n```\n\n\n```python\n def get(self, request):\n        user = request.user\n        address = Address.objects.get_default_address(user)\n\n        #获取redis数据连接\n        con = get_redis_connection(\"default\")\n        #获取数据\n        history_key = 'history_%id'%user.id\n        #拿前五个\n        sku_ids = con.lrange(history_key, 0, 4)\n        #获取此ID内的物体\n        # goods_li = GoodsSKU.objects.filter(id__in=sku_ids)\n        goods_li = []\n        for id in sku_ids:\n            goods = GoodsSKU.objects.get(id=id)\n            goods_li.append(goods)\n        #数据组装\n        context = {'page': 'user',\n                   'address': address,\n                   'goods_li':goods_li}\n\n        return render(request, 'user_center_info.html', context)\n```\n\n3.在Html中配置数据，显示使用for goods, 和empty表示\n\n![enter description here](/img/1575033223646.png)\n\n\n## 分布式FastDFS文件系统\n\n![enter description here](/img/1575033366217.png)\n\n\n客户端先发请求到Tracker服务器，服务器将返回一个Storage服务器地址，客户端再上传到此Storage服务器\n\n![enter description here](/img/1575033456146.png)\n\n\n电商网站的图片数据一般不放在Django服务器，以防服务器存储器爆掉\n![enter description here](/img/1575034858096.png)\n\nFastDFS 采用hash值标识存储文件\n\n**文件上传**\n\n![enter description here](/img/1575035108391.png)\n![enter description here](/img/1575035161292.png)\n\n**文件下载**\n\n![enter description here](/img/1575035213445.png) \n\n![enter description here](/img/1575035246421.png)\n\n**安装配置**\n\n![安装](/img/1575290159935.png)\n\n![服务器配置](/img/1575290242736.png)\n\n![服务器配置](/img/1575290266752.png)\n\n![启动](/img/1575290288546.png)\n\n![安装Nginx](/img/1575290314506.png)\n\n\n**结合nginx使用，提高多人访问的效率**\n\n获取文件需要借助nginx来获取静态文件。\n\n![安装Nginx](/img/1575290314506.png)\n\n![fastdfs-nginx](/img/1575603749178.png)\n\n注： 是conf目录\n![连接fadfs与nginx](/img/1575634128185.png)\n\n![http server配置](/img/1575634466665.png)\n\n![server配置](/img/1575635246200.png)\n\n![启动](/img/1575635485238.png)\n\n上传测试: windows电脑下：\n1. 去github下下载zip，解压\n2. 把fdfs_client文件夹复制到自己conda环境下\n3. 复制远端的client.conf，修改base_path和 网址（一般不用改）\n4. 注释掉fdfs_client.sendfile这句代码在storage_client.py\n5. 写一个Python文件，一定要在自己的conda环境下！\n\n```python\nfrom fdfs_client.client import Fdfs_client\n\nclient = Fdfs_client('F:/Projects/django_env/client.conf')\nret = client.upload_by_filename('timg.jpg')\nprint(ret)\n```\n\n上传成功后：可以使用我们的 http://39.97.170.176:8888/ 做为前缀加上地址来访问图片\n![测试上传](/img/1575640031870.png)\n\n**fdfs工作流程**\n\n![fdfs工作流程](/img/1575981798051.png)\n\n\n**实现fdfs**\n\n* 写一个如下结构：\n![fdfs文件](/img/1575984532516.png)\n* storage.py中继承官方的Storage类并重写方法\n\n```python\nfrom django.core.files.storage import Storage\nfrom fdfs_client.client import Fdfs_client\nfrom django.conf import settings\n\n\nclass FDFSStorage(Storage):\n\n    def __init__(self, client_conf=None, base_url=None):\n        if client_conf is None:\n            client_conf = settings.FDFS_CLIENT_CONF\n        self.client_conf = client_conf\n\n        if base_url is None:\n            base_url = settings.FDFS_URL\n        self.base_url = base_url\n\n    def _open(self, name, mode='rb'):\n        pass\n\n    def _save(self, name, content):\n        client = Fdfs_client(self.client_conf)\n\n        # 上传文件内容\n        res = client.upload_by_buffer(content.read())\n        # return dict\n        # {\n        #     'Group name': group_name,\n        #     'Remote file_id': remote_file_id,\n        #     'Status': 'Upload successed.',\n        #     'Local file name': '',\n        #     'Uploaded size': upload_size,\n        #     'Storage IP': storage_ip\n        # } if success else None\n\n        if res.get('Status') !=  'Upload successed.':\n            # 上传失败\n            raise Exception('上传文件到DFS失败')\n\n        # 获取返回的文件ID\n        filename = res.get('Remote file_id')\n\n        # 返回文件ID\n        return filename\n\n    def exists(self, name):\n        return False\n\n\n    def url(self, name):\n        '''返回文件url'''\n        return self.base_url+name\n\n```\n\n* 最后在settings中加入\n\n```python\n#配置文件存储器\nDEFAULT_FILE_STORAGE = 'utils.fdfs.storage.FDFSStorage'\n\n#设置fdfs 的client.conf文件路径\nFDFS_CLIENT_CONF='./utils/fdfs/client.conf'\n\n#FDFS服务器地址\nFDFS_URL='http://39.97.170.176:8888/'\n```\n\n**总结**\n\n使用fdfs好处：\n1. 海量存储，存储内容易扩展\n2. 解决文件内容重复\n3. 结合nginx，提高网站提供图片的效率\n","slug":"天天生鲜项目实例","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh11j003t4wf0ldwwhiez","content":"<h2 id=\"相关背景概念\"><a href=\"#相关背景概念\" class=\"headerlink\" title=\"相关背景概念\"></a>相关背景概念</h2><blockquote>\n<p>B2B, O2O, B2C, C2C..</p>\n</blockquote>\n<h2 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h2><p><img src=\"/img/1573441070020.png\" alt=\"enter description here\"></p>\n<blockquote>\n<p>对数据库进行授权<br><img src=\"/img/1573442010455.png\" alt=\"enter description here\"></p>\n</blockquote>\n<blockquote>\n<p>使用后台管理<br><img src=\"/img/1573442404015.png\" alt=\"enter description here\"></p>\n</blockquote>\n<h2 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h2><p><strong>1.一个模块对应一个APP</strong><br><strong>2.将所有app归类到一个apps文件夹</strong><br><strong>3.[可选]  设置一个系统路径，这样就不用注册APP时添加前缀文件夹</strong></p>\n<pre><code class=\"python\">sys.path.insert(0, os.path.join(BASE_DIR, &#39;apps&#39;))</code></pre>\n<p><strong>4.添加templates包和static包</strong></p>\n<blockquote>\n<p>TEMPLATES_DIR = os.path.join(BASE_DIR, ‘templates’)<br>TEMPLATES = [<br>    {<br>        ‘BACKEND’: ‘django.template.backends.django.DjangoTemplates’,<br>        ‘DIRS’: [TEMPLATES_DIR],<br>        …<br>STATICFILES_DIRS = [os.path.join(BASE_DIR, ‘static’)]</p>\n</blockquote>\n<p><strong>5.添加templates和static路径到setting</strong></p>\n<p><strong>6.配置数据库为Mysql</strong></p>\n<blockquote>\n<p>  ‘ENGINE’: ‘django.db.backends.mysql’,<br>        ‘NAME’: ‘dailyfresh’,<br>        ‘USER’: ‘root’,<br>        ‘PASSWORD’:’bk102435’,<br>        ‘HOST’:’39.97.170.176’,<br>        ‘PORT’:3306,</p>\n</blockquote>\n<p><strong>7.设置语言</strong></p>\n<pre><code class=\"python\">LANGUAGE_CODE = &#39;zh-hans&#39;\nTIME_ZONE = &#39;Asia/Shanghai&#39;</code></pre>\n<p><strong>8.配置项目总的urls</strong><br><strong>9.为各应用创建urls</strong></p>\n<p><strong>10.数据层准备，创建db包，创建basemodel.py</strong></p>\n<p><strong>11.[可选]创建各models 或 链接现有数据库</strong></p>\n<blockquote>\n<p>Inpectdb 也可针对某张表：<br>python manage.py inspectdb TableName &gt; output.py<br>链接： <a href=\"https://www.jianshu.com/p/037bd7e20a7a\">https://www.jianshu.com/p/037bd7e20a7a</a></p>\n</blockquote>\n<p><strong>12.指定django认证系统的模型</strong><br>这样superuser的模型表就被指定到自己的user表</p>\n<blockquote>\n<p>settings.py中加入<br>AUTH_USER_MODEL = ‘user.User’</p>\n</blockquote>\n<h3 id=\"13-可能出现的问题\"><a href=\"#13-可能出现的问题\" class=\"headerlink\" title=\"13.  可能出现的问题\"></a>13.  可能出现的问题</h3><p>不确定是不是使用pymysql导致的，这里会有两个问题</p>\n<ul>\n<li>1.现在django使用mysqlclient，而且恶心的是会在启动时自动验证版本号，pymysql最高只到0.9.3。这里根据报错直接那代码注释即可！</li>\n<li>2.makemigration出错，提示在django代码里的operations.py中的last_executed_query函数，由于python3与Python2的decode与encode函数区别，这里也需要把.decode..去掉。</li>\n</ul>\n<h2 id=\"User模块-注册\"><a href=\"#User模块-注册\" class=\"headerlink\" title=\"User模块 - 注册\"></a>User模块 - 注册</h2><p><strong>1.准备views函数</strong></p>\n<ul>\n<li>views.py添加相应函数<br>register函数为接收跳转网页, register_handler函数接收处理及逻辑</li>\n</ul>\n<pre><code class=\"python\">def register():\n    pass\ndef register_handle():\n    pass</code></pre>\n<ul>\n<li>urls.py配置对应view函数路径</li>\n</ul>\n<pre><code class=\"python\">path(&#39;register&#39;,views.register,name=&#39;register&#39;)\npath(&#39;register_handle&#39;,views.register_handle,name=&#39;register_handle&#39;)</code></pre>\n<p><strong>2.templates里放入html信息</strong></p>\n<ul>\n<li>编辑表单&lt;form&gt;<br>  添加method,action.<br>  写法升级：</li>\n</ul>\n<pre><code class=\"python\">action=&quot;{% url 'user:detail' %}&quot; </code></pre>\n<p>旧的写法:</p>\n<pre><code class=\"python\">action = &quot;/user/register_handle&quot;</code></pre>\n<blockquote>\n<p>注意事项：</p>\n<ol>\n<li>网页使用跳转，需要在urls.py中指定name:<br>如下：所对应的地址段需要设置不同的正则</li>\n</ol>\n<pre><code class=\"python\">path(&#39;add/&#39;, calc_views.add, name=&#39;add&#39;),  # new\npath(&#39;add/&lt;int:a&gt;/&lt;int:b&gt;/&#39;, calc_views.old_add2_redirect,name=&#39;add&#39;),</code></pre>\n<p>2.使用shell, 用reverse测试<br>地址反射的机制：django.urls reverse<br>3.定义一个跳转函数来做：</p>\n<pre><code class=\"python\">urls.py中加入如下：\n path(&#39;add/&lt;int:a&gt;/&lt;int:b&gt;/&#39;, calc_views.old_add2_redirect,name=&#39;add&#39;),\npath(&#39;new_add/&lt;int:a&gt;/&lt;int:b&gt;/&#39;, calc_views.add2, name=&#39;add2&#39;),\n\nviews.py中加入如下：\ndef old_add2_redirect(request):\nreturn HttpResponseRedirect(\n       reverse(&#39;add2&#39;, args=(a, b))\n   )\n测试网址： http://127.0.0.1:8000/add/5/6/ \n这时最终就将跳到美术http://127.0.0.1:8000/new_add/5/6/</code></pre>\n</blockquote>\n<p><strong>3.使用类视图</strong></p>\n<blockquote>\n<p>1.优化去register_handle函数，使用get/post判断实现不同的跳转类型<br>2.基于1的优化，使用类视图方式加载</p>\n</blockquote>\n<pre><code class=\"python\">from django.views.generic import View\n\nclass RegisterView(View):\n\n    def get(self, request):\n        pass\n\n    def post(self, request):\n        pass</code></pre>\n<p><strong>3.激活用户</strong></p>\n<ol>\n<li>使用itsdangerous为网址进行加密签名</li>\n<li>调用django.core.mail 的send_mail来发送邮件，把链接成文本发送过去</li>\n</ol>\n<pre><code class=\"python\">from django.conf import settings\nfrom django.core.mail import send_mail\nimport time\n\ndef send_register_active_email(to_email, username, token):\n    &#39;&#39;&#39;send active email&#39;&#39;&#39;\n    subject = &quot;天天生鲜欢迎消息&quot;\n    message = &quot;&quot;\n    sender = settings.DEFAULT_FROM_EMAIL\n    receiver = [to_email]\n    html_message = &quot;&lt;h1&gt;%s, 欢迎你&lt;/h1&gt;请点击下面链接激活&lt;br/&gt;&lt;a href=\\&quot;http://127.0.0.1:8000/user/active/%s\\&quot;&gt;http://127.0.0.1:8000/user/active/%s&lt;/a&gt;&quot; % (\n    username, token, token)\n    send_mail(subject, message, sender, receiver, html_message=html_message)\n    time.sleep(5)</code></pre>\n<blockquote>\n<p>也可使用Python的发email库</p>\n</blockquote>\n<blockquote>\n<pre><code class=\"python\"> def active_email(self, email_addr, active_code):\n     # 第三方 SMTP 服务 # 授权码：cmatkgceuuxcbddc\n     mail_host = &quot;smtp.qq.com&quot;  # 设置服务器\n     mail_user = &quot;1024037035@qq.com&quot;  # 用户名\n     mail_pass = &quot;cmatkgceuuxcbddc&quot;  # 口令\n     sender = &#39;1024037035@qq.com&#39;\n     receivers = [email_addr]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱\n      # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码\n     try:\n         smtp_obj = smtplib.SMTP()\n         smtp_obj.connect(mail_host, 25)  # 25 为 SMTP 端口号\n         smtp_obj.login(mail_user, mail_pass)\n         smtp_obj.sendmail(sender, receivers, message.as_string())\n         return True\n         &quot;邮件发送成功&quot;\n     except smtplib.SMTPException:\n          return False\n           &quot;Error: 无法发送邮件&quot;</code></pre>\n</blockquote>\n<ol start=\"3\">\n<li>在Url中配置激活的功能</li>\n</ol>\n<pre><code class=\"python\">path(&#39;active/&lt;token&gt;&#39;,ActiveView.as_view(), name=&#39;active&#39;),</code></pre>\n<ol start=\"4\">\n<li>在views.py中写一个ActiveView的视图来处理激活</li>\n</ol>\n<pre><code class=\"python\">class ActiveView(View):\n    def get(self, request, token):\n        try:\n            serializer = Serializer(settings.SECRET_KEY, 3600)\n            # print(type(token))\n            token = token.encode()\n            info = serializer.loads(token)\n            user_id = info[&#39;confirm&#39;]\n            user = User.objects.get(id=user_id)\n            user.is_active = 1\n            user.save()\n\n            # 跳转到登陆页面\n            return redirect(reverse(&#39;user:login&#39;))\n        except SignatureExpired as e:\n            # 激活链接过期\n            return HttpResponse(&#39;激活链接已过期&#39;)</code></pre>\n<p><strong>4.使用celery做为异步处理</strong></p>\n<p><img src=\"/img/1574171584470.png\" alt=\"enter description here\"></p>\n<p>1.配置一个项目目录为：celery_tasks/tasks.py的文件<br>2.在tasks.py写入配置如 </p>\n<pre><code class=\"python\"># use celery\nfrom celery import Celery\n# create celery instance\napp = Celery(&#39;celery_tasks.tasks&#39;, broker=&#39;redis://:pwd@39.97.170.176:6379/8&#39;)\n\n# define task function\n@app.task\ndef send_register_active_email(to_email, username, token):\n    pass</code></pre>\n<p>3.执行的脚本函数里写入：</p>\n<pre><code class=\"python\">        # 发送邮件1\n        send_register_active_email.delay(email, username, secret_info)</code></pre>\n<p>4.在有redis的电脑上</p>\n<ul>\n<li>复制项目代码</li>\n<li>在tasks.py中加入初始化django的代码</li>\n<li><pre><code class=\"python\">import os\nimport django\nfrom django.core.wsgi import get_wsgi_application\n</code></pre>\n</li>\n</ul>\n<p>os.environ.setdefault(‘DJANGO_SETTINGS_MODULE’, ‘dailyfresh.settings’)<br>django.setup()</p>\n<pre><code>* 启动worker\n</code></pre><p>celery -A celery_tasks.tasks worker -l info</p>\n<pre><code>* 启动redis , 大功告成，测试\n\n&gt; 可能出现的问题\n&gt; 在windows系统中：\n&gt;  使用这种方式来启动worker: pip install eventlet -&gt; celery -A your_app_name worker --pool=eventlet\n&gt;  或： celery -A your_app_name worker --pool=solo -l info\n&gt;  或：\n&gt;  at worker side:\nset FORKED_BY_MULTIPROCESSING = 1\nthen\ncelery -A myworker worker --loglevel=info\n\n## User模块 - 登录\n\n**LoginView，使用自带的授权**\n\n授权，如果成功则会返回user对象：：\n</code></pre><p>user = authenticate(username=username, password=pwd)</p>\n<pre><code>\n登录：\n\n```python\nlogin(request, user)</code></pre><p>添加URL及表单部分，参考注册流程</p>\n<p><strong>为减少数据库操作，使用redis存储</strong></p>\n<p>1.安装 django-redis<br>2.settings加入如下配置即可：</p>\n<pre><code class=\"python\">#Django 缓存配置\nCACHES = {\n    &quot;default&quot;: {\n        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,\n        &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/9&quot;, #服务器地址\n        &quot;OPTIONS&quot;: {\n            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,\n            &quot;CONNECTION_POOL_KWARGS&quot;: {&quot;max_connections&quot;: 100}, # 最大连接数\n            &quot;PASSWORD&quot;: &quot;bk102435&quot;,\n        }\n    }\n}\n#配置session存储\nSESSION_ENGINE = &#39;django.contrib.sessions.backends.cache&#39;\nSESSION_CACHE_ALIAS = &#39;default&#39;</code></pre>\n<p><strong>把用户名记在cookie</strong></p>\n<p>1.登录成功时，把username字段存在cookie中</p>\n<pre><code class=\"python\">response = redirect(reverse(&#39;goods:index&#39;))\nremember = request.POST.get(&#39;remember&#39;)\n\nif remember == &#39;on&#39;:\n    response.set_cookie(&#39;username&#39;, username, max_age=7*24*3600)\nelse:\n    response.delete_cookie(&#39;username&#39;)</code></pre>\n<p>2.get方法中取出cookie数据</p>\n<pre><code>if &#39;username&#39; in request.COOKIES:\n    username = request.COOKIES.get(&#39;username&#39;)\n    checked = &#39;checked&#39;\nelse:\n    username = &#39;&#39;\n    checked = &#39;&#39;\nreturn render(request, &#39;login.html&#39;, {&#39;username&#39;:username, &#39;checked&#39;:checked})</code></pre><h2 id=\"User-模块-用户中心\"><a href=\"#User-模块-用户中心\" class=\"headerlink\" title=\"User 模块 - 用户中心\"></a>User 模块 - 用户中心</h2><p><strong>从模板网页中抽象</strong></p>\n<ol>\n<li>将共同部分放在一个html， 不同部分使用</li>\n</ol>\n<p>base_user_center.html:</p>\n<p><img src=\"/img/1574937645193.png\" alt=\"enter description here\"></p>\n<p>2.在对应的功能页面继承</p>\n<p><img src=\"/img/1574937788143.png\" alt=\"enter description here\"></p>\n<p><strong>使用if 做功能块显示隐藏</strong></p>\n<p>如上方的：</p>\n<p><img src=\"/img/1574937430699.png\" alt=\"enter description here\"></p>\n<p><strong>使用官方提供的授权管理</strong></p>\n<p>有些页面需要登录后才能显示，如这里的用户中心页<br>使用django的login_required装饰器来做</p>\n<p><a href=\"https://docs.djangoproject.com/en/2.2/topics/auth/default/\">https://docs.djangoproject.com/en/2.2/topics/auth/default/</a></p>\n<ol>\n<li>当用户已登录过，将直接跳转至所需页面</li>\n<li>当未登录，将默认跳转至/accounts/login/?next=/polls/3/.</li>\n<li>login_url可在settings.LOGIN_URL中配置 或login_url参数中配置</li>\n<li>next可在redirect_field_name参数中配置</li>\n</ol>\n<pre><code class=\"python\">from django.contrib.auth.decorators import login_required\n\n@login_required(login_url=&#39;/accounts/login/&#39;)\ndef my_view(request):</code></pre>\n<ol start=\"5\">\n<li>处理用户通过非登录界面过来的<pre><code class=\"python\"># 处理通过跳转的请求值#\n             # 设置下一步自动跳转 #\n             next_url = request.GET.get(&#39;next&#39;, reverse(&#39;goods:index&#39;))\n             response = redirect(reverse(next_url))</code></pre>\n</li>\n</ol>\n<blockquote>\n<p>注意：需要将form表单的action设成无action，这样提交的内容将按当前内容来指定！</p>\n</blockquote>\n<p>6.使用Mixin优化写法</p>\n<ul>\n<li>新建utils文件夹，新建一个LoginRequireMixin类</li>\n</ul>\n<pre><code class=\"python\">class LoginRequiredMixin(object):\n    @classmethod\n    def as_view(cls, **initkwargs):\n        view = super(LoginRequiredMixin, cls).as_view(**initkwargs)\n        return login_required(view)</code></pre>\n<p>在所有view函数中继承</p>\n<pre><code class=\"python\">class AddressView(LoginRequiredMixin, View):\n    pass</code></pre>\n<blockquote>\n<p>Mixin的原理是，执行一个子类没有的函数，Python继承规则是第一个父类先找，找到cls所代表的类的父类，再调用其as_view<br>super(A,cls) 找到A的父类，并将cls转成父类对象！</p>\n</blockquote>\n<p><strong>使用官方提供的是否登录标识</strong></p>\n<pre><code class=\"python\">if request.user.is_authenticated:\n    # Do something for authenticated users.\n    ...\nelse:\n    # Do something for anonymous users.\n    ...</code></pre>\n<p>因此在html中加入如下代码：</p>\n<p><img src=\"/img/1574937768754.png\" alt=\"enter description here\"></p>\n<p><strong>使用官方提供的退出登录</strong></p>\n<p>logout函数</p>\n<pre><code class=\"html\">&lt;a href=&quot;{% url 'user:logout' %}&quot;&gt;退出&lt;/a&gt;</code></pre>\n<pre><code class=\"python\">class LogoutView(View):\n    def get(self, request):\n        logout(request)\n        return redirect(reverse(&#39;goods:index&#39;))</code></pre>\n<p><strong>实现地址页的功能</strong></p>\n<blockquote>\n<p>1.使用request.user拿到user对象<br>2.Address.objects.create/get 来操作数据库<br>3.post请求中收到后再进行操作<br>4.Post请求完毕后，在get请求中再取数据库的地址来到html<br>5.显示get请求的结果到html</p>\n</blockquote>\n<p><strong>抽象Model里的管理器</strong></p>\n<p>model.py里：</p>\n<p>需要继承manager</p>\n<pre><code class=\"python\">class AddressManager(models.Manager):\n    &#39;&#39;&#39;自定义模型管理器&#39;&#39;&#39;\n    def get_default_address(self, user):\n        #self.model: 获取self对象所在模型类\n        try:\n            address = self.get(user=user, is_default=True)\n        except self.DoesNotExist as e:\n            address = None\n        return address\n\nclass Address(BaseModel):\n    &quot;&quot;&quot;地址模型类&quot;&quot;&quot;\n    pass\n    # 在这里使用定义的管理器\n    objects = AddressManager()</code></pre>\n<blockquote>\n<p>需要使用Address.objects.get_default_address来调用。这样传入self</p>\n</blockquote>\n<p><strong>用户中心的历史记录显示</strong></p>\n<p><img src=\"/img/1575029000281.png\" alt=\"enter description here\"></p>\n<p>参考redis资料<br><a href=\"https://django-redis-chs.readthedocs.io/zh_CN/latest/#\">https://django-redis-chs.readthedocs.io/zh_CN/latest/#</a></p>\n<ol>\n<li><p>获取StrictRedis对象<br> 一般做法：</p>\n<pre><code class=\"python\"> from redis import StrictRedis\n sr = StrictRedis(host=&#39;127.0.0.1&#39;, port=&#39;6379&#39;, db=9)</code></pre>\n<p> 但可以使用原生端的使用方式：</p>\n<pre><code class=\"python\"> from django_redis import get_redis_connection\n con = get_redis_connection(&quot;default&quot;)</code></pre>\n</li>\n<li><p>获取redis数据并返回界面</p>\n</li>\n</ol>\n<pre><code class=\"python\">  #获取redis数据连接\n        con = get_redis_connection(&quot;default&quot;)\n        #获取数据\n        history_key = &#39;history_%id&#39;%user.id\n        #拿前五个\n        sku_ids = con.lrange(history_key, 0, 4)</code></pre>\n<pre><code class=\"python\"> def get(self, request):\n        user = request.user\n        address = Address.objects.get_default_address(user)\n\n        #获取redis数据连接\n        con = get_redis_connection(&quot;default&quot;)\n        #获取数据\n        history_key = &#39;history_%id&#39;%user.id\n        #拿前五个\n        sku_ids = con.lrange(history_key, 0, 4)\n        #获取此ID内的物体\n        # goods_li = GoodsSKU.objects.filter(id__in=sku_ids)\n        goods_li = []\n        for id in sku_ids:\n            goods = GoodsSKU.objects.get(id=id)\n            goods_li.append(goods)\n        #数据组装\n        context = {&#39;page&#39;: &#39;user&#39;,\n                   &#39;address&#39;: address,\n                   &#39;goods_li&#39;:goods_li}\n\n        return render(request, &#39;user_center_info.html&#39;, context)</code></pre>\n<p>3.在Html中配置数据，显示使用for goods, 和empty表示</p>\n<p><img src=\"/img/1575033223646.png\" alt=\"enter description here\"></p>\n<h2 id=\"分布式FastDFS文件系统\"><a href=\"#分布式FastDFS文件系统\" class=\"headerlink\" title=\"分布式FastDFS文件系统\"></a>分布式FastDFS文件系统</h2><p><img src=\"/img/1575033366217.png\" alt=\"enter description here\"></p>\n<p>客户端先发请求到Tracker服务器，服务器将返回一个Storage服务器地址，客户端再上传到此Storage服务器</p>\n<p><img src=\"/img/1575033456146.png\" alt=\"enter description here\"></p>\n<p>电商网站的图片数据一般不放在Django服务器，以防服务器存储器爆掉<br><img src=\"/img/1575034858096.png\" alt=\"enter description here\"></p>\n<p>FastDFS 采用hash值标识存储文件</p>\n<p><strong>文件上传</strong></p>\n<p><img src=\"/img/1575035108391.png\" alt=\"enter description here\"><br><img src=\"/img/1575035161292.png\" alt=\"enter description here\"></p>\n<p><strong>文件下载</strong></p>\n<p><img src=\"/img/1575035213445.png\" alt=\"enter description here\"> </p>\n<p><img src=\"/img/1575035246421.png\" alt=\"enter description here\"></p>\n<p><strong>安装配置</strong></p>\n<p><img src=\"/img/1575290159935.png\" alt=\"安装\"></p>\n<p><img src=\"/img/1575290242736.png\" alt=\"服务器配置\"></p>\n<p><img src=\"/img/1575290266752.png\" alt=\"服务器配置\"></p>\n<p><img src=\"/img/1575290288546.png\" alt=\"启动\"></p>\n<p><img src=\"/img/1575290314506.png\" alt=\"安装Nginx\"></p>\n<p><strong>结合nginx使用，提高多人访问的效率</strong></p>\n<p>获取文件需要借助nginx来获取静态文件。</p>\n<p><img src=\"/img/1575290314506.png\" alt=\"安装Nginx\"></p>\n<p><img src=\"/img/1575603749178.png\" alt=\"fastdfs-nginx\"></p>\n<p>注： 是conf目录<br><img src=\"/img/1575634128185.png\" alt=\"连接fadfs与nginx\"></p>\n<p><img src=\"/img/1575634466665.png\" alt=\"http server配置\"></p>\n<p><img src=\"/img/1575635246200.png\" alt=\"server配置\"></p>\n<p><img src=\"/img/1575635485238.png\" alt=\"启动\"></p>\n<p>上传测试: windows电脑下：</p>\n<ol>\n<li>去github下下载zip，解压</li>\n<li>把fdfs_client文件夹复制到自己conda环境下</li>\n<li>复制远端的client.conf，修改base_path和 网址（一般不用改）</li>\n<li>注释掉fdfs_client.sendfile这句代码在storage_client.py</li>\n<li>写一个Python文件，一定要在自己的conda环境下！</li>\n</ol>\n<pre><code class=\"python\">from fdfs_client.client import Fdfs_client\n\nclient = Fdfs_client(&#39;F:/Projects/django_env/client.conf&#39;)\nret = client.upload_by_filename(&#39;timg.jpg&#39;)\nprint(ret)</code></pre>\n<p>上传成功后：可以使用我们的 <a href=\"http://39.97.170.176:8888/\">http://39.97.170.176:8888/</a> 做为前缀加上地址来访问图片<br><img src=\"/img/1575640031870.png\" alt=\"测试上传\"></p>\n<p><strong>fdfs工作流程</strong></p>\n<p><img src=\"/img/1575981798051.png\" alt=\"fdfs工作流程\"></p>\n<p><strong>实现fdfs</strong></p>\n<ul>\n<li>写一个如下结构：<br><img src=\"/img/1575984532516.png\" alt=\"fdfs文件\"></li>\n<li>storage.py中继承官方的Storage类并重写方法</li>\n</ul>\n<pre><code class=\"python\">from django.core.files.storage import Storage\nfrom fdfs_client.client import Fdfs_client\nfrom django.conf import settings\n\n\nclass FDFSStorage(Storage):\n\n    def __init__(self, client_conf=None, base_url=None):\n        if client_conf is None:\n            client_conf = settings.FDFS_CLIENT_CONF\n        self.client_conf = client_conf\n\n        if base_url is None:\n            base_url = settings.FDFS_URL\n        self.base_url = base_url\n\n    def _open(self, name, mode=&#39;rb&#39;):\n        pass\n\n    def _save(self, name, content):\n        client = Fdfs_client(self.client_conf)\n\n        # 上传文件内容\n        res = client.upload_by_buffer(content.read())\n        # return dict\n        # {\n        #     &#39;Group name&#39;: group_name,\n        #     &#39;Remote file_id&#39;: remote_file_id,\n        #     &#39;Status&#39;: &#39;Upload successed.&#39;,\n        #     &#39;Local file name&#39;: &#39;&#39;,\n        #     &#39;Uploaded size&#39;: upload_size,\n        #     &#39;Storage IP&#39;: storage_ip\n        # } if success else None\n\n        if res.get(&#39;Status&#39;) !=  &#39;Upload successed.&#39;:\n            # 上传失败\n            raise Exception(&#39;上传文件到DFS失败&#39;)\n\n        # 获取返回的文件ID\n        filename = res.get(&#39;Remote file_id&#39;)\n\n        # 返回文件ID\n        return filename\n\n    def exists(self, name):\n        return False\n\n\n    def url(self, name):\n        &#39;&#39;&#39;返回文件url&#39;&#39;&#39;\n        return self.base_url+name\n</code></pre>\n<ul>\n<li>最后在settings中加入</li>\n</ul>\n<pre><code class=\"python\">#配置文件存储器\nDEFAULT_FILE_STORAGE = &#39;utils.fdfs.storage.FDFSStorage&#39;\n\n#设置fdfs 的client.conf文件路径\nFDFS_CLIENT_CONF=&#39;./utils/fdfs/client.conf&#39;\n\n#FDFS服务器地址\nFDFS_URL=&#39;http://39.97.170.176:8888/&#39;</code></pre>\n<p><strong>总结</strong></p>\n<p>使用fdfs好处：</p>\n<ol>\n<li>海量存储，存储内容易扩展</li>\n<li>解决文件内容重复</li>\n<li>结合nginx，提高网站提供图片的效率</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"相关背景概念\"><a href=\"#相关背景概念\" class=\"headerlink\" title=\"相关背景概念\"></a>相关背景概念</h2><blockquote>\n<p>B2B, O2O, B2C, C2C..</p>\n</blockquote>\n<h2 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h2><p><img src=\"/img/1573441070020.png\" alt=\"enter description here\"></p>\n<blockquote>\n<p>对数据库进行授权<br><img src=\"/img/1573442010455.png\" alt=\"enter description here\"></p>\n</blockquote>\n<blockquote>\n<p>使用后台管理<br><img src=\"/img/1573442404015.png\" alt=\"enter description here\"></p>\n</blockquote>\n<h2 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h2><p><strong>1.一个模块对应一个APP</strong><br><strong>2.将所有app归类到一个apps文件夹</strong><br><strong>3.[可选]  设置一个系统路径，这样就不用注册APP时添加前缀文件夹</strong></p>\n<pre><code class=\"python\">sys.path.insert(0, os.path.join(BASE_DIR, &#39;apps&#39;))</code></pre>\n<p><strong>4.添加templates包和static包</strong></p>\n<blockquote>\n<p>TEMPLATES_DIR = os.path.join(BASE_DIR, ‘templates’)<br>TEMPLATES = [<br>    {<br>        ‘BACKEND’: ‘django.template.backends.django.DjangoTemplates’,<br>        ‘DIRS’: [TEMPLATES_DIR],<br>        …<br>STATICFILES_DIRS = [os.path.join(BASE_DIR, ‘static’)]</p>\n</blockquote>\n<p><strong>5.添加templates和static路径到setting</strong></p>\n<p><strong>6.配置数据库为Mysql</strong></p>\n<blockquote>\n<p>  ‘ENGINE’: ‘django.db.backends.mysql’,<br>        ‘NAME’: ‘dailyfresh’,<br>        ‘USER’: ‘root’,<br>        ‘PASSWORD’:’bk102435’,<br>        ‘HOST’:’39.97.170.176’,<br>        ‘PORT’:3306,</p>\n</blockquote>\n<p><strong>7.设置语言</strong></p>\n<pre><code class=\"python\">LANGUAGE_CODE = &#39;zh-hans&#39;\nTIME_ZONE = &#39;Asia/Shanghai&#39;</code></pre>\n<p><strong>8.配置项目总的urls</strong><br><strong>9.为各应用创建urls</strong></p>\n<p><strong>10.数据层准备，创建db包，创建basemodel.py</strong></p>\n<p><strong>11.[可选]创建各models 或 链接现有数据库</strong></p>\n<blockquote>\n<p>Inpectdb 也可针对某张表：<br>python manage.py inspectdb TableName &gt; output.py<br>链接： <a href=\"https://www.jianshu.com/p/037bd7e20a7a\">https://www.jianshu.com/p/037bd7e20a7a</a></p>\n</blockquote>\n<p><strong>12.指定django认证系统的模型</strong><br>这样superuser的模型表就被指定到自己的user表</p>\n<blockquote>\n<p>settings.py中加入<br>AUTH_USER_MODEL = ‘user.User’</p>\n</blockquote>\n<h3 id=\"13-可能出现的问题\"><a href=\"#13-可能出现的问题\" class=\"headerlink\" title=\"13.  可能出现的问题\"></a>13.  可能出现的问题</h3><p>不确定是不是使用pymysql导致的，这里会有两个问题</p>\n<ul>\n<li>1.现在django使用mysqlclient，而且恶心的是会在启动时自动验证版本号，pymysql最高只到0.9.3。这里根据报错直接那代码注释即可！</li>\n<li>2.makemigration出错，提示在django代码里的operations.py中的last_executed_query函数，由于python3与Python2的decode与encode函数区别，这里也需要把.decode..去掉。</li>\n</ul>\n<h2 id=\"User模块-注册\"><a href=\"#User模块-注册\" class=\"headerlink\" title=\"User模块 - 注册\"></a>User模块 - 注册</h2><p><strong>1.准备views函数</strong></p>\n<ul>\n<li>views.py添加相应函数<br>register函数为接收跳转网页, register_handler函数接收处理及逻辑</li>\n</ul>\n<pre><code class=\"python\">def register():\n    pass\ndef register_handle():\n    pass</code></pre>\n<ul>\n<li>urls.py配置对应view函数路径</li>\n</ul>\n<pre><code class=\"python\">path(&#39;register&#39;,views.register,name=&#39;register&#39;)\npath(&#39;register_handle&#39;,views.register_handle,name=&#39;register_handle&#39;)</code></pre>\n<p><strong>2.templates里放入html信息</strong></p>\n<ul>\n<li>编辑表单&lt;form&gt;<br>  添加method,action.<br>  写法升级：</li>\n</ul>\n<pre><code class=\"python\">action=&quot;{% url 'user:detail' %}&quot; </code></pre>\n<p>旧的写法:</p>\n<pre><code class=\"python\">action = &quot;/user/register_handle&quot;</code></pre>\n<blockquote>\n<p>注意事项：</p>\n<ol>\n<li>网页使用跳转，需要在urls.py中指定name:<br>如下：所对应的地址段需要设置不同的正则</li>\n</ol>\n<pre><code class=\"python\">path(&#39;add/&#39;, calc_views.add, name=&#39;add&#39;),  # new\npath(&#39;add/&lt;int:a&gt;/&lt;int:b&gt;/&#39;, calc_views.old_add2_redirect,name=&#39;add&#39;),</code></pre>\n<p>2.使用shell, 用reverse测试<br>地址反射的机制：django.urls reverse<br>3.定义一个跳转函数来做：</p>\n<pre><code class=\"python\">urls.py中加入如下：\n path(&#39;add/&lt;int:a&gt;/&lt;int:b&gt;/&#39;, calc_views.old_add2_redirect,name=&#39;add&#39;),\npath(&#39;new_add/&lt;int:a&gt;/&lt;int:b&gt;/&#39;, calc_views.add2, name=&#39;add2&#39;),\n\nviews.py中加入如下：\ndef old_add2_redirect(request):\nreturn HttpResponseRedirect(\n       reverse(&#39;add2&#39;, args=(a, b))\n   )\n测试网址： http://127.0.0.1:8000/add/5/6/ \n这时最终就将跳到美术http://127.0.0.1:8000/new_add/5/6/</code></pre>\n</blockquote>\n<p><strong>3.使用类视图</strong></p>\n<blockquote>\n<p>1.优化去register_handle函数，使用get/post判断实现不同的跳转类型<br>2.基于1的优化，使用类视图方式加载</p>\n</blockquote>\n<pre><code class=\"python\">from django.views.generic import View\n\nclass RegisterView(View):\n\n    def get(self, request):\n        pass\n\n    def post(self, request):\n        pass</code></pre>\n<p><strong>3.激活用户</strong></p>\n<ol>\n<li>使用itsdangerous为网址进行加密签名</li>\n<li>调用django.core.mail 的send_mail来发送邮件，把链接成文本发送过去</li>\n</ol>\n<pre><code class=\"python\">from django.conf import settings\nfrom django.core.mail import send_mail\nimport time\n\ndef send_register_active_email(to_email, username, token):\n    &#39;&#39;&#39;send active email&#39;&#39;&#39;\n    subject = &quot;天天生鲜欢迎消息&quot;\n    message = &quot;&quot;\n    sender = settings.DEFAULT_FROM_EMAIL\n    receiver = [to_email]\n    html_message = &quot;&lt;h1&gt;%s, 欢迎你&lt;/h1&gt;请点击下面链接激活&lt;br/&gt;&lt;a href=\\&quot;http://127.0.0.1:8000/user/active/%s\\&quot;&gt;http://127.0.0.1:8000/user/active/%s&lt;/a&gt;&quot; % (\n    username, token, token)\n    send_mail(subject, message, sender, receiver, html_message=html_message)\n    time.sleep(5)</code></pre>\n<blockquote>\n<p>也可使用Python的发email库</p>\n</blockquote>\n<blockquote>\n<pre><code class=\"python\"> def active_email(self, email_addr, active_code):\n     # 第三方 SMTP 服务 # 授权码：cmatkgceuuxcbddc\n     mail_host = &quot;smtp.qq.com&quot;  # 设置服务器\n     mail_user = &quot;1024037035@qq.com&quot;  # 用户名\n     mail_pass = &quot;cmatkgceuuxcbddc&quot;  # 口令\n     sender = &#39;1024037035@qq.com&#39;\n     receivers = [email_addr]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱\n      # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码\n     try:\n         smtp_obj = smtplib.SMTP()\n         smtp_obj.connect(mail_host, 25)  # 25 为 SMTP 端口号\n         smtp_obj.login(mail_user, mail_pass)\n         smtp_obj.sendmail(sender, receivers, message.as_string())\n         return True\n         &quot;邮件发送成功&quot;\n     except smtplib.SMTPException:\n          return False\n           &quot;Error: 无法发送邮件&quot;</code></pre>\n</blockquote>\n<ol start=\"3\">\n<li>在Url中配置激活的功能</li>\n</ol>\n<pre><code class=\"python\">path(&#39;active/&lt;token&gt;&#39;,ActiveView.as_view(), name=&#39;active&#39;),</code></pre>\n<ol start=\"4\">\n<li>在views.py中写一个ActiveView的视图来处理激活</li>\n</ol>\n<pre><code class=\"python\">class ActiveView(View):\n    def get(self, request, token):\n        try:\n            serializer = Serializer(settings.SECRET_KEY, 3600)\n            # print(type(token))\n            token = token.encode()\n            info = serializer.loads(token)\n            user_id = info[&#39;confirm&#39;]\n            user = User.objects.get(id=user_id)\n            user.is_active = 1\n            user.save()\n\n            # 跳转到登陆页面\n            return redirect(reverse(&#39;user:login&#39;))\n        except SignatureExpired as e:\n            # 激活链接过期\n            return HttpResponse(&#39;激活链接已过期&#39;)</code></pre>\n<p><strong>4.使用celery做为异步处理</strong></p>\n<p><img src=\"/img/1574171584470.png\" alt=\"enter description here\"></p>\n<p>1.配置一个项目目录为：celery_tasks/tasks.py的文件<br>2.在tasks.py写入配置如 </p>\n<pre><code class=\"python\"># use celery\nfrom celery import Celery\n# create celery instance\napp = Celery(&#39;celery_tasks.tasks&#39;, broker=&#39;redis://:pwd@39.97.170.176:6379/8&#39;)\n\n# define task function\n@app.task\ndef send_register_active_email(to_email, username, token):\n    pass</code></pre>\n<p>3.执行的脚本函数里写入：</p>\n<pre><code class=\"python\">        # 发送邮件1\n        send_register_active_email.delay(email, username, secret_info)</code></pre>\n<p>4.在有redis的电脑上</p>\n<ul>\n<li>复制项目代码</li>\n<li>在tasks.py中加入初始化django的代码</li>\n<li><pre><code class=\"python\">import os\nimport django\nfrom django.core.wsgi import get_wsgi_application\n</code></pre>\n</li>\n</ul>\n<p>os.environ.setdefault(‘DJANGO_SETTINGS_MODULE’, ‘dailyfresh.settings’)<br>django.setup()</p>\n<pre><code>* 启动worker\n</code></pre><p>celery -A celery_tasks.tasks worker -l info</p>\n<pre><code>* 启动redis , 大功告成，测试\n\n&gt; 可能出现的问题\n&gt; 在windows系统中：\n&gt;  使用这种方式来启动worker: pip install eventlet -&gt; celery -A your_app_name worker --pool=eventlet\n&gt;  或： celery -A your_app_name worker --pool=solo -l info\n&gt;  或：\n&gt;  at worker side:\nset FORKED_BY_MULTIPROCESSING = 1\nthen\ncelery -A myworker worker --loglevel=info\n\n## User模块 - 登录\n\n**LoginView，使用自带的授权**\n\n授权，如果成功则会返回user对象：：\n</code></pre><p>user = authenticate(username=username, password=pwd)</p>\n<pre><code>\n登录：\n\n```python\nlogin(request, user)</code></pre><p>添加URL及表单部分，参考注册流程</p>\n<p><strong>为减少数据库操作，使用redis存储</strong></p>\n<p>1.安装 django-redis<br>2.settings加入如下配置即可：</p>\n<pre><code class=\"python\">#Django 缓存配置\nCACHES = {\n    &quot;default&quot;: {\n        &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,\n        &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/9&quot;, #服务器地址\n        &quot;OPTIONS&quot;: {\n            &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,\n            &quot;CONNECTION_POOL_KWARGS&quot;: {&quot;max_connections&quot;: 100}, # 最大连接数\n            &quot;PASSWORD&quot;: &quot;bk102435&quot;,\n        }\n    }\n}\n#配置session存储\nSESSION_ENGINE = &#39;django.contrib.sessions.backends.cache&#39;\nSESSION_CACHE_ALIAS = &#39;default&#39;</code></pre>\n<p><strong>把用户名记在cookie</strong></p>\n<p>1.登录成功时，把username字段存在cookie中</p>\n<pre><code class=\"python\">response = redirect(reverse(&#39;goods:index&#39;))\nremember = request.POST.get(&#39;remember&#39;)\n\nif remember == &#39;on&#39;:\n    response.set_cookie(&#39;username&#39;, username, max_age=7*24*3600)\nelse:\n    response.delete_cookie(&#39;username&#39;)</code></pre>\n<p>2.get方法中取出cookie数据</p>\n<pre><code>if &#39;username&#39; in request.COOKIES:\n    username = request.COOKIES.get(&#39;username&#39;)\n    checked = &#39;checked&#39;\nelse:\n    username = &#39;&#39;\n    checked = &#39;&#39;\nreturn render(request, &#39;login.html&#39;, {&#39;username&#39;:username, &#39;checked&#39;:checked})</code></pre><h2 id=\"User-模块-用户中心\"><a href=\"#User-模块-用户中心\" class=\"headerlink\" title=\"User 模块 - 用户中心\"></a>User 模块 - 用户中心</h2><p><strong>从模板网页中抽象</strong></p>\n<ol>\n<li>将共同部分放在一个html， 不同部分使用</li>\n</ol>\n<p>base_user_center.html:</p>\n<p><img src=\"/img/1574937645193.png\" alt=\"enter description here\"></p>\n<p>2.在对应的功能页面继承</p>\n<p><img src=\"/img/1574937788143.png\" alt=\"enter description here\"></p>\n<p><strong>使用if 做功能块显示隐藏</strong></p>\n<p>如上方的：</p>\n<p><img src=\"/img/1574937430699.png\" alt=\"enter description here\"></p>\n<p><strong>使用官方提供的授权管理</strong></p>\n<p>有些页面需要登录后才能显示，如这里的用户中心页<br>使用django的login_required装饰器来做</p>\n<p><a href=\"https://docs.djangoproject.com/en/2.2/topics/auth/default/\">https://docs.djangoproject.com/en/2.2/topics/auth/default/</a></p>\n<ol>\n<li>当用户已登录过，将直接跳转至所需页面</li>\n<li>当未登录，将默认跳转至/accounts/login/?next=/polls/3/.</li>\n<li>login_url可在settings.LOGIN_URL中配置 或login_url参数中配置</li>\n<li>next可在redirect_field_name参数中配置</li>\n</ol>\n<pre><code class=\"python\">from django.contrib.auth.decorators import login_required\n\n@login_required(login_url=&#39;/accounts/login/&#39;)\ndef my_view(request):</code></pre>\n<ol start=\"5\">\n<li>处理用户通过非登录界面过来的<pre><code class=\"python\"># 处理通过跳转的请求值#\n             # 设置下一步自动跳转 #\n             next_url = request.GET.get(&#39;next&#39;, reverse(&#39;goods:index&#39;))\n             response = redirect(reverse(next_url))</code></pre>\n</li>\n</ol>\n<blockquote>\n<p>注意：需要将form表单的action设成无action，这样提交的内容将按当前内容来指定！</p>\n</blockquote>\n<p>6.使用Mixin优化写法</p>\n<ul>\n<li>新建utils文件夹，新建一个LoginRequireMixin类</li>\n</ul>\n<pre><code class=\"python\">class LoginRequiredMixin(object):\n    @classmethod\n    def as_view(cls, **initkwargs):\n        view = super(LoginRequiredMixin, cls).as_view(**initkwargs)\n        return login_required(view)</code></pre>\n<p>在所有view函数中继承</p>\n<pre><code class=\"python\">class AddressView(LoginRequiredMixin, View):\n    pass</code></pre>\n<blockquote>\n<p>Mixin的原理是，执行一个子类没有的函数，Python继承规则是第一个父类先找，找到cls所代表的类的父类，再调用其as_view<br>super(A,cls) 找到A的父类，并将cls转成父类对象！</p>\n</blockquote>\n<p><strong>使用官方提供的是否登录标识</strong></p>\n<pre><code class=\"python\">if request.user.is_authenticated:\n    # Do something for authenticated users.\n    ...\nelse:\n    # Do something for anonymous users.\n    ...</code></pre>\n<p>因此在html中加入如下代码：</p>\n<p><img src=\"/img/1574937768754.png\" alt=\"enter description here\"></p>\n<p><strong>使用官方提供的退出登录</strong></p>\n<p>logout函数</p>\n<pre><code class=\"html\">&lt;a href=&quot;{% url 'user:logout' %}&quot;&gt;退出&lt;/a&gt;</code></pre>\n<pre><code class=\"python\">class LogoutView(View):\n    def get(self, request):\n        logout(request)\n        return redirect(reverse(&#39;goods:index&#39;))</code></pre>\n<p><strong>实现地址页的功能</strong></p>\n<blockquote>\n<p>1.使用request.user拿到user对象<br>2.Address.objects.create/get 来操作数据库<br>3.post请求中收到后再进行操作<br>4.Post请求完毕后，在get请求中再取数据库的地址来到html<br>5.显示get请求的结果到html</p>\n</blockquote>\n<p><strong>抽象Model里的管理器</strong></p>\n<p>model.py里：</p>\n<p>需要继承manager</p>\n<pre><code class=\"python\">class AddressManager(models.Manager):\n    &#39;&#39;&#39;自定义模型管理器&#39;&#39;&#39;\n    def get_default_address(self, user):\n        #self.model: 获取self对象所在模型类\n        try:\n            address = self.get(user=user, is_default=True)\n        except self.DoesNotExist as e:\n            address = None\n        return address\n\nclass Address(BaseModel):\n    &quot;&quot;&quot;地址模型类&quot;&quot;&quot;\n    pass\n    # 在这里使用定义的管理器\n    objects = AddressManager()</code></pre>\n<blockquote>\n<p>需要使用Address.objects.get_default_address来调用。这样传入self</p>\n</blockquote>\n<p><strong>用户中心的历史记录显示</strong></p>\n<p><img src=\"/img/1575029000281.png\" alt=\"enter description here\"></p>\n<p>参考redis资料<br><a href=\"https://django-redis-chs.readthedocs.io/zh_CN/latest/#\">https://django-redis-chs.readthedocs.io/zh_CN/latest/#</a></p>\n<ol>\n<li><p>获取StrictRedis对象<br> 一般做法：</p>\n<pre><code class=\"python\"> from redis import StrictRedis\n sr = StrictRedis(host=&#39;127.0.0.1&#39;, port=&#39;6379&#39;, db=9)</code></pre>\n<p> 但可以使用原生端的使用方式：</p>\n<pre><code class=\"python\"> from django_redis import get_redis_connection\n con = get_redis_connection(&quot;default&quot;)</code></pre>\n</li>\n<li><p>获取redis数据并返回界面</p>\n</li>\n</ol>\n<pre><code class=\"python\">  #获取redis数据连接\n        con = get_redis_connection(&quot;default&quot;)\n        #获取数据\n        history_key = &#39;history_%id&#39;%user.id\n        #拿前五个\n        sku_ids = con.lrange(history_key, 0, 4)</code></pre>\n<pre><code class=\"python\"> def get(self, request):\n        user = request.user\n        address = Address.objects.get_default_address(user)\n\n        #获取redis数据连接\n        con = get_redis_connection(&quot;default&quot;)\n        #获取数据\n        history_key = &#39;history_%id&#39;%user.id\n        #拿前五个\n        sku_ids = con.lrange(history_key, 0, 4)\n        #获取此ID内的物体\n        # goods_li = GoodsSKU.objects.filter(id__in=sku_ids)\n        goods_li = []\n        for id in sku_ids:\n            goods = GoodsSKU.objects.get(id=id)\n            goods_li.append(goods)\n        #数据组装\n        context = {&#39;page&#39;: &#39;user&#39;,\n                   &#39;address&#39;: address,\n                   &#39;goods_li&#39;:goods_li}\n\n        return render(request, &#39;user_center_info.html&#39;, context)</code></pre>\n<p>3.在Html中配置数据，显示使用for goods, 和empty表示</p>\n<p><img src=\"/img/1575033223646.png\" alt=\"enter description here\"></p>\n<h2 id=\"分布式FastDFS文件系统\"><a href=\"#分布式FastDFS文件系统\" class=\"headerlink\" title=\"分布式FastDFS文件系统\"></a>分布式FastDFS文件系统</h2><p><img src=\"/img/1575033366217.png\" alt=\"enter description here\"></p>\n<p>客户端先发请求到Tracker服务器，服务器将返回一个Storage服务器地址，客户端再上传到此Storage服务器</p>\n<p><img src=\"/img/1575033456146.png\" alt=\"enter description here\"></p>\n<p>电商网站的图片数据一般不放在Django服务器，以防服务器存储器爆掉<br><img src=\"/img/1575034858096.png\" alt=\"enter description here\"></p>\n<p>FastDFS 采用hash值标识存储文件</p>\n<p><strong>文件上传</strong></p>\n<p><img src=\"/img/1575035108391.png\" alt=\"enter description here\"><br><img src=\"/img/1575035161292.png\" alt=\"enter description here\"></p>\n<p><strong>文件下载</strong></p>\n<p><img src=\"/img/1575035213445.png\" alt=\"enter description here\"> </p>\n<p><img src=\"/img/1575035246421.png\" alt=\"enter description here\"></p>\n<p><strong>安装配置</strong></p>\n<p><img src=\"/img/1575290159935.png\" alt=\"安装\"></p>\n<p><img src=\"/img/1575290242736.png\" alt=\"服务器配置\"></p>\n<p><img src=\"/img/1575290266752.png\" alt=\"服务器配置\"></p>\n<p><img src=\"/img/1575290288546.png\" alt=\"启动\"></p>\n<p><img src=\"/img/1575290314506.png\" alt=\"安装Nginx\"></p>\n<p><strong>结合nginx使用，提高多人访问的效率</strong></p>\n<p>获取文件需要借助nginx来获取静态文件。</p>\n<p><img src=\"/img/1575290314506.png\" alt=\"安装Nginx\"></p>\n<p><img src=\"/img/1575603749178.png\" alt=\"fastdfs-nginx\"></p>\n<p>注： 是conf目录<br><img src=\"/img/1575634128185.png\" alt=\"连接fadfs与nginx\"></p>\n<p><img src=\"/img/1575634466665.png\" alt=\"http server配置\"></p>\n<p><img src=\"/img/1575635246200.png\" alt=\"server配置\"></p>\n<p><img src=\"/img/1575635485238.png\" alt=\"启动\"></p>\n<p>上传测试: windows电脑下：</p>\n<ol>\n<li>去github下下载zip，解压</li>\n<li>把fdfs_client文件夹复制到自己conda环境下</li>\n<li>复制远端的client.conf，修改base_path和 网址（一般不用改）</li>\n<li>注释掉fdfs_client.sendfile这句代码在storage_client.py</li>\n<li>写一个Python文件，一定要在自己的conda环境下！</li>\n</ol>\n<pre><code class=\"python\">from fdfs_client.client import Fdfs_client\n\nclient = Fdfs_client(&#39;F:/Projects/django_env/client.conf&#39;)\nret = client.upload_by_filename(&#39;timg.jpg&#39;)\nprint(ret)</code></pre>\n<p>上传成功后：可以使用我们的 <a href=\"http://39.97.170.176:8888/\">http://39.97.170.176:8888/</a> 做为前缀加上地址来访问图片<br><img src=\"/img/1575640031870.png\" alt=\"测试上传\"></p>\n<p><strong>fdfs工作流程</strong></p>\n<p><img src=\"/img/1575981798051.png\" alt=\"fdfs工作流程\"></p>\n<p><strong>实现fdfs</strong></p>\n<ul>\n<li>写一个如下结构：<br><img src=\"/img/1575984532516.png\" alt=\"fdfs文件\"></li>\n<li>storage.py中继承官方的Storage类并重写方法</li>\n</ul>\n<pre><code class=\"python\">from django.core.files.storage import Storage\nfrom fdfs_client.client import Fdfs_client\nfrom django.conf import settings\n\n\nclass FDFSStorage(Storage):\n\n    def __init__(self, client_conf=None, base_url=None):\n        if client_conf is None:\n            client_conf = settings.FDFS_CLIENT_CONF\n        self.client_conf = client_conf\n\n        if base_url is None:\n            base_url = settings.FDFS_URL\n        self.base_url = base_url\n\n    def _open(self, name, mode=&#39;rb&#39;):\n        pass\n\n    def _save(self, name, content):\n        client = Fdfs_client(self.client_conf)\n\n        # 上传文件内容\n        res = client.upload_by_buffer(content.read())\n        # return dict\n        # {\n        #     &#39;Group name&#39;: group_name,\n        #     &#39;Remote file_id&#39;: remote_file_id,\n        #     &#39;Status&#39;: &#39;Upload successed.&#39;,\n        #     &#39;Local file name&#39;: &#39;&#39;,\n        #     &#39;Uploaded size&#39;: upload_size,\n        #     &#39;Storage IP&#39;: storage_ip\n        # } if success else None\n\n        if res.get(&#39;Status&#39;) !=  &#39;Upload successed.&#39;:\n            # 上传失败\n            raise Exception(&#39;上传文件到DFS失败&#39;)\n\n        # 获取返回的文件ID\n        filename = res.get(&#39;Remote file_id&#39;)\n\n        # 返回文件ID\n        return filename\n\n    def exists(self, name):\n        return False\n\n\n    def url(self, name):\n        &#39;&#39;&#39;返回文件url&#39;&#39;&#39;\n        return self.base_url+name\n</code></pre>\n<ul>\n<li>最后在settings中加入</li>\n</ul>\n<pre><code class=\"python\">#配置文件存储器\nDEFAULT_FILE_STORAGE = &#39;utils.fdfs.storage.FDFSStorage&#39;\n\n#设置fdfs 的client.conf文件路径\nFDFS_CLIENT_CONF=&#39;./utils/fdfs/client.conf&#39;\n\n#FDFS服务器地址\nFDFS_URL=&#39;http://39.97.170.176:8888/&#39;</code></pre>\n<p><strong>总结</strong></p>\n<p>使用fdfs好处：</p>\n<ol>\n<li>海量存储，存储内容易扩展</li>\n<li>解决文件内容重复</li>\n<li>结合nginx，提高网站提供图片的效率</li>\n</ol>\n"},{"title":"四元数旋转函数学习","_content":"\n## LookRotation(Vector3 forward, [DefaultValue(\"Vector3.up\")] Vector3 upwards)\n\n理解为将Z轴正方向转到第一个”forward“参数位置，把UP正方向转到第二个’upwards‘位置\n\n> LookRotation的含义就是，计算让Z轴对齐forward，让y轴对齐upward 所需要的旋转四元数。\n\n## FromToRotation(Vector3 fromDirection, Vector3 toDirection)\n\n> 从一个转向到另一个目标转向。如：\n> Quaternion.LookRotation(new Vector3(1,0,0)) 等价于 Quaternion.FromToRotation(Vector3.forward, new Vector3(1,0,0));\n\n\n[参考学习](https://blog.csdn.net/narutojzm1/article/details/51276433)\n\n## AngleAxis(float angle, Vector3 axis)\n\n> 以axis为轴，转一个角度。 \n\n示例：如以A（0，10，0）到B（10，0，0）形成一个方向，以此方向转90。\n起始位置如图：\n![起始位置](/img/1578566566815.png)\n\n转90度后如图：\n![转后](/img/1578566598445.png)","source":"_posts/四元数旋转函数学习.md","raw":"---\ntitle: 四元数旋转函数学习\ncategories:\n- Unity学习\ntags: \n- Unity学习\n---\n\n## LookRotation(Vector3 forward, [DefaultValue(\"Vector3.up\")] Vector3 upwards)\n\n理解为将Z轴正方向转到第一个”forward“参数位置，把UP正方向转到第二个’upwards‘位置\n\n> LookRotation的含义就是，计算让Z轴对齐forward，让y轴对齐upward 所需要的旋转四元数。\n\n## FromToRotation(Vector3 fromDirection, Vector3 toDirection)\n\n> 从一个转向到另一个目标转向。如：\n> Quaternion.LookRotation(new Vector3(1,0,0)) 等价于 Quaternion.FromToRotation(Vector3.forward, new Vector3(1,0,0));\n\n\n[参考学习](https://blog.csdn.net/narutojzm1/article/details/51276433)\n\n## AngleAxis(float angle, Vector3 axis)\n\n> 以axis为轴，转一个角度。 \n\n示例：如以A（0，10，0）到B（10，0，0）形成一个方向，以此方向转90。\n起始位置如图：\n![起始位置](/img/1578566566815.png)\n\n转90度后如图：\n![转后](/img/1578566598445.png)","slug":"四元数旋转函数学习","published":1,"date":"2020-09-08T03:23:20.889Z","updated":"2020-09-08T03:23:20.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh11l003w4wf0yhuj3se1","content":"<h2 id=\"LookRotation-Vector3-forward-DefaultValue-“Vector3-up”-Vector3-upwards\"><a href=\"#LookRotation-Vector3-forward-DefaultValue-“Vector3-up”-Vector3-upwards\" class=\"headerlink\" title=\"LookRotation(Vector3 forward, [DefaultValue(“Vector3.up”)] Vector3 upwards)\"></a>LookRotation(Vector3 forward, [DefaultValue(“Vector3.up”)] Vector3 upwards)</h2><p>理解为将Z轴正方向转到第一个”forward“参数位置，把UP正方向转到第二个’upwards‘位置</p>\n<blockquote>\n<p>LookRotation的含义就是，计算让Z轴对齐forward，让y轴对齐upward 所需要的旋转四元数。</p>\n</blockquote>\n<h2 id=\"FromToRotation-Vector3-fromDirection-Vector3-toDirection\"><a href=\"#FromToRotation-Vector3-fromDirection-Vector3-toDirection\" class=\"headerlink\" title=\"FromToRotation(Vector3 fromDirection, Vector3 toDirection)\"></a>FromToRotation(Vector3 fromDirection, Vector3 toDirection)</h2><blockquote>\n<p>从一个转向到另一个目标转向。如：<br>Quaternion.LookRotation(new Vector3(1,0,0)) 等价于 Quaternion.FromToRotation(Vector3.forward, new Vector3(1,0,0));</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/narutojzm1/article/details/51276433\">参考学习</a></p>\n<h2 id=\"AngleAxis-float-angle-Vector3-axis\"><a href=\"#AngleAxis-float-angle-Vector3-axis\" class=\"headerlink\" title=\"AngleAxis(float angle, Vector3 axis)\"></a>AngleAxis(float angle, Vector3 axis)</h2><blockquote>\n<p>以axis为轴，转一个角度。 </p>\n</blockquote>\n<p>示例：如以A（0，10，0）到B（10，0，0）形成一个方向，以此方向转90。<br>起始位置如图：<br><img src=\"/img/1578566566815.png\" alt=\"起始位置\"></p>\n<p>转90度后如图：<br><img src=\"/img/1578566598445.png\" alt=\"转后\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LookRotation-Vector3-forward-DefaultValue-“Vector3-up”-Vector3-upwards\"><a href=\"#LookRotation-Vector3-forward-DefaultValue-“Vector3-up”-Vector3-upwards\" class=\"headerlink\" title=\"LookRotation(Vector3 forward, [DefaultValue(“Vector3.up”)] Vector3 upwards)\"></a>LookRotation(Vector3 forward, [DefaultValue(“Vector3.up”)] Vector3 upwards)</h2><p>理解为将Z轴正方向转到第一个”forward“参数位置，把UP正方向转到第二个’upwards‘位置</p>\n<blockquote>\n<p>LookRotation的含义就是，计算让Z轴对齐forward，让y轴对齐upward 所需要的旋转四元数。</p>\n</blockquote>\n<h2 id=\"FromToRotation-Vector3-fromDirection-Vector3-toDirection\"><a href=\"#FromToRotation-Vector3-fromDirection-Vector3-toDirection\" class=\"headerlink\" title=\"FromToRotation(Vector3 fromDirection, Vector3 toDirection)\"></a>FromToRotation(Vector3 fromDirection, Vector3 toDirection)</h2><blockquote>\n<p>从一个转向到另一个目标转向。如：<br>Quaternion.LookRotation(new Vector3(1,0,0)) 等价于 Quaternion.FromToRotation(Vector3.forward, new Vector3(1,0,0));</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/narutojzm1/article/details/51276433\">参考学习</a></p>\n<h2 id=\"AngleAxis-float-angle-Vector3-axis\"><a href=\"#AngleAxis-float-angle-Vector3-axis\" class=\"headerlink\" title=\"AngleAxis(float angle, Vector3 axis)\"></a>AngleAxis(float angle, Vector3 axis)</h2><blockquote>\n<p>以axis为轴，转一个角度。 </p>\n</blockquote>\n<p>示例：如以A（0，10，0）到B（10，0，0）形成一个方向，以此方向转90。<br>起始位置如图：<br><img src=\"/img/1578566566815.png\" alt=\"起始位置\"></p>\n<p>转90度后如图：<br><img src=\"/img/1578566598445.png\" alt=\"转后\"></p>\n"},{"title":"天天生鲜项目实例P2","_content":"\n## 首页模块\n\n\n**IndexView中加入信息**\n\n在goods/views.py加入indexview的功能\n\n```python\nfrom django.urls import path\nfrom .views import IndexView\n\napp_name = 'goods'\nurlpatterns = [\n    path('', IndexView.as_view() ,name='index')\n]\n\n```\n\n```python\nfrom django.core.paginator import Paginator\nfrom django.shortcuts import render, redirect, reverse\nfrom django.views.generic.base import View\nfrom django_redis import get_redis_connection\nfrom django.core.cache import cache\nfrom goods.models import GoodsType, IndexGoodsBanner, IndexTypeGoodsBanner, IndexPromotionBanner, GoodsSKU\nfrom order.models import OrderGoods\n\nclass IndexView(View):\n    def get(self, request):\n        # get all goods type\n        types = GoodsType.objects.all()\n\n        # 获取首页轮播商品信息\n        goods_banners = IndexGoodsBanner.objects.all().order_by('index')\n\n        # 获取促销信息\n        promotion_banners = IndexPromotionBanner.objects.all().order_by('index')\n\n        # 获取分类商品展示信息\n        for type in types:\n            #获取图片类的banner展示信息\n            image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1)\n            #获取文字类的banner展示信息\n            title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0)\n\n            #添加属性\n            type.image_banners = image_banners\n            type.title_banners = title_banners\n\n        #获取用户购物车中的商品数目\n        user = request.user\n        cart_count = 0\n\n        if user.is_authenticated:\n            # 用户已登录有授权\n            conn = get_redis_connection('default')\n            cart_key = 'cart_%d'%user.id\n            cart_count = conn.hlen(cart_key)\n\n        # 组织上下文\n        context = {\n            'types':types,\n            'goods_banners':goods_banners,\n            'promotion_banners':promotion_banners,\n            'cart_count':cart_count\n        }\n\n        # 使用模板\n        return render(request, 'index.html', context)\n\n```\n\n**使用celery生成Index的static文件**\n\n新建任务：\n\n> 注意：\n> 1.from goods.models 要在django.setup之后\n> 2.worker端的fdfs_client需要升级到Python3的exception写法。\n> 3.worker端的fdfs_client考虑先将utils的import注释\n\n```python\n@app.task\ndef generate_static_index_html():\n    # get all goods type\n    types = GoodsType.objects.all()\n\n    # 获取首页轮播商品信息\n    goods_banners = IndexGoodsBanner.objects.all().order_by('index')\n\n    # 获取促销信息\n    promotion_banners = IndexPromotionBanner.objects.all().order_by('index')\n\n    # 获取分类商品展示信息\n    for type in types:\n        # 获取图片类的banner展示信息\n        image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1)\n        # 获取文字类的banner展示信息\n        title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0)\n\n        # 添加属性\n        type.image_banners = image_banners\n        type.title_banners = title_banners\n\n    # 组织上下文\n    context = {\n        'types': types,\n        'goods_banners': goods_banners,\n        'promotion_banners': promotion_banners,\n    }\n\n    # 使用模板\n    # 1.加载模板文件\n    temp = loader.get_template('static_index.html')\n    # 2.渲染\n    static_index_html = temp.render(context)\n\n    # 生成首页的静态文件\n    save_path = os.path.join(settings.BASE_DIR, 'static/index.html')\n    with open(save_path, 'w') as f:\n        f.write(static_index_html)\n```\n\n![流程](/img/1576549292557.png)\n\n**在admin的委托返回调用中，执行celery**\n\n在goods的admin.py中监听一下admin后台的save和delete操作，然后执行celery刷新内容返回。\n\n![执行流程](/img/1576551196217.png)\n\n 在admin.py中加入\n\n```python\nclass BaseModelAdmin(admin.ModelAdmin):\n    def save_model(self, request, obj, form, change):\n        # 先执行数据库操作\n        super().save_model(request, obj, form, change)\n\n        # 发送celery事件\n        from celery_tasks.tasks import generate_static_index_html\n        generate_static_index_html.delay()\n\n    def delete_model(self, request, obj):\n        # 先执行数据库操作\n        super().delete_model(request, obj)\n\n        # 发送celery事件\n        from celery_tasks.tasks import generate_static_index_html\n        generate_static_index_html.delay()\n```\n\n> 遇到问题： 第一次修改后，celery生成的页面太快了，还没等save-model结束，因此查出来的数据是旧的。下一次又可以刷出最新数据\n> 方案：在celery里加入一个等待，保证model已经处理完数据库了，这样celery任务可以查到最新的结果。\n\n**将index页面的两种获取方式调度起来**\n\n![静态页面的调度](/img/1576554364999.png)\n\n**使用django的缓存机制存储页面**\n\nhttps://docs.djangoproject.com/zh-hans/3.0/topics/cache/\n\n* 存储\n\n```python\ncache.set()\npass\ncache.get()\n```\n\n* 更新\n在admin.py里进行清空缓存\n\n```python\n        # 清缓存\n        cache.delete(index_cache_key)\n```\n\n> 小结：缓存机制的目的之一在于防止黑客利用各多台电脑进行访问型攻击（DDOS），缓存通过减少数据库的查询次数，实现对性能的优化。\n\n![缓存机制](/img/1576636756891.png)\n\n**使用redis存储购物车数据**\n\n![讨论](/img/1576722037256.png)\n\n\n## 商品详情页面\n\n**1.views.py 为页面添加必要数据**\n\n```python\n# 商品详情页\n    def get(self, request, goods_id):\n\n        try:\n            # 拿商品SKU\n            good_sku = GoodsSKU.objects.get(id=goods_id)\n        except GoodsSKU.DoesNotExist:\n            return redirect(reverse(\"goods:index\"))\n\n        # 拿所有类型\n        all_good_types = GoodsType.objects.all()\n\n        # 拿商品评论并排除掉commit为空的\n        sku_orders = OrderGoods.objects.filter(sku=good_sku).exclude(comment='')\n\n        # 拿同类型的商品（以时间倒序）\n        new_skus = GoodsSKU.objects.filter(type=good_sku.type).order_by(\"-create_time\")\n\n        # 获取购物车数量\n        user = request.user\n        cart_count = 0\n\n        if user.is_authenticated:\n            # 用户已登录有授权\n            conn = get_redis_connection('default')\n            cart_key = 'cart_%d' % user.id\n            cart_count = conn.hlen(cart_key)\n\n        # 上下文组织，sku,types, sku_orders, new_skus, cart_count\n        context = {\n            \"sku\": good_sku,\n            \"types\": all_good_types,\n            \"sku_orders\": sku_orders,\n            \"new_skus\": new_skus,\n            \"cart_count\": cart_count\n        }\n\n        return render(request, 'detail.html',context)\n```\n\n**2.页面编辑**\n\n使用双curly braces（放变量）或百分号的curly braces（放语句）\n\n forloop.counter来获取循环当前的ID\n\n**3.关闭escape转义**\n\n1.使用autoescape off来关闭转义，\n\n![关闭转义](/img/1576810604102.png)\n\n2.使用| safe来关闭转义\n\n![用safe关闭转义](/img/1576810673369.png)\n\n\n## 商品列表页\n\n**分析页面**\n\n> 使用/list/type/page?sort=default 这种地址来设计\n\n**分页的功能实现**\n\n> 使用Paginator分页来查询分页\n\n**路径传递方式**\n\n![路径传递方式](/img/1577414335373.png)\n\n**页码控制**\n\n![控制显示的页码](/img/1577414816762.png)\n\n> 遇到一个问题：get误写成filter，后果就是把这些结果放里面搜索会报 The QuerySet value for an exact lookup must be limited to one result using slicing. 以后需要注意\n\n\n**搜索引擎与全文检索**\n\n使用haystack的全文检索框架，whoosh的搜索引擎\n\n![结构分析](/img/1578122441016.png)\n\n![全文检索](/img/1578122530429.png)\n\n\n* 安装和配置\n\n![安装](/img/1578122591339.png)\n\n![配置haystack](/img/1578122991267.png)\n\n>haystack默认安装无如下内容，需按情况配置\n![配置](/img/1578123391128.png)\n\n> 索引文件生成：\n![索引文件生成：](/img/1578123481409.png)\n\n\n[官网](https://django-haystack.readthedocs.io/en/master/signal_processors.html)\n\n\n![索引类定义](/img/1578365001196.png)\n![建立索引](/img/1578377646492.png)\n\n改成如下：\n\n```python\n# 定义索引类\n\nfrom haystack import indexes\n# 导入模型类\nfrom goods.models import GoodsSKU\n\n#指定类建立索引\nclass GoodsSKUIndex(indexes.SearchIndex, indexes.Indexable):\n    # 索引字段， use_template表明把哪些字段建立索引文件（使用一个模板文件来说明）\n    text = indexes.CharField(document=True, use_template=True)\n\n    def get_model(self):\n        return GoodsSKU\n\n    def index_queryset(self, using=None):\n        return self.get_model().objects.all()\n```\n\n> 手动建立模型文件\ntemplates / search / indexes / 【app】 / 【模型类全小写】_text.txt\n\n![全文检索](/img/1578378838931.png)\n\n\n* 使用\n\n![结果](/img/1578378917671.png)\n> 表单中，参数名：q为写死的。method=‘get’是写死的\nurl的路径配置必须也是haystack.urls模块\n\n> 改变分词方式：\n![改变分词方式](/img/1578379986297.png)\n\n创建ChineseAnalyzer.py，写入：\n\n![内容截图](/img/1578380200054.png)\n![内容截图2](/img/1578380227603.png)\n\n![更改默认分析](/img/1578380391307.png)\n\n![更新分词方式](/img/1578380648851.png)\n\n> 总结： 选一个全文搜索的框架，如这里的haystack（django内置的），再找一个搜索引擎，如这里的whoosh引擎， 使用时会生成index文件，一般在配置中指明。在执行搜索时，引擎会在Index中查找。 另外也可以为其指定一个分词规则，如这里的jieba，这样可以根据分词来生成搜索。\n\n\n## 购物车模块\n\n**商品详情个数的JS**\n\n```js\nupdate_price();\nfunction update_price(){\n\tprice = $('.show_pirze').children('em').text();\n\tcount = $('.num_show').val();\n\n\tprice = parseFloat(price);\n\tcount = parseInt(count);\n\tamount = price * count;\n\t$('.total').children('em').text(amount.toFixed(2)+'元');//保留两位小数\n}\n$('.add').click(function () {\n\tcount = $('.num_show').val();\n\tcount = parseInt(count)+1;\n\t$('.num_show').val(count);\n\tupdate_price();\n});\n\n$('.minus').click(function () {\n\tcount = $('.num_show').val();\n\tcount = parseInt(count)-1;\n\tif(count <= 0){\n\t\treturn;\n\t}\n\t$('.num_show').val(count);\n\tupdate_price();\n});\n```\n\n**购物车添加的请求设计**\n\n流程：\n1. 采用ajax， post请求\n2. 传递参数，商品ID，数量\n\n> 目前为止，有post,get,url三种类型的请求类型，\n> 对于访问数据为主的参数，一般使用get请求\n> 对于涉及增删改的参数，一般使用post请求。\n\n> 另外，django防止csrf的方式，默认打开csrf中间件，post提交时加上csrf token标签\n![csrf生成的代码](/img/1578454158486.png)\n> Ajax发起的请求都在后台，在浏览器看不到效果\n> 前后端合作过程中，得确定好请求方式和参数\n\n![enter description here](/img/1578453777774.png)\n![enter description here](/img/1578453790169.png)\n![enter description here](/img/1578454203406.png)\n![enter description here](/img/1578454302221.png)","source":"_posts/天天生鲜项目实例P2.md","raw":"---\ntitle: 天天生鲜项目实例P2\ncategories:\n- Python\ntags: \n- Python\n- Note\n- Django\n- 实例\n---\n\n## 首页模块\n\n\n**IndexView中加入信息**\n\n在goods/views.py加入indexview的功能\n\n```python\nfrom django.urls import path\nfrom .views import IndexView\n\napp_name = 'goods'\nurlpatterns = [\n    path('', IndexView.as_view() ,name='index')\n]\n\n```\n\n```python\nfrom django.core.paginator import Paginator\nfrom django.shortcuts import render, redirect, reverse\nfrom django.views.generic.base import View\nfrom django_redis import get_redis_connection\nfrom django.core.cache import cache\nfrom goods.models import GoodsType, IndexGoodsBanner, IndexTypeGoodsBanner, IndexPromotionBanner, GoodsSKU\nfrom order.models import OrderGoods\n\nclass IndexView(View):\n    def get(self, request):\n        # get all goods type\n        types = GoodsType.objects.all()\n\n        # 获取首页轮播商品信息\n        goods_banners = IndexGoodsBanner.objects.all().order_by('index')\n\n        # 获取促销信息\n        promotion_banners = IndexPromotionBanner.objects.all().order_by('index')\n\n        # 获取分类商品展示信息\n        for type in types:\n            #获取图片类的banner展示信息\n            image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1)\n            #获取文字类的banner展示信息\n            title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0)\n\n            #添加属性\n            type.image_banners = image_banners\n            type.title_banners = title_banners\n\n        #获取用户购物车中的商品数目\n        user = request.user\n        cart_count = 0\n\n        if user.is_authenticated:\n            # 用户已登录有授权\n            conn = get_redis_connection('default')\n            cart_key = 'cart_%d'%user.id\n            cart_count = conn.hlen(cart_key)\n\n        # 组织上下文\n        context = {\n            'types':types,\n            'goods_banners':goods_banners,\n            'promotion_banners':promotion_banners,\n            'cart_count':cart_count\n        }\n\n        # 使用模板\n        return render(request, 'index.html', context)\n\n```\n\n**使用celery生成Index的static文件**\n\n新建任务：\n\n> 注意：\n> 1.from goods.models 要在django.setup之后\n> 2.worker端的fdfs_client需要升级到Python3的exception写法。\n> 3.worker端的fdfs_client考虑先将utils的import注释\n\n```python\n@app.task\ndef generate_static_index_html():\n    # get all goods type\n    types = GoodsType.objects.all()\n\n    # 获取首页轮播商品信息\n    goods_banners = IndexGoodsBanner.objects.all().order_by('index')\n\n    # 获取促销信息\n    promotion_banners = IndexPromotionBanner.objects.all().order_by('index')\n\n    # 获取分类商品展示信息\n    for type in types:\n        # 获取图片类的banner展示信息\n        image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1)\n        # 获取文字类的banner展示信息\n        title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0)\n\n        # 添加属性\n        type.image_banners = image_banners\n        type.title_banners = title_banners\n\n    # 组织上下文\n    context = {\n        'types': types,\n        'goods_banners': goods_banners,\n        'promotion_banners': promotion_banners,\n    }\n\n    # 使用模板\n    # 1.加载模板文件\n    temp = loader.get_template('static_index.html')\n    # 2.渲染\n    static_index_html = temp.render(context)\n\n    # 生成首页的静态文件\n    save_path = os.path.join(settings.BASE_DIR, 'static/index.html')\n    with open(save_path, 'w') as f:\n        f.write(static_index_html)\n```\n\n![流程](/img/1576549292557.png)\n\n**在admin的委托返回调用中，执行celery**\n\n在goods的admin.py中监听一下admin后台的save和delete操作，然后执行celery刷新内容返回。\n\n![执行流程](/img/1576551196217.png)\n\n 在admin.py中加入\n\n```python\nclass BaseModelAdmin(admin.ModelAdmin):\n    def save_model(self, request, obj, form, change):\n        # 先执行数据库操作\n        super().save_model(request, obj, form, change)\n\n        # 发送celery事件\n        from celery_tasks.tasks import generate_static_index_html\n        generate_static_index_html.delay()\n\n    def delete_model(self, request, obj):\n        # 先执行数据库操作\n        super().delete_model(request, obj)\n\n        # 发送celery事件\n        from celery_tasks.tasks import generate_static_index_html\n        generate_static_index_html.delay()\n```\n\n> 遇到问题： 第一次修改后，celery生成的页面太快了，还没等save-model结束，因此查出来的数据是旧的。下一次又可以刷出最新数据\n> 方案：在celery里加入一个等待，保证model已经处理完数据库了，这样celery任务可以查到最新的结果。\n\n**将index页面的两种获取方式调度起来**\n\n![静态页面的调度](/img/1576554364999.png)\n\n**使用django的缓存机制存储页面**\n\nhttps://docs.djangoproject.com/zh-hans/3.0/topics/cache/\n\n* 存储\n\n```python\ncache.set()\npass\ncache.get()\n```\n\n* 更新\n在admin.py里进行清空缓存\n\n```python\n        # 清缓存\n        cache.delete(index_cache_key)\n```\n\n> 小结：缓存机制的目的之一在于防止黑客利用各多台电脑进行访问型攻击（DDOS），缓存通过减少数据库的查询次数，实现对性能的优化。\n\n![缓存机制](/img/1576636756891.png)\n\n**使用redis存储购物车数据**\n\n![讨论](/img/1576722037256.png)\n\n\n## 商品详情页面\n\n**1.views.py 为页面添加必要数据**\n\n```python\n# 商品详情页\n    def get(self, request, goods_id):\n\n        try:\n            # 拿商品SKU\n            good_sku = GoodsSKU.objects.get(id=goods_id)\n        except GoodsSKU.DoesNotExist:\n            return redirect(reverse(\"goods:index\"))\n\n        # 拿所有类型\n        all_good_types = GoodsType.objects.all()\n\n        # 拿商品评论并排除掉commit为空的\n        sku_orders = OrderGoods.objects.filter(sku=good_sku).exclude(comment='')\n\n        # 拿同类型的商品（以时间倒序）\n        new_skus = GoodsSKU.objects.filter(type=good_sku.type).order_by(\"-create_time\")\n\n        # 获取购物车数量\n        user = request.user\n        cart_count = 0\n\n        if user.is_authenticated:\n            # 用户已登录有授权\n            conn = get_redis_connection('default')\n            cart_key = 'cart_%d' % user.id\n            cart_count = conn.hlen(cart_key)\n\n        # 上下文组织，sku,types, sku_orders, new_skus, cart_count\n        context = {\n            \"sku\": good_sku,\n            \"types\": all_good_types,\n            \"sku_orders\": sku_orders,\n            \"new_skus\": new_skus,\n            \"cart_count\": cart_count\n        }\n\n        return render(request, 'detail.html',context)\n```\n\n**2.页面编辑**\n\n使用双curly braces（放变量）或百分号的curly braces（放语句）\n\n forloop.counter来获取循环当前的ID\n\n**3.关闭escape转义**\n\n1.使用autoescape off来关闭转义，\n\n![关闭转义](/img/1576810604102.png)\n\n2.使用| safe来关闭转义\n\n![用safe关闭转义](/img/1576810673369.png)\n\n\n## 商品列表页\n\n**分析页面**\n\n> 使用/list/type/page?sort=default 这种地址来设计\n\n**分页的功能实现**\n\n> 使用Paginator分页来查询分页\n\n**路径传递方式**\n\n![路径传递方式](/img/1577414335373.png)\n\n**页码控制**\n\n![控制显示的页码](/img/1577414816762.png)\n\n> 遇到一个问题：get误写成filter，后果就是把这些结果放里面搜索会报 The QuerySet value for an exact lookup must be limited to one result using slicing. 以后需要注意\n\n\n**搜索引擎与全文检索**\n\n使用haystack的全文检索框架，whoosh的搜索引擎\n\n![结构分析](/img/1578122441016.png)\n\n![全文检索](/img/1578122530429.png)\n\n\n* 安装和配置\n\n![安装](/img/1578122591339.png)\n\n![配置haystack](/img/1578122991267.png)\n\n>haystack默认安装无如下内容，需按情况配置\n![配置](/img/1578123391128.png)\n\n> 索引文件生成：\n![索引文件生成：](/img/1578123481409.png)\n\n\n[官网](https://django-haystack.readthedocs.io/en/master/signal_processors.html)\n\n\n![索引类定义](/img/1578365001196.png)\n![建立索引](/img/1578377646492.png)\n\n改成如下：\n\n```python\n# 定义索引类\n\nfrom haystack import indexes\n# 导入模型类\nfrom goods.models import GoodsSKU\n\n#指定类建立索引\nclass GoodsSKUIndex(indexes.SearchIndex, indexes.Indexable):\n    # 索引字段， use_template表明把哪些字段建立索引文件（使用一个模板文件来说明）\n    text = indexes.CharField(document=True, use_template=True)\n\n    def get_model(self):\n        return GoodsSKU\n\n    def index_queryset(self, using=None):\n        return self.get_model().objects.all()\n```\n\n> 手动建立模型文件\ntemplates / search / indexes / 【app】 / 【模型类全小写】_text.txt\n\n![全文检索](/img/1578378838931.png)\n\n\n* 使用\n\n![结果](/img/1578378917671.png)\n> 表单中，参数名：q为写死的。method=‘get’是写死的\nurl的路径配置必须也是haystack.urls模块\n\n> 改变分词方式：\n![改变分词方式](/img/1578379986297.png)\n\n创建ChineseAnalyzer.py，写入：\n\n![内容截图](/img/1578380200054.png)\n![内容截图2](/img/1578380227603.png)\n\n![更改默认分析](/img/1578380391307.png)\n\n![更新分词方式](/img/1578380648851.png)\n\n> 总结： 选一个全文搜索的框架，如这里的haystack（django内置的），再找一个搜索引擎，如这里的whoosh引擎， 使用时会生成index文件，一般在配置中指明。在执行搜索时，引擎会在Index中查找。 另外也可以为其指定一个分词规则，如这里的jieba，这样可以根据分词来生成搜索。\n\n\n## 购物车模块\n\n**商品详情个数的JS**\n\n```js\nupdate_price();\nfunction update_price(){\n\tprice = $('.show_pirze').children('em').text();\n\tcount = $('.num_show').val();\n\n\tprice = parseFloat(price);\n\tcount = parseInt(count);\n\tamount = price * count;\n\t$('.total').children('em').text(amount.toFixed(2)+'元');//保留两位小数\n}\n$('.add').click(function () {\n\tcount = $('.num_show').val();\n\tcount = parseInt(count)+1;\n\t$('.num_show').val(count);\n\tupdate_price();\n});\n\n$('.minus').click(function () {\n\tcount = $('.num_show').val();\n\tcount = parseInt(count)-1;\n\tif(count <= 0){\n\t\treturn;\n\t}\n\t$('.num_show').val(count);\n\tupdate_price();\n});\n```\n\n**购物车添加的请求设计**\n\n流程：\n1. 采用ajax， post请求\n2. 传递参数，商品ID，数量\n\n> 目前为止，有post,get,url三种类型的请求类型，\n> 对于访问数据为主的参数，一般使用get请求\n> 对于涉及增删改的参数，一般使用post请求。\n\n> 另外，django防止csrf的方式，默认打开csrf中间件，post提交时加上csrf token标签\n![csrf生成的代码](/img/1578454158486.png)\n> Ajax发起的请求都在后台，在浏览器看不到效果\n> 前后端合作过程中，得确定好请求方式和参数\n\n![enter description here](/img/1578453777774.png)\n![enter description here](/img/1578453790169.png)\n![enter description here](/img/1578454203406.png)\n![enter description here](/img/1578454302221.png)","slug":"天天生鲜项目实例P2","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh11o00414wf0jwtg4uef","content":"<h2 id=\"首页模块\"><a href=\"#首页模块\" class=\"headerlink\" title=\"首页模块\"></a>首页模块</h2><p><strong>IndexView中加入信息</strong></p>\n<p>在goods/views.py加入indexview的功能</p>\n<pre><code class=\"python\">from django.urls import path\nfrom .views import IndexView\n\napp_name = &#39;goods&#39;\nurlpatterns = [\n    path(&#39;&#39;, IndexView.as_view() ,name=&#39;index&#39;)\n]\n</code></pre>\n<pre><code class=\"python\">from django.core.paginator import Paginator\nfrom django.shortcuts import render, redirect, reverse\nfrom django.views.generic.base import View\nfrom django_redis import get_redis_connection\nfrom django.core.cache import cache\nfrom goods.models import GoodsType, IndexGoodsBanner, IndexTypeGoodsBanner, IndexPromotionBanner, GoodsSKU\nfrom order.models import OrderGoods\n\nclass IndexView(View):\n    def get(self, request):\n        # get all goods type\n        types = GoodsType.objects.all()\n\n        # 获取首页轮播商品信息\n        goods_banners = IndexGoodsBanner.objects.all().order_by(&#39;index&#39;)\n\n        # 获取促销信息\n        promotion_banners = IndexPromotionBanner.objects.all().order_by(&#39;index&#39;)\n\n        # 获取分类商品展示信息\n        for type in types:\n            #获取图片类的banner展示信息\n            image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1)\n            #获取文字类的banner展示信息\n            title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0)\n\n            #添加属性\n            type.image_banners = image_banners\n            type.title_banners = title_banners\n\n        #获取用户购物车中的商品数目\n        user = request.user\n        cart_count = 0\n\n        if user.is_authenticated:\n            # 用户已登录有授权\n            conn = get_redis_connection(&#39;default&#39;)\n            cart_key = &#39;cart_%d&#39;%user.id\n            cart_count = conn.hlen(cart_key)\n\n        # 组织上下文\n        context = {\n            &#39;types&#39;:types,\n            &#39;goods_banners&#39;:goods_banners,\n            &#39;promotion_banners&#39;:promotion_banners,\n            &#39;cart_count&#39;:cart_count\n        }\n\n        # 使用模板\n        return render(request, &#39;index.html&#39;, context)\n</code></pre>\n<p><strong>使用celery生成Index的static文件</strong></p>\n<p>新建任务：</p>\n<blockquote>\n<p>注意：<br>1.from goods.models 要在django.setup之后<br>2.worker端的fdfs_client需要升级到Python3的exception写法。<br>3.worker端的fdfs_client考虑先将utils的import注释</p>\n</blockquote>\n<pre><code class=\"python\">@app.task\ndef generate_static_index_html():\n    # get all goods type\n    types = GoodsType.objects.all()\n\n    # 获取首页轮播商品信息\n    goods_banners = IndexGoodsBanner.objects.all().order_by(&#39;index&#39;)\n\n    # 获取促销信息\n    promotion_banners = IndexPromotionBanner.objects.all().order_by(&#39;index&#39;)\n\n    # 获取分类商品展示信息\n    for type in types:\n        # 获取图片类的banner展示信息\n        image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1)\n        # 获取文字类的banner展示信息\n        title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0)\n\n        # 添加属性\n        type.image_banners = image_banners\n        type.title_banners = title_banners\n\n    # 组织上下文\n    context = {\n        &#39;types&#39;: types,\n        &#39;goods_banners&#39;: goods_banners,\n        &#39;promotion_banners&#39;: promotion_banners,\n    }\n\n    # 使用模板\n    # 1.加载模板文件\n    temp = loader.get_template(&#39;static_index.html&#39;)\n    # 2.渲染\n    static_index_html = temp.render(context)\n\n    # 生成首页的静态文件\n    save_path = os.path.join(settings.BASE_DIR, &#39;static/index.html&#39;)\n    with open(save_path, &#39;w&#39;) as f:\n        f.write(static_index_html)</code></pre>\n<p><img src=\"/img/1576549292557.png\" alt=\"流程\"></p>\n<p><strong>在admin的委托返回调用中，执行celery</strong></p>\n<p>在goods的admin.py中监听一下admin后台的save和delete操作，然后执行celery刷新内容返回。</p>\n<p><img src=\"/img/1576551196217.png\" alt=\"执行流程\"></p>\n<p> 在admin.py中加入</p>\n<pre><code class=\"python\">class BaseModelAdmin(admin.ModelAdmin):\n    def save_model(self, request, obj, form, change):\n        # 先执行数据库操作\n        super().save_model(request, obj, form, change)\n\n        # 发送celery事件\n        from celery_tasks.tasks import generate_static_index_html\n        generate_static_index_html.delay()\n\n    def delete_model(self, request, obj):\n        # 先执行数据库操作\n        super().delete_model(request, obj)\n\n        # 发送celery事件\n        from celery_tasks.tasks import generate_static_index_html\n        generate_static_index_html.delay()</code></pre>\n<blockquote>\n<p>遇到问题： 第一次修改后，celery生成的页面太快了，还没等save-model结束，因此查出来的数据是旧的。下一次又可以刷出最新数据<br>方案：在celery里加入一个等待，保证model已经处理完数据库了，这样celery任务可以查到最新的结果。</p>\n</blockquote>\n<p><strong>将index页面的两种获取方式调度起来</strong></p>\n<p><img src=\"/img/1576554364999.png\" alt=\"静态页面的调度\"></p>\n<p><strong>使用django的缓存机制存储页面</strong></p>\n<p><a href=\"https://docs.djangoproject.com/zh-hans/3.0/topics/cache/\">https://docs.djangoproject.com/zh-hans/3.0/topics/cache/</a></p>\n<ul>\n<li>存储</li>\n</ul>\n<pre><code class=\"python\">cache.set()\npass\ncache.get()</code></pre>\n<ul>\n<li>更新<br>在admin.py里进行清空缓存</li>\n</ul>\n<pre><code class=\"python\">        # 清缓存\n        cache.delete(index_cache_key)</code></pre>\n<blockquote>\n<p>小结：缓存机制的目的之一在于防止黑客利用各多台电脑进行访问型攻击（DDOS），缓存通过减少数据库的查询次数，实现对性能的优化。</p>\n</blockquote>\n<p><img src=\"/img/1576636756891.png\" alt=\"缓存机制\"></p>\n<p><strong>使用redis存储购物车数据</strong></p>\n<p><img src=\"/img/1576722037256.png\" alt=\"讨论\"></p>\n<h2 id=\"商品详情页面\"><a href=\"#商品详情页面\" class=\"headerlink\" title=\"商品详情页面\"></a>商品详情页面</h2><p><strong>1.views.py 为页面添加必要数据</strong></p>\n<pre><code class=\"python\"># 商品详情页\n    def get(self, request, goods_id):\n\n        try:\n            # 拿商品SKU\n            good_sku = GoodsSKU.objects.get(id=goods_id)\n        except GoodsSKU.DoesNotExist:\n            return redirect(reverse(&quot;goods:index&quot;))\n\n        # 拿所有类型\n        all_good_types = GoodsType.objects.all()\n\n        # 拿商品评论并排除掉commit为空的\n        sku_orders = OrderGoods.objects.filter(sku=good_sku).exclude(comment=&#39;&#39;)\n\n        # 拿同类型的商品（以时间倒序）\n        new_skus = GoodsSKU.objects.filter(type=good_sku.type).order_by(&quot;-create_time&quot;)\n\n        # 获取购物车数量\n        user = request.user\n        cart_count = 0\n\n        if user.is_authenticated:\n            # 用户已登录有授权\n            conn = get_redis_connection(&#39;default&#39;)\n            cart_key = &#39;cart_%d&#39; % user.id\n            cart_count = conn.hlen(cart_key)\n\n        # 上下文组织，sku,types, sku_orders, new_skus, cart_count\n        context = {\n            &quot;sku&quot;: good_sku,\n            &quot;types&quot;: all_good_types,\n            &quot;sku_orders&quot;: sku_orders,\n            &quot;new_skus&quot;: new_skus,\n            &quot;cart_count&quot;: cart_count\n        }\n\n        return render(request, &#39;detail.html&#39;,context)</code></pre>\n<p><strong>2.页面编辑</strong></p>\n<p>使用双curly braces（放变量）或百分号的curly braces（放语句）</p>\n<p> forloop.counter来获取循环当前的ID</p>\n<p><strong>3.关闭escape转义</strong></p>\n<p>1.使用autoescape off来关闭转义，</p>\n<p><img src=\"/img/1576810604102.png\" alt=\"关闭转义\"></p>\n<p>2.使用| safe来关闭转义</p>\n<p><img src=\"/img/1576810673369.png\" alt=\"用safe关闭转义\"></p>\n<h2 id=\"商品列表页\"><a href=\"#商品列表页\" class=\"headerlink\" title=\"商品列表页\"></a>商品列表页</h2><p><strong>分析页面</strong></p>\n<blockquote>\n<p>使用/list/type/page?sort=default 这种地址来设计</p>\n</blockquote>\n<p><strong>分页的功能实现</strong></p>\n<blockquote>\n<p>使用Paginator分页来查询分页</p>\n</blockquote>\n<p><strong>路径传递方式</strong></p>\n<p><img src=\"/img/1577414335373.png\" alt=\"路径传递方式\"></p>\n<p><strong>页码控制</strong></p>\n<p><img src=\"/img/1577414816762.png\" alt=\"控制显示的页码\"></p>\n<blockquote>\n<p>遇到一个问题：get误写成filter，后果就是把这些结果放里面搜索会报 The QuerySet value for an exact lookup must be limited to one result using slicing. 以后需要注意</p>\n</blockquote>\n<p><strong>搜索引擎与全文检索</strong></p>\n<p>使用haystack的全文检索框架，whoosh的搜索引擎</p>\n<p><img src=\"/img/1578122441016.png\" alt=\"结构分析\"></p>\n<p><img src=\"/img/1578122530429.png\" alt=\"全文检索\"></p>\n<ul>\n<li>安装和配置</li>\n</ul>\n<p><img src=\"/img/1578122591339.png\" alt=\"安装\"></p>\n<p><img src=\"/img/1578122991267.png\" alt=\"配置haystack\"></p>\n<blockquote>\n<p>haystack默认安装无如下内容，需按情况配置<br><img src=\"/img/1578123391128.png\" alt=\"配置\"></p>\n</blockquote>\n<blockquote>\n<p>索引文件生成：<br><img src=\"/img/1578123481409.png\" alt=\"索引文件生成：\"></p>\n</blockquote>\n<p><a href=\"https://django-haystack.readthedocs.io/en/master/signal_processors.html\">官网</a></p>\n<p><img src=\"/img/1578365001196.png\" alt=\"索引类定义\"><br><img src=\"/img/1578377646492.png\" alt=\"建立索引\"></p>\n<p>改成如下：</p>\n<pre><code class=\"python\"># 定义索引类\n\nfrom haystack import indexes\n# 导入模型类\nfrom goods.models import GoodsSKU\n\n#指定类建立索引\nclass GoodsSKUIndex(indexes.SearchIndex, indexes.Indexable):\n    # 索引字段， use_template表明把哪些字段建立索引文件（使用一个模板文件来说明）\n    text = indexes.CharField(document=True, use_template=True)\n\n    def get_model(self):\n        return GoodsSKU\n\n    def index_queryset(self, using=None):\n        return self.get_model().objects.all()</code></pre>\n<blockquote>\n<p>手动建立模型文件<br>templates / search / indexes / 【app】 / 【模型类全小写】_text.txt</p>\n</blockquote>\n<p><img src=\"/img/1578378838931.png\" alt=\"全文检索\"></p>\n<ul>\n<li>使用</li>\n</ul>\n<p><img src=\"/img/1578378917671.png\" alt=\"结果\"></p>\n<blockquote>\n<p>表单中，参数名：q为写死的。method=‘get’是写死的<br>url的路径配置必须也是haystack.urls模块</p>\n</blockquote>\n<blockquote>\n<p>改变分词方式：<br><img src=\"/img/1578379986297.png\" alt=\"改变分词方式\"></p>\n</blockquote>\n<p>创建ChineseAnalyzer.py，写入：</p>\n<p><img src=\"/img/1578380200054.png\" alt=\"内容截图\"><br><img src=\"/img/1578380227603.png\" alt=\"内容截图2\"></p>\n<p><img src=\"/img/1578380391307.png\" alt=\"更改默认分析\"></p>\n<p><img src=\"/img/1578380648851.png\" alt=\"更新分词方式\"></p>\n<blockquote>\n<p>总结： 选一个全文搜索的框架，如这里的haystack（django内置的），再找一个搜索引擎，如这里的whoosh引擎， 使用时会生成index文件，一般在配置中指明。在执行搜索时，引擎会在Index中查找。 另外也可以为其指定一个分词规则，如这里的jieba，这样可以根据分词来生成搜索。</p>\n</blockquote>\n<h2 id=\"购物车模块\"><a href=\"#购物车模块\" class=\"headerlink\" title=\"购物车模块\"></a>购物车模块</h2><p><strong>商品详情个数的JS</strong></p>\n<pre><code class=\"js\">update_price();\nfunction update_price(){\n    price = $(&#39;.show_pirze&#39;).children(&#39;em&#39;).text();\n    count = $(&#39;.num_show&#39;).val();\n\n    price = parseFloat(price);\n    count = parseInt(count);\n    amount = price * count;\n    $(&#39;.total&#39;).children(&#39;em&#39;).text(amount.toFixed(2)+&#39;元&#39;);//保留两位小数\n}\n$(&#39;.add&#39;).click(function () {\n    count = $(&#39;.num_show&#39;).val();\n    count = parseInt(count)+1;\n    $(&#39;.num_show&#39;).val(count);\n    update_price();\n});\n\n$(&#39;.minus&#39;).click(function () {\n    count = $(&#39;.num_show&#39;).val();\n    count = parseInt(count)-1;\n    if(count &lt;= 0){\n        return;\n    }\n    $(&#39;.num_show&#39;).val(count);\n    update_price();\n});</code></pre>\n<p><strong>购物车添加的请求设计</strong></p>\n<p>流程：</p>\n<ol>\n<li>采用ajax， post请求</li>\n<li>传递参数，商品ID，数量</li>\n</ol>\n<blockquote>\n<p>目前为止，有post,get,url三种类型的请求类型，<br>对于访问数据为主的参数，一般使用get请求<br>对于涉及增删改的参数，一般使用post请求。</p>\n</blockquote>\n<blockquote>\n<p>另外，django防止csrf的方式，默认打开csrf中间件，post提交时加上csrf token标签<br><img src=\"/img/1578454158486.png\" alt=\"csrf生成的代码\"><br>Ajax发起的请求都在后台，在浏览器看不到效果<br>前后端合作过程中，得确定好请求方式和参数</p>\n</blockquote>\n<p><img src=\"/img/1578453777774.png\" alt=\"enter description here\"><br><img src=\"/img/1578453790169.png\" alt=\"enter description here\"><br><img src=\"/img/1578454203406.png\" alt=\"enter description here\"><br><img src=\"/img/1578454302221.png\" alt=\"enter description here\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"首页模块\"><a href=\"#首页模块\" class=\"headerlink\" title=\"首页模块\"></a>首页模块</h2><p><strong>IndexView中加入信息</strong></p>\n<p>在goods/views.py加入indexview的功能</p>\n<pre><code class=\"python\">from django.urls import path\nfrom .views import IndexView\n\napp_name = &#39;goods&#39;\nurlpatterns = [\n    path(&#39;&#39;, IndexView.as_view() ,name=&#39;index&#39;)\n]\n</code></pre>\n<pre><code class=\"python\">from django.core.paginator import Paginator\nfrom django.shortcuts import render, redirect, reverse\nfrom django.views.generic.base import View\nfrom django_redis import get_redis_connection\nfrom django.core.cache import cache\nfrom goods.models import GoodsType, IndexGoodsBanner, IndexTypeGoodsBanner, IndexPromotionBanner, GoodsSKU\nfrom order.models import OrderGoods\n\nclass IndexView(View):\n    def get(self, request):\n        # get all goods type\n        types = GoodsType.objects.all()\n\n        # 获取首页轮播商品信息\n        goods_banners = IndexGoodsBanner.objects.all().order_by(&#39;index&#39;)\n\n        # 获取促销信息\n        promotion_banners = IndexPromotionBanner.objects.all().order_by(&#39;index&#39;)\n\n        # 获取分类商品展示信息\n        for type in types:\n            #获取图片类的banner展示信息\n            image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1)\n            #获取文字类的banner展示信息\n            title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0)\n\n            #添加属性\n            type.image_banners = image_banners\n            type.title_banners = title_banners\n\n        #获取用户购物车中的商品数目\n        user = request.user\n        cart_count = 0\n\n        if user.is_authenticated:\n            # 用户已登录有授权\n            conn = get_redis_connection(&#39;default&#39;)\n            cart_key = &#39;cart_%d&#39;%user.id\n            cart_count = conn.hlen(cart_key)\n\n        # 组织上下文\n        context = {\n            &#39;types&#39;:types,\n            &#39;goods_banners&#39;:goods_banners,\n            &#39;promotion_banners&#39;:promotion_banners,\n            &#39;cart_count&#39;:cart_count\n        }\n\n        # 使用模板\n        return render(request, &#39;index.html&#39;, context)\n</code></pre>\n<p><strong>使用celery生成Index的static文件</strong></p>\n<p>新建任务：</p>\n<blockquote>\n<p>注意：<br>1.from goods.models 要在django.setup之后<br>2.worker端的fdfs_client需要升级到Python3的exception写法。<br>3.worker端的fdfs_client考虑先将utils的import注释</p>\n</blockquote>\n<pre><code class=\"python\">@app.task\ndef generate_static_index_html():\n    # get all goods type\n    types = GoodsType.objects.all()\n\n    # 获取首页轮播商品信息\n    goods_banners = IndexGoodsBanner.objects.all().order_by(&#39;index&#39;)\n\n    # 获取促销信息\n    promotion_banners = IndexPromotionBanner.objects.all().order_by(&#39;index&#39;)\n\n    # 获取分类商品展示信息\n    for type in types:\n        # 获取图片类的banner展示信息\n        image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1)\n        # 获取文字类的banner展示信息\n        title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=0)\n\n        # 添加属性\n        type.image_banners = image_banners\n        type.title_banners = title_banners\n\n    # 组织上下文\n    context = {\n        &#39;types&#39;: types,\n        &#39;goods_banners&#39;: goods_banners,\n        &#39;promotion_banners&#39;: promotion_banners,\n    }\n\n    # 使用模板\n    # 1.加载模板文件\n    temp = loader.get_template(&#39;static_index.html&#39;)\n    # 2.渲染\n    static_index_html = temp.render(context)\n\n    # 生成首页的静态文件\n    save_path = os.path.join(settings.BASE_DIR, &#39;static/index.html&#39;)\n    with open(save_path, &#39;w&#39;) as f:\n        f.write(static_index_html)</code></pre>\n<p><img src=\"/img/1576549292557.png\" alt=\"流程\"></p>\n<p><strong>在admin的委托返回调用中，执行celery</strong></p>\n<p>在goods的admin.py中监听一下admin后台的save和delete操作，然后执行celery刷新内容返回。</p>\n<p><img src=\"/img/1576551196217.png\" alt=\"执行流程\"></p>\n<p> 在admin.py中加入</p>\n<pre><code class=\"python\">class BaseModelAdmin(admin.ModelAdmin):\n    def save_model(self, request, obj, form, change):\n        # 先执行数据库操作\n        super().save_model(request, obj, form, change)\n\n        # 发送celery事件\n        from celery_tasks.tasks import generate_static_index_html\n        generate_static_index_html.delay()\n\n    def delete_model(self, request, obj):\n        # 先执行数据库操作\n        super().delete_model(request, obj)\n\n        # 发送celery事件\n        from celery_tasks.tasks import generate_static_index_html\n        generate_static_index_html.delay()</code></pre>\n<blockquote>\n<p>遇到问题： 第一次修改后，celery生成的页面太快了，还没等save-model结束，因此查出来的数据是旧的。下一次又可以刷出最新数据<br>方案：在celery里加入一个等待，保证model已经处理完数据库了，这样celery任务可以查到最新的结果。</p>\n</blockquote>\n<p><strong>将index页面的两种获取方式调度起来</strong></p>\n<p><img src=\"/img/1576554364999.png\" alt=\"静态页面的调度\"></p>\n<p><strong>使用django的缓存机制存储页面</strong></p>\n<p><a href=\"https://docs.djangoproject.com/zh-hans/3.0/topics/cache/\">https://docs.djangoproject.com/zh-hans/3.0/topics/cache/</a></p>\n<ul>\n<li>存储</li>\n</ul>\n<pre><code class=\"python\">cache.set()\npass\ncache.get()</code></pre>\n<ul>\n<li>更新<br>在admin.py里进行清空缓存</li>\n</ul>\n<pre><code class=\"python\">        # 清缓存\n        cache.delete(index_cache_key)</code></pre>\n<blockquote>\n<p>小结：缓存机制的目的之一在于防止黑客利用各多台电脑进行访问型攻击（DDOS），缓存通过减少数据库的查询次数，实现对性能的优化。</p>\n</blockquote>\n<p><img src=\"/img/1576636756891.png\" alt=\"缓存机制\"></p>\n<p><strong>使用redis存储购物车数据</strong></p>\n<p><img src=\"/img/1576722037256.png\" alt=\"讨论\"></p>\n<h2 id=\"商品详情页面\"><a href=\"#商品详情页面\" class=\"headerlink\" title=\"商品详情页面\"></a>商品详情页面</h2><p><strong>1.views.py 为页面添加必要数据</strong></p>\n<pre><code class=\"python\"># 商品详情页\n    def get(self, request, goods_id):\n\n        try:\n            # 拿商品SKU\n            good_sku = GoodsSKU.objects.get(id=goods_id)\n        except GoodsSKU.DoesNotExist:\n            return redirect(reverse(&quot;goods:index&quot;))\n\n        # 拿所有类型\n        all_good_types = GoodsType.objects.all()\n\n        # 拿商品评论并排除掉commit为空的\n        sku_orders = OrderGoods.objects.filter(sku=good_sku).exclude(comment=&#39;&#39;)\n\n        # 拿同类型的商品（以时间倒序）\n        new_skus = GoodsSKU.objects.filter(type=good_sku.type).order_by(&quot;-create_time&quot;)\n\n        # 获取购物车数量\n        user = request.user\n        cart_count = 0\n\n        if user.is_authenticated:\n            # 用户已登录有授权\n            conn = get_redis_connection(&#39;default&#39;)\n            cart_key = &#39;cart_%d&#39; % user.id\n            cart_count = conn.hlen(cart_key)\n\n        # 上下文组织，sku,types, sku_orders, new_skus, cart_count\n        context = {\n            &quot;sku&quot;: good_sku,\n            &quot;types&quot;: all_good_types,\n            &quot;sku_orders&quot;: sku_orders,\n            &quot;new_skus&quot;: new_skus,\n            &quot;cart_count&quot;: cart_count\n        }\n\n        return render(request, &#39;detail.html&#39;,context)</code></pre>\n<p><strong>2.页面编辑</strong></p>\n<p>使用双curly braces（放变量）或百分号的curly braces（放语句）</p>\n<p> forloop.counter来获取循环当前的ID</p>\n<p><strong>3.关闭escape转义</strong></p>\n<p>1.使用autoescape off来关闭转义，</p>\n<p><img src=\"/img/1576810604102.png\" alt=\"关闭转义\"></p>\n<p>2.使用| safe来关闭转义</p>\n<p><img src=\"/img/1576810673369.png\" alt=\"用safe关闭转义\"></p>\n<h2 id=\"商品列表页\"><a href=\"#商品列表页\" class=\"headerlink\" title=\"商品列表页\"></a>商品列表页</h2><p><strong>分析页面</strong></p>\n<blockquote>\n<p>使用/list/type/page?sort=default 这种地址来设计</p>\n</blockquote>\n<p><strong>分页的功能实现</strong></p>\n<blockquote>\n<p>使用Paginator分页来查询分页</p>\n</blockquote>\n<p><strong>路径传递方式</strong></p>\n<p><img src=\"/img/1577414335373.png\" alt=\"路径传递方式\"></p>\n<p><strong>页码控制</strong></p>\n<p><img src=\"/img/1577414816762.png\" alt=\"控制显示的页码\"></p>\n<blockquote>\n<p>遇到一个问题：get误写成filter，后果就是把这些结果放里面搜索会报 The QuerySet value for an exact lookup must be limited to one result using slicing. 以后需要注意</p>\n</blockquote>\n<p><strong>搜索引擎与全文检索</strong></p>\n<p>使用haystack的全文检索框架，whoosh的搜索引擎</p>\n<p><img src=\"/img/1578122441016.png\" alt=\"结构分析\"></p>\n<p><img src=\"/img/1578122530429.png\" alt=\"全文检索\"></p>\n<ul>\n<li>安装和配置</li>\n</ul>\n<p><img src=\"/img/1578122591339.png\" alt=\"安装\"></p>\n<p><img src=\"/img/1578122991267.png\" alt=\"配置haystack\"></p>\n<blockquote>\n<p>haystack默认安装无如下内容，需按情况配置<br><img src=\"/img/1578123391128.png\" alt=\"配置\"></p>\n</blockquote>\n<blockquote>\n<p>索引文件生成：<br><img src=\"/img/1578123481409.png\" alt=\"索引文件生成：\"></p>\n</blockquote>\n<p><a href=\"https://django-haystack.readthedocs.io/en/master/signal_processors.html\">官网</a></p>\n<p><img src=\"/img/1578365001196.png\" alt=\"索引类定义\"><br><img src=\"/img/1578377646492.png\" alt=\"建立索引\"></p>\n<p>改成如下：</p>\n<pre><code class=\"python\"># 定义索引类\n\nfrom haystack import indexes\n# 导入模型类\nfrom goods.models import GoodsSKU\n\n#指定类建立索引\nclass GoodsSKUIndex(indexes.SearchIndex, indexes.Indexable):\n    # 索引字段， use_template表明把哪些字段建立索引文件（使用一个模板文件来说明）\n    text = indexes.CharField(document=True, use_template=True)\n\n    def get_model(self):\n        return GoodsSKU\n\n    def index_queryset(self, using=None):\n        return self.get_model().objects.all()</code></pre>\n<blockquote>\n<p>手动建立模型文件<br>templates / search / indexes / 【app】 / 【模型类全小写】_text.txt</p>\n</blockquote>\n<p><img src=\"/img/1578378838931.png\" alt=\"全文检索\"></p>\n<ul>\n<li>使用</li>\n</ul>\n<p><img src=\"/img/1578378917671.png\" alt=\"结果\"></p>\n<blockquote>\n<p>表单中，参数名：q为写死的。method=‘get’是写死的<br>url的路径配置必须也是haystack.urls模块</p>\n</blockquote>\n<blockquote>\n<p>改变分词方式：<br><img src=\"/img/1578379986297.png\" alt=\"改变分词方式\"></p>\n</blockquote>\n<p>创建ChineseAnalyzer.py，写入：</p>\n<p><img src=\"/img/1578380200054.png\" alt=\"内容截图\"><br><img src=\"/img/1578380227603.png\" alt=\"内容截图2\"></p>\n<p><img src=\"/img/1578380391307.png\" alt=\"更改默认分析\"></p>\n<p><img src=\"/img/1578380648851.png\" alt=\"更新分词方式\"></p>\n<blockquote>\n<p>总结： 选一个全文搜索的框架，如这里的haystack（django内置的），再找一个搜索引擎，如这里的whoosh引擎， 使用时会生成index文件，一般在配置中指明。在执行搜索时，引擎会在Index中查找。 另外也可以为其指定一个分词规则，如这里的jieba，这样可以根据分词来生成搜索。</p>\n</blockquote>\n<h2 id=\"购物车模块\"><a href=\"#购物车模块\" class=\"headerlink\" title=\"购物车模块\"></a>购物车模块</h2><p><strong>商品详情个数的JS</strong></p>\n<pre><code class=\"js\">update_price();\nfunction update_price(){\n    price = $(&#39;.show_pirze&#39;).children(&#39;em&#39;).text();\n    count = $(&#39;.num_show&#39;).val();\n\n    price = parseFloat(price);\n    count = parseInt(count);\n    amount = price * count;\n    $(&#39;.total&#39;).children(&#39;em&#39;).text(amount.toFixed(2)+&#39;元&#39;);//保留两位小数\n}\n$(&#39;.add&#39;).click(function () {\n    count = $(&#39;.num_show&#39;).val();\n    count = parseInt(count)+1;\n    $(&#39;.num_show&#39;).val(count);\n    update_price();\n});\n\n$(&#39;.minus&#39;).click(function () {\n    count = $(&#39;.num_show&#39;).val();\n    count = parseInt(count)-1;\n    if(count &lt;= 0){\n        return;\n    }\n    $(&#39;.num_show&#39;).val(count);\n    update_price();\n});</code></pre>\n<p><strong>购物车添加的请求设计</strong></p>\n<p>流程：</p>\n<ol>\n<li>采用ajax， post请求</li>\n<li>传递参数，商品ID，数量</li>\n</ol>\n<blockquote>\n<p>目前为止，有post,get,url三种类型的请求类型，<br>对于访问数据为主的参数，一般使用get请求<br>对于涉及增删改的参数，一般使用post请求。</p>\n</blockquote>\n<blockquote>\n<p>另外，django防止csrf的方式，默认打开csrf中间件，post提交时加上csrf token标签<br><img src=\"/img/1578454158486.png\" alt=\"csrf生成的代码\"><br>Ajax发起的请求都在后台，在浏览器看不到效果<br>前后端合作过程中，得确定好请求方式和参数</p>\n</blockquote>\n<p><img src=\"/img/1578453777774.png\" alt=\"enter description here\"><br><img src=\"/img/1578453790169.png\" alt=\"enter description here\"><br><img src=\"/img/1578454203406.png\" alt=\"enter description here\"><br><img src=\"/img/1578454302221.png\" alt=\"enter description here\"></p>\n"},{"title":"开言_Bargaining in the market","_content":"\n\n### 预习\n1. souvenior\n+ 纪念品\n2. jeez\n+ 叹词\n3. no can do\n无能为力。\n\n\n### Dialog\n\n> Excuse me sir, how much is this souvenior?\n> Oh, that one there is $30.\n> Jeez! That's a lot! is that the best price you can give me?\n> I don't go bargaining. $25 is the cheapest I can go.\n> I see ,are you sure you can't go any lower?\n> Sorry , I can't, and you won't find a better price in the market.\n> How about two for 40?\n> No can do. But I can do three for 60.\n> Thanks, but no thanks.\n> Ok, ok! Two for 40!\n> Deal! You take credit?\n> Cash only , sir!\n\n\n### Dialog study","source":"_posts/开言_Bargaining in the market.md","raw":"---\ntitle: 开言_Bargaining in the market\ncategories:\n- 英语学习\ntags: \n- English\n- Note\n---\n\n\n### 预习\n1. souvenior\n+ 纪念品\n2. jeez\n+ 叹词\n3. no can do\n无能为力。\n\n\n### Dialog\n\n> Excuse me sir, how much is this souvenior?\n> Oh, that one there is $30.\n> Jeez! That's a lot! is that the best price you can give me?\n> I don't go bargaining. $25 is the cheapest I can go.\n> I see ,are you sure you can't go any lower?\n> Sorry , I can't, and you won't find a better price in the market.\n> How about two for 40?\n> No can do. But I can do three for 60.\n> Thanks, but no thanks.\n> Ok, ok! Two for 40!\n> Deal! You take credit?\n> Cash only , sir!\n\n\n### Dialog study","slug":"开言_Bargaining in the market","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh11p00444wf0hiaql9e5","content":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>souvenior</li>\n</ol>\n<ul>\n<li>纪念品</li>\n</ul>\n<ol start=\"2\">\n<li>jeez</li>\n</ol>\n<ul>\n<li>叹词</li>\n</ul>\n<ol start=\"3\">\n<li>no can do<br>无能为力。</li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><blockquote>\n<p>Excuse me sir, how much is this souvenior?<br>Oh, that one there is $30.<br>Jeez! That’s a lot! is that the best price you can give me?<br>I don’t go bargaining. $25 is the cheapest I can go.<br>I see ,are you sure you can’t go any lower?<br>Sorry , I can’t, and you won’t find a better price in the market.<br>How about two for 40?<br>No can do. But I can do three for 60.<br>Thanks, but no thanks.<br>Ok, ok! Two for 40!<br>Deal! You take credit?<br>Cash only , sir!</p>\n</blockquote>\n<h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>souvenior</li>\n</ol>\n<ul>\n<li>纪念品</li>\n</ul>\n<ol start=\"2\">\n<li>jeez</li>\n</ol>\n<ul>\n<li>叹词</li>\n</ul>\n<ol start=\"3\">\n<li>no can do<br>无能为力。</li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><blockquote>\n<p>Excuse me sir, how much is this souvenior?<br>Oh, that one there is $30.<br>Jeez! That’s a lot! is that the best price you can give me?<br>I don’t go bargaining. $25 is the cheapest I can go.<br>I see ,are you sure you can’t go any lower?<br>Sorry , I can’t, and you won’t find a better price in the market.<br>How about two for 40?<br>No can do. But I can do three for 60.<br>Thanks, but no thanks.<br>Ok, ok! Two for 40!<br>Deal! You take credit?<br>Cash only , sir!</p>\n</blockquote>\n<h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>"},{"title":"开言_Happy Hour Drinks with Coworks","_content":"\n\n### 预习\n1. six-pack\n2. all-time\n3. brand-new\n+ just bought.. very very new\n4. ex-wife\n+ wife\n5. buy one, get one\n\n\n### Dialog\n\n\n\n### Dialog study","source":"_posts/开言_Happy Hour Drinks with Coworks.md","raw":"---\ntitle: 开言_Happy Hour Drinks with Coworks\ncategories:\n- 英语学习\ntags: \n- English\n- Note\n---\n\n\n### 预习\n1. six-pack\n2. all-time\n3. brand-new\n+ just bought.. very very new\n4. ex-wife\n+ wife\n5. buy one, get one\n\n\n### Dialog\n\n\n\n### Dialog study","slug":"开言_Happy Hour Drinks with Coworks","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh12600494wf064cacvot","content":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>six-pack</li>\n<li>all-time</li>\n<li>brand-new</li>\n</ol>\n<ul>\n<li>just bought.. very very new</li>\n</ul>\n<ol start=\"4\">\n<li>ex-wife</li>\n</ol>\n<ul>\n<li>wife</li>\n</ul>\n<ol start=\"5\">\n<li>buy one, get one</li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>six-pack</li>\n<li>all-time</li>\n<li>brand-new</li>\n</ol>\n<ul>\n<li>just bought.. very very new</li>\n</ul>\n<ol start=\"4\">\n<li>ex-wife</li>\n</ol>\n<ul>\n<li>wife</li>\n</ul>\n<ol start=\"5\">\n<li>buy one, get one</li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>"},{"title":"开言","_content":"\n\n### 预习\n1. do you have a miniute\n2. been meaning to\n\tI've been meaning to go to the store to by milk.\n\t//Haven't dont it yet but you're doing it.\n3. MacDonald  - fastfood chains.\n4. \n\n\n### Dialog\n\n### Dialog study","source":"_posts/开言- To tip or not to tip.md","raw":"---\ntitle: 开言\ncategories:\n- 英语学习\ntags: \n- English\n- Note\n---\n\n\n### 预习\n1. do you have a miniute\n2. been meaning to\n\tI've been meaning to go to the store to by milk.\n\t//Haven't dont it yet but you're doing it.\n3. MacDonald  - fastfood chains.\n4. \n\n\n### Dialog\n\n### Dialog study","slug":"开言- To tip or not to tip","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh12a004c4wf0qduq4jiq","content":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>do you have a miniute</li>\n<li>been meaning to<br> I’ve been meaning to go to the store to by milk.<br> //Haven’t dont it yet but you’re doing it.</li>\n<li>MacDonald  - fastfood chains.</li>\n<li></li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>do you have a miniute</li>\n<li>been meaning to<br> I’ve been meaning to go to the store to by milk.<br> //Haven’t dont it yet but you’re doing it.</li>\n<li>MacDonald  - fastfood chains.</li>\n<li></li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>"},{"title":"常用单词学习","_content":"\n## colon\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30Anbf371a598eda69b4ccf46d35c7add5fc.mp3?t=colon\">\n      </audio>\n      \n+ 英 /ˈkəʊlən; ˈkəʊlɒn/  美 /ˈkoʊlən/  全球(美国)\nn. [解剖] 结肠；**冒号**（用于引语、说明、例证等之前）；科郎（哥斯达黎加货币单位）\n\n## quote\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30AQ4bbc942967962574bc81e020b01e1ba5.mp3?t=quote\">\n      </audio>\n\t  \n+ 英 /kwəʊt/  美 /kwoʊt/  全球(加拿大)  \nvt. 引述；引用；举例说明；报价；以……为证；为（企业的股份）上市\nvi. 引述；引用\nn. 引文；语录；开价；（股票）牌价；**引号**；（建筑或维修的）报价单\nn. (Quote) （美、俄、澳、马、荷）克奥特（人名）\n\n## apostrophe\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30SK8385e1c12f88cd501bf9c8ecfdef0800.mp3?t=apostrophe\">\n      </audio>\n\t  \n+ 英 /əˈpɒstrəfi/  美 /əˈpɑːstrəfi/  全球(英国)  \nn. 省略符号，撇号；呼语，顿呼\n\n## curly braces\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd309Bd6d78ac827a8d1b86b3bf601e93b4aaf.mp3?t=curly\">\n      </audio>\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30VP32b434afefd5946ee0ffb398b9d27f54.mp3?t=braces\">\n      </audio>\n\t  \n花括号\n\n## forward slash\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30eR83f990e90451dafef5a412ccdb12bd5b.mp3?t=slash\">\n      </audio>\n\t  \n斜杠（分隔号“/”）\n\n## back slash\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30eR83f990e90451dafef5a412ccdb12bd5b.mp3?t=slash\">\n      </audio>\n\t  \n正斜杠（分隔“\\”）\n\n## modulus\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30Ac9556257c524e8be83626de5de312dc40.mp3?t=modulus\">\n      </audio>\n\t  \n+ /'mɑdʒə,lai/ \nn. 模数；模（modulis 是复数）\n\n## asterisks\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30hw37be14616938459174674dfbc8e99d58.mp3?t=asterisk\">\n      </audio>\n\n+ 英 /ˈæstərɪsk/  美 /ˈæstərɪsk/  全球(美国)  \nn. 星号；星号键\nvt. 注上星号；用星号标出\n\n## exponentiation\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30Bt28530849f681345db3701ff6ce7a6bc0.mp3?t=exponentiation\">\n      </audio>\n\t  \n+ 英 /,ekspənenʃɪ'eɪʃ(ə)n/  美 /,ɛkspo,nɛnʃɪ'eʃən/  全球(美国)  \nn. [数] 取幂，求幂；乘方\n\n## multiplication\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30PS0d4e8cd35271884d6f6a01965ff6139c.mp3?t=multiplication\">\n      </audio>\n\t  \n+ 英 /ˌmʌltɪplɪˈkeɪʃn/  美 /ˌmʌltɪplɪˈkeɪʃn/  全球(美国)  \nn. [数] 乘法；增加\n\n## parenthesis\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30z4458c07e8c85323c67609468b15e1bc7b.mp3?t=parenthesis\">\n      </audio>\n\t  \n+ 英 /pəˈrenθəsɪs/  美 /pəˈrenθəsɪs/  全球(美国)  \nn. 插入语,插入成分\nn. **圆括号**\nn. 间歇，插曲\n\n## mammal\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30UHa4f52b3cda24670558fd591e13eb700f.mp3?t=mammal\">\n      </audio>\n\t  \n+ 英 /ˈmæml/  美 /ˈmæml/  全球(美国)  \nn. [脊椎] 哺乳动物\n\n## loaves\n+ I'd love two loaves of breads fresh from ovan.\nn. loaf 多数，多条面包\n\n## wheat\nn. 小麦\n\n## cereal\nn.谷物\n\n## muffins\nn.松饼\n\n## oven\nn.烤箱\n\n## fresh from\n+  fresh from oven\n刚出，新鲜出\n\n## bread rolls\nn. 圆面包\n\n## $20.50\n20 dollars and 50 cents\n\n## a slice of\n切一片\n\n## heavy drinker\nn. 大酒量的人\n\n## lightweight\nn.酒量不好的人\n\n## blow\nv. 吹\n\n## steam\nn. 蒸汽\n\n## blow off some steam\n舒缓压力\n\n## brew\n+ I brew some coffee. \nn.酿的啤酒/咖啡 v.酿\n\n## beer\nn.啤酒\n\n## on the rocks\n+ This whiskey on the rocks is fantastic.\nn.破产，酒加冰\n\n## neat\n+ They like to drink their whiskey neet.\nn. 原汁原味\n\n\n## hard stuff\nn.烈酒， 难搞的东西\n\n## stiff \n+ I could handle a stiff drink, but I'd still rather order sweeter cocktails.\nadj.烈性的，严厉的，呆板的\n\n## hangover\nbe hangover /  have a hangover\nI don't like being hangover the next day.\nn.宿醉， 遗物\n\n## hammered\n+ I got hammered last night.\n+ We can get you home if you hammered.\nadj.醉酒的\n\n## nagging\nn.唠叨、\n\n## drink someone under the table\nn.把某人喝倒\n\n## soda\nn.苏打\n\n## buzzed\nadj. 头有点晕\n\n## watered down\n渗水\n\n## shots\n+ take the shot. 一口喝完\n+ we have a lots of shots.\nn. 喝酒的小杯子\n\n## chug\nAre you chugging it?\nn. beer的杯子\n\n## tequila\nn. 龙舌兰酒\n\n## bartender\nn.调酒师\n\n## beer gut\nn.啤酒肚\n\n## beer belly\nn.啤酒肚\n\n## go for a jog\nn.运动，慢跑\n\n## carbonated drink/beverage\nn. 碳酸饮料\n\n## snack\nn. 小吃\n\n## cuisine\nn.烹饪","source":"_posts/常用单词学习.md","raw":"---\ntitle: 常用单词学习\ncategories:\n- 英语学习\ntags: \n- English\n- Note\n---\n\n## colon\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30Anbf371a598eda69b4ccf46d35c7add5fc.mp3?t=colon\">\n      </audio>\n      \n+ 英 /ˈkəʊlən; ˈkəʊlɒn/  美 /ˈkoʊlən/  全球(美国)\nn. [解剖] 结肠；**冒号**（用于引语、说明、例证等之前）；科郎（哥斯达黎加货币单位）\n\n## quote\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30AQ4bbc942967962574bc81e020b01e1ba5.mp3?t=quote\">\n      </audio>\n\t  \n+ 英 /kwəʊt/  美 /kwoʊt/  全球(加拿大)  \nvt. 引述；引用；举例说明；报价；以……为证；为（企业的股份）上市\nvi. 引述；引用\nn. 引文；语录；开价；（股票）牌价；**引号**；（建筑或维修的）报价单\nn. (Quote) （美、俄、澳、马、荷）克奥特（人名）\n\n## apostrophe\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30SK8385e1c12f88cd501bf9c8ecfdef0800.mp3?t=apostrophe\">\n      </audio>\n\t  \n+ 英 /əˈpɒstrəfi/  美 /əˈpɑːstrəfi/  全球(英国)  \nn. 省略符号，撇号；呼语，顿呼\n\n## curly braces\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd309Bd6d78ac827a8d1b86b3bf601e93b4aaf.mp3?t=curly\">\n      </audio>\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30VP32b434afefd5946ee0ffb398b9d27f54.mp3?t=braces\">\n      </audio>\n\t  \n花括号\n\n## forward slash\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30eR83f990e90451dafef5a412ccdb12bd5b.mp3?t=slash\">\n      </audio>\n\t  \n斜杠（分隔号“/”）\n\n## back slash\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30eR83f990e90451dafef5a412ccdb12bd5b.mp3?t=slash\">\n      </audio>\n\t  \n正斜杠（分隔“\\”）\n\n## modulus\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30Ac9556257c524e8be83626de5de312dc40.mp3?t=modulus\">\n      </audio>\n\t  \n+ /'mɑdʒə,lai/ \nn. 模数；模（modulis 是复数）\n\n## asterisks\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30hw37be14616938459174674dfbc8e99d58.mp3?t=asterisk\">\n      </audio>\n\n+ 英 /ˈæstərɪsk/  美 /ˈæstərɪsk/  全球(美国)  \nn. 星号；星号键\nvt. 注上星号；用星号标出\n\n## exponentiation\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30Bt28530849f681345db3701ff6ce7a6bc0.mp3?t=exponentiation\">\n      </audio>\n\t  \n+ 英 /,ekspənenʃɪ'eɪʃ(ə)n/  美 /,ɛkspo,nɛnʃɪ'eʃən/  全球(美国)  \nn. [数] 取幂，求幂；乘方\n\n## multiplication\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30PS0d4e8cd35271884d6f6a01965ff6139c.mp3?t=multiplication\">\n      </audio>\n\t  \n+ 英 /ˌmʌltɪplɪˈkeɪʃn/  美 /ˌmʌltɪplɪˈkeɪʃn/  全球(美国)  \nn. [数] 乘法；增加\n\n## parenthesis\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30z4458c07e8c85323c67609468b15e1bc7b.mp3?t=parenthesis\">\n      </audio>\n\t  \n+ 英 /pəˈrenθəsɪs/  美 /pəˈrenθəsɪs/  全球(美国)  \nn. 插入语,插入成分\nn. **圆括号**\nn. 间歇，插曲\n\n## mammal\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30UHa4f52b3cda24670558fd591e13eb700f.mp3?t=mammal\">\n      </audio>\n\t  \n+ 英 /ˈmæml/  美 /ˈmæml/  全球(美国)  \nn. [脊椎] 哺乳动物\n\n## loaves\n+ I'd love two loaves of breads fresh from ovan.\nn. loaf 多数，多条面包\n\n## wheat\nn. 小麦\n\n## cereal\nn.谷物\n\n## muffins\nn.松饼\n\n## oven\nn.烤箱\n\n## fresh from\n+  fresh from oven\n刚出，新鲜出\n\n## bread rolls\nn. 圆面包\n\n## $20.50\n20 dollars and 50 cents\n\n## a slice of\n切一片\n\n## heavy drinker\nn. 大酒量的人\n\n## lightweight\nn.酒量不好的人\n\n## blow\nv. 吹\n\n## steam\nn. 蒸汽\n\n## blow off some steam\n舒缓压力\n\n## brew\n+ I brew some coffee. \nn.酿的啤酒/咖啡 v.酿\n\n## beer\nn.啤酒\n\n## on the rocks\n+ This whiskey on the rocks is fantastic.\nn.破产，酒加冰\n\n## neat\n+ They like to drink their whiskey neet.\nn. 原汁原味\n\n\n## hard stuff\nn.烈酒， 难搞的东西\n\n## stiff \n+ I could handle a stiff drink, but I'd still rather order sweeter cocktails.\nadj.烈性的，严厉的，呆板的\n\n## hangover\nbe hangover /  have a hangover\nI don't like being hangover the next day.\nn.宿醉， 遗物\n\n## hammered\n+ I got hammered last night.\n+ We can get you home if you hammered.\nadj.醉酒的\n\n## nagging\nn.唠叨、\n\n## drink someone under the table\nn.把某人喝倒\n\n## soda\nn.苏打\n\n## buzzed\nadj. 头有点晕\n\n## watered down\n渗水\n\n## shots\n+ take the shot. 一口喝完\n+ we have a lots of shots.\nn. 喝酒的小杯子\n\n## chug\nAre you chugging it?\nn. beer的杯子\n\n## tequila\nn. 龙舌兰酒\n\n## bartender\nn.调酒师\n\n## beer gut\nn.啤酒肚\n\n## beer belly\nn.啤酒肚\n\n## go for a jog\nn.运动，慢跑\n\n## carbonated drink/beverage\nn. 碳酸饮料\n\n## snack\nn. 小吃\n\n## cuisine\nn.烹饪","slug":"常用单词学习","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh12c004h4wf0ua8g3p9m","content":"<h2 id=\"colon\"><a href=\"#colon\" class=\"headerlink\" title=\"colon\"></a>colon</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30Anbf371a598eda69b4ccf46d35c7add5fc.mp3?t=colon\">\n      </audio>\n\n<ul>\n<li>英 /ˈkəʊlən; ˈkəʊlɒn/  美 /ˈkoʊlən/  全球(美国)<br>n. [解剖] 结肠；<strong>冒号</strong>（用于引语、说明、例证等之前）；科郎（哥斯达黎加货币单位）</li>\n</ul>\n<h2 id=\"quote\"><a href=\"#quote\" class=\"headerlink\" title=\"quote\"></a>quote</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30AQ4bbc942967962574bc81e020b01e1ba5.mp3?t=quote\">\n      </audio>\n\n<ul>\n<li>英 /kwəʊt/  美 /kwoʊt/  全球(加拿大)<br>vt. 引述；引用；举例说明；报价；以……为证；为（企业的股份）上市<br>vi. 引述；引用<br>n. 引文；语录；开价；（股票）牌价；<strong>引号</strong>；（建筑或维修的）报价单<br>n. (Quote) （美、俄、澳、马、荷）克奥特（人名）</li>\n</ul>\n<h2 id=\"apostrophe\"><a href=\"#apostrophe\" class=\"headerlink\" title=\"apostrophe\"></a>apostrophe</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30SK8385e1c12f88cd501bf9c8ecfdef0800.mp3?t=apostrophe\">\n      </audio>\n\n<ul>\n<li>英 /əˈpɒstrəfi/  美 /əˈpɑːstrəfi/  全球(英国)<br>n. 省略符号，撇号；呼语，顿呼</li>\n</ul>\n<h2 id=\"curly-braces\"><a href=\"#curly-braces\" class=\"headerlink\" title=\"curly braces\"></a>curly braces</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd309Bd6d78ac827a8d1b86b3bf601e93b4aaf.mp3?t=curly\">\n      </audio>\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30VP32b434afefd5946ee0ffb398b9d27f54.mp3?t=braces\">\n      </audio>\n\n<p>花括号</p>\n<h2 id=\"forward-slash\"><a href=\"#forward-slash\" class=\"headerlink\" title=\"forward slash\"></a>forward slash</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30eR83f990e90451dafef5a412ccdb12bd5b.mp3?t=slash\">\n      </audio>\n\n<p>斜杠（分隔号“/”）</p>\n<h2 id=\"back-slash\"><a href=\"#back-slash\" class=\"headerlink\" title=\"back slash\"></a>back slash</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30eR83f990e90451dafef5a412ccdb12bd5b.mp3?t=slash\">\n      </audio>\n\n<p>正斜杠（分隔“\\”）</p>\n<h2 id=\"modulus\"><a href=\"#modulus\" class=\"headerlink\" title=\"modulus\"></a>modulus</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30Ac9556257c524e8be83626de5de312dc40.mp3?t=modulus\">\n      </audio>\n\n<ul>\n<li>/‘mɑdʒə,lai/<br>n. 模数；模（modulis 是复数）</li>\n</ul>\n<h2 id=\"asterisks\"><a href=\"#asterisks\" class=\"headerlink\" title=\"asterisks\"></a>asterisks</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30hw37be14616938459174674dfbc8e99d58.mp3?t=asterisk\">\n      </audio>\n\n<ul>\n<li>英 /ˈæstərɪsk/  美 /ˈæstərɪsk/  全球(美国)<br>n. 星号；星号键<br>vt. 注上星号；用星号标出</li>\n</ul>\n<h2 id=\"exponentiation\"><a href=\"#exponentiation\" class=\"headerlink\" title=\"exponentiation\"></a>exponentiation</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30Bt28530849f681345db3701ff6ce7a6bc0.mp3?t=exponentiation\">\n      </audio>\n\n<ul>\n<li>英 /,ekspənenʃɪ’eɪʃ(ə)n/  美 /,ɛkspo,nɛnʃɪ’eʃən/  全球(美国)<br>n. [数] 取幂，求幂；乘方</li>\n</ul>\n<h2 id=\"multiplication\"><a href=\"#multiplication\" class=\"headerlink\" title=\"multiplication\"></a>multiplication</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30PS0d4e8cd35271884d6f6a01965ff6139c.mp3?t=multiplication\">\n      </audio>\n\n<ul>\n<li>英 /ˌmʌltɪplɪˈkeɪʃn/  美 /ˌmʌltɪplɪˈkeɪʃn/  全球(美国)<br>n. [数] 乘法；增加</li>\n</ul>\n<h2 id=\"parenthesis\"><a href=\"#parenthesis\" class=\"headerlink\" title=\"parenthesis\"></a>parenthesis</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30z4458c07e8c85323c67609468b15e1bc7b.mp3?t=parenthesis\">\n      </audio>\n\n<ul>\n<li>英 /pəˈrenθəsɪs/  美 /pəˈrenθəsɪs/  全球(美国)<br>n. 插入语,插入成分<br>n. <strong>圆括号</strong><br>n. 间歇，插曲</li>\n</ul>\n<h2 id=\"mammal\"><a href=\"#mammal\" class=\"headerlink\" title=\"mammal\"></a>mammal</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30UHa4f52b3cda24670558fd591e13eb700f.mp3?t=mammal\">\n      </audio>\n\n<ul>\n<li>英 /ˈmæml/  美 /ˈmæml/  全球(美国)<br>n. [脊椎] 哺乳动物</li>\n</ul>\n<h2 id=\"loaves\"><a href=\"#loaves\" class=\"headerlink\" title=\"loaves\"></a>loaves</h2><ul>\n<li>I’d love two loaves of breads fresh from ovan.<br>n. loaf 多数，多条面包</li>\n</ul>\n<h2 id=\"wheat\"><a href=\"#wheat\" class=\"headerlink\" title=\"wheat\"></a>wheat</h2><p>n. 小麦</p>\n<h2 id=\"cereal\"><a href=\"#cereal\" class=\"headerlink\" title=\"cereal\"></a>cereal</h2><p>n.谷物</p>\n<h2 id=\"muffins\"><a href=\"#muffins\" class=\"headerlink\" title=\"muffins\"></a>muffins</h2><p>n.松饼</p>\n<h2 id=\"oven\"><a href=\"#oven\" class=\"headerlink\" title=\"oven\"></a>oven</h2><p>n.烤箱</p>\n<h2 id=\"fresh-from\"><a href=\"#fresh-from\" class=\"headerlink\" title=\"fresh from\"></a>fresh from</h2><ul>\n<li>fresh from oven<br>刚出，新鲜出</li>\n</ul>\n<h2 id=\"bread-rolls\"><a href=\"#bread-rolls\" class=\"headerlink\" title=\"bread rolls\"></a>bread rolls</h2><p>n. 圆面包</p>\n<h2 id=\"20-50\"><a href=\"#20-50\" class=\"headerlink\" title=\"$20.50\"></a>$20.50</h2><p>20 dollars and 50 cents</p>\n<h2 id=\"a-slice-of\"><a href=\"#a-slice-of\" class=\"headerlink\" title=\"a slice of\"></a>a slice of</h2><p>切一片</p>\n<h2 id=\"heavy-drinker\"><a href=\"#heavy-drinker\" class=\"headerlink\" title=\"heavy drinker\"></a>heavy drinker</h2><p>n. 大酒量的人</p>\n<h2 id=\"lightweight\"><a href=\"#lightweight\" class=\"headerlink\" title=\"lightweight\"></a>lightweight</h2><p>n.酒量不好的人</p>\n<h2 id=\"blow\"><a href=\"#blow\" class=\"headerlink\" title=\"blow\"></a>blow</h2><p>v. 吹</p>\n<h2 id=\"steam\"><a href=\"#steam\" class=\"headerlink\" title=\"steam\"></a>steam</h2><p>n. 蒸汽</p>\n<h2 id=\"blow-off-some-steam\"><a href=\"#blow-off-some-steam\" class=\"headerlink\" title=\"blow off some steam\"></a>blow off some steam</h2><p>舒缓压力</p>\n<h2 id=\"brew\"><a href=\"#brew\" class=\"headerlink\" title=\"brew\"></a>brew</h2><ul>\n<li>I brew some coffee.<br>n.酿的啤酒/咖啡 v.酿</li>\n</ul>\n<h2 id=\"beer\"><a href=\"#beer\" class=\"headerlink\" title=\"beer\"></a>beer</h2><p>n.啤酒</p>\n<h2 id=\"on-the-rocks\"><a href=\"#on-the-rocks\" class=\"headerlink\" title=\"on the rocks\"></a>on the rocks</h2><ul>\n<li>This whiskey on the rocks is fantastic.<br>n.破产，酒加冰</li>\n</ul>\n<h2 id=\"neat\"><a href=\"#neat\" class=\"headerlink\" title=\"neat\"></a>neat</h2><ul>\n<li>They like to drink their whiskey neet.<br>n. 原汁原味</li>\n</ul>\n<h2 id=\"hard-stuff\"><a href=\"#hard-stuff\" class=\"headerlink\" title=\"hard stuff\"></a>hard stuff</h2><p>n.烈酒， 难搞的东西</p>\n<h2 id=\"stiff\"><a href=\"#stiff\" class=\"headerlink\" title=\"stiff\"></a>stiff</h2><ul>\n<li>I could handle a stiff drink, but I’d still rather order sweeter cocktails.<br>adj.烈性的，严厉的，呆板的</li>\n</ul>\n<h2 id=\"hangover\"><a href=\"#hangover\" class=\"headerlink\" title=\"hangover\"></a>hangover</h2><p>be hangover /  have a hangover<br>I don’t like being hangover the next day.<br>n.宿醉， 遗物</p>\n<h2 id=\"hammered\"><a href=\"#hammered\" class=\"headerlink\" title=\"hammered\"></a>hammered</h2><ul>\n<li>I got hammered last night.</li>\n<li>We can get you home if you hammered.<br>adj.醉酒的</li>\n</ul>\n<h2 id=\"nagging\"><a href=\"#nagging\" class=\"headerlink\" title=\"nagging\"></a>nagging</h2><p>n.唠叨、</p>\n<h2 id=\"drink-someone-under-the-table\"><a href=\"#drink-someone-under-the-table\" class=\"headerlink\" title=\"drink someone under the table\"></a>drink someone under the table</h2><p>n.把某人喝倒</p>\n<h2 id=\"soda\"><a href=\"#soda\" class=\"headerlink\" title=\"soda\"></a>soda</h2><p>n.苏打</p>\n<h2 id=\"buzzed\"><a href=\"#buzzed\" class=\"headerlink\" title=\"buzzed\"></a>buzzed</h2><p>adj. 头有点晕</p>\n<h2 id=\"watered-down\"><a href=\"#watered-down\" class=\"headerlink\" title=\"watered down\"></a>watered down</h2><p>渗水</p>\n<h2 id=\"shots\"><a href=\"#shots\" class=\"headerlink\" title=\"shots\"></a>shots</h2><ul>\n<li>take the shot. 一口喝完</li>\n<li>we have a lots of shots.<br>n. 喝酒的小杯子</li>\n</ul>\n<h2 id=\"chug\"><a href=\"#chug\" class=\"headerlink\" title=\"chug\"></a>chug</h2><p>Are you chugging it?<br>n. beer的杯子</p>\n<h2 id=\"tequila\"><a href=\"#tequila\" class=\"headerlink\" title=\"tequila\"></a>tequila</h2><p>n. 龙舌兰酒</p>\n<h2 id=\"bartender\"><a href=\"#bartender\" class=\"headerlink\" title=\"bartender\"></a>bartender</h2><p>n.调酒师</p>\n<h2 id=\"beer-gut\"><a href=\"#beer-gut\" class=\"headerlink\" title=\"beer gut\"></a>beer gut</h2><p>n.啤酒肚</p>\n<h2 id=\"beer-belly\"><a href=\"#beer-belly\" class=\"headerlink\" title=\"beer belly\"></a>beer belly</h2><p>n.啤酒肚</p>\n<h2 id=\"go-for-a-jog\"><a href=\"#go-for-a-jog\" class=\"headerlink\" title=\"go for a jog\"></a>go for a jog</h2><p>n.运动，慢跑</p>\n<h2 id=\"carbonated-drink-beverage\"><a href=\"#carbonated-drink-beverage\" class=\"headerlink\" title=\"carbonated drink/beverage\"></a>carbonated drink/beverage</h2><p>n. 碳酸饮料</p>\n<h2 id=\"snack\"><a href=\"#snack\" class=\"headerlink\" title=\"snack\"></a>snack</h2><p>n. 小吃</p>\n<h2 id=\"cuisine\"><a href=\"#cuisine\" class=\"headerlink\" title=\"cuisine\"></a>cuisine</h2><p>n.烹饪</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"colon\"><a href=\"#colon\" class=\"headerlink\" title=\"colon\"></a>colon</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30Anbf371a598eda69b4ccf46d35c7add5fc.mp3?t=colon\">\n      </audio>\n\n<ul>\n<li>英 /ˈkəʊlən; ˈkəʊlɒn/  美 /ˈkoʊlən/  全球(美国)<br>n. [解剖] 结肠；<strong>冒号</strong>（用于引语、说明、例证等之前）；科郎（哥斯达黎加货币单位）</li>\n</ul>\n<h2 id=\"quote\"><a href=\"#quote\" class=\"headerlink\" title=\"quote\"></a>quote</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30AQ4bbc942967962574bc81e020b01e1ba5.mp3?t=quote\">\n      </audio>\n\n<ul>\n<li>英 /kwəʊt/  美 /kwoʊt/  全球(加拿大)<br>vt. 引述；引用；举例说明；报价；以……为证；为（企业的股份）上市<br>vi. 引述；引用<br>n. 引文；语录；开价；（股票）牌价；<strong>引号</strong>；（建筑或维修的）报价单<br>n. (Quote) （美、俄、澳、马、荷）克奥特（人名）</li>\n</ul>\n<h2 id=\"apostrophe\"><a href=\"#apostrophe\" class=\"headerlink\" title=\"apostrophe\"></a>apostrophe</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30SK8385e1c12f88cd501bf9c8ecfdef0800.mp3?t=apostrophe\">\n      </audio>\n\n<ul>\n<li>英 /əˈpɒstrəfi/  美 /əˈpɑːstrəfi/  全球(英国)<br>n. 省略符号，撇号；呼语，顿呼</li>\n</ul>\n<h2 id=\"curly-braces\"><a href=\"#curly-braces\" class=\"headerlink\" title=\"curly braces\"></a>curly braces</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd309Bd6d78ac827a8d1b86b3bf601e93b4aaf.mp3?t=curly\">\n      </audio>\n<audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30VP32b434afefd5946ee0ffb398b9d27f54.mp3?t=braces\">\n      </audio>\n\n<p>花括号</p>\n<h2 id=\"forward-slash\"><a href=\"#forward-slash\" class=\"headerlink\" title=\"forward slash\"></a>forward slash</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30eR83f990e90451dafef5a412ccdb12bd5b.mp3?t=slash\">\n      </audio>\n\n<p>斜杠（分隔号“/”）</p>\n<h2 id=\"back-slash\"><a href=\"#back-slash\" class=\"headerlink\" title=\"back slash\"></a>back slash</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30eR83f990e90451dafef5a412ccdb12bd5b.mp3?t=slash\">\n      </audio>\n\n<p>正斜杠（分隔“\\”）</p>\n<h2 id=\"modulus\"><a href=\"#modulus\" class=\"headerlink\" title=\"modulus\"></a>modulus</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30Ac9556257c524e8be83626de5de312dc40.mp3?t=modulus\">\n      </audio>\n\n<ul>\n<li>/‘mɑdʒə,lai/<br>n. 模数；模（modulis 是复数）</li>\n</ul>\n<h2 id=\"asterisks\"><a href=\"#asterisks\" class=\"headerlink\" title=\"asterisks\"></a>asterisks</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30hw37be14616938459174674dfbc8e99d58.mp3?t=asterisk\">\n      </audio>\n\n<ul>\n<li>英 /ˈæstərɪsk/  美 /ˈæstərɪsk/  全球(美国)<br>n. 星号；星号键<br>vt. 注上星号；用星号标出</li>\n</ul>\n<h2 id=\"exponentiation\"><a href=\"#exponentiation\" class=\"headerlink\" title=\"exponentiation\"></a>exponentiation</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30Bt28530849f681345db3701ff6ce7a6bc0.mp3?t=exponentiation\">\n      </audio>\n\n<ul>\n<li>英 /,ekspənenʃɪ’eɪʃ(ə)n/  美 /,ɛkspo,nɛnʃɪ’eʃən/  全球(美国)<br>n. [数] 取幂，求幂；乘方</li>\n</ul>\n<h2 id=\"multiplication\"><a href=\"#multiplication\" class=\"headerlink\" title=\"multiplication\"></a>multiplication</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30PS0d4e8cd35271884d6f6a01965ff6139c.mp3?t=multiplication\">\n      </audio>\n\n<ul>\n<li>英 /ˌmʌltɪplɪˈkeɪʃn/  美 /ˌmʌltɪplɪˈkeɪʃn/  全球(美国)<br>n. [数] 乘法；增加</li>\n</ul>\n<h2 id=\"parenthesis\"><a href=\"#parenthesis\" class=\"headerlink\" title=\"parenthesis\"></a>parenthesis</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/muTd30z4458c07e8c85323c67609468b15e1bc7b.mp3?t=parenthesis\">\n      </audio>\n\n<ul>\n<li>英 /pəˈrenθəsɪs/  美 /pəˈrenθəsɪs/  全球(美国)<br>n. 插入语,插入成分<br>n. <strong>圆括号</strong><br>n. 间歇，插曲</li>\n</ul>\n<h2 id=\"mammal\"><a href=\"#mammal\" class=\"headerlink\" title=\"mammal\"></a>mammal</h2><audio id=\"audio\" controls=\"\" preload=\"none\">\n      <source id=\"mp3\" src=\"http://audio.dict.cn/fuTd30UHa4f52b3cda24670558fd591e13eb700f.mp3?t=mammal\">\n      </audio>\n\n<ul>\n<li>英 /ˈmæml/  美 /ˈmæml/  全球(美国)<br>n. [脊椎] 哺乳动物</li>\n</ul>\n<h2 id=\"loaves\"><a href=\"#loaves\" class=\"headerlink\" title=\"loaves\"></a>loaves</h2><ul>\n<li>I’d love two loaves of breads fresh from ovan.<br>n. loaf 多数，多条面包</li>\n</ul>\n<h2 id=\"wheat\"><a href=\"#wheat\" class=\"headerlink\" title=\"wheat\"></a>wheat</h2><p>n. 小麦</p>\n<h2 id=\"cereal\"><a href=\"#cereal\" class=\"headerlink\" title=\"cereal\"></a>cereal</h2><p>n.谷物</p>\n<h2 id=\"muffins\"><a href=\"#muffins\" class=\"headerlink\" title=\"muffins\"></a>muffins</h2><p>n.松饼</p>\n<h2 id=\"oven\"><a href=\"#oven\" class=\"headerlink\" title=\"oven\"></a>oven</h2><p>n.烤箱</p>\n<h2 id=\"fresh-from\"><a href=\"#fresh-from\" class=\"headerlink\" title=\"fresh from\"></a>fresh from</h2><ul>\n<li>fresh from oven<br>刚出，新鲜出</li>\n</ul>\n<h2 id=\"bread-rolls\"><a href=\"#bread-rolls\" class=\"headerlink\" title=\"bread rolls\"></a>bread rolls</h2><p>n. 圆面包</p>\n<h2 id=\"20-50\"><a href=\"#20-50\" class=\"headerlink\" title=\"$20.50\"></a>$20.50</h2><p>20 dollars and 50 cents</p>\n<h2 id=\"a-slice-of\"><a href=\"#a-slice-of\" class=\"headerlink\" title=\"a slice of\"></a>a slice of</h2><p>切一片</p>\n<h2 id=\"heavy-drinker\"><a href=\"#heavy-drinker\" class=\"headerlink\" title=\"heavy drinker\"></a>heavy drinker</h2><p>n. 大酒量的人</p>\n<h2 id=\"lightweight\"><a href=\"#lightweight\" class=\"headerlink\" title=\"lightweight\"></a>lightweight</h2><p>n.酒量不好的人</p>\n<h2 id=\"blow\"><a href=\"#blow\" class=\"headerlink\" title=\"blow\"></a>blow</h2><p>v. 吹</p>\n<h2 id=\"steam\"><a href=\"#steam\" class=\"headerlink\" title=\"steam\"></a>steam</h2><p>n. 蒸汽</p>\n<h2 id=\"blow-off-some-steam\"><a href=\"#blow-off-some-steam\" class=\"headerlink\" title=\"blow off some steam\"></a>blow off some steam</h2><p>舒缓压力</p>\n<h2 id=\"brew\"><a href=\"#brew\" class=\"headerlink\" title=\"brew\"></a>brew</h2><ul>\n<li>I brew some coffee.<br>n.酿的啤酒/咖啡 v.酿</li>\n</ul>\n<h2 id=\"beer\"><a href=\"#beer\" class=\"headerlink\" title=\"beer\"></a>beer</h2><p>n.啤酒</p>\n<h2 id=\"on-the-rocks\"><a href=\"#on-the-rocks\" class=\"headerlink\" title=\"on the rocks\"></a>on the rocks</h2><ul>\n<li>This whiskey on the rocks is fantastic.<br>n.破产，酒加冰</li>\n</ul>\n<h2 id=\"neat\"><a href=\"#neat\" class=\"headerlink\" title=\"neat\"></a>neat</h2><ul>\n<li>They like to drink their whiskey neet.<br>n. 原汁原味</li>\n</ul>\n<h2 id=\"hard-stuff\"><a href=\"#hard-stuff\" class=\"headerlink\" title=\"hard stuff\"></a>hard stuff</h2><p>n.烈酒， 难搞的东西</p>\n<h2 id=\"stiff\"><a href=\"#stiff\" class=\"headerlink\" title=\"stiff\"></a>stiff</h2><ul>\n<li>I could handle a stiff drink, but I’d still rather order sweeter cocktails.<br>adj.烈性的，严厉的，呆板的</li>\n</ul>\n<h2 id=\"hangover\"><a href=\"#hangover\" class=\"headerlink\" title=\"hangover\"></a>hangover</h2><p>be hangover /  have a hangover<br>I don’t like being hangover the next day.<br>n.宿醉， 遗物</p>\n<h2 id=\"hammered\"><a href=\"#hammered\" class=\"headerlink\" title=\"hammered\"></a>hammered</h2><ul>\n<li>I got hammered last night.</li>\n<li>We can get you home if you hammered.<br>adj.醉酒的</li>\n</ul>\n<h2 id=\"nagging\"><a href=\"#nagging\" class=\"headerlink\" title=\"nagging\"></a>nagging</h2><p>n.唠叨、</p>\n<h2 id=\"drink-someone-under-the-table\"><a href=\"#drink-someone-under-the-table\" class=\"headerlink\" title=\"drink someone under the table\"></a>drink someone under the table</h2><p>n.把某人喝倒</p>\n<h2 id=\"soda\"><a href=\"#soda\" class=\"headerlink\" title=\"soda\"></a>soda</h2><p>n.苏打</p>\n<h2 id=\"buzzed\"><a href=\"#buzzed\" class=\"headerlink\" title=\"buzzed\"></a>buzzed</h2><p>adj. 头有点晕</p>\n<h2 id=\"watered-down\"><a href=\"#watered-down\" class=\"headerlink\" title=\"watered down\"></a>watered down</h2><p>渗水</p>\n<h2 id=\"shots\"><a href=\"#shots\" class=\"headerlink\" title=\"shots\"></a>shots</h2><ul>\n<li>take the shot. 一口喝完</li>\n<li>we have a lots of shots.<br>n. 喝酒的小杯子</li>\n</ul>\n<h2 id=\"chug\"><a href=\"#chug\" class=\"headerlink\" title=\"chug\"></a>chug</h2><p>Are you chugging it?<br>n. beer的杯子</p>\n<h2 id=\"tequila\"><a href=\"#tequila\" class=\"headerlink\" title=\"tequila\"></a>tequila</h2><p>n. 龙舌兰酒</p>\n<h2 id=\"bartender\"><a href=\"#bartender\" class=\"headerlink\" title=\"bartender\"></a>bartender</h2><p>n.调酒师</p>\n<h2 id=\"beer-gut\"><a href=\"#beer-gut\" class=\"headerlink\" title=\"beer gut\"></a>beer gut</h2><p>n.啤酒肚</p>\n<h2 id=\"beer-belly\"><a href=\"#beer-belly\" class=\"headerlink\" title=\"beer belly\"></a>beer belly</h2><p>n.啤酒肚</p>\n<h2 id=\"go-for-a-jog\"><a href=\"#go-for-a-jog\" class=\"headerlink\" title=\"go for a jog\"></a>go for a jog</h2><p>n.运动，慢跑</p>\n<h2 id=\"carbonated-drink-beverage\"><a href=\"#carbonated-drink-beverage\" class=\"headerlink\" title=\"carbonated drink/beverage\"></a>carbonated drink/beverage</h2><p>n. 碳酸饮料</p>\n<h2 id=\"snack\"><a href=\"#snack\" class=\"headerlink\" title=\"snack\"></a>snack</h2><p>n. 小吃</p>\n<h2 id=\"cuisine\"><a href=\"#cuisine\" class=\"headerlink\" title=\"cuisine\"></a>cuisine</h2><p>n.烹饪</p>\n"},{"title":"开言体验营 - Day1","_content":"\n### 预习\n1. pull up\nv. 拿出来\n\n2. QR code\nn.二维码\n\n3. Scanning\nv. 扫描\n\n4. Professionals\nn. 专业人士\n\n5. keeping up\nv. 跟上，追踪\n\n6. public accounts\nn. 公众号\n\n7. networking\nn. 建立人脉\n\n### Dialog\n> A: It was great meeting you.\n> B: Likewise. Let's keep in touch. Could I have you wechat?\n> A: Sure. Just a sec, let me pull up my QR code. Here you go.\n> B: Great. Opps, that didn't work, let me try scanning you again, here we go.\n> A: Wonderful. I just accepted your contact request.\n> B: Great! Now we are connected. I'm in a great Wechat Group for marketting professionals. Would you like to join?\n> A: Sure, I'd love to.\n> B: I'll send you a invite right away. I find it great for networking, keeping up with industry news and local events.The people in the group is very helpful. I'll recommend a few great public account for you to follow, too.\n> A: That's excellent! I really appreciate it.\n> B: No problem, anytime!\n\n\n### Dialog study\n1. likewise\n* means 'the same'\n* almost anything where you would need to say blah blah blah **too**..\neg. : > Spencer, you are very handsome.\n\t\t> Ah, likewise.\n\t\t> Thank you. \n2.  Could I have you wechat?\n    more polite: > may I add you on wechat?\n\tor  > do you have wechat?\n\t\n3. pull up \n This is always about computers or phones, or things like that you can open something.\n e.g.: Let me pull up my QR code.\n \n 4. QR code\n quick response\n \n 5. contact request\n \n 6. here you go <=> give something.\nI'm giving you something.\n \n 7. here we go <=> start\n It's starting now. let do this..\n \n 8. professional\n n. someone who get paid to do something.\n \n 9.invite\nn. I'll send you an invite.\n \n 10. networking\n n. meeting people that could, related to you professionally.\n \n 11. keeping up\n e.g.: I keep up with fashion. keeping up with industry news.\n \n 12. local events\n this dialogue is probably a networking event.\n \n ","source":"_posts/开言体验营 - Day1.md","raw":"---\ntitle: 开言体验营 - Day1\ncategories:\n- 英语学习\ntags: \n- English\n- Note\n---\n\n### 预习\n1. pull up\nv. 拿出来\n\n2. QR code\nn.二维码\n\n3. Scanning\nv. 扫描\n\n4. Professionals\nn. 专业人士\n\n5. keeping up\nv. 跟上，追踪\n\n6. public accounts\nn. 公众号\n\n7. networking\nn. 建立人脉\n\n### Dialog\n> A: It was great meeting you.\n> B: Likewise. Let's keep in touch. Could I have you wechat?\n> A: Sure. Just a sec, let me pull up my QR code. Here you go.\n> B: Great. Opps, that didn't work, let me try scanning you again, here we go.\n> A: Wonderful. I just accepted your contact request.\n> B: Great! Now we are connected. I'm in a great Wechat Group for marketting professionals. Would you like to join?\n> A: Sure, I'd love to.\n> B: I'll send you a invite right away. I find it great for networking, keeping up with industry news and local events.The people in the group is very helpful. I'll recommend a few great public account for you to follow, too.\n> A: That's excellent! I really appreciate it.\n> B: No problem, anytime!\n\n\n### Dialog study\n1. likewise\n* means 'the same'\n* almost anything where you would need to say blah blah blah **too**..\neg. : > Spencer, you are very handsome.\n\t\t> Ah, likewise.\n\t\t> Thank you. \n2.  Could I have you wechat?\n    more polite: > may I add you on wechat?\n\tor  > do you have wechat?\n\t\n3. pull up \n This is always about computers or phones, or things like that you can open something.\n e.g.: Let me pull up my QR code.\n \n 4. QR code\n quick response\n \n 5. contact request\n \n 6. here you go <=> give something.\nI'm giving you something.\n \n 7. here we go <=> start\n It's starting now. let do this..\n \n 8. professional\n n. someone who get paid to do something.\n \n 9.invite\nn. I'll send you an invite.\n \n 10. networking\n n. meeting people that could, related to you professionally.\n \n 11. keeping up\n e.g.: I keep up with fashion. keeping up with industry news.\n \n 12. local events\n this dialogue is probably a networking event.\n \n ","slug":"开言体验营 - Day1","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh12d004k4wf0wjizb137","content":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li><p>pull up<br>v. 拿出来</p>\n</li>\n<li><p>QR code<br>n.二维码</p>\n</li>\n<li><p>Scanning<br>v. 扫描</p>\n</li>\n<li><p>Professionals<br>n. 专业人士</p>\n</li>\n<li><p>keeping up<br>v. 跟上，追踪</p>\n</li>\n<li><p>public accounts<br>n. 公众号</p>\n</li>\n<li><p>networking<br>n. 建立人脉</p>\n</li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><blockquote>\n<p>A: It was great meeting you.<br>B: Likewise. Let’s keep in touch. Could I have you wechat?<br>A: Sure. Just a sec, let me pull up my QR code. Here you go.<br>B: Great. Opps, that didn’t work, let me try scanning you again, here we go.<br>A: Wonderful. I just accepted your contact request.<br>B: Great! Now we are connected. I’m in a great Wechat Group for marketting professionals. Would you like to join?<br>A: Sure, I’d love to.<br>B: I’ll send you a invite right away. I find it great for networking, keeping up with industry news and local events.The people in the group is very helpful. I’ll recommend a few great public account for you to follow, too.<br>A: That’s excellent! I really appreciate it.<br>B: No problem, anytime!</p>\n</blockquote>\n<h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3><ol>\n<li>likewise</li>\n</ol>\n<ul>\n<li>means ‘the same’</li>\n<li>almost anything where you would need to say blah blah blah <strong>too</strong>..<br>eg. : &gt; Spencer, you are very handsome.<pre><code>  &gt; Ah, likewise.\n  &gt; Thank you. </code></pre></li>\n</ul>\n<ol start=\"2\">\n<li><p>Could I have you wechat?<br>more polite: &gt; may I add you on wechat?<br>or  &gt; do you have wechat?</p>\n</li>\n<li><p>pull up<br>This is always about computers or phones, or things like that you can open something.<br>e.g.: Let me pull up my QR code.</p>\n<ol start=\"4\">\n<li><p>QR code<br>quick response</p>\n</li>\n<li><p>contact request</p>\n</li>\n<li><p>here you go &lt;=&gt; give something.<br>I’m giving you something.</p>\n</li>\n<li><p>here we go &lt;=&gt; start<br>It’s starting now. let do this..</p>\n</li>\n<li><p>professional<br>n. someone who get paid to do something.</p>\n</li>\n</ol>\n<p>9.invite<br>n. I’ll send you an invite.</p>\n<ol start=\"10\">\n<li><p>networking<br>n. meeting people that could, related to you professionally.</p>\n</li>\n<li><p>keeping up<br>e.g.: I keep up with fashion. keeping up with industry news.</p>\n</li>\n<li><p>local events<br>this dialogue is probably a networking event.</p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li><p>pull up<br>v. 拿出来</p>\n</li>\n<li><p>QR code<br>n.二维码</p>\n</li>\n<li><p>Scanning<br>v. 扫描</p>\n</li>\n<li><p>Professionals<br>n. 专业人士</p>\n</li>\n<li><p>keeping up<br>v. 跟上，追踪</p>\n</li>\n<li><p>public accounts<br>n. 公众号</p>\n</li>\n<li><p>networking<br>n. 建立人脉</p>\n</li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><blockquote>\n<p>A: It was great meeting you.<br>B: Likewise. Let’s keep in touch. Could I have you wechat?<br>A: Sure. Just a sec, let me pull up my QR code. Here you go.<br>B: Great. Opps, that didn’t work, let me try scanning you again, here we go.<br>A: Wonderful. I just accepted your contact request.<br>B: Great! Now we are connected. I’m in a great Wechat Group for marketting professionals. Would you like to join?<br>A: Sure, I’d love to.<br>B: I’ll send you a invite right away. I find it great for networking, keeping up with industry news and local events.The people in the group is very helpful. I’ll recommend a few great public account for you to follow, too.<br>A: That’s excellent! I really appreciate it.<br>B: No problem, anytime!</p>\n</blockquote>\n<h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3><ol>\n<li>likewise</li>\n</ol>\n<ul>\n<li>means ‘the same’</li>\n<li>almost anything where you would need to say blah blah blah <strong>too</strong>..<br>eg. : &gt; Spencer, you are very handsome.<pre><code>  &gt; Ah, likewise.\n  &gt; Thank you. </code></pre></li>\n</ul>\n<ol start=\"2\">\n<li><p>Could I have you wechat?<br>more polite: &gt; may I add you on wechat?<br>or  &gt; do you have wechat?</p>\n</li>\n<li><p>pull up<br>This is always about computers or phones, or things like that you can open something.<br>e.g.: Let me pull up my QR code.</p>\n<ol start=\"4\">\n<li><p>QR code<br>quick response</p>\n</li>\n<li><p>contact request</p>\n</li>\n<li><p>here you go &lt;=&gt; give something.<br>I’m giving you something.</p>\n</li>\n<li><p>here we go &lt;=&gt; start<br>It’s starting now. let do this..</p>\n</li>\n<li><p>professional<br>n. someone who get paid to do something.</p>\n</li>\n</ol>\n<p>9.invite<br>n. I’ll send you an invite.</p>\n<ol start=\"10\">\n<li><p>networking<br>n. meeting people that could, related to you professionally.</p>\n</li>\n<li><p>keeping up<br>e.g.: I keep up with fashion. keeping up with industry news.</p>\n</li>\n<li><p>local events<br>this dialogue is probably a networking event.</p>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"开言体验营 - Day4","_content":"\n\n### 预习\n1. Chinese zodiac 生肖\n2. literal translation\n3. tons \n4. beer \n\te.g. I had tons of beer last night.\n5. wacky -> weird\n6. silly \n### Dialog\n\n### Dialog study","source":"_posts/开言体验营 - Day4.md","raw":"---\ntitle: 开言体验营 - Day4\ncategories:\n- 英语学习\ntags: \n- English\n- Note\n---\n\n\n### 预习\n1. Chinese zodiac 生肖\n2. literal translation\n3. tons \n4. beer \n\te.g. I had tons of beer last night.\n5. wacky -> weird\n6. silly \n### Dialog\n\n### Dialog study","slug":"开言体验营 - Day4","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh12g004p4wf0mcq2d0le","content":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>Chinese zodiac 生肖</li>\n<li>literal translation</li>\n<li>tons </li>\n<li>beer<br> e.g. I had tons of beer last night.</li>\n<li>wacky -&gt; weird</li>\n<li>silly <h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3></li>\n</ol>\n<h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>Chinese zodiac 生肖</li>\n<li>literal translation</li>\n<li>tons </li>\n<li>beer<br> e.g. I had tons of beer last night.</li>\n<li>wacky -&gt; weird</li>\n<li>silly <h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3></li>\n</ol>\n<h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>"},{"title":"开言体验营 - Day2","_content":"\n\n### 预习\n1. Espresso\n2. Americano\n3. Latte\n4. Cappuccino\n5. Mocha\n6. Macchiato\n\ne.g. I'd like to order a latte.\n### Dialog\n\n### Dialog study\n","source":"_posts/开言体验营 - Day2.md","raw":"---\ntitle: 开言体验营 - Day2\ncategories:\n- 英语学习\ntags: \n- English\n- Note\n---\n\n\n### 预习\n1. Espresso\n2. Americano\n3. Latte\n4. Cappuccino\n5. Mocha\n6. Macchiato\n\ne.g. I'd like to order a latte.\n### Dialog\n\n### Dialog study\n","slug":"开言体验营 - Day2","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh12h004s4wf0x11ebyuj","content":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>Espresso</li>\n<li>Americano</li>\n<li>Latte</li>\n<li>Cappuccino</li>\n<li>Mocha</li>\n<li>Macchiato</li>\n</ol>\n<p>e.g. I’d like to order a latte.</p>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><ol>\n<li>Espresso</li>\n<li>Americano</li>\n<li>Latte</li>\n<li>Cappuccino</li>\n<li>Mocha</li>\n<li>Macchiato</li>\n</ol>\n<p>e.g. I’d like to order a latte.</p>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>"},{"title":"开言体验营 - Day5","_content":"\n\n### 预习\n1.put you up \n提供住宿，容忍\nBosses have a lot to put up with like you for instance!\nAll women search for beauty. Maybe you will feel better after you put on make-up.\n\n2. layover\n转机\n\n### Dialog\n\n### Dialog study","source":"_posts/开言体验营 - Day5.md","raw":"---\ntitle: 开言体验营 - Day5\ncategories:\n- 英语学习\ntags: \n- English\n- Note\n---\n\n\n### 预习\n1.put you up \n提供住宿，容忍\nBosses have a lot to put up with like you for instance!\nAll women search for beauty. Maybe you will feel better after you put on make-up.\n\n2. layover\n转机\n\n### Dialog\n\n### Dialog study","slug":"开言体验营 - Day5","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh12u004x4wf090hbcbdm","content":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><p>1.put you up<br>提供住宿，容忍<br>Bosses have a lot to put up with like you for instance!<br>All women search for beauty. Maybe you will feel better after you put on make-up.</p>\n<ol start=\"2\">\n<li>layover<br>转机</li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"预习\"><a href=\"#预习\" class=\"headerlink\" title=\"预习\"></a>预习</h3><p>1.put you up<br>提供住宿，容忍<br>Bosses have a lot to put up with like you for instance!<br>All women search for beauty. Maybe you will feel better after you put on make-up.</p>\n<ol start=\"2\">\n<li>layover<br>转机</li>\n</ol>\n<h3 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h3><h3 id=\"Dialog-study\"><a href=\"#Dialog-study\" class=\"headerlink\" title=\"Dialog study\"></a>Dialog study</h3>"},{"title":"数据结构-数组,链表结构","_content":"\n## 一、数组\n\n#### 物理大小和逻辑大小\n物理大小：创建时的大小\n逻辑大小：可使用的大小\n* 如果逻辑大小>=物理大小，代表数组被填满了。\n\n### 增加（插入，替换）、删除静态数组策略\n\n* 增加： 当逻辑大小已经等于物理大小时，再添加元素数组需要扩容。每增加一个元素就扩容，添加N项的话会带来O(n^2)算法消耗，可以在达到这个条件时，直接为数组扩容两倍。\n* 插入：从数组尾部往后移一位，执行到插入点位置为止，制造一个空洞为新元素\n* 删除： 当逻辑大小已经小于或等于物理大小四分之一时，将数组容量砍半。\n删除元素，将此元素索引后一位往前移一位。与插入相反。\n\n### 复杂度分析\n第i个位置插入，删除： O(n) 平均情况\n增加减少容量： O(n) 平均情况\n第i个位置访问，替换：O(1)\n\n\n## 二、链表\n\n#### 单链表， 双链表。\n* 末尾删除： 找出倒数第二个结点，将其next指针指为none即可。\n* 表头删除：找出第一个结点，将next指给head\n\n#### 复杂度分析：\n* 访问第i个元素：O(n) 平均情况\n* 在第i个元素替换：O(n) 平均情况\n* 在开始入插入：O(1) all\n* 在结束处删除：O(1) all\n* 在第i个位置插入，删除：O(n) 平均情况\n\n>　链表的优势在于内存性能，虽然存储指向指针会占用大小，但相对数组还是有优势．另外优势在于对首尾元素的删除插入处理时的效率更快．\n\n### 优化：哑头节点的循环列表\n```python\nhead = Node(None, None)\nhead.next = head\n```\n> 方便处理插入遍历，只需判断条件为probe.next != head即不是最后一个元素\n\n\n\n\n\n","source":"_posts/数据结构-数组链表结构.md","raw":"---\ntitle: 数据结构-数组,链表结构\ncategories:\n- 数据结构\n---\n\n## 一、数组\n\n#### 物理大小和逻辑大小\n物理大小：创建时的大小\n逻辑大小：可使用的大小\n* 如果逻辑大小>=物理大小，代表数组被填满了。\n\n### 增加（插入，替换）、删除静态数组策略\n\n* 增加： 当逻辑大小已经等于物理大小时，再添加元素数组需要扩容。每增加一个元素就扩容，添加N项的话会带来O(n^2)算法消耗，可以在达到这个条件时，直接为数组扩容两倍。\n* 插入：从数组尾部往后移一位，执行到插入点位置为止，制造一个空洞为新元素\n* 删除： 当逻辑大小已经小于或等于物理大小四分之一时，将数组容量砍半。\n删除元素，将此元素索引后一位往前移一位。与插入相反。\n\n### 复杂度分析\n第i个位置插入，删除： O(n) 平均情况\n增加减少容量： O(n) 平均情况\n第i个位置访问，替换：O(1)\n\n\n## 二、链表\n\n#### 单链表， 双链表。\n* 末尾删除： 找出倒数第二个结点，将其next指针指为none即可。\n* 表头删除：找出第一个结点，将next指给head\n\n#### 复杂度分析：\n* 访问第i个元素：O(n) 平均情况\n* 在第i个元素替换：O(n) 平均情况\n* 在开始入插入：O(1) all\n* 在结束处删除：O(1) all\n* 在第i个位置插入，删除：O(n) 平均情况\n\n>　链表的优势在于内存性能，虽然存储指向指针会占用大小，但相对数组还是有优势．另外优势在于对首尾元素的删除插入处理时的效率更快．\n\n### 优化：哑头节点的循环列表\n```python\nhead = Node(None, None)\nhead.next = head\n```\n> 方便处理插入遍历，只需判断条件为probe.next != head即不是最后一个元素\n\n\n\n\n\n","slug":"数据结构-数组链表结构","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh12w00504wf0gojky6nz","content":"<h2 id=\"一、数组\"><a href=\"#一、数组\" class=\"headerlink\" title=\"一、数组\"></a>一、数组</h2><h4 id=\"物理大小和逻辑大小\"><a href=\"#物理大小和逻辑大小\" class=\"headerlink\" title=\"物理大小和逻辑大小\"></a>物理大小和逻辑大小</h4><p>物理大小：创建时的大小<br>逻辑大小：可使用的大小</p>\n<ul>\n<li>如果逻辑大小&gt;=物理大小，代表数组被填满了。</li>\n</ul>\n<h3 id=\"增加（插入，替换）、删除静态数组策略\"><a href=\"#增加（插入，替换）、删除静态数组策略\" class=\"headerlink\" title=\"增加（插入，替换）、删除静态数组策略\"></a>增加（插入，替换）、删除静态数组策略</h3><ul>\n<li>增加： 当逻辑大小已经等于物理大小时，再添加元素数组需要扩容。每增加一个元素就扩容，添加N项的话会带来O(n^2)算法消耗，可以在达到这个条件时，直接为数组扩容两倍。</li>\n<li>插入：从数组尾部往后移一位，执行到插入点位置为止，制造一个空洞为新元素</li>\n<li>删除： 当逻辑大小已经小于或等于物理大小四分之一时，将数组容量砍半。<br>删除元素，将此元素索引后一位往前移一位。与插入相反。</li>\n</ul>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>第i个位置插入，删除： O(n) 平均情况<br>增加减少容量： O(n) 平均情况<br>第i个位置访问，替换：O(1)</p>\n<h2 id=\"二、链表\"><a href=\"#二、链表\" class=\"headerlink\" title=\"二、链表\"></a>二、链表</h2><h4 id=\"单链表，-双链表。\"><a href=\"#单链表，-双链表。\" class=\"headerlink\" title=\"单链表， 双链表。\"></a>单链表， 双链表。</h4><ul>\n<li>末尾删除： 找出倒数第二个结点，将其next指针指为none即可。</li>\n<li>表头删除：找出第一个结点，将next指给head</li>\n</ul>\n<h4 id=\"复杂度分析：\"><a href=\"#复杂度分析：\" class=\"headerlink\" title=\"复杂度分析：\"></a>复杂度分析：</h4><ul>\n<li>访问第i个元素：O(n) 平均情况</li>\n<li>在第i个元素替换：O(n) 平均情况</li>\n<li>在开始入插入：O(1) all</li>\n<li>在结束处删除：O(1) all</li>\n<li>在第i个位置插入，删除：O(n) 平均情况</li>\n</ul>\n<blockquote>\n<p>　链表的优势在于内存性能，虽然存储指向指针会占用大小，但相对数组还是有优势．另外优势在于对首尾元素的删除插入处理时的效率更快．</p>\n</blockquote>\n<h3 id=\"优化：哑头节点的循环列表\"><a href=\"#优化：哑头节点的循环列表\" class=\"headerlink\" title=\"优化：哑头节点的循环列表\"></a>优化：哑头节点的循环列表</h3><pre><code class=\"python\">head = Node(None, None)\nhead.next = head</code></pre>\n<blockquote>\n<p>方便处理插入遍历，只需判断条件为probe.next != head即不是最后一个元素</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、数组\"><a href=\"#一、数组\" class=\"headerlink\" title=\"一、数组\"></a>一、数组</h2><h4 id=\"物理大小和逻辑大小\"><a href=\"#物理大小和逻辑大小\" class=\"headerlink\" title=\"物理大小和逻辑大小\"></a>物理大小和逻辑大小</h4><p>物理大小：创建时的大小<br>逻辑大小：可使用的大小</p>\n<ul>\n<li>如果逻辑大小&gt;=物理大小，代表数组被填满了。</li>\n</ul>\n<h3 id=\"增加（插入，替换）、删除静态数组策略\"><a href=\"#增加（插入，替换）、删除静态数组策略\" class=\"headerlink\" title=\"增加（插入，替换）、删除静态数组策略\"></a>增加（插入，替换）、删除静态数组策略</h3><ul>\n<li>增加： 当逻辑大小已经等于物理大小时，再添加元素数组需要扩容。每增加一个元素就扩容，添加N项的话会带来O(n^2)算法消耗，可以在达到这个条件时，直接为数组扩容两倍。</li>\n<li>插入：从数组尾部往后移一位，执行到插入点位置为止，制造一个空洞为新元素</li>\n<li>删除： 当逻辑大小已经小于或等于物理大小四分之一时，将数组容量砍半。<br>删除元素，将此元素索引后一位往前移一位。与插入相反。</li>\n</ul>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>第i个位置插入，删除： O(n) 平均情况<br>增加减少容量： O(n) 平均情况<br>第i个位置访问，替换：O(1)</p>\n<h2 id=\"二、链表\"><a href=\"#二、链表\" class=\"headerlink\" title=\"二、链表\"></a>二、链表</h2><h4 id=\"单链表，-双链表。\"><a href=\"#单链表，-双链表。\" class=\"headerlink\" title=\"单链表， 双链表。\"></a>单链表， 双链表。</h4><ul>\n<li>末尾删除： 找出倒数第二个结点，将其next指针指为none即可。</li>\n<li>表头删除：找出第一个结点，将next指给head</li>\n</ul>\n<h4 id=\"复杂度分析：\"><a href=\"#复杂度分析：\" class=\"headerlink\" title=\"复杂度分析：\"></a>复杂度分析：</h4><ul>\n<li>访问第i个元素：O(n) 平均情况</li>\n<li>在第i个元素替换：O(n) 平均情况</li>\n<li>在开始入插入：O(1) all</li>\n<li>在结束处删除：O(1) all</li>\n<li>在第i个位置插入，删除：O(n) 平均情况</li>\n</ul>\n<blockquote>\n<p>　链表的优势在于内存性能，虽然存储指向指针会占用大小，但相对数组还是有优势．另外优势在于对首尾元素的删除插入处理时的效率更快．</p>\n</blockquote>\n<h3 id=\"优化：哑头节点的循环列表\"><a href=\"#优化：哑头节点的循环列表\" class=\"headerlink\" title=\"优化：哑头节点的循环列表\"></a>优化：哑头节点的循环列表</h3><pre><code class=\"python\">head = Node(None, None)\nhead.next = head</code></pre>\n<blockquote>\n<p>方便处理插入遍历，只需判断条件为probe.next != head即不是最后一个元素</p>\n</blockquote>\n"},{"title":"排序算法","_content":"\n#### 冒泡排序\n\n![冒泡排序示例:](/img/1585903822933.png)\n\n* 时间复杂度：O（n^2）\n* 特点：稳定的排序算法，即数组内相等元素不会排序后发生变化！\n\n#### 插入排序\n\n\n![插入排序示例](/img/1585907380155.png)\n![插入排序时间复杂度](/img/1585908731720.png)\n\n* 特点：同样是稳定的\n\n#### 归并排序\n\n* 核心思想：分治的思想\n\n![归并排序代码1](/img/1585908824999.png)\n![归并排序代码2](/img/1585908857419.png)\n\n![复杂度分析](/img/1585909201370.png)\n\n* 特点：同样是稳定的\n\n#### 快速排序\n\n* 基本思路实现：选取左点，左右两端分别往中间走，注意要用“等于”的条件。\n\n![基本的快排的Partition函数实现](/img/1586247034757.png)\n\n\n* 优化1： 选择点的优化：\n\n![选点优化的快排Partition函数](/img/1586247286704.png)\n\n* 优化2： 改交换为赋值：\n\n![交换换赋值的优化的快排Partition函数](/img/1586247445746.png)\n\n* 优化3： 设定小个数的数组使用插入排序来完成\n\n* 优化4： 使用伪递归：\n![伪递归优化快排](/img/1586248831375.png)\n\n","source":"_posts/排序算法.md","raw":"---\ntitle: 排序算法\ncategories:\n- 数据结构\n---\n\n#### 冒泡排序\n\n![冒泡排序示例:](/img/1585903822933.png)\n\n* 时间复杂度：O（n^2）\n* 特点：稳定的排序算法，即数组内相等元素不会排序后发生变化！\n\n#### 插入排序\n\n\n![插入排序示例](/img/1585907380155.png)\n![插入排序时间复杂度](/img/1585908731720.png)\n\n* 特点：同样是稳定的\n\n#### 归并排序\n\n* 核心思想：分治的思想\n\n![归并排序代码1](/img/1585908824999.png)\n![归并排序代码2](/img/1585908857419.png)\n\n![复杂度分析](/img/1585909201370.png)\n\n* 特点：同样是稳定的\n\n#### 快速排序\n\n* 基本思路实现：选取左点，左右两端分别往中间走，注意要用“等于”的条件。\n\n![基本的快排的Partition函数实现](/img/1586247034757.png)\n\n\n* 优化1： 选择点的优化：\n\n![选点优化的快排Partition函数](/img/1586247286704.png)\n\n* 优化2： 改交换为赋值：\n\n![交换换赋值的优化的快排Partition函数](/img/1586247445746.png)\n\n* 优化3： 设定小个数的数组使用插入排序来完成\n\n* 优化4： 使用伪递归：\n![伪递归优化快排](/img/1586248831375.png)\n\n","slug":"排序算法","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh12y00544wf062agtdmv","content":"<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p><img src=\"/img/1585903822933.png\" alt=\"冒泡排序示例:\"></p>\n<ul>\n<li>时间复杂度：O（n^2）</li>\n<li>特点：稳定的排序算法，即数组内相等元素不会排序后发生变化！</li>\n</ul>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p><img src=\"/img/1585907380155.png\" alt=\"插入排序示例\"><br><img src=\"/img/1585908731720.png\" alt=\"插入排序时间复杂度\"></p>\n<ul>\n<li>特点：同样是稳定的</li>\n</ul>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><ul>\n<li>核心思想：分治的思想</li>\n</ul>\n<p><img src=\"/img/1585908824999.png\" alt=\"归并排序代码1\"><br><img src=\"/img/1585908857419.png\" alt=\"归并排序代码2\"></p>\n<p><img src=\"/img/1585909201370.png\" alt=\"复杂度分析\"></p>\n<ul>\n<li>特点：同样是稳定的</li>\n</ul>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><ul>\n<li>基本思路实现：选取左点，左右两端分别往中间走，注意要用“等于”的条件。</li>\n</ul>\n<p><img src=\"/img/1586247034757.png\" alt=\"基本的快排的Partition函数实现\"></p>\n<ul>\n<li>优化1： 选择点的优化：</li>\n</ul>\n<p><img src=\"/img/1586247286704.png\" alt=\"选点优化的快排Partition函数\"></p>\n<ul>\n<li>优化2： 改交换为赋值：</li>\n</ul>\n<p><img src=\"/img/1586247445746.png\" alt=\"交换换赋值的优化的快排Partition函数\"></p>\n<ul>\n<li><p>优化3： 设定小个数的数组使用插入排序来完成</p>\n</li>\n<li><p>优化4： 使用伪递归：<br><img src=\"/img/1586248831375.png\" alt=\"伪递归优化快排\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p><img src=\"/img/1585903822933.png\" alt=\"冒泡排序示例:\"></p>\n<ul>\n<li>时间复杂度：O（n^2）</li>\n<li>特点：稳定的排序算法，即数组内相等元素不会排序后发生变化！</li>\n</ul>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p><img src=\"/img/1585907380155.png\" alt=\"插入排序示例\"><br><img src=\"/img/1585908731720.png\" alt=\"插入排序时间复杂度\"></p>\n<ul>\n<li>特点：同样是稳定的</li>\n</ul>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><ul>\n<li>核心思想：分治的思想</li>\n</ul>\n<p><img src=\"/img/1585908824999.png\" alt=\"归并排序代码1\"><br><img src=\"/img/1585908857419.png\" alt=\"归并排序代码2\"></p>\n<p><img src=\"/img/1585909201370.png\" alt=\"复杂度分析\"></p>\n<ul>\n<li>特点：同样是稳定的</li>\n</ul>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><ul>\n<li>基本思路实现：选取左点，左右两端分别往中间走，注意要用“等于”的条件。</li>\n</ul>\n<p><img src=\"/img/1586247034757.png\" alt=\"基本的快排的Partition函数实现\"></p>\n<ul>\n<li>优化1： 选择点的优化：</li>\n</ul>\n<p><img src=\"/img/1586247286704.png\" alt=\"选点优化的快排Partition函数\"></p>\n<ul>\n<li>优化2： 改交换为赋值：</li>\n</ul>\n<p><img src=\"/img/1586247445746.png\" alt=\"交换换赋值的优化的快排Partition函数\"></p>\n<ul>\n<li><p>优化3： 设定小个数的数组使用插入排序来完成</p>\n</li>\n<li><p>优化4： 使用伪递归：<br><img src=\"/img/1586248831375.png\" alt=\"伪递归优化快排\"></p>\n</li>\n</ul>\n"},{"title":"性能优化相关","_content":"1.渲染\n\n- 利用reflect probe代替反射、折射，尽量不用RTT、GrabPass、RenderWithShader、CommandBuffer.Blit (BuiltinRenderTextureType.CurrentActive...)\n- 建立统一后处理框架(bloom、hdr、DOF等)代替多后处理，可以共用模糊函数，减少多次blit；另外要注意RTT的尺寸。\n- 空气折射、热浪扭曲等使用GrabPass不是所有硬件都支持，改为RTT或者后处理来优化。\n- 建立统一shader材质代替单一shader，充分利用shader_feature、multi_compile，并将宏开关显示于界面。\n- 图像混合代替多通道纹理，阴影投射、阴影接收、MetaPass、forwardadd 等pass不需要时要剔除。\n- 少用alpha test、discard、clip、Alpha Converage等，因为会影响Early-Z Culling、HSR的优化。\n- 避免Alpha Blend穿透问题（权重混合、深度剥离等透明排序方法代价太大了）。\n- 光照贴图代替动态阴影、尽量不用实时光；阴影贴图、环境贴图用16位代替32位；利用projector+rtt或者光圈代替实时阴影。\n- 将环境参数（风、雨、太阳）等shader全局参数统一管理。\n- 非主角可以用matcap代替pbr、无金属不一定要用pbr，仔细选择物理渲染所用的FDG（F:schlick、cook-torrance、lerp、要求不高用4次方，D：blinn-phong、beckmann、GGX、GGX Anisotropic,G:neumann、cook-torrance、Kelemen、SmithGGX；standard shader要注意选择BRDF1-BRDF3），渲染要求不高时不用GGX；可以用LH来优化GGX。\n- 用fixed、half代替float,建立shader统一类型（fixed效率是float的4倍，half是float的2倍），小心选择shader变量的修饰(uniform、static、全局),选择Mobile或Unlit目录下shader\n- 使用高低配渲染，内存足够时可以考虑开启mipmap\n- 使用surface shader注意关掉不用的功能，比如：noshadow、noambient、novertexlights、nolightmap、nodynlightmap、nodirlightmap、nofog、nometa、noforwardadd等\n- standard shader的变体太多（3万多），导致编译时间较长，内存占用也很惊人（接近1G），如果使用要关掉没用的shader_feature,比如：==**_PARALLAXMAP、SHADOWS_SOFT、DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE、_DETAIL_MULX2、_ALPHAPREMULTIPLY_ON；另外要去掉多余的pass** #F44336==\n- shaderforge、Amplify Shader Editor生成的shader有多余代码要程序专门优化，Amplify Shader Editor功能更强大一些，而且开源，建议学习。\n- 不要用unity自带terrian，因为即使只用3张splat图，shader也是对应4个的，建议T4M或者转为mesh。\n- 模型和材质相同且数量巨大时用Instance来优化，比如草。\n- 利用查找纹理(LUT)来优化复杂的光照渲染，比如：皮肤、头发、喷漆等。\n- 尽量不要使用Procedural Sky，计算瑞丽散射和米氏散射效率比较低。\n- 尽量不要使用speedtree，改为模型加简单树叶动画，不过SpeedTreeWind.cginc里面的动画函数很丰富，- TerrianEngine中的SmoothTriangleWave很好用。\n- 多用调试工具检查shader性能，常用工具有：FrameDebug、Nsight、RenderDoc 、AMD GPU -ShaderAnalyzer / PVRShaderEditor、Adreno Profiler 、腾讯Cube、UWA等；另外可以内置GM界面，比如开关阴影，批量替换shader等方便真机调试。\n\n> 另一方面，Matcap是完全不考虑光照影响的渲染方法，因此也不存在能量守恒，只能通过采样贴图的绘制做出能量守恒的效果，所以不是真正的PBR，也因此能做出很多PBR无法实现的效果。\n\n\n\n2.脚本\n\n减少GetComponent、find等查找函数在Update等循环函数中的调用、go.CompareTag代替go.tag 、\n减少SendMessage等同步函数调用；减少字符串连接；for代替foreach，5.5以后版本foreach已经优化过了；少用linq；\n大资源改为异步加载\n合理处理协程调用\n将AI、网络等放在单独线程\n发布优化：关闭log、剔除代码\n伪随机\n脚本挂载类改为Manager等全局类实现\nlua中尽量不实现update、fixedupdate等循环函数，lua和csharp互调用的效率比较低。\n\n3.内存管理\n\n池子管理粒子、float UI等小资源，频繁地GC会造成卡顿\n必要时主动调用GC.Collect()\n按照不同资源、不同设备管理资源生命周期，Resources.Load和Assetbundle统一接口，利用引用计数来管理生命周期，并打印和观察生命周期。保证资源随场景而卸载，不常驻内存，确定哪些是预加载，哪些泄漏。\n内存泄漏（减少驻留内存）：Container内资源不remove掉用Resources.UnloadUnusedAssets是卸载不掉的；对于这种情况，建议直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况；通过Android PSS/iOS Instrument反馈的App线程内存来查看；\n堆内存过大：避免一次性堆内存的过大分配，Mono的堆内存一旦分配，就不会返还给系统，这意味着Mono的堆内存是只升不降的。常见：高频调用new；log输出；\nCPU占用高：NGui的重建网格导致UIPanel.LateUpdate（按照静止、移动、高频移动来切分）；NGUI锚点自身的更新逻辑也会消耗不少CPU开销。即使是在控件静止不动的情况下，控件的锚点也会每帧更新（见UIWidget.OnUpdate函数），而且它的更新是递归式的，使CPU占用率更高。因此我们修改了NGUI的内部代码，使锚点只在必要时更新。一般只在控件初始化和屏幕大小发生变化时更新即可。不过这个优化的代价是控件的顶点位置发生变化的时候（比如控件在运动，或控件大小改变等），上层逻辑需要自己负责更新锚点。 加载用协程； 控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD血条可能会大量出现，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。\n资源冗余：AssetBundle打包打到多份中；动态修改资源导致的Instance拷贝多份（比如动态修改材质，Renderer.meterial，Animation.AddClip）。\n磁盘空间换内存：对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间\n\n4.美术\n\n建立资源审查规范和审查工具：PBR材质贴图制作规范、场景制作资源控制规范、角色制作规范、特效制作规范；利用AssetPostprocessor建立审查工具。\n压缩纹理、优化精灵填充率、压缩动画、压缩声音、压缩UI（九宫格优于拉伸）；严格控制模型面数、纹理数、角色骨骼数。\n粒子：录制动画代替粒子、减少粒子数量、粒子不要碰撞\n角色：启用Optimize Game Objects减少节点,使用（SimpleLOD、Cruncher）优化面数。\n模型：导入检查Read/Write only、Optimize Mesh、法线切线、color、禁用Mipmap\n压缩纹理问题：压缩可能导致色阶不足；无透明通道用ETC1,现在安卓不支持ETC2已不足5%，建议放弃分离通道办法。\nUI：尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；\nugui：可以充分利用canvas来切分不同元素。\n大贴图会导致卡顿，可以切分为多个加载。\niOS使用mp3压缩、Android使用Vorbis压缩\n\n\n5.批次\n\n开启static batch\n开启dynamic batch：要求模型小于900顶点，用法线小于300，用切线小于180，缩放不一致、使用lightmap、多通道材质等会使dynamic batch无效。\n减少GameObject，场景模型数量对fps影响巨大。\n批次不是越少越好，过大的渲染数据会给总线传输带来压力。\n\n6.物理\n\n不需要移动的物体设为Static\n不要用Mesh碰撞，角色不用碰撞体\n触发器逻辑优化\n寻路频率、AI逻辑频率 、Fixed Timestep、降帧到30\n出现卡顿的复杂计算，例如寻路、大量资源加载 可以用分帧或者协成异步来处理","source":"_posts/性能优化相关.md","raw":"---\ntitle: 性能优化相关\ncategories:\n- Unity\n---\n1.渲染\n\n- 利用reflect probe代替反射、折射，尽量不用RTT、GrabPass、RenderWithShader、CommandBuffer.Blit (BuiltinRenderTextureType.CurrentActive...)\n- 建立统一后处理框架(bloom、hdr、DOF等)代替多后处理，可以共用模糊函数，减少多次blit；另外要注意RTT的尺寸。\n- 空气折射、热浪扭曲等使用GrabPass不是所有硬件都支持，改为RTT或者后处理来优化。\n- 建立统一shader材质代替单一shader，充分利用shader_feature、multi_compile，并将宏开关显示于界面。\n- 图像混合代替多通道纹理，阴影投射、阴影接收、MetaPass、forwardadd 等pass不需要时要剔除。\n- 少用alpha test、discard、clip、Alpha Converage等，因为会影响Early-Z Culling、HSR的优化。\n- 避免Alpha Blend穿透问题（权重混合、深度剥离等透明排序方法代价太大了）。\n- 光照贴图代替动态阴影、尽量不用实时光；阴影贴图、环境贴图用16位代替32位；利用projector+rtt或者光圈代替实时阴影。\n- 将环境参数（风、雨、太阳）等shader全局参数统一管理。\n- 非主角可以用matcap代替pbr、无金属不一定要用pbr，仔细选择物理渲染所用的FDG（F:schlick、cook-torrance、lerp、要求不高用4次方，D：blinn-phong、beckmann、GGX、GGX Anisotropic,G:neumann、cook-torrance、Kelemen、SmithGGX；standard shader要注意选择BRDF1-BRDF3），渲染要求不高时不用GGX；可以用LH来优化GGX。\n- 用fixed、half代替float,建立shader统一类型（fixed效率是float的4倍，half是float的2倍），小心选择shader变量的修饰(uniform、static、全局),选择Mobile或Unlit目录下shader\n- 使用高低配渲染，内存足够时可以考虑开启mipmap\n- 使用surface shader注意关掉不用的功能，比如：noshadow、noambient、novertexlights、nolightmap、nodynlightmap、nodirlightmap、nofog、nometa、noforwardadd等\n- standard shader的变体太多（3万多），导致编译时间较长，内存占用也很惊人（接近1G），如果使用要关掉没用的shader_feature,比如：==**_PARALLAXMAP、SHADOWS_SOFT、DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE、_DETAIL_MULX2、_ALPHAPREMULTIPLY_ON；另外要去掉多余的pass** #F44336==\n- shaderforge、Amplify Shader Editor生成的shader有多余代码要程序专门优化，Amplify Shader Editor功能更强大一些，而且开源，建议学习。\n- 不要用unity自带terrian，因为即使只用3张splat图，shader也是对应4个的，建议T4M或者转为mesh。\n- 模型和材质相同且数量巨大时用Instance来优化，比如草。\n- 利用查找纹理(LUT)来优化复杂的光照渲染，比如：皮肤、头发、喷漆等。\n- 尽量不要使用Procedural Sky，计算瑞丽散射和米氏散射效率比较低。\n- 尽量不要使用speedtree，改为模型加简单树叶动画，不过SpeedTreeWind.cginc里面的动画函数很丰富，- TerrianEngine中的SmoothTriangleWave很好用。\n- 多用调试工具检查shader性能，常用工具有：FrameDebug、Nsight、RenderDoc 、AMD GPU -ShaderAnalyzer / PVRShaderEditor、Adreno Profiler 、腾讯Cube、UWA等；另外可以内置GM界面，比如开关阴影，批量替换shader等方便真机调试。\n\n> 另一方面，Matcap是完全不考虑光照影响的渲染方法，因此也不存在能量守恒，只能通过采样贴图的绘制做出能量守恒的效果，所以不是真正的PBR，也因此能做出很多PBR无法实现的效果。\n\n\n\n2.脚本\n\n减少GetComponent、find等查找函数在Update等循环函数中的调用、go.CompareTag代替go.tag 、\n减少SendMessage等同步函数调用；减少字符串连接；for代替foreach，5.5以后版本foreach已经优化过了；少用linq；\n大资源改为异步加载\n合理处理协程调用\n将AI、网络等放在单独线程\n发布优化：关闭log、剔除代码\n伪随机\n脚本挂载类改为Manager等全局类实现\nlua中尽量不实现update、fixedupdate等循环函数，lua和csharp互调用的效率比较低。\n\n3.内存管理\n\n池子管理粒子、float UI等小资源，频繁地GC会造成卡顿\n必要时主动调用GC.Collect()\n按照不同资源、不同设备管理资源生命周期，Resources.Load和Assetbundle统一接口，利用引用计数来管理生命周期，并打印和观察生命周期。保证资源随场景而卸载，不常驻内存，确定哪些是预加载，哪些泄漏。\n内存泄漏（减少驻留内存）：Container内资源不remove掉用Resources.UnloadUnusedAssets是卸载不掉的；对于这种情况，建议直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况；通过Android PSS/iOS Instrument反馈的App线程内存来查看；\n堆内存过大：避免一次性堆内存的过大分配，Mono的堆内存一旦分配，就不会返还给系统，这意味着Mono的堆内存是只升不降的。常见：高频调用new；log输出；\nCPU占用高：NGui的重建网格导致UIPanel.LateUpdate（按照静止、移动、高频移动来切分）；NGUI锚点自身的更新逻辑也会消耗不少CPU开销。即使是在控件静止不动的情况下，控件的锚点也会每帧更新（见UIWidget.OnUpdate函数），而且它的更新是递归式的，使CPU占用率更高。因此我们修改了NGUI的内部代码，使锚点只在必要时更新。一般只在控件初始化和屏幕大小发生变化时更新即可。不过这个优化的代价是控件的顶点位置发生变化的时候（比如控件在运动，或控件大小改变等），上层逻辑需要自己负责更新锚点。 加载用协程； 控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD血条可能会大量出现，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。\n资源冗余：AssetBundle打包打到多份中；动态修改资源导致的Instance拷贝多份（比如动态修改材质，Renderer.meterial，Animation.AddClip）。\n磁盘空间换内存：对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间\n\n4.美术\n\n建立资源审查规范和审查工具：PBR材质贴图制作规范、场景制作资源控制规范、角色制作规范、特效制作规范；利用AssetPostprocessor建立审查工具。\n压缩纹理、优化精灵填充率、压缩动画、压缩声音、压缩UI（九宫格优于拉伸）；严格控制模型面数、纹理数、角色骨骼数。\n粒子：录制动画代替粒子、减少粒子数量、粒子不要碰撞\n角色：启用Optimize Game Objects减少节点,使用（SimpleLOD、Cruncher）优化面数。\n模型：导入检查Read/Write only、Optimize Mesh、法线切线、color、禁用Mipmap\n压缩纹理问题：压缩可能导致色阶不足；无透明通道用ETC1,现在安卓不支持ETC2已不足5%，建议放弃分离通道办法。\nUI：尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；\nugui：可以充分利用canvas来切分不同元素。\n大贴图会导致卡顿，可以切分为多个加载。\niOS使用mp3压缩、Android使用Vorbis压缩\n\n\n5.批次\n\n开启static batch\n开启dynamic batch：要求模型小于900顶点，用法线小于300，用切线小于180，缩放不一致、使用lightmap、多通道材质等会使dynamic batch无效。\n减少GameObject，场景模型数量对fps影响巨大。\n批次不是越少越好，过大的渲染数据会给总线传输带来压力。\n\n6.物理\n\n不需要移动的物体设为Static\n不要用Mesh碰撞，角色不用碰撞体\n触发器逻辑优化\n寻路频率、AI逻辑频率 、Fixed Timestep、降帧到30\n出现卡顿的复杂计算，例如寻路、大量资源加载 可以用分帧或者协成异步来处理","slug":"性能优化相关","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh13100584wf0fif278j8","content":"<p>1.渲染</p>\n<ul>\n<li>利用reflect probe代替反射、折射，尽量不用RTT、GrabPass、RenderWithShader、CommandBuffer.Blit (BuiltinRenderTextureType.CurrentActive…)</li>\n<li>建立统一后处理框架(bloom、hdr、DOF等)代替多后处理，可以共用模糊函数，减少多次blit；另外要注意RTT的尺寸。</li>\n<li>空气折射、热浪扭曲等使用GrabPass不是所有硬件都支持，改为RTT或者后处理来优化。</li>\n<li>建立统一shader材质代替单一shader，充分利用shader_feature、multi_compile，并将宏开关显示于界面。</li>\n<li>图像混合代替多通道纹理，阴影投射、阴影接收、MetaPass、forwardadd 等pass不需要时要剔除。</li>\n<li>少用alpha test、discard、clip、Alpha Converage等，因为会影响Early-Z Culling、HSR的优化。</li>\n<li>避免Alpha Blend穿透问题（权重混合、深度剥离等透明排序方法代价太大了）。</li>\n<li>光照贴图代替动态阴影、尽量不用实时光；阴影贴图、环境贴图用16位代替32位；利用projector+rtt或者光圈代替实时阴影。</li>\n<li>将环境参数（风、雨、太阳）等shader全局参数统一管理。</li>\n<li>非主角可以用matcap代替pbr、无金属不一定要用pbr，仔细选择物理渲染所用的FDG（F:schlick、cook-torrance、lerp、要求不高用4次方，D：blinn-phong、beckmann、GGX、GGX Anisotropic,G:neumann、cook-torrance、Kelemen、SmithGGX；standard shader要注意选择BRDF1-BRDF3），渲染要求不高时不用GGX；可以用LH来优化GGX。</li>\n<li>用fixed、half代替float,建立shader统一类型（fixed效率是float的4倍，half是float的2倍），小心选择shader变量的修饰(uniform、static、全局),选择Mobile或Unlit目录下shader</li>\n<li>使用高低配渲染，内存足够时可以考虑开启mipmap</li>\n<li>使用surface shader注意关掉不用的功能，比如：noshadow、noambient、novertexlights、nolightmap、nodynlightmap、nodirlightmap、nofog、nometa、noforwardadd等</li>\n<li>standard shader的变体太多（3万多），导致编译时间较长，内存占用也很惊人（接近1G），如果使用要关掉没用的shader_feature,比如：==<strong>_PARALLAXMAP、SHADOWS_SOFT、DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE、_DETAIL_MULX2、_ALPHAPREMULTIPLY_ON；另外要去掉多余的pass</strong> #F44336==</li>\n<li>shaderforge、Amplify Shader Editor生成的shader有多余代码要程序专门优化，Amplify Shader Editor功能更强大一些，而且开源，建议学习。</li>\n<li>不要用unity自带terrian，因为即使只用3张splat图，shader也是对应4个的，建议T4M或者转为mesh。</li>\n<li>模型和材质相同且数量巨大时用Instance来优化，比如草。</li>\n<li>利用查找纹理(LUT)来优化复杂的光照渲染，比如：皮肤、头发、喷漆等。</li>\n<li>尽量不要使用Procedural Sky，计算瑞丽散射和米氏散射效率比较低。</li>\n<li>尽量不要使用speedtree，改为模型加简单树叶动画，不过SpeedTreeWind.cginc里面的动画函数很丰富，- TerrianEngine中的SmoothTriangleWave很好用。</li>\n<li>多用调试工具检查shader性能，常用工具有：FrameDebug、Nsight、RenderDoc 、AMD GPU -ShaderAnalyzer / PVRShaderEditor、Adreno Profiler 、腾讯Cube、UWA等；另外可以内置GM界面，比如开关阴影，批量替换shader等方便真机调试。</li>\n</ul>\n<blockquote>\n<p>另一方面，Matcap是完全不考虑光照影响的渲染方法，因此也不存在能量守恒，只能通过采样贴图的绘制做出能量守恒的效果，所以不是真正的PBR，也因此能做出很多PBR无法实现的效果。</p>\n</blockquote>\n<p>2.脚本</p>\n<p>减少GetComponent、find等查找函数在Update等循环函数中的调用、go.CompareTag代替go.tag 、<br>减少SendMessage等同步函数调用；减少字符串连接；for代替foreach，5.5以后版本foreach已经优化过了；少用linq；<br>大资源改为异步加载<br>合理处理协程调用<br>将AI、网络等放在单独线程<br>发布优化：关闭log、剔除代码<br>伪随机<br>脚本挂载类改为Manager等全局类实现<br>lua中尽量不实现update、fixedupdate等循环函数，lua和csharp互调用的效率比较低。</p>\n<p>3.内存管理</p>\n<p>池子管理粒子、float UI等小资源，频繁地GC会造成卡顿<br>必要时主动调用GC.Collect()<br>按照不同资源、不同设备管理资源生命周期，Resources.Load和Assetbundle统一接口，利用引用计数来管理生命周期，并打印和观察生命周期。保证资源随场景而卸载，不常驻内存，确定哪些是预加载，哪些泄漏。<br>内存泄漏（减少驻留内存）：Container内资源不remove掉用Resources.UnloadUnusedAssets是卸载不掉的；对于这种情况，建议直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况；通过Android PSS/iOS Instrument反馈的App线程内存来查看；<br>堆内存过大：避免一次性堆内存的过大分配，Mono的堆内存一旦分配，就不会返还给系统，这意味着Mono的堆内存是只升不降的。常见：高频调用new；log输出；<br>CPU占用高：NGui的重建网格导致UIPanel.LateUpdate（按照静止、移动、高频移动来切分）；NGUI锚点自身的更新逻辑也会消耗不少CPU开销。即使是在控件静止不动的情况下，控件的锚点也会每帧更新（见UIWidget.OnUpdate函数），而且它的更新是递归式的，使CPU占用率更高。因此我们修改了NGUI的内部代码，使锚点只在必要时更新。一般只在控件初始化和屏幕大小发生变化时更新即可。不过这个优化的代价是控件的顶点位置发生变化的时候（比如控件在运动，或控件大小改变等），上层逻辑需要自己负责更新锚点。 加载用协程； 控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD血条可能会大量出现，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。<br>资源冗余：AssetBundle打包打到多份中；动态修改资源导致的Instance拷贝多份（比如动态修改材质，Renderer.meterial，Animation.AddClip）。<br>磁盘空间换内存：对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间</p>\n<p>4.美术</p>\n<p>建立资源审查规范和审查工具：PBR材质贴图制作规范、场景制作资源控制规范、角色制作规范、特效制作规范；利用AssetPostprocessor建立审查工具。<br>压缩纹理、优化精灵填充率、压缩动画、压缩声音、压缩UI（九宫格优于拉伸）；严格控制模型面数、纹理数、角色骨骼数。<br>粒子：录制动画代替粒子、减少粒子数量、粒子不要碰撞<br>角色：启用Optimize Game Objects减少节点,使用（SimpleLOD、Cruncher）优化面数。<br>模型：导入检查Read/Write only、Optimize Mesh、法线切线、color、禁用Mipmap<br>压缩纹理问题：压缩可能导致色阶不足；无透明通道用ETC1,现在安卓不支持ETC2已不足5%，建议放弃分离通道办法。<br>UI：尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；<br>ugui：可以充分利用canvas来切分不同元素。<br>大贴图会导致卡顿，可以切分为多个加载。<br>iOS使用mp3压缩、Android使用Vorbis压缩</p>\n<p>5.批次</p>\n<p>开启static batch<br>开启dynamic batch：要求模型小于900顶点，用法线小于300，用切线小于180，缩放不一致、使用lightmap、多通道材质等会使dynamic batch无效。<br>减少GameObject，场景模型数量对fps影响巨大。<br>批次不是越少越好，过大的渲染数据会给总线传输带来压力。</p>\n<p>6.物理</p>\n<p>不需要移动的物体设为Static<br>不要用Mesh碰撞，角色不用碰撞体<br>触发器逻辑优化<br>寻路频率、AI逻辑频率 、Fixed Timestep、降帧到30<br>出现卡顿的复杂计算，例如寻路、大量资源加载 可以用分帧或者协成异步来处理</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.渲染</p>\n<ul>\n<li>利用reflect probe代替反射、折射，尽量不用RTT、GrabPass、RenderWithShader、CommandBuffer.Blit (BuiltinRenderTextureType.CurrentActive…)</li>\n<li>建立统一后处理框架(bloom、hdr、DOF等)代替多后处理，可以共用模糊函数，减少多次blit；另外要注意RTT的尺寸。</li>\n<li>空气折射、热浪扭曲等使用GrabPass不是所有硬件都支持，改为RTT或者后处理来优化。</li>\n<li>建立统一shader材质代替单一shader，充分利用shader_feature、multi_compile，并将宏开关显示于界面。</li>\n<li>图像混合代替多通道纹理，阴影投射、阴影接收、MetaPass、forwardadd 等pass不需要时要剔除。</li>\n<li>少用alpha test、discard、clip、Alpha Converage等，因为会影响Early-Z Culling、HSR的优化。</li>\n<li>避免Alpha Blend穿透问题（权重混合、深度剥离等透明排序方法代价太大了）。</li>\n<li>光照贴图代替动态阴影、尽量不用实时光；阴影贴图、环境贴图用16位代替32位；利用projector+rtt或者光圈代替实时阴影。</li>\n<li>将环境参数（风、雨、太阳）等shader全局参数统一管理。</li>\n<li>非主角可以用matcap代替pbr、无金属不一定要用pbr，仔细选择物理渲染所用的FDG（F:schlick、cook-torrance、lerp、要求不高用4次方，D：blinn-phong、beckmann、GGX、GGX Anisotropic,G:neumann、cook-torrance、Kelemen、SmithGGX；standard shader要注意选择BRDF1-BRDF3），渲染要求不高时不用GGX；可以用LH来优化GGX。</li>\n<li>用fixed、half代替float,建立shader统一类型（fixed效率是float的4倍，half是float的2倍），小心选择shader变量的修饰(uniform、static、全局),选择Mobile或Unlit目录下shader</li>\n<li>使用高低配渲染，内存足够时可以考虑开启mipmap</li>\n<li>使用surface shader注意关掉不用的功能，比如：noshadow、noambient、novertexlights、nolightmap、nodynlightmap、nodirlightmap、nofog、nometa、noforwardadd等</li>\n<li>standard shader的变体太多（3万多），导致编译时间较长，内存占用也很惊人（接近1G），如果使用要关掉没用的shader_feature,比如：==<strong>_PARALLAXMAP、SHADOWS_SOFT、DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE、_DETAIL_MULX2、_ALPHAPREMULTIPLY_ON；另外要去掉多余的pass</strong> #F44336==</li>\n<li>shaderforge、Amplify Shader Editor生成的shader有多余代码要程序专门优化，Amplify Shader Editor功能更强大一些，而且开源，建议学习。</li>\n<li>不要用unity自带terrian，因为即使只用3张splat图，shader也是对应4个的，建议T4M或者转为mesh。</li>\n<li>模型和材质相同且数量巨大时用Instance来优化，比如草。</li>\n<li>利用查找纹理(LUT)来优化复杂的光照渲染，比如：皮肤、头发、喷漆等。</li>\n<li>尽量不要使用Procedural Sky，计算瑞丽散射和米氏散射效率比较低。</li>\n<li>尽量不要使用speedtree，改为模型加简单树叶动画，不过SpeedTreeWind.cginc里面的动画函数很丰富，- TerrianEngine中的SmoothTriangleWave很好用。</li>\n<li>多用调试工具检查shader性能，常用工具有：FrameDebug、Nsight、RenderDoc 、AMD GPU -ShaderAnalyzer / PVRShaderEditor、Adreno Profiler 、腾讯Cube、UWA等；另外可以内置GM界面，比如开关阴影，批量替换shader等方便真机调试。</li>\n</ul>\n<blockquote>\n<p>另一方面，Matcap是完全不考虑光照影响的渲染方法，因此也不存在能量守恒，只能通过采样贴图的绘制做出能量守恒的效果，所以不是真正的PBR，也因此能做出很多PBR无法实现的效果。</p>\n</blockquote>\n<p>2.脚本</p>\n<p>减少GetComponent、find等查找函数在Update等循环函数中的调用、go.CompareTag代替go.tag 、<br>减少SendMessage等同步函数调用；减少字符串连接；for代替foreach，5.5以后版本foreach已经优化过了；少用linq；<br>大资源改为异步加载<br>合理处理协程调用<br>将AI、网络等放在单独线程<br>发布优化：关闭log、剔除代码<br>伪随机<br>脚本挂载类改为Manager等全局类实现<br>lua中尽量不实现update、fixedupdate等循环函数，lua和csharp互调用的效率比较低。</p>\n<p>3.内存管理</p>\n<p>池子管理粒子、float UI等小资源，频繁地GC会造成卡顿<br>必要时主动调用GC.Collect()<br>按照不同资源、不同设备管理资源生命周期，Resources.Load和Assetbundle统一接口，利用引用计数来管理生命周期，并打印和观察生命周期。保证资源随场景而卸载，不常驻内存，确定哪些是预加载，哪些泄漏。<br>内存泄漏（减少驻留内存）：Container内资源不remove掉用Resources.UnloadUnusedAssets是卸载不掉的；对于这种情况，建议直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况；通过Android PSS/iOS Instrument反馈的App线程内存来查看；<br>堆内存过大：避免一次性堆内存的过大分配，Mono的堆内存一旦分配，就不会返还给系统，这意味着Mono的堆内存是只升不降的。常见：高频调用new；log输出；<br>CPU占用高：NGui的重建网格导致UIPanel.LateUpdate（按照静止、移动、高频移动来切分）；NGUI锚点自身的更新逻辑也会消耗不少CPU开销。即使是在控件静止不动的情况下，控件的锚点也会每帧更新（见UIWidget.OnUpdate函数），而且它的更新是递归式的，使CPU占用率更高。因此我们修改了NGUI的内部代码，使锚点只在必要时更新。一般只在控件初始化和屏幕大小发生变化时更新即可。不过这个优化的代价是控件的顶点位置发生变化的时候（比如控件在运动，或控件大小改变等），上层逻辑需要自己负责更新锚点。 加载用协程； 控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD血条可能会大量出现，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。<br>资源冗余：AssetBundle打包打到多份中；动态修改资源导致的Instance拷贝多份（比如动态修改材质，Renderer.meterial，Animation.AddClip）。<br>磁盘空间换内存：对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间</p>\n<p>4.美术</p>\n<p>建立资源审查规范和审查工具：PBR材质贴图制作规范、场景制作资源控制规范、角色制作规范、特效制作规范；利用AssetPostprocessor建立审查工具。<br>压缩纹理、优化精灵填充率、压缩动画、压缩声音、压缩UI（九宫格优于拉伸）；严格控制模型面数、纹理数、角色骨骼数。<br>粒子：录制动画代替粒子、减少粒子数量、粒子不要碰撞<br>角色：启用Optimize Game Objects减少节点,使用（SimpleLOD、Cruncher）优化面数。<br>模型：导入检查Read/Write only、Optimize Mesh、法线切线、color、禁用Mipmap<br>压缩纹理问题：压缩可能导致色阶不足；无透明通道用ETC1,现在安卓不支持ETC2已不足5%，建议放弃分离通道办法。<br>UI：尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；<br>ugui：可以充分利用canvas来切分不同元素。<br>大贴图会导致卡顿，可以切分为多个加载。<br>iOS使用mp3压缩、Android使用Vorbis压缩</p>\n<p>5.批次</p>\n<p>开启static batch<br>开启dynamic batch：要求模型小于900顶点，用法线小于300，用切线小于180，缩放不一致、使用lightmap、多通道材质等会使dynamic batch无效。<br>减少GameObject，场景模型数量对fps影响巨大。<br>批次不是越少越好，过大的渲染数据会给总线传输带来压力。</p>\n<p>6.物理</p>\n<p>不需要移动的物体设为Static<br>不要用Mesh碰撞，角色不用碰撞体<br>触发器逻辑优化<br>寻路频率、AI逻辑频率 、Fixed Timestep、降帧到30<br>出现卡顿的复杂计算，例如寻路、大量资源加载 可以用分帧或者协成异步来处理</p>\n"},{"title":"开言学习笔记1","_content":"\n##  Housewarming Party 乔迁派对\n\n#### Dialog\n\n* A: Hey guys, glad you could make it! Come on in!\n* B: Thanks for inviting us! Wow, I love your new place, it's gorgeus!\n* A: Thanks. I moved in last week. I'm still setting up the living room.\n* B: I love the layout. The view is great too!\n* A: Thanks. I was lucky to find this place. Come on, I'll show you around.\n* B: Oh, here, before I forget, I brought you a housewarming gift.\n* A: Wine! Thank you. You shouldn't have.\n* B: Oh, it's my pleasure. Should I put it on the table?\n* A: Sure. After that, come with me. I want you to meet my new neighbors.\n* B: Sure, I'd love to.\n\n#### Phrases\n* Come on in!\n* Setting up\n* show you around\n* housewarming gift\n\n## Opening a bank account\n\n#### Words\n* teller\n* balance\n* checking account借记账号 & saving account存储账号\n > checking account: day to day banking. use every day\n* interest 利息\n* fees\n* doable 可行的\n* deposit v.存款 + deposit some money\n* wage\n \n #### Dialog\n * A: Hi there, how can I help you today?\n * B: Hi, I'd like to open a personal bank account.\n * A: OK, are you looking to set up a checking account, savings acount or both?\n * B: Hmm. What's the difference?\n * A: Checking is for day-to-day banking and savings help you earn interest.\n * B:Alright, I'll get both. Are there any monthly fee?\n * A: Our basic account is just $12 a month. But if your balance is over $1500, it's free.\n * B: Ok, that's totally doable, I'll go with that.\n * A: Great, how much would you to deposit today? The minimum is $25.\n * B: I'll put $2000 into checking and $1000 into savings.\n * A: Excellent! Now all I need is you ID and some personal information.\n \n #### Phrases\n * go with that  == choose that\n\n## Overdue bills\n\n#### Sentences\n* The baby is overdue. \n* You are overdue for something.\n\n#### Words&Phrases\n* get on top of == get in control of \n* shark\n* loan\n* pay off\n* ten out of ten //10总分得10分\n* borrow from the bank\n* utility\n* past due & overdue\n* cut off\n* budgets a little == plan spending \n* get off light == punishment was really not all that terrible.\n \n#### Dialog\n\n\n## Calling the landlord\n\n#### Phrases\n* drop by 顺道拜访\n* broke down\n* have issues\n\n#### Dialog\n* A:Hi Bob. It's Kelly, do you have a moment?\n* B:Of cource Kelly, what can I do for you?\n* A:Well, I'm having a few issues at my apartment.\n* B:Oh, is the wifi going in and out again?\n* A:No, the connection is ok. but the water heater is broken, so only cold water comes out.\n* B:Oh, are you home tomorrow? I can drop by and have a look.\n* A:Sure, could you also look at the washing machine? it broke down and won't turn on.\n* B:Hmm.. was there anything stuck in the machine?\n* A:No, I think it's just old. would it be possible to have it repaired by Friday?\n* B:Well, I can't make any promises, but I'll try my best.\n \n ","source":"_posts/开言学习笔记1.md","raw":"---\ntitle: 开言学习笔记1\ncategories:\n- 英语学习\ntags: \n- English\n- Note\n---\n\n##  Housewarming Party 乔迁派对\n\n#### Dialog\n\n* A: Hey guys, glad you could make it! Come on in!\n* B: Thanks for inviting us! Wow, I love your new place, it's gorgeus!\n* A: Thanks. I moved in last week. I'm still setting up the living room.\n* B: I love the layout. The view is great too!\n* A: Thanks. I was lucky to find this place. Come on, I'll show you around.\n* B: Oh, here, before I forget, I brought you a housewarming gift.\n* A: Wine! Thank you. You shouldn't have.\n* B: Oh, it's my pleasure. Should I put it on the table?\n* A: Sure. After that, come with me. I want you to meet my new neighbors.\n* B: Sure, I'd love to.\n\n#### Phrases\n* Come on in!\n* Setting up\n* show you around\n* housewarming gift\n\n## Opening a bank account\n\n#### Words\n* teller\n* balance\n* checking account借记账号 & saving account存储账号\n > checking account: day to day banking. use every day\n* interest 利息\n* fees\n* doable 可行的\n* deposit v.存款 + deposit some money\n* wage\n \n #### Dialog\n * A: Hi there, how can I help you today?\n * B: Hi, I'd like to open a personal bank account.\n * A: OK, are you looking to set up a checking account, savings acount or both?\n * B: Hmm. What's the difference?\n * A: Checking is for day-to-day banking and savings help you earn interest.\n * B:Alright, I'll get both. Are there any monthly fee?\n * A: Our basic account is just $12 a month. But if your balance is over $1500, it's free.\n * B: Ok, that's totally doable, I'll go with that.\n * A: Great, how much would you to deposit today? The minimum is $25.\n * B: I'll put $2000 into checking and $1000 into savings.\n * A: Excellent! Now all I need is you ID and some personal information.\n \n #### Phrases\n * go with that  == choose that\n\n## Overdue bills\n\n#### Sentences\n* The baby is overdue. \n* You are overdue for something.\n\n#### Words&Phrases\n* get on top of == get in control of \n* shark\n* loan\n* pay off\n* ten out of ten //10总分得10分\n* borrow from the bank\n* utility\n* past due & overdue\n* cut off\n* budgets a little == plan spending \n* get off light == punishment was really not all that terrible.\n \n#### Dialog\n\n\n## Calling the landlord\n\n#### Phrases\n* drop by 顺道拜访\n* broke down\n* have issues\n\n#### Dialog\n* A:Hi Bob. It's Kelly, do you have a moment?\n* B:Of cource Kelly, what can I do for you?\n* A:Well, I'm having a few issues at my apartment.\n* B:Oh, is the wifi going in and out again?\n* A:No, the connection is ok. but the water heater is broken, so only cold water comes out.\n* B:Oh, are you home tomorrow? I can drop by and have a look.\n* A:Sure, could you also look at the washing machine? it broke down and won't turn on.\n* B:Hmm.. was there anything stuck in the machine?\n* A:No, I think it's just old. would it be possible to have it repaired by Friday?\n* B:Well, I can't make any promises, but I'll try my best.\n \n ","slug":"开言学习笔记1","published":1,"date":"2020-09-08T03:23:20.890Z","updated":"2020-09-08T03:23:20.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh132005c4wf07lz3ergp","content":"<h2 id=\"Housewarming-Party-乔迁派对\"><a href=\"#Housewarming-Party-乔迁派对\" class=\"headerlink\" title=\"Housewarming Party 乔迁派对\"></a>Housewarming Party 乔迁派对</h2><h4 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h4><ul>\n<li>A: Hey guys, glad you could make it! Come on in!</li>\n<li>B: Thanks for inviting us! Wow, I love your new place, it’s gorgeus!</li>\n<li>A: Thanks. I moved in last week. I’m still setting up the living room.</li>\n<li>B: I love the layout. The view is great too!</li>\n<li>A: Thanks. I was lucky to find this place. Come on, I’ll show you around.</li>\n<li>B: Oh, here, before I forget, I brought you a housewarming gift.</li>\n<li>A: Wine! Thank you. You shouldn’t have.</li>\n<li>B: Oh, it’s my pleasure. Should I put it on the table?</li>\n<li>A: Sure. After that, come with me. I want you to meet my new neighbors.</li>\n<li>B: Sure, I’d love to.</li>\n</ul>\n<h4 id=\"Phrases\"><a href=\"#Phrases\" class=\"headerlink\" title=\"Phrases\"></a>Phrases</h4><ul>\n<li>Come on in!</li>\n<li>Setting up</li>\n<li>show you around</li>\n<li>housewarming gift</li>\n</ul>\n<h2 id=\"Opening-a-bank-account\"><a href=\"#Opening-a-bank-account\" class=\"headerlink\" title=\"Opening a bank account\"></a>Opening a bank account</h2><h4 id=\"Words\"><a href=\"#Words\" class=\"headerlink\" title=\"Words\"></a>Words</h4><ul>\n<li><p>teller</p>\n</li>\n<li><p>balance</p>\n</li>\n<li><p>checking account借记账号 &amp; saving account存储账号</p>\n<blockquote>\n<p>checking account: day to day banking. use every day</p>\n</blockquote>\n</li>\n<li><p>interest 利息</p>\n</li>\n<li><p>fees</p>\n</li>\n<li><p>doable 可行的</p>\n</li>\n<li><p>deposit v.存款 + deposit some money</p>\n</li>\n<li><p>wage</p>\n<h4 id=\"Dialog-1\"><a href=\"#Dialog-1\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h4><ul>\n<li>A: Hi there, how can I help you today?</li>\n<li>B: Hi, I’d like to open a personal bank account.</li>\n<li>A: OK, are you looking to set up a checking account, savings acount or both?</li>\n<li>B: Hmm. What’s the difference?</li>\n<li>A: Checking is for day-to-day banking and savings help you earn interest.</li>\n<li>B:Alright, I’ll get both. Are there any monthly fee?</li>\n<li>A: Our basic account is just $12 a month. But if your balance is over $1500, it’s free.</li>\n<li>B: Ok, that’s totally doable, I’ll go with that.</li>\n<li>A: Great, how much would you to deposit today? The minimum is $25.</li>\n<li>B: I’ll put $2000 into checking and $1000 into savings.</li>\n<li>A: Excellent! Now all I need is you ID and some personal information.</li>\n</ul>\n<h4 id=\"Phrases-1\"><a href=\"#Phrases-1\" class=\"headerlink\" title=\"Phrases\"></a>Phrases</h4><ul>\n<li>go with that  == choose that</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Overdue-bills\"><a href=\"#Overdue-bills\" class=\"headerlink\" title=\"Overdue bills\"></a>Overdue bills</h2><h4 id=\"Sentences\"><a href=\"#Sentences\" class=\"headerlink\" title=\"Sentences\"></a>Sentences</h4><ul>\n<li>The baby is overdue. </li>\n<li>You are overdue for something.</li>\n</ul>\n<h4 id=\"Words-amp-Phrases\"><a href=\"#Words-amp-Phrases\" class=\"headerlink\" title=\"Words&amp;Phrases\"></a>Words&amp;Phrases</h4><ul>\n<li>get on top of == get in control of </li>\n<li>shark</li>\n<li>loan</li>\n<li>pay off</li>\n<li>ten out of ten //10总分得10分</li>\n<li>borrow from the bank</li>\n<li>utility</li>\n<li>past due &amp; overdue</li>\n<li>cut off</li>\n<li>budgets a little == plan spending </li>\n<li>get off light == punishment was really not all that terrible.</li>\n</ul>\n<h4 id=\"Dialog-2\"><a href=\"#Dialog-2\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h4><h2 id=\"Calling-the-landlord\"><a href=\"#Calling-the-landlord\" class=\"headerlink\" title=\"Calling the landlord\"></a>Calling the landlord</h2><h4 id=\"Phrases-2\"><a href=\"#Phrases-2\" class=\"headerlink\" title=\"Phrases\"></a>Phrases</h4><ul>\n<li>drop by 顺道拜访</li>\n<li>broke down</li>\n<li>have issues</li>\n</ul>\n<h4 id=\"Dialog-3\"><a href=\"#Dialog-3\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h4><ul>\n<li>A:Hi Bob. It’s Kelly, do you have a moment?</li>\n<li>B:Of cource Kelly, what can I do for you?</li>\n<li>A:Well, I’m having a few issues at my apartment.</li>\n<li>B:Oh, is the wifi going in and out again?</li>\n<li>A:No, the connection is ok. but the water heater is broken, so only cold water comes out.</li>\n<li>B:Oh, are you home tomorrow? I can drop by and have a look.</li>\n<li>A:Sure, could you also look at the washing machine? it broke down and won’t turn on.</li>\n<li>B:Hmm.. was there anything stuck in the machine?</li>\n<li>A:No, I think it’s just old. would it be possible to have it repaired by Friday?</li>\n<li>B:Well, I can’t make any promises, but I’ll try my best.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Housewarming-Party-乔迁派对\"><a href=\"#Housewarming-Party-乔迁派对\" class=\"headerlink\" title=\"Housewarming Party 乔迁派对\"></a>Housewarming Party 乔迁派对</h2><h4 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h4><ul>\n<li>A: Hey guys, glad you could make it! Come on in!</li>\n<li>B: Thanks for inviting us! Wow, I love your new place, it’s gorgeus!</li>\n<li>A: Thanks. I moved in last week. I’m still setting up the living room.</li>\n<li>B: I love the layout. The view is great too!</li>\n<li>A: Thanks. I was lucky to find this place. Come on, I’ll show you around.</li>\n<li>B: Oh, here, before I forget, I brought you a housewarming gift.</li>\n<li>A: Wine! Thank you. You shouldn’t have.</li>\n<li>B: Oh, it’s my pleasure. Should I put it on the table?</li>\n<li>A: Sure. After that, come with me. I want you to meet my new neighbors.</li>\n<li>B: Sure, I’d love to.</li>\n</ul>\n<h4 id=\"Phrases\"><a href=\"#Phrases\" class=\"headerlink\" title=\"Phrases\"></a>Phrases</h4><ul>\n<li>Come on in!</li>\n<li>Setting up</li>\n<li>show you around</li>\n<li>housewarming gift</li>\n</ul>\n<h2 id=\"Opening-a-bank-account\"><a href=\"#Opening-a-bank-account\" class=\"headerlink\" title=\"Opening a bank account\"></a>Opening a bank account</h2><h4 id=\"Words\"><a href=\"#Words\" class=\"headerlink\" title=\"Words\"></a>Words</h4><ul>\n<li><p>teller</p>\n</li>\n<li><p>balance</p>\n</li>\n<li><p>checking account借记账号 &amp; saving account存储账号</p>\n<blockquote>\n<p>checking account: day to day banking. use every day</p>\n</blockquote>\n</li>\n<li><p>interest 利息</p>\n</li>\n<li><p>fees</p>\n</li>\n<li><p>doable 可行的</p>\n</li>\n<li><p>deposit v.存款 + deposit some money</p>\n</li>\n<li><p>wage</p>\n<h4 id=\"Dialog-1\"><a href=\"#Dialog-1\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h4><ul>\n<li>A: Hi there, how can I help you today?</li>\n<li>B: Hi, I’d like to open a personal bank account.</li>\n<li>A: OK, are you looking to set up a checking account, savings acount or both?</li>\n<li>B: Hmm. What’s the difference?</li>\n<li>A: Checking is for day-to-day banking and savings help you earn interest.</li>\n<li>B:Alright, I’ll get both. Are there any monthly fee?</li>\n<li>A: Our basic account is just $12 a month. But if your balance is over $1500, it’s free.</li>\n<li>B: Ok, that’s totally doable, I’ll go with that.</li>\n<li>A: Great, how much would you to deposit today? The minimum is $25.</li>\n<li>B: I’ll put $2000 into checking and $1000 into savings.</li>\n<li>A: Excellent! Now all I need is you ID and some personal information.</li>\n</ul>\n<h4 id=\"Phrases-1\"><a href=\"#Phrases-1\" class=\"headerlink\" title=\"Phrases\"></a>Phrases</h4><ul>\n<li>go with that  == choose that</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Overdue-bills\"><a href=\"#Overdue-bills\" class=\"headerlink\" title=\"Overdue bills\"></a>Overdue bills</h2><h4 id=\"Sentences\"><a href=\"#Sentences\" class=\"headerlink\" title=\"Sentences\"></a>Sentences</h4><ul>\n<li>The baby is overdue. </li>\n<li>You are overdue for something.</li>\n</ul>\n<h4 id=\"Words-amp-Phrases\"><a href=\"#Words-amp-Phrases\" class=\"headerlink\" title=\"Words&amp;Phrases\"></a>Words&amp;Phrases</h4><ul>\n<li>get on top of == get in control of </li>\n<li>shark</li>\n<li>loan</li>\n<li>pay off</li>\n<li>ten out of ten //10总分得10分</li>\n<li>borrow from the bank</li>\n<li>utility</li>\n<li>past due &amp; overdue</li>\n<li>cut off</li>\n<li>budgets a little == plan spending </li>\n<li>get off light == punishment was really not all that terrible.</li>\n</ul>\n<h4 id=\"Dialog-2\"><a href=\"#Dialog-2\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h4><h2 id=\"Calling-the-landlord\"><a href=\"#Calling-the-landlord\" class=\"headerlink\" title=\"Calling the landlord\"></a>Calling the landlord</h2><h4 id=\"Phrases-2\"><a href=\"#Phrases-2\" class=\"headerlink\" title=\"Phrases\"></a>Phrases</h4><ul>\n<li>drop by 顺道拜访</li>\n<li>broke down</li>\n<li>have issues</li>\n</ul>\n<h4 id=\"Dialog-3\"><a href=\"#Dialog-3\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h4><ul>\n<li>A:Hi Bob. It’s Kelly, do you have a moment?</li>\n<li>B:Of cource Kelly, what can I do for you?</li>\n<li>A:Well, I’m having a few issues at my apartment.</li>\n<li>B:Oh, is the wifi going in and out again?</li>\n<li>A:No, the connection is ok. but the water heater is broken, so only cold water comes out.</li>\n<li>B:Oh, are you home tomorrow? I can drop by and have a look.</li>\n<li>A:Sure, could you also look at the washing machine? it broke down and won’t turn on.</li>\n<li>B:Hmm.. was there anything stuck in the machine?</li>\n<li>A:No, I think it’s just old. would it be possible to have it repaired by Friday?</li>\n<li>B:Well, I can’t make any promises, but I’ll try my best.</li>\n</ul>\n"},{"title":"最新Addressable资源打包与加载框架","_content":"\n#### 一、Addressable介绍\n\nAddressable是Unity最新推出且正式发布的资源管理系统，内含引用计数管理，快速资源热更，资源性能查看器，资源冗余工具等等，据官方的说法，这就像当初AssetBundle取代Resources一样，Addressable就是为了取代直接使用AssetBundle而生。\n\n#### 二、Addressable下载更新\n> 内容均在ResDownloadComponent中。\n\n##### 1. 打包资源\n手动： 使用 Build ->New Build -> Default Build Script。 也可用打包脚本，`AddressableAssetSettings.CleanPlayerContent();\n        AddressableAssetSettings.BuildPlayerContent();`\n生成的资源将在Library->com.unityengine.addressable下\n> 建议本机初次导项目后，先执行一次打包资源，再使用Use Existing Build的Play Mode Script方式，以bundle加载运行，方便测试。\n\n##### 2. 更新资源\n* 在发完包的情况下，在打包的机器上的Unity，选择Tools -> Check for Content Update Restriction 来获取变更的资源\n* 将这些资源应用出来一个新的Group， 再统一挂上updates的标签！\n* 选择Build -> Update a previous build 选择android的bin文件，等待完成，将会生成新的updates开头的更新文件，将这些文件上传即可更新。\n> 更新完后之后，如果再需要出包，请将资源归还到原group中，以防下次混乱了。\n\n#### 3.打包工具使用\n本地打包，可使用Tools -> 打包工具，勾选 是否打包工程，将导出一个gradle的工程，否则将先打出工程后接着打出apk。\n打包机不可使用此工具打包，由CI控制。\n\n#### 三、Addressable内置接口介绍\n\n> 针对Addressable有两个缓存池，一个针对asset的 AssetCachePoolComponent，用于存放所有的资源，一般存放不需要实例化的资源，如material等。  另一个针对实例对象的 ResGameObjectPoolComponent， 用于存放实例出来的资源，会记录对象的handle句柄和对象实例列表。\n\n ##### 1. 加载接口\n\n1.1 LoadAssetAsyncHandle(assetName, saveToCache = false, isGlobal = false)\n * 以asset的形式加载资源不实例化，只返回相应资源句柄. [saveToCache]意为加载完的资源将直接记到缓存池，[isGlobal] 决定了是全局缓存池还是场景缓存池\n**注意： [isGlobal]只在[saveToCache]为 true 时才会使用,用于保存在全局缓存池或对应场景的池子中**\n```csharp\n ETTask<AsyncOperationHandle<T>> LoadAssetAsyncHandle<T>(string assetName, bool saveToCache = false, bool isGlobal = false)\n```\n\n>简单用法使用示例：(加载配置文件的Config预制)\n>\n>```csharp\n> //获取加载完的句柄\n>var configGOHandle = await ResourceLoaderComponent.Instance.LoadAssetAsyncHandle<GameObject>(\"Config\");\n>//从Handle中获取结果\n> configGO = configGOHandle.Result;\n> //当时即销毁此Handle\n>ResourceLoaderComponent.Instance.ReleaseHandle(configGOHandle);\n\n\n>深度使用示例：\n>```csharp\n>//预加载需要用的材质，设值记录到缓存, 且非全局资源\n>await ResourceLoaderComponent.Instance.LoadAssetAsyncHandle<Material>(\"GrayMaterial\",true,false);\n> //从缓存加载对应的材质\n> Material MAT_GARY = ResourceLoaderComponent.Instance.LoadFromCache<Material>(\"GrayMaterial\", false);\n>//从缓存删除对应的材质\n> ResourceLoaderComponent.Instance.ReleaseFromCache(\"GrayMaterial\",false,typeof(Material));\n>```\n\n1.2 LoadAssetsAsyncHandle(assetName, label = ResourceLabel.none, saveToCache = false, isGlobal = false)\n* 以asset的形式加载资源不实例化，只返回相应此资源数组句柄. 区别于1.1接口，此接口可配置多一个label的参数指明资源标签。\n**注意：如果保存到缓存中，则是一个数组，LoadFromCache时必须使用一个数组返回。**\n```csharp\n ETTask<AsyncOperationHandle<IList<T>>> LoadAssetsAsyncHandle<T>(string assetName, ResourceLabel label = ResourceLabel.none, bool saveToCache = false, bool isGlobal = false)\n```\n\n>使用示例：\n>```csharp\n>var handle = await Game.Scene.GetComponent<ResourceLoaderComponent>().LoadAssetsAsyncHandle<GameObject>(\"HeadResSmallSize\",ResourceLabel.ui);\n>var userIcon = handle.Result[0];\n>``` \n \n1.3 LoadPrefab(assetName, label, dontDestroy = false, parent = null)\n* 以asset和label的形式加载资源并实例化, 如果dontDestroy为true，则为全局资源，不随场景删除\n```csharp\n ETTask<GameObject> LoadPrefab(string assetName, ResourceLabel label = ResourceLabel.none, bool dontDestroy = false, Transform parent = null)\n```\n\n>使用示例：\n>```csharp\n>//(配置Buff的预制)\n> GameObject configGo = await Game.Scene.GetComponent<ResourceLoaderComponent>().LoadPrefab($\"{buffCfg}\",ResourceLabel.buff);\n >```\n\n1.4 LoadPrefab(assetName, label, scene, parent = null)\n* 以asset和label的形式加载资源并实例化,同1.3，不过传入一个框架里的Scene对象用于存储此对象的缓存池\n```csharp\n ETTask<GameObject> LoadPrefab(string assetName, ResourceLabel label = ResourceLabel.none, bool dontDestroy = false, Transform parent = null)\n```\n\n ##### 2. 缓存类接口\n \n 2.1 ReleaseFromCache(string key, bool isGlobal, Type resType)\n* 将某个key直接从【AssetCachePool】对象池子里释放，isGlobal决定了使用全局缓存池还是场景缓存池\n\n2.2 LoadFromCache<T>(string key, bool isGlobal) where T: UnityEngine.Object\n * 从【ResGameObjectPool】缓存池加载一个类型T的对象，isGlobal决定了使用全局缓存池还是场景缓存池\n\n2.3 RecyclePrefab(string poolKey,GameObject o, bool isGlobal = false)\n* 将对象o回收进某个key对应的【ResGameObjectPool】缓存池，isGlobal决定了使用全局缓存池还是场景缓存池\n\n2.4 RecyclePrefab(string assetName, ResourceLabel resLabel, GameObject o, bool isGlobal = false)\n* 将对象o回收进某个资源名及label对应的【ResGameObjectPool】缓存池，isGlobal决定了使用全局缓存池还是场景缓存池\n\n2.5 ReleasePrefab(string assetName, ResourceLabel resLabel, bool isGlobal = false)\n*  将对应assetName和resLabel的实例对象从【ResGameObjectPool】池子中释放（清除），isGlobal决定了使用全局缓存池还是场景缓存池\n\n\n##### 3. addressable接口\n\n3.1 ReleaseHandle(AsyncOperationHandle handle)\n* 释放一个addressable的异步句柄 \n\n","source":"_posts/最新Addressable资源打包与加载框架.md","raw":"---\ntitle: 最新Addressable资源打包与加载框架\ncategories:\n- 公司\ntags: \n---\n\n#### 一、Addressable介绍\n\nAddressable是Unity最新推出且正式发布的资源管理系统，内含引用计数管理，快速资源热更，资源性能查看器，资源冗余工具等等，据官方的说法，这就像当初AssetBundle取代Resources一样，Addressable就是为了取代直接使用AssetBundle而生。\n\n#### 二、Addressable下载更新\n> 内容均在ResDownloadComponent中。\n\n##### 1. 打包资源\n手动： 使用 Build ->New Build -> Default Build Script。 也可用打包脚本，`AddressableAssetSettings.CleanPlayerContent();\n        AddressableAssetSettings.BuildPlayerContent();`\n生成的资源将在Library->com.unityengine.addressable下\n> 建议本机初次导项目后，先执行一次打包资源，再使用Use Existing Build的Play Mode Script方式，以bundle加载运行，方便测试。\n\n##### 2. 更新资源\n* 在发完包的情况下，在打包的机器上的Unity，选择Tools -> Check for Content Update Restriction 来获取变更的资源\n* 将这些资源应用出来一个新的Group， 再统一挂上updates的标签！\n* 选择Build -> Update a previous build 选择android的bin文件，等待完成，将会生成新的updates开头的更新文件，将这些文件上传即可更新。\n> 更新完后之后，如果再需要出包，请将资源归还到原group中，以防下次混乱了。\n\n#### 3.打包工具使用\n本地打包，可使用Tools -> 打包工具，勾选 是否打包工程，将导出一个gradle的工程，否则将先打出工程后接着打出apk。\n打包机不可使用此工具打包，由CI控制。\n\n#### 三、Addressable内置接口介绍\n\n> 针对Addressable有两个缓存池，一个针对asset的 AssetCachePoolComponent，用于存放所有的资源，一般存放不需要实例化的资源，如material等。  另一个针对实例对象的 ResGameObjectPoolComponent， 用于存放实例出来的资源，会记录对象的handle句柄和对象实例列表。\n\n ##### 1. 加载接口\n\n1.1 LoadAssetAsyncHandle(assetName, saveToCache = false, isGlobal = false)\n * 以asset的形式加载资源不实例化，只返回相应资源句柄. [saveToCache]意为加载完的资源将直接记到缓存池，[isGlobal] 决定了是全局缓存池还是场景缓存池\n**注意： [isGlobal]只在[saveToCache]为 true 时才会使用,用于保存在全局缓存池或对应场景的池子中**\n```csharp\n ETTask<AsyncOperationHandle<T>> LoadAssetAsyncHandle<T>(string assetName, bool saveToCache = false, bool isGlobal = false)\n```\n\n>简单用法使用示例：(加载配置文件的Config预制)\n>\n>```csharp\n> //获取加载完的句柄\n>var configGOHandle = await ResourceLoaderComponent.Instance.LoadAssetAsyncHandle<GameObject>(\"Config\");\n>//从Handle中获取结果\n> configGO = configGOHandle.Result;\n> //当时即销毁此Handle\n>ResourceLoaderComponent.Instance.ReleaseHandle(configGOHandle);\n\n\n>深度使用示例：\n>```csharp\n>//预加载需要用的材质，设值记录到缓存, 且非全局资源\n>await ResourceLoaderComponent.Instance.LoadAssetAsyncHandle<Material>(\"GrayMaterial\",true,false);\n> //从缓存加载对应的材质\n> Material MAT_GARY = ResourceLoaderComponent.Instance.LoadFromCache<Material>(\"GrayMaterial\", false);\n>//从缓存删除对应的材质\n> ResourceLoaderComponent.Instance.ReleaseFromCache(\"GrayMaterial\",false,typeof(Material));\n>```\n\n1.2 LoadAssetsAsyncHandle(assetName, label = ResourceLabel.none, saveToCache = false, isGlobal = false)\n* 以asset的形式加载资源不实例化，只返回相应此资源数组句柄. 区别于1.1接口，此接口可配置多一个label的参数指明资源标签。\n**注意：如果保存到缓存中，则是一个数组，LoadFromCache时必须使用一个数组返回。**\n```csharp\n ETTask<AsyncOperationHandle<IList<T>>> LoadAssetsAsyncHandle<T>(string assetName, ResourceLabel label = ResourceLabel.none, bool saveToCache = false, bool isGlobal = false)\n```\n\n>使用示例：\n>```csharp\n>var handle = await Game.Scene.GetComponent<ResourceLoaderComponent>().LoadAssetsAsyncHandle<GameObject>(\"HeadResSmallSize\",ResourceLabel.ui);\n>var userIcon = handle.Result[0];\n>``` \n \n1.3 LoadPrefab(assetName, label, dontDestroy = false, parent = null)\n* 以asset和label的形式加载资源并实例化, 如果dontDestroy为true，则为全局资源，不随场景删除\n```csharp\n ETTask<GameObject> LoadPrefab(string assetName, ResourceLabel label = ResourceLabel.none, bool dontDestroy = false, Transform parent = null)\n```\n\n>使用示例：\n>```csharp\n>//(配置Buff的预制)\n> GameObject configGo = await Game.Scene.GetComponent<ResourceLoaderComponent>().LoadPrefab($\"{buffCfg}\",ResourceLabel.buff);\n >```\n\n1.4 LoadPrefab(assetName, label, scene, parent = null)\n* 以asset和label的形式加载资源并实例化,同1.3，不过传入一个框架里的Scene对象用于存储此对象的缓存池\n```csharp\n ETTask<GameObject> LoadPrefab(string assetName, ResourceLabel label = ResourceLabel.none, bool dontDestroy = false, Transform parent = null)\n```\n\n ##### 2. 缓存类接口\n \n 2.1 ReleaseFromCache(string key, bool isGlobal, Type resType)\n* 将某个key直接从【AssetCachePool】对象池子里释放，isGlobal决定了使用全局缓存池还是场景缓存池\n\n2.2 LoadFromCache<T>(string key, bool isGlobal) where T: UnityEngine.Object\n * 从【ResGameObjectPool】缓存池加载一个类型T的对象，isGlobal决定了使用全局缓存池还是场景缓存池\n\n2.3 RecyclePrefab(string poolKey,GameObject o, bool isGlobal = false)\n* 将对象o回收进某个key对应的【ResGameObjectPool】缓存池，isGlobal决定了使用全局缓存池还是场景缓存池\n\n2.4 RecyclePrefab(string assetName, ResourceLabel resLabel, GameObject o, bool isGlobal = false)\n* 将对象o回收进某个资源名及label对应的【ResGameObjectPool】缓存池，isGlobal决定了使用全局缓存池还是场景缓存池\n\n2.5 ReleasePrefab(string assetName, ResourceLabel resLabel, bool isGlobal = false)\n*  将对应assetName和resLabel的实例对象从【ResGameObjectPool】池子中释放（清除），isGlobal决定了使用全局缓存池还是场景缓存池\n\n\n##### 3. addressable接口\n\n3.1 ReleaseHandle(AsyncOperationHandle handle)\n* 释放一个addressable的异步句柄 \n\n","slug":"最新Addressable资源打包与加载框架","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh133005f4wf0mwnnrv8h","content":"<h4 id=\"一、Addressable介绍\"><a href=\"#一、Addressable介绍\" class=\"headerlink\" title=\"一、Addressable介绍\"></a>一、Addressable介绍</h4><p>Addressable是Unity最新推出且正式发布的资源管理系统，内含引用计数管理，快速资源热更，资源性能查看器，资源冗余工具等等，据官方的说法，这就像当初AssetBundle取代Resources一样，Addressable就是为了取代直接使用AssetBundle而生。</p>\n<h4 id=\"二、Addressable下载更新\"><a href=\"#二、Addressable下载更新\" class=\"headerlink\" title=\"二、Addressable下载更新\"></a>二、Addressable下载更新</h4><blockquote>\n<p>内容均在ResDownloadComponent中。</p>\n</blockquote>\n<h5 id=\"1-打包资源\"><a href=\"#1-打包资源\" class=\"headerlink\" title=\"1. 打包资源\"></a>1. 打包资源</h5><p>手动： 使用 Build -&gt;New Build -&gt; Default Build Script。 也可用打包脚本，<code>AddressableAssetSettings.CleanPlayerContent();\n        AddressableAssetSettings.BuildPlayerContent();</code><br>生成的资源将在Library-&gt;com.unityengine.addressable下</p>\n<blockquote>\n<p>建议本机初次导项目后，先执行一次打包资源，再使用Use Existing Build的Play Mode Script方式，以bundle加载运行，方便测试。</p>\n</blockquote>\n<h5 id=\"2-更新资源\"><a href=\"#2-更新资源\" class=\"headerlink\" title=\"2. 更新资源\"></a>2. 更新资源</h5><ul>\n<li>在发完包的情况下，在打包的机器上的Unity，选择Tools -&gt; Check for Content Update Restriction 来获取变更的资源</li>\n<li>将这些资源应用出来一个新的Group， 再统一挂上updates的标签！</li>\n<li>选择Build -&gt; Update a previous build 选择android的bin文件，等待完成，将会生成新的updates开头的更新文件，将这些文件上传即可更新。<blockquote>\n<p>更新完后之后，如果再需要出包，请将资源归还到原group中，以防下次混乱了。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-打包工具使用\"><a href=\"#3-打包工具使用\" class=\"headerlink\" title=\"3.打包工具使用\"></a>3.打包工具使用</h4><p>本地打包，可使用Tools -&gt; 打包工具，勾选 是否打包工程，将导出一个gradle的工程，否则将先打出工程后接着打出apk。<br>打包机不可使用此工具打包，由CI控制。</p>\n<h4 id=\"三、Addressable内置接口介绍\"><a href=\"#三、Addressable内置接口介绍\" class=\"headerlink\" title=\"三、Addressable内置接口介绍\"></a>三、Addressable内置接口介绍</h4><blockquote>\n<p>针对Addressable有两个缓存池，一个针对asset的 AssetCachePoolComponent，用于存放所有的资源，一般存放不需要实例化的资源，如material等。  另一个针对实例对象的 ResGameObjectPoolComponent， 用于存放实例出来的资源，会记录对象的handle句柄和对象实例列表。</p>\n</blockquote>\n<h5 id=\"1-加载接口\"><a href=\"#1-加载接口\" class=\"headerlink\" title=\"1. 加载接口\"></a>1. 加载接口</h5><p>1.1 LoadAssetAsyncHandle(assetName, saveToCache = false, isGlobal = false)</p>\n<ul>\n<li>以asset的形式加载资源不实例化，只返回相应资源句柄. [saveToCache]意为加载完的资源将直接记到缓存池，[isGlobal] 决定了是全局缓存池还是场景缓存池<br><strong>注意： [isGlobal]只在[saveToCache]为 true 时才会使用,用于保存在全局缓存池或对应场景的池子中</strong><pre><code class=\"csharp\">ETTask&lt;AsyncOperationHandle&lt;T&gt;&gt; LoadAssetAsyncHandle&lt;T&gt;(string assetName, bool saveToCache = false, bool isGlobal = false)</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>简单用法使用示例：(加载配置文件的Config预制)</p>\n<pre><code class=\"csharp\">//获取加载完的句柄\nvar configGOHandle = await ResourceLoaderComponent.Instance.LoadAssetAsyncHandle&lt;GameObject&gt;(&quot;Config&quot;);\n//从Handle中获取结果\nconfigGO = configGOHandle.Result;\n//当时即销毁此Handle\nResourceLoaderComponent.Instance.ReleaseHandle(configGOHandle);</code></pre>\n</blockquote>\n<blockquote>\n<p>深度使用示例：</p>\n<pre><code class=\"csharp\">//预加载需要用的材质，设值记录到缓存, 且非全局资源\nawait ResourceLoaderComponent.Instance.LoadAssetAsyncHandle&lt;Material&gt;(&quot;GrayMaterial&quot;,true,false);\n//从缓存加载对应的材质\nMaterial MAT_GARY = ResourceLoaderComponent.Instance.LoadFromCache&lt;Material&gt;(&quot;GrayMaterial&quot;, false);\n//从缓存删除对应的材质\nResourceLoaderComponent.Instance.ReleaseFromCache(&quot;GrayMaterial&quot;,false,typeof(Material));</code></pre>\n</blockquote>\n<p>1.2 LoadAssetsAsyncHandle(assetName, label = ResourceLabel.none, saveToCache = false, isGlobal = false)</p>\n<ul>\n<li>以asset的形式加载资源不实例化，只返回相应此资源数组句柄. 区别于1.1接口，此接口可配置多一个label的参数指明资源标签。</li>\n<li><em>注意：如果保存到缓存中，则是一个数组，LoadFromCache时必须使用一个数组返回。*</em><pre><code class=\"csharp\">ETTask&lt;AsyncOperationHandle&lt;IList&lt;T&gt;&gt;&gt; LoadAssetsAsyncHandle&lt;T&gt;(string assetName, ResourceLabel label = ResourceLabel.none, bool saveToCache = false, bool isGlobal = false)</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>使用示例：</p>\n<pre><code class=\"csharp\">var handle = await Game.Scene.GetComponent&lt;ResourceLoaderComponent&gt;().LoadAssetsAsyncHandle&lt;GameObject&gt;(&quot;HeadResSmallSize&quot;,ResourceLabel.ui);\nvar userIcon = handle.Result[0];</code></pre>\n</blockquote>\n<p>1.3 LoadPrefab(assetName, label, dontDestroy = false, parent = null)</p>\n<ul>\n<li>以asset和label的形式加载资源并实例化, 如果dontDestroy为true，则为全局资源，不随场景删除<pre><code class=\"csharp\">ETTask&lt;GameObject&gt; LoadPrefab(string assetName, ResourceLabel label = ResourceLabel.none, bool dontDestroy = false, Transform parent = null)</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>使用示例：</p>\n<pre><code class=\"csharp\">//(配置Buff的预制)\nGameObject configGo = await Game.Scene.GetComponent&lt;ResourceLoaderComponent&gt;().LoadPrefab($&quot;{buffCfg}&quot;,ResourceLabel.buff);</code></pre>\n</blockquote>\n<p>1.4 LoadPrefab(assetName, label, scene, parent = null)</p>\n<ul>\n<li><p>以asset和label的形式加载资源并实例化,同1.3，不过传入一个框架里的Scene对象用于存储此对象的缓存池</p>\n<pre><code class=\"csharp\">ETTask&lt;GameObject&gt; LoadPrefab(string assetName, ResourceLabel label = ResourceLabel.none, bool dontDestroy = false, Transform parent = null)</code></pre>\n<h5 id=\"2-缓存类接口\"><a href=\"#2-缓存类接口\" class=\"headerlink\" title=\"2. 缓存类接口\"></a>2. 缓存类接口</h5><p>2.1 ReleaseFromCache(string key, bool isGlobal, Type resType)</p>\n</li>\n<li><p>将某个key直接从【AssetCachePool】对象池子里释放，isGlobal决定了使用全局缓存池还是场景缓存池</p>\n</li>\n</ul>\n<p>2.2 LoadFromCache<T>(string key, bool isGlobal) where T: UnityEngine.Object</p>\n<ul>\n<li>从【ResGameObjectPool】缓存池加载一个类型T的对象，isGlobal决定了使用全局缓存池还是场景缓存池</li>\n</ul>\n<p>2.3 RecyclePrefab(string poolKey,GameObject o, bool isGlobal = false)</p>\n<ul>\n<li>将对象o回收进某个key对应的【ResGameObjectPool】缓存池，isGlobal决定了使用全局缓存池还是场景缓存池</li>\n</ul>\n<p>2.4 RecyclePrefab(string assetName, ResourceLabel resLabel, GameObject o, bool isGlobal = false)</p>\n<ul>\n<li>将对象o回收进某个资源名及label对应的【ResGameObjectPool】缓存池，isGlobal决定了使用全局缓存池还是场景缓存池</li>\n</ul>\n<p>2.5 ReleasePrefab(string assetName, ResourceLabel resLabel, bool isGlobal = false)</p>\n<ul>\n<li>将对应assetName和resLabel的实例对象从【ResGameObjectPool】池子中释放（清除），isGlobal决定了使用全局缓存池还是场景缓存池</li>\n</ul>\n<h5 id=\"3-addressable接口\"><a href=\"#3-addressable接口\" class=\"headerlink\" title=\"3. addressable接口\"></a>3. addressable接口</h5><p>3.1 ReleaseHandle(AsyncOperationHandle handle)</p>\n<ul>\n<li>释放一个addressable的异步句柄 </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、Addressable介绍\"><a href=\"#一、Addressable介绍\" class=\"headerlink\" title=\"一、Addressable介绍\"></a>一、Addressable介绍</h4><p>Addressable是Unity最新推出且正式发布的资源管理系统，内含引用计数管理，快速资源热更，资源性能查看器，资源冗余工具等等，据官方的说法，这就像当初AssetBundle取代Resources一样，Addressable就是为了取代直接使用AssetBundle而生。</p>\n<h4 id=\"二、Addressable下载更新\"><a href=\"#二、Addressable下载更新\" class=\"headerlink\" title=\"二、Addressable下载更新\"></a>二、Addressable下载更新</h4><blockquote>\n<p>内容均在ResDownloadComponent中。</p>\n</blockquote>\n<h5 id=\"1-打包资源\"><a href=\"#1-打包资源\" class=\"headerlink\" title=\"1. 打包资源\"></a>1. 打包资源</h5><p>手动： 使用 Build -&gt;New Build -&gt; Default Build Script。 也可用打包脚本，<code>AddressableAssetSettings.CleanPlayerContent();\n        AddressableAssetSettings.BuildPlayerContent();</code><br>生成的资源将在Library-&gt;com.unityengine.addressable下</p>\n<blockquote>\n<p>建议本机初次导项目后，先执行一次打包资源，再使用Use Existing Build的Play Mode Script方式，以bundle加载运行，方便测试。</p>\n</blockquote>\n<h5 id=\"2-更新资源\"><a href=\"#2-更新资源\" class=\"headerlink\" title=\"2. 更新资源\"></a>2. 更新资源</h5><ul>\n<li>在发完包的情况下，在打包的机器上的Unity，选择Tools -&gt; Check for Content Update Restriction 来获取变更的资源</li>\n<li>将这些资源应用出来一个新的Group， 再统一挂上updates的标签！</li>\n<li>选择Build -&gt; Update a previous build 选择android的bin文件，等待完成，将会生成新的updates开头的更新文件，将这些文件上传即可更新。<blockquote>\n<p>更新完后之后，如果再需要出包，请将资源归还到原group中，以防下次混乱了。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-打包工具使用\"><a href=\"#3-打包工具使用\" class=\"headerlink\" title=\"3.打包工具使用\"></a>3.打包工具使用</h4><p>本地打包，可使用Tools -&gt; 打包工具，勾选 是否打包工程，将导出一个gradle的工程，否则将先打出工程后接着打出apk。<br>打包机不可使用此工具打包，由CI控制。</p>\n<h4 id=\"三、Addressable内置接口介绍\"><a href=\"#三、Addressable内置接口介绍\" class=\"headerlink\" title=\"三、Addressable内置接口介绍\"></a>三、Addressable内置接口介绍</h4><blockquote>\n<p>针对Addressable有两个缓存池，一个针对asset的 AssetCachePoolComponent，用于存放所有的资源，一般存放不需要实例化的资源，如material等。  另一个针对实例对象的 ResGameObjectPoolComponent， 用于存放实例出来的资源，会记录对象的handle句柄和对象实例列表。</p>\n</blockquote>\n<h5 id=\"1-加载接口\"><a href=\"#1-加载接口\" class=\"headerlink\" title=\"1. 加载接口\"></a>1. 加载接口</h5><p>1.1 LoadAssetAsyncHandle(assetName, saveToCache = false, isGlobal = false)</p>\n<ul>\n<li>以asset的形式加载资源不实例化，只返回相应资源句柄. [saveToCache]意为加载完的资源将直接记到缓存池，[isGlobal] 决定了是全局缓存池还是场景缓存池<br><strong>注意： [isGlobal]只在[saveToCache]为 true 时才会使用,用于保存在全局缓存池或对应场景的池子中</strong><pre><code class=\"csharp\">ETTask&lt;AsyncOperationHandle&lt;T&gt;&gt; LoadAssetAsyncHandle&lt;T&gt;(string assetName, bool saveToCache = false, bool isGlobal = false)</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>简单用法使用示例：(加载配置文件的Config预制)</p>\n<pre><code class=\"csharp\">//获取加载完的句柄\nvar configGOHandle = await ResourceLoaderComponent.Instance.LoadAssetAsyncHandle&lt;GameObject&gt;(&quot;Config&quot;);\n//从Handle中获取结果\nconfigGO = configGOHandle.Result;\n//当时即销毁此Handle\nResourceLoaderComponent.Instance.ReleaseHandle(configGOHandle);</code></pre>\n</blockquote>\n<blockquote>\n<p>深度使用示例：</p>\n<pre><code class=\"csharp\">//预加载需要用的材质，设值记录到缓存, 且非全局资源\nawait ResourceLoaderComponent.Instance.LoadAssetAsyncHandle&lt;Material&gt;(&quot;GrayMaterial&quot;,true,false);\n//从缓存加载对应的材质\nMaterial MAT_GARY = ResourceLoaderComponent.Instance.LoadFromCache&lt;Material&gt;(&quot;GrayMaterial&quot;, false);\n//从缓存删除对应的材质\nResourceLoaderComponent.Instance.ReleaseFromCache(&quot;GrayMaterial&quot;,false,typeof(Material));</code></pre>\n</blockquote>\n<p>1.2 LoadAssetsAsyncHandle(assetName, label = ResourceLabel.none, saveToCache = false, isGlobal = false)</p>\n<ul>\n<li>以asset的形式加载资源不实例化，只返回相应此资源数组句柄. 区别于1.1接口，此接口可配置多一个label的参数指明资源标签。</li>\n<li><em>注意：如果保存到缓存中，则是一个数组，LoadFromCache时必须使用一个数组返回。*</em><pre><code class=\"csharp\">ETTask&lt;AsyncOperationHandle&lt;IList&lt;T&gt;&gt;&gt; LoadAssetsAsyncHandle&lt;T&gt;(string assetName, ResourceLabel label = ResourceLabel.none, bool saveToCache = false, bool isGlobal = false)</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>使用示例：</p>\n<pre><code class=\"csharp\">var handle = await Game.Scene.GetComponent&lt;ResourceLoaderComponent&gt;().LoadAssetsAsyncHandle&lt;GameObject&gt;(&quot;HeadResSmallSize&quot;,ResourceLabel.ui);\nvar userIcon = handle.Result[0];</code></pre>\n</blockquote>\n<p>1.3 LoadPrefab(assetName, label, dontDestroy = false, parent = null)</p>\n<ul>\n<li>以asset和label的形式加载资源并实例化, 如果dontDestroy为true，则为全局资源，不随场景删除<pre><code class=\"csharp\">ETTask&lt;GameObject&gt; LoadPrefab(string assetName, ResourceLabel label = ResourceLabel.none, bool dontDestroy = false, Transform parent = null)</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>使用示例：</p>\n<pre><code class=\"csharp\">//(配置Buff的预制)\nGameObject configGo = await Game.Scene.GetComponent&lt;ResourceLoaderComponent&gt;().LoadPrefab($&quot;{buffCfg}&quot;,ResourceLabel.buff);</code></pre>\n</blockquote>\n<p>1.4 LoadPrefab(assetName, label, scene, parent = null)</p>\n<ul>\n<li><p>以asset和label的形式加载资源并实例化,同1.3，不过传入一个框架里的Scene对象用于存储此对象的缓存池</p>\n<pre><code class=\"csharp\">ETTask&lt;GameObject&gt; LoadPrefab(string assetName, ResourceLabel label = ResourceLabel.none, bool dontDestroy = false, Transform parent = null)</code></pre>\n<h5 id=\"2-缓存类接口\"><a href=\"#2-缓存类接口\" class=\"headerlink\" title=\"2. 缓存类接口\"></a>2. 缓存类接口</h5><p>2.1 ReleaseFromCache(string key, bool isGlobal, Type resType)</p>\n</li>\n<li><p>将某个key直接从【AssetCachePool】对象池子里释放，isGlobal决定了使用全局缓存池还是场景缓存池</p>\n</li>\n</ul>\n<p>2.2 LoadFromCache<T>(string key, bool isGlobal) where T: UnityEngine.Object</p>\n<ul>\n<li>从【ResGameObjectPool】缓存池加载一个类型T的对象，isGlobal决定了使用全局缓存池还是场景缓存池</li>\n</ul>\n<p>2.3 RecyclePrefab(string poolKey,GameObject o, bool isGlobal = false)</p>\n<ul>\n<li>将对象o回收进某个key对应的【ResGameObjectPool】缓存池，isGlobal决定了使用全局缓存池还是场景缓存池</li>\n</ul>\n<p>2.4 RecyclePrefab(string assetName, ResourceLabel resLabel, GameObject o, bool isGlobal = false)</p>\n<ul>\n<li>将对象o回收进某个资源名及label对应的【ResGameObjectPool】缓存池，isGlobal决定了使用全局缓存池还是场景缓存池</li>\n</ul>\n<p>2.5 ReleasePrefab(string assetName, ResourceLabel resLabel, bool isGlobal = false)</p>\n<ul>\n<li>将对应assetName和resLabel的实例对象从【ResGameObjectPool】池子中释放（清除），isGlobal决定了使用全局缓存池还是场景缓存池</li>\n</ul>\n<h5 id=\"3-addressable接口\"><a href=\"#3-addressable接口\" class=\"headerlink\" title=\"3. addressable接口\"></a>3. addressable接口</h5><p>3.1 ReleaseHandle(AsyncOperationHandle handle)</p>\n<ul>\n<li>释放一个addressable的异步句柄 </li>\n</ul>\n"},{"title":"数据结构-图","_content":"\n#### 图\n\n1. 相关定义\n* 表示方式 Graph： G（V，E） 由顶点的有穷非空集合和顶点之间的边组成。\n> 线性表的数据元素叫元素，树中叫结点，图中叫顶点Vertex\n* 无向边：两个随机顶点之间的边无方向，用无序偶(Vi,Vj)或(Vj,Vi)表示\n* 有向边：顶点之间的边是有向的，用有序偶表示：<Vi,Vj>表示，与<Vj,Vi>是不同的。 又称为弧。\n> 有向边总是<弧尾，弧头>的。从尾指向头。\n* 简单图：不存在重复边，且不存在指向自身的元素的图。\n* 无向完全图：任意两个顶点都有边,含有n个顶点的图有 n*(n-1) /2的边\n* 有向完全图： 任意两个顶点存在互为相反的两条弧，则为有向完全图，n*(n-1)\n* 稀疏图与稠密图： 边或弧数小于n * logn的图为稀疏图，反之为稠密图\n* 网：图上的边指定权，则称为网。\n* 子图：为父图的子集的图。\n\n2.顶点与边的关系\n\n2.1. 邻接与度\n* 无向图\n* 邻接点：对于G(V,E)，如果边（V1，V2）属于E，则顶点V1,V2为邻接点。\n> 边（V1,V2) 依附 （incident） 于顶点V1,V2 。或说边与顶点V1,V2相关联。\n* 顶点的度（TD）：顶点V的度表示与此顶点相关联的==边的个数==！\n\n* 有向图\n* 邻接： <V1,V2> 意为V2邻接自V1，V1邻接V2\n* 入度InDegree(ID)：以顶点V2为弧头的称为V2的入度。\n* 出度OutDegree(OD): 以顶点V1为弧尾的称为V1的出度。\n* 总度：TD = ID+OD\n\n2.2 路径\n由顶点A到达顶点B\n* 路径的长度：路径上的边的数目\n* 环：第一个顶点到最后一个顶点相同的路径称为回路或环\n* 简单环：除了第一个和最后一个顶点，其他顶点不重复的回路。\n\n2.3 连通图\n* V1V2是连通：如果顶点V1到顶点V2有路径\n* 连通图：任意两个点都是连通\n\n* 无向图：\n* 极大连通子图（连通分量）的概念：\n* 1.要是子图\n* 2.含有极大顶点数，就是要有此连通子图的极大点数\n* 3.在2的基础上，包含依附于这些顶点所有的边\n\n* 有向图\n* 强连通图：对于任意顶点的Vi Vj都存在路径。\n\n\n* 连通图的生成树：\n* 定义： 一个极小的连通子图，含有所有顶点n，但边只有(n-1)条\n\n* 有向树：\n* 定义：一个有向图，存在仅有一个顶点入度为0，其他点入度均为1，则为有向树\n![有向树](/img/1585708632739.png)\n\n3.存储结构 - 邻接矩阵\n> 内存的物理位置是线性的，但图的元素关系是平面的。\n\n3.1 邻接矩阵（无向图）\n\n* 存储方式： 顶点用一维数组存储，边、弧用二维数组\n* 无向图的矩阵表是对称的。\n![邻接矩阵的存储方式](/img/1585709533268.png)\n\n* 所谓对称矩阵：就是满足ａ［ｉ］［ｊ］　＝　ａ［ｊ］［ｉ］（０＜＝ｉ，　ｊ＜＝ｎ）。即以对角线为轴，右上角的元与左上角的元是相等的。\n* 有了邻接矩阵的无向图，可以获取以下信息\n* 1.判断两个点是否有边\n* 2.判断一个点的度是多少，只要求某一行某一列的元素之和\n* 3.求一个点的邻接点，获取以点Vi为行或列的一条数组里矩阵值为1的点。\n\n3.2 邻接矩阵（有向图）\n\n![有向图的邻接矩阵](/img/1585710256442.png)\n\n* 特性：\n* 1.有向图的邻接矩阵一般不是对称矩阵，除非所有顶点都互相邻接\n* 2.入度的值即为矩阵的列的各数之和。出度为行的各数之和。\n\n3.3 邻接矩阵（网）\n\n> 每条边带有权的图就叫网。\n\n* 即0为自身关联，无穷表示没有弧。\n\n![网的邻接矩阵](/img/1585710628207.png)\n\n4.存储结构 - 邻接表\n\n![思考](/img/1585710777047.png)\n\n* 以数组链表的形式存储\n4.1 无向图\n![无向图的邻接表](/img/1585711969955.png)\n\n4.2 有向图\n* 以每个点当弧尾建立邻接表。这样更容易得出每个点的出度。\n![有向图的邻接表](/img/1585711991004.png)\n\n> 有向图的逆邻接表\n![有向图的逆邻接表](/img/1585712085363.png)\n\n4.3 邻接表（网）\n* 区别于有向图，增加一个数据域存储权值\n\n![邻接表存储图](/img/1585712479371.png)\n\n\n5. 存储结构 - 十字链表\n\n> 4的邻接表无法满足不同的入度出度都有需求的情况，因此使用新的结构来存放\n把邻接表与逆邻接表放在一起\n\n![基础结构](/img/1585713033340.png)\n\n![十字链表](/img/1585712995976.png)\n\n* 特性：\n* 更容易找到入度与出度\n* 算法复杂度与邻接表是一样，是有向图应用中好用的数据结构\n\n6.存储结构- 邻接多重表\n\n* 专为无向表设计，边表存放的是一条边，而不是一个顶点\n \n![邻接多重表的边表结构](/img/1585714606930.png)\n\n![邻接多重表-示例](/img/1585714787406.png)\n\n7.存储结构 -边集数组\n* 使用两个一维数组构成，一个存储顶点，一个存储边和权重\n\n![边集数组](/img/1585714939207.png)\n\n\n8. 遍历-深度优先遍历\n\n* 概述： 以一个点开始，以左/右固定遍历原则来遍历一个图，每成功访问到的一个顶点就标记一下，已经遍历到的点就回退到上一层。以此循环\n\n![示例](/img/1585722630933.png)\n![右手原则的深度优先遍历](/img/1585722584708.png)\n\n> . 哈密尔顿路径\n>* 经过图中每个顶点且只经过一次\n> 如果最终还能回到起始点，则称为哈密尔顿回路\n\n> 扩展-马踏棋盘算法\n> 递归： https://www.cnblogs.com/lpfuture/p/7111524.html\n> 贪心非递归：https://www.jianshu.com/p/6c185f290e10\n\n9.遍历-广度优先遍历\n\n* 类似于树的层级遍历，一层一层遍历\n![广度优先遍历](/img/1585742087660.png)\n\n* 常用实现：使用队列的形式：\n![队列实现广度遍历](/img/1585742120344.png)\n\n![算法实现](/img/1585742361670.png)\n\n\n10.最小生成树 - 普里姆算法：\n![普里姆算法C-Part1](/img/1585742844977.png)\n\n![普里姆算法C-Part2](/img/1585743156869.png)\n\n以此文章为示例学习：\nhttps://blog.csdn.net/yeruby/article/details/38615045\n> 从一个点开始以一个数组记录接下来能走的路的权值，下一步的路将是这些权值中的最小值，将将游标移至此最小值的点，标记此点完成状态。接着重复此过程，每次都更新权值数组的值，直到所有的点都被标记为完成。 一定要注意是更新！！！\n\n![时间复杂度对比](/img/1585819226392.png)","source":"_posts/数据结构-笔记1.md","raw":"---\ntitle: 数据结构-图\ncategories:\n- 数据结构\n---\n\n#### 图\n\n1. 相关定义\n* 表示方式 Graph： G（V，E） 由顶点的有穷非空集合和顶点之间的边组成。\n> 线性表的数据元素叫元素，树中叫结点，图中叫顶点Vertex\n* 无向边：两个随机顶点之间的边无方向，用无序偶(Vi,Vj)或(Vj,Vi)表示\n* 有向边：顶点之间的边是有向的，用有序偶表示：<Vi,Vj>表示，与<Vj,Vi>是不同的。 又称为弧。\n> 有向边总是<弧尾，弧头>的。从尾指向头。\n* 简单图：不存在重复边，且不存在指向自身的元素的图。\n* 无向完全图：任意两个顶点都有边,含有n个顶点的图有 n*(n-1) /2的边\n* 有向完全图： 任意两个顶点存在互为相反的两条弧，则为有向完全图，n*(n-1)\n* 稀疏图与稠密图： 边或弧数小于n * logn的图为稀疏图，反之为稠密图\n* 网：图上的边指定权，则称为网。\n* 子图：为父图的子集的图。\n\n2.顶点与边的关系\n\n2.1. 邻接与度\n* 无向图\n* 邻接点：对于G(V,E)，如果边（V1，V2）属于E，则顶点V1,V2为邻接点。\n> 边（V1,V2) 依附 （incident） 于顶点V1,V2 。或说边与顶点V1,V2相关联。\n* 顶点的度（TD）：顶点V的度表示与此顶点相关联的==边的个数==！\n\n* 有向图\n* 邻接： <V1,V2> 意为V2邻接自V1，V1邻接V2\n* 入度InDegree(ID)：以顶点V2为弧头的称为V2的入度。\n* 出度OutDegree(OD): 以顶点V1为弧尾的称为V1的出度。\n* 总度：TD = ID+OD\n\n2.2 路径\n由顶点A到达顶点B\n* 路径的长度：路径上的边的数目\n* 环：第一个顶点到最后一个顶点相同的路径称为回路或环\n* 简单环：除了第一个和最后一个顶点，其他顶点不重复的回路。\n\n2.3 连通图\n* V1V2是连通：如果顶点V1到顶点V2有路径\n* 连通图：任意两个点都是连通\n\n* 无向图：\n* 极大连通子图（连通分量）的概念：\n* 1.要是子图\n* 2.含有极大顶点数，就是要有此连通子图的极大点数\n* 3.在2的基础上，包含依附于这些顶点所有的边\n\n* 有向图\n* 强连通图：对于任意顶点的Vi Vj都存在路径。\n\n\n* 连通图的生成树：\n* 定义： 一个极小的连通子图，含有所有顶点n，但边只有(n-1)条\n\n* 有向树：\n* 定义：一个有向图，存在仅有一个顶点入度为0，其他点入度均为1，则为有向树\n![有向树](/img/1585708632739.png)\n\n3.存储结构 - 邻接矩阵\n> 内存的物理位置是线性的，但图的元素关系是平面的。\n\n3.1 邻接矩阵（无向图）\n\n* 存储方式： 顶点用一维数组存储，边、弧用二维数组\n* 无向图的矩阵表是对称的。\n![邻接矩阵的存储方式](/img/1585709533268.png)\n\n* 所谓对称矩阵：就是满足ａ［ｉ］［ｊ］　＝　ａ［ｊ］［ｉ］（０＜＝ｉ，　ｊ＜＝ｎ）。即以对角线为轴，右上角的元与左上角的元是相等的。\n* 有了邻接矩阵的无向图，可以获取以下信息\n* 1.判断两个点是否有边\n* 2.判断一个点的度是多少，只要求某一行某一列的元素之和\n* 3.求一个点的邻接点，获取以点Vi为行或列的一条数组里矩阵值为1的点。\n\n3.2 邻接矩阵（有向图）\n\n![有向图的邻接矩阵](/img/1585710256442.png)\n\n* 特性：\n* 1.有向图的邻接矩阵一般不是对称矩阵，除非所有顶点都互相邻接\n* 2.入度的值即为矩阵的列的各数之和。出度为行的各数之和。\n\n3.3 邻接矩阵（网）\n\n> 每条边带有权的图就叫网。\n\n* 即0为自身关联，无穷表示没有弧。\n\n![网的邻接矩阵](/img/1585710628207.png)\n\n4.存储结构 - 邻接表\n\n![思考](/img/1585710777047.png)\n\n* 以数组链表的形式存储\n4.1 无向图\n![无向图的邻接表](/img/1585711969955.png)\n\n4.2 有向图\n* 以每个点当弧尾建立邻接表。这样更容易得出每个点的出度。\n![有向图的邻接表](/img/1585711991004.png)\n\n> 有向图的逆邻接表\n![有向图的逆邻接表](/img/1585712085363.png)\n\n4.3 邻接表（网）\n* 区别于有向图，增加一个数据域存储权值\n\n![邻接表存储图](/img/1585712479371.png)\n\n\n5. 存储结构 - 十字链表\n\n> 4的邻接表无法满足不同的入度出度都有需求的情况，因此使用新的结构来存放\n把邻接表与逆邻接表放在一起\n\n![基础结构](/img/1585713033340.png)\n\n![十字链表](/img/1585712995976.png)\n\n* 特性：\n* 更容易找到入度与出度\n* 算法复杂度与邻接表是一样，是有向图应用中好用的数据结构\n\n6.存储结构- 邻接多重表\n\n* 专为无向表设计，边表存放的是一条边，而不是一个顶点\n \n![邻接多重表的边表结构](/img/1585714606930.png)\n\n![邻接多重表-示例](/img/1585714787406.png)\n\n7.存储结构 -边集数组\n* 使用两个一维数组构成，一个存储顶点，一个存储边和权重\n\n![边集数组](/img/1585714939207.png)\n\n\n8. 遍历-深度优先遍历\n\n* 概述： 以一个点开始，以左/右固定遍历原则来遍历一个图，每成功访问到的一个顶点就标记一下，已经遍历到的点就回退到上一层。以此循环\n\n![示例](/img/1585722630933.png)\n![右手原则的深度优先遍历](/img/1585722584708.png)\n\n> . 哈密尔顿路径\n>* 经过图中每个顶点且只经过一次\n> 如果最终还能回到起始点，则称为哈密尔顿回路\n\n> 扩展-马踏棋盘算法\n> 递归： https://www.cnblogs.com/lpfuture/p/7111524.html\n> 贪心非递归：https://www.jianshu.com/p/6c185f290e10\n\n9.遍历-广度优先遍历\n\n* 类似于树的层级遍历，一层一层遍历\n![广度优先遍历](/img/1585742087660.png)\n\n* 常用实现：使用队列的形式：\n![队列实现广度遍历](/img/1585742120344.png)\n\n![算法实现](/img/1585742361670.png)\n\n\n10.最小生成树 - 普里姆算法：\n![普里姆算法C-Part1](/img/1585742844977.png)\n\n![普里姆算法C-Part2](/img/1585743156869.png)\n\n以此文章为示例学习：\nhttps://blog.csdn.net/yeruby/article/details/38615045\n> 从一个点开始以一个数组记录接下来能走的路的权值，下一步的路将是这些权值中的最小值，将将游标移至此最小值的点，标记此点完成状态。接着重复此过程，每次都更新权值数组的值，直到所有的点都被标记为完成。 一定要注意是更新！！！\n\n![时间复杂度对比](/img/1585819226392.png)","slug":"数据结构-笔记1","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh135005k4wf0l1ht2d17","content":"<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><ol>\n<li>相关定义</li>\n</ol>\n<ul>\n<li>表示方式 Graph： G（V，E） 由顶点的有穷非空集合和顶点之间的边组成。<blockquote>\n<p>线性表的数据元素叫元素，树中叫结点，图中叫顶点Vertex</p>\n</blockquote>\n</li>\n<li>无向边：两个随机顶点之间的边无方向，用无序偶(Vi,Vj)或(Vj,Vi)表示</li>\n<li>有向边：顶点之间的边是有向的，用有序偶表示：&lt;Vi,Vj&gt;表示，与&lt;Vj,Vi&gt;是不同的。 又称为弧。<blockquote>\n<p>有向边总是&lt;弧尾，弧头&gt;的。从尾指向头。</p>\n</blockquote>\n</li>\n<li>简单图：不存在重复边，且不存在指向自身的元素的图。</li>\n<li>无向完全图：任意两个顶点都有边,含有n个顶点的图有 n*(n-1) /2的边</li>\n<li>有向完全图： 任意两个顶点存在互为相反的两条弧，则为有向完全图，n*(n-1)</li>\n<li>稀疏图与稠密图： 边或弧数小于n * logn的图为稀疏图，反之为稠密图</li>\n<li>网：图上的边指定权，则称为网。</li>\n<li>子图：为父图的子集的图。</li>\n</ul>\n<p>2.顶点与边的关系</p>\n<p>2.1. 邻接与度</p>\n<ul>\n<li><p>无向图</p>\n</li>\n<li><p>邻接点：对于G(V,E)，如果边（V1，V2）属于E，则顶点V1,V2为邻接点。</p>\n<blockquote>\n<p>边（V1,V2) 依附 （incident） 于顶点V1,V2 。或说边与顶点V1,V2相关联。</p>\n</blockquote>\n</li>\n<li><p>顶点的度（TD）：顶点V的度表示与此顶点相关联的==边的个数==！</p>\n</li>\n<li><p>有向图</p>\n</li>\n<li><p>邻接： &lt;V1,V2&gt; 意为V2邻接自V1，V1邻接V2</p>\n</li>\n<li><p>入度InDegree(ID)：以顶点V2为弧头的称为V2的入度。</p>\n</li>\n<li><p>出度OutDegree(OD): 以顶点V1为弧尾的称为V1的出度。</p>\n</li>\n<li><p>总度：TD = ID+OD</p>\n</li>\n</ul>\n<p>2.2 路径<br>由顶点A到达顶点B</p>\n<ul>\n<li>路径的长度：路径上的边的数目</li>\n<li>环：第一个顶点到最后一个顶点相同的路径称为回路或环</li>\n<li>简单环：除了第一个和最后一个顶点，其他顶点不重复的回路。</li>\n</ul>\n<p>2.3 连通图</p>\n<ul>\n<li><p>V1V2是连通：如果顶点V1到顶点V2有路径</p>\n</li>\n<li><p>连通图：任意两个点都是连通</p>\n</li>\n<li><p>无向图：</p>\n</li>\n<li><p>极大连通子图（连通分量）的概念：</p>\n</li>\n<li><p>1.要是子图</p>\n</li>\n<li><p>2.含有极大顶点数，就是要有此连通子图的极大点数</p>\n</li>\n<li><p>3.在2的基础上，包含依附于这些顶点所有的边</p>\n</li>\n<li><p>有向图</p>\n</li>\n<li><p>强连通图：对于任意顶点的Vi Vj都存在路径。</p>\n</li>\n</ul>\n<ul>\n<li><p>连通图的生成树：</p>\n</li>\n<li><p>定义： 一个极小的连通子图，含有所有顶点n，但边只有(n-1)条</p>\n</li>\n<li><p>有向树：</p>\n</li>\n<li><p>定义：一个有向图，存在仅有一个顶点入度为0，其他点入度均为1，则为有向树<br><img src=\"/img/1585708632739.png\" alt=\"有向树\"></p>\n</li>\n</ul>\n<p>3.存储结构 - 邻接矩阵</p>\n<blockquote>\n<p>内存的物理位置是线性的，但图的元素关系是平面的。</p>\n</blockquote>\n<p>3.1 邻接矩阵（无向图）</p>\n<ul>\n<li><p>存储方式： 顶点用一维数组存储，边、弧用二维数组</p>\n</li>\n<li><p>无向图的矩阵表是对称的。<br><img src=\"/img/1585709533268.png\" alt=\"邻接矩阵的存储方式\"></p>\n</li>\n<li><p>所谓对称矩阵：就是满足ａ［ｉ］［ｊ］　＝　ａ［ｊ］［ｉ］（０＜＝ｉ，　ｊ＜＝ｎ）。即以对角线为轴，右上角的元与左上角的元是相等的。</p>\n</li>\n<li><p>有了邻接矩阵的无向图，可以获取以下信息</p>\n</li>\n<li><p>1.判断两个点是否有边</p>\n</li>\n<li><p>2.判断一个点的度是多少，只要求某一行某一列的元素之和</p>\n</li>\n<li><p>3.求一个点的邻接点，获取以点Vi为行或列的一条数组里矩阵值为1的点。</p>\n</li>\n</ul>\n<p>3.2 邻接矩阵（有向图）</p>\n<p><img src=\"/img/1585710256442.png\" alt=\"有向图的邻接矩阵\"></p>\n<ul>\n<li>特性：</li>\n<li>1.有向图的邻接矩阵一般不是对称矩阵，除非所有顶点都互相邻接</li>\n<li>2.入度的值即为矩阵的列的各数之和。出度为行的各数之和。</li>\n</ul>\n<p>3.3 邻接矩阵（网）</p>\n<blockquote>\n<p>每条边带有权的图就叫网。</p>\n</blockquote>\n<ul>\n<li>即0为自身关联，无穷表示没有弧。</li>\n</ul>\n<p><img src=\"/img/1585710628207.png\" alt=\"网的邻接矩阵\"></p>\n<p>4.存储结构 - 邻接表</p>\n<p><img src=\"/img/1585710777047.png\" alt=\"思考\"></p>\n<ul>\n<li>以数组链表的形式存储</li>\n</ul>\n<p>4.1 无向图<br><img src=\"/img/1585711969955.png\" alt=\"无向图的邻接表\"></p>\n<p>4.2 有向图</p>\n<ul>\n<li>以每个点当弧尾建立邻接表。这样更容易得出每个点的出度。<br><img src=\"/img/1585711991004.png\" alt=\"有向图的邻接表\"></li>\n</ul>\n<blockquote>\n<p>有向图的逆邻接表<br><img src=\"/img/1585712085363.png\" alt=\"有向图的逆邻接表\"></p>\n</blockquote>\n<p>4.3 邻接表（网）</p>\n<ul>\n<li>区别于有向图，增加一个数据域存储权值</li>\n</ul>\n<p><img src=\"/img/1585712479371.png\" alt=\"邻接表存储图\"></p>\n<ol start=\"5\">\n<li>存储结构 - 十字链表</li>\n</ol>\n<blockquote>\n<p>4的邻接表无法满足不同的入度出度都有需求的情况，因此使用新的结构来存放<br>把邻接表与逆邻接表放在一起</p>\n</blockquote>\n<p><img src=\"/img/1585713033340.png\" alt=\"基础结构\"></p>\n<p><img src=\"/img/1585712995976.png\" alt=\"十字链表\"></p>\n<ul>\n<li>特性：</li>\n<li>更容易找到入度与出度</li>\n<li>算法复杂度与邻接表是一样，是有向图应用中好用的数据结构</li>\n</ul>\n<p>6.存储结构- 邻接多重表</p>\n<ul>\n<li>专为无向表设计，边表存放的是一条边，而不是一个顶点</li>\n</ul>\n<p><img src=\"/img/1585714606930.png\" alt=\"邻接多重表的边表结构\"></p>\n<p><img src=\"/img/1585714787406.png\" alt=\"邻接多重表-示例\"></p>\n<p>7.存储结构 -边集数组</p>\n<ul>\n<li>使用两个一维数组构成，一个存储顶点，一个存储边和权重</li>\n</ul>\n<p><img src=\"/img/1585714939207.png\" alt=\"边集数组\"></p>\n<ol start=\"8\">\n<li>遍历-深度优先遍历</li>\n</ol>\n<ul>\n<li>概述： 以一个点开始，以左/右固定遍历原则来遍历一个图，每成功访问到的一个顶点就标记一下，已经遍历到的点就回退到上一层。以此循环</li>\n</ul>\n<p><img src=\"/img/1585722630933.png\" alt=\"示例\"><br><img src=\"/img/1585722584708.png\" alt=\"右手原则的深度优先遍历\"></p>\n<blockquote>\n<p>. 哈密尔顿路径</p>\n<ul>\n<li>经过图中每个顶点且只经过一次<br>如果最终还能回到起始点，则称为哈密尔顿回路</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>扩展-马踏棋盘算法<br>递归： <a href=\"https://www.cnblogs.com/lpfuture/p/7111524.html\">https://www.cnblogs.com/lpfuture/p/7111524.html</a><br>贪心非递归：<a href=\"https://www.jianshu.com/p/6c185f290e10\">https://www.jianshu.com/p/6c185f290e10</a></p>\n</blockquote>\n<p>9.遍历-广度优先遍历</p>\n<ul>\n<li><p>类似于树的层级遍历，一层一层遍历<br><img src=\"/img/1585742087660.png\" alt=\"广度优先遍历\"></p>\n</li>\n<li><p>常用实现：使用队列的形式：<br><img src=\"/img/1585742120344.png\" alt=\"队列实现广度遍历\"></p>\n</li>\n</ul>\n<p><img src=\"/img/1585742361670.png\" alt=\"算法实现\"></p>\n<p>10.最小生成树 - 普里姆算法：<br><img src=\"/img/1585742844977.png\" alt=\"普里姆算法C-Part1\"></p>\n<p><img src=\"/img/1585743156869.png\" alt=\"普里姆算法C-Part2\"></p>\n<p>以此文章为示例学习：<br><a href=\"https://blog.csdn.net/yeruby/article/details/38615045\">https://blog.csdn.net/yeruby/article/details/38615045</a></p>\n<blockquote>\n<p>从一个点开始以一个数组记录接下来能走的路的权值，下一步的路将是这些权值中的最小值，将将游标移至此最小值的点，标记此点完成状态。接着重复此过程，每次都更新权值数组的值，直到所有的点都被标记为完成。 一定要注意是更新！！！</p>\n</blockquote>\n<p><img src=\"/img/1585819226392.png\" alt=\"时间复杂度对比\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><ol>\n<li>相关定义</li>\n</ol>\n<ul>\n<li>表示方式 Graph： G（V，E） 由顶点的有穷非空集合和顶点之间的边组成。<blockquote>\n<p>线性表的数据元素叫元素，树中叫结点，图中叫顶点Vertex</p>\n</blockquote>\n</li>\n<li>无向边：两个随机顶点之间的边无方向，用无序偶(Vi,Vj)或(Vj,Vi)表示</li>\n<li>有向边：顶点之间的边是有向的，用有序偶表示：&lt;Vi,Vj&gt;表示，与&lt;Vj,Vi&gt;是不同的。 又称为弧。<blockquote>\n<p>有向边总是&lt;弧尾，弧头&gt;的。从尾指向头。</p>\n</blockquote>\n</li>\n<li>简单图：不存在重复边，且不存在指向自身的元素的图。</li>\n<li>无向完全图：任意两个顶点都有边,含有n个顶点的图有 n*(n-1) /2的边</li>\n<li>有向完全图： 任意两个顶点存在互为相反的两条弧，则为有向完全图，n*(n-1)</li>\n<li>稀疏图与稠密图： 边或弧数小于n * logn的图为稀疏图，反之为稠密图</li>\n<li>网：图上的边指定权，则称为网。</li>\n<li>子图：为父图的子集的图。</li>\n</ul>\n<p>2.顶点与边的关系</p>\n<p>2.1. 邻接与度</p>\n<ul>\n<li><p>无向图</p>\n</li>\n<li><p>邻接点：对于G(V,E)，如果边（V1，V2）属于E，则顶点V1,V2为邻接点。</p>\n<blockquote>\n<p>边（V1,V2) 依附 （incident） 于顶点V1,V2 。或说边与顶点V1,V2相关联。</p>\n</blockquote>\n</li>\n<li><p>顶点的度（TD）：顶点V的度表示与此顶点相关联的==边的个数==！</p>\n</li>\n<li><p>有向图</p>\n</li>\n<li><p>邻接： &lt;V1,V2&gt; 意为V2邻接自V1，V1邻接V2</p>\n</li>\n<li><p>入度InDegree(ID)：以顶点V2为弧头的称为V2的入度。</p>\n</li>\n<li><p>出度OutDegree(OD): 以顶点V1为弧尾的称为V1的出度。</p>\n</li>\n<li><p>总度：TD = ID+OD</p>\n</li>\n</ul>\n<p>2.2 路径<br>由顶点A到达顶点B</p>\n<ul>\n<li>路径的长度：路径上的边的数目</li>\n<li>环：第一个顶点到最后一个顶点相同的路径称为回路或环</li>\n<li>简单环：除了第一个和最后一个顶点，其他顶点不重复的回路。</li>\n</ul>\n<p>2.3 连通图</p>\n<ul>\n<li><p>V1V2是连通：如果顶点V1到顶点V2有路径</p>\n</li>\n<li><p>连通图：任意两个点都是连通</p>\n</li>\n<li><p>无向图：</p>\n</li>\n<li><p>极大连通子图（连通分量）的概念：</p>\n</li>\n<li><p>1.要是子图</p>\n</li>\n<li><p>2.含有极大顶点数，就是要有此连通子图的极大点数</p>\n</li>\n<li><p>3.在2的基础上，包含依附于这些顶点所有的边</p>\n</li>\n<li><p>有向图</p>\n</li>\n<li><p>强连通图：对于任意顶点的Vi Vj都存在路径。</p>\n</li>\n</ul>\n<ul>\n<li><p>连通图的生成树：</p>\n</li>\n<li><p>定义： 一个极小的连通子图，含有所有顶点n，但边只有(n-1)条</p>\n</li>\n<li><p>有向树：</p>\n</li>\n<li><p>定义：一个有向图，存在仅有一个顶点入度为0，其他点入度均为1，则为有向树<br><img src=\"/img/1585708632739.png\" alt=\"有向树\"></p>\n</li>\n</ul>\n<p>3.存储结构 - 邻接矩阵</p>\n<blockquote>\n<p>内存的物理位置是线性的，但图的元素关系是平面的。</p>\n</blockquote>\n<p>3.1 邻接矩阵（无向图）</p>\n<ul>\n<li><p>存储方式： 顶点用一维数组存储，边、弧用二维数组</p>\n</li>\n<li><p>无向图的矩阵表是对称的。<br><img src=\"/img/1585709533268.png\" alt=\"邻接矩阵的存储方式\"></p>\n</li>\n<li><p>所谓对称矩阵：就是满足ａ［ｉ］［ｊ］　＝　ａ［ｊ］［ｉ］（０＜＝ｉ，　ｊ＜＝ｎ）。即以对角线为轴，右上角的元与左上角的元是相等的。</p>\n</li>\n<li><p>有了邻接矩阵的无向图，可以获取以下信息</p>\n</li>\n<li><p>1.判断两个点是否有边</p>\n</li>\n<li><p>2.判断一个点的度是多少，只要求某一行某一列的元素之和</p>\n</li>\n<li><p>3.求一个点的邻接点，获取以点Vi为行或列的一条数组里矩阵值为1的点。</p>\n</li>\n</ul>\n<p>3.2 邻接矩阵（有向图）</p>\n<p><img src=\"/img/1585710256442.png\" alt=\"有向图的邻接矩阵\"></p>\n<ul>\n<li>特性：</li>\n<li>1.有向图的邻接矩阵一般不是对称矩阵，除非所有顶点都互相邻接</li>\n<li>2.入度的值即为矩阵的列的各数之和。出度为行的各数之和。</li>\n</ul>\n<p>3.3 邻接矩阵（网）</p>\n<blockquote>\n<p>每条边带有权的图就叫网。</p>\n</blockquote>\n<ul>\n<li>即0为自身关联，无穷表示没有弧。</li>\n</ul>\n<p><img src=\"/img/1585710628207.png\" alt=\"网的邻接矩阵\"></p>\n<p>4.存储结构 - 邻接表</p>\n<p><img src=\"/img/1585710777047.png\" alt=\"思考\"></p>\n<ul>\n<li>以数组链表的形式存储</li>\n</ul>\n<p>4.1 无向图<br><img src=\"/img/1585711969955.png\" alt=\"无向图的邻接表\"></p>\n<p>4.2 有向图</p>\n<ul>\n<li>以每个点当弧尾建立邻接表。这样更容易得出每个点的出度。<br><img src=\"/img/1585711991004.png\" alt=\"有向图的邻接表\"></li>\n</ul>\n<blockquote>\n<p>有向图的逆邻接表<br><img src=\"/img/1585712085363.png\" alt=\"有向图的逆邻接表\"></p>\n</blockquote>\n<p>4.3 邻接表（网）</p>\n<ul>\n<li>区别于有向图，增加一个数据域存储权值</li>\n</ul>\n<p><img src=\"/img/1585712479371.png\" alt=\"邻接表存储图\"></p>\n<ol start=\"5\">\n<li>存储结构 - 十字链表</li>\n</ol>\n<blockquote>\n<p>4的邻接表无法满足不同的入度出度都有需求的情况，因此使用新的结构来存放<br>把邻接表与逆邻接表放在一起</p>\n</blockquote>\n<p><img src=\"/img/1585713033340.png\" alt=\"基础结构\"></p>\n<p><img src=\"/img/1585712995976.png\" alt=\"十字链表\"></p>\n<ul>\n<li>特性：</li>\n<li>更容易找到入度与出度</li>\n<li>算法复杂度与邻接表是一样，是有向图应用中好用的数据结构</li>\n</ul>\n<p>6.存储结构- 邻接多重表</p>\n<ul>\n<li>专为无向表设计，边表存放的是一条边，而不是一个顶点</li>\n</ul>\n<p><img src=\"/img/1585714606930.png\" alt=\"邻接多重表的边表结构\"></p>\n<p><img src=\"/img/1585714787406.png\" alt=\"邻接多重表-示例\"></p>\n<p>7.存储结构 -边集数组</p>\n<ul>\n<li>使用两个一维数组构成，一个存储顶点，一个存储边和权重</li>\n</ul>\n<p><img src=\"/img/1585714939207.png\" alt=\"边集数组\"></p>\n<ol start=\"8\">\n<li>遍历-深度优先遍历</li>\n</ol>\n<ul>\n<li>概述： 以一个点开始，以左/右固定遍历原则来遍历一个图，每成功访问到的一个顶点就标记一下，已经遍历到的点就回退到上一层。以此循环</li>\n</ul>\n<p><img src=\"/img/1585722630933.png\" alt=\"示例\"><br><img src=\"/img/1585722584708.png\" alt=\"右手原则的深度优先遍历\"></p>\n<blockquote>\n<p>. 哈密尔顿路径</p>\n<ul>\n<li>经过图中每个顶点且只经过一次<br>如果最终还能回到起始点，则称为哈密尔顿回路</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>扩展-马踏棋盘算法<br>递归： <a href=\"https://www.cnblogs.com/lpfuture/p/7111524.html\">https://www.cnblogs.com/lpfuture/p/7111524.html</a><br>贪心非递归：<a href=\"https://www.jianshu.com/p/6c185f290e10\">https://www.jianshu.com/p/6c185f290e10</a></p>\n</blockquote>\n<p>9.遍历-广度优先遍历</p>\n<ul>\n<li><p>类似于树的层级遍历，一层一层遍历<br><img src=\"/img/1585742087660.png\" alt=\"广度优先遍历\"></p>\n</li>\n<li><p>常用实现：使用队列的形式：<br><img src=\"/img/1585742120344.png\" alt=\"队列实现广度遍历\"></p>\n</li>\n</ul>\n<p><img src=\"/img/1585742361670.png\" alt=\"算法实现\"></p>\n<p>10.最小生成树 - 普里姆算法：<br><img src=\"/img/1585742844977.png\" alt=\"普里姆算法C-Part1\"></p>\n<p><img src=\"/img/1585743156869.png\" alt=\"普里姆算法C-Part2\"></p>\n<p>以此文章为示例学习：<br><a href=\"https://blog.csdn.net/yeruby/article/details/38615045\">https://blog.csdn.net/yeruby/article/details/38615045</a></p>\n<blockquote>\n<p>从一个点开始以一个数组记录接下来能走的路的权值，下一步的路将是这些权值中的最小值，将将游标移至此最小值的点，标记此点完成状态。接着重复此过程，每次都更新权值数组的值，直到所有的点都被标记为完成。 一定要注意是更新！！！</p>\n</blockquote>\n<p><img src=\"/img/1585819226392.png\" alt=\"时间复杂度对比\"></p>\n"},{"title":"数据结构在C#","_content":"\n数组Array：顺序存储结构\n\t\t优点：按位置索引很快，修改效率高。\n\t\t缺点：需声明存放类型，且只能存放相同类型，必须指定长度（过长浪费，过短溢出），插入与删除很慢（排除特殊情况）。\n\t\n数组ArrayList：顺序存储结构，解决了Array的缺点，由源码得知，默认容量为4，容量自增2倍。\n\t\t不过由于容量是类成员，自增机制会引发线程安全问题，所以ArrayList不是线程安全的。\n\t\t优点：无需指定长度，无需声明存放类型，可存放不同类型元素，底层是object,顺序存储结构常有优点这里都有。\n\t\t缺点：由于底层元素是object，当为值类型时，存在装箱/拆箱操作，效率降低，且可能会有非类型安全问题。顺序存储结构常有缺点这里都有。\n\t\n数组List：顺序存储结构，综合Array和ArrayList的优点，所以List也不是线程安全的。\n\t\t优点：无需指定长度，长度自增。需声明存放类型，内部用Array实现，保证了类型安全。\n\t\t缺点：顺序存储结构常有缺点都有。\n\t所以现在基本上不使用Array和ArrayList，而是使用List。\n\t\n双向链表LinkList：链式存储结构,非线程安全，可自己加锁实现线程安全。\n\t\t优点：插入，删除效率高，只需修改指针域的前驱节点和后继节点即可进行插入删除。\n\t\t缺点：无法基于位置索引，必须从头结点依次遍历。\n\t\n队列Queue：顺序存储结构，先进先出集合。由官方文档得知，非线程安全，但是其有线程安全的的队列实现为ConcurrentQueue<T>。\n\t\t默认容量为32，容量自增为4(.net framework 4.8)，其他版本可能会有变化。\n\t\n栈Stack：顺序存储结构，后进先出集合，默认容量10，容量自增2倍。非线程安全。\n\n\n\n![递归算法](/img/1586415301619.png)\n* 公式法求复杂度：\n* ![公式法](/img/1586415991649.png)\n* ![三种情况](/img/1586416006714.png)\n\n* ![例一](/img/1586416029304.png)\n* ![例二](/img/1586416055487.png)\n* ![例三](/img/1586416101201.png)\n\n![回溯法](/img/1586416261865.png)\n\n![经典找集合总和的算法](/img/1586416480976.png)\n\nNQueen算法：\n![回溯法NQueen](/img/1586418715552.png)\n\n算法复杂度：\n![NQueen算法复杂度](/img/1586419084172.png)\n\n* 题外：关于ref, out的区别\n1、ref指定的参数在函数调用时候必须初始化，不能为空的引用。而out指定的参数在函数调用时候可以不初始化；\n\n2、out指定的参数在进入函数时会清空自己，必须在函数内部赋初值。而ref指定的参数不需要。","source":"_posts/数据结构在Charp.md","raw":"---\ntitle: 数据结构在C#\ncategories:\n- Unity\n---\n\n数组Array：顺序存储结构\n\t\t优点：按位置索引很快，修改效率高。\n\t\t缺点：需声明存放类型，且只能存放相同类型，必须指定长度（过长浪费，过短溢出），插入与删除很慢（排除特殊情况）。\n\t\n数组ArrayList：顺序存储结构，解决了Array的缺点，由源码得知，默认容量为4，容量自增2倍。\n\t\t不过由于容量是类成员，自增机制会引发线程安全问题，所以ArrayList不是线程安全的。\n\t\t优点：无需指定长度，无需声明存放类型，可存放不同类型元素，底层是object,顺序存储结构常有优点这里都有。\n\t\t缺点：由于底层元素是object，当为值类型时，存在装箱/拆箱操作，效率降低，且可能会有非类型安全问题。顺序存储结构常有缺点这里都有。\n\t\n数组List：顺序存储结构，综合Array和ArrayList的优点，所以List也不是线程安全的。\n\t\t优点：无需指定长度，长度自增。需声明存放类型，内部用Array实现，保证了类型安全。\n\t\t缺点：顺序存储结构常有缺点都有。\n\t所以现在基本上不使用Array和ArrayList，而是使用List。\n\t\n双向链表LinkList：链式存储结构,非线程安全，可自己加锁实现线程安全。\n\t\t优点：插入，删除效率高，只需修改指针域的前驱节点和后继节点即可进行插入删除。\n\t\t缺点：无法基于位置索引，必须从头结点依次遍历。\n\t\n队列Queue：顺序存储结构，先进先出集合。由官方文档得知，非线程安全，但是其有线程安全的的队列实现为ConcurrentQueue<T>。\n\t\t默认容量为32，容量自增为4(.net framework 4.8)，其他版本可能会有变化。\n\t\n栈Stack：顺序存储结构，后进先出集合，默认容量10，容量自增2倍。非线程安全。\n\n\n\n![递归算法](/img/1586415301619.png)\n* 公式法求复杂度：\n* ![公式法](/img/1586415991649.png)\n* ![三种情况](/img/1586416006714.png)\n\n* ![例一](/img/1586416029304.png)\n* ![例二](/img/1586416055487.png)\n* ![例三](/img/1586416101201.png)\n\n![回溯法](/img/1586416261865.png)\n\n![经典找集合总和的算法](/img/1586416480976.png)\n\nNQueen算法：\n![回溯法NQueen](/img/1586418715552.png)\n\n算法复杂度：\n![NQueen算法复杂度](/img/1586419084172.png)\n\n* 题外：关于ref, out的区别\n1、ref指定的参数在函数调用时候必须初始化，不能为空的引用。而out指定的参数在函数调用时候可以不初始化；\n\n2、out指定的参数在进入函数时会清空自己，必须在函数内部赋初值。而ref指定的参数不需要。","slug":"数据结构在Charp","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh13l005n4wf0yuowu6h1","content":"<p>数组Array：顺序存储结构<br>        优点：按位置索引很快，修改效率高。<br>        缺点：需声明存放类型，且只能存放相同类型，必须指定长度（过长浪费，过短溢出），插入与删除很慢（排除特殊情况）。</p>\n<p>数组ArrayList：顺序存储结构，解决了Array的缺点，由源码得知，默认容量为4，容量自增2倍。<br>        不过由于容量是类成员，自增机制会引发线程安全问题，所以ArrayList不是线程安全的。<br>        优点：无需指定长度，无需声明存放类型，可存放不同类型元素，底层是object,顺序存储结构常有优点这里都有。<br>        缺点：由于底层元素是object，当为值类型时，存在装箱/拆箱操作，效率降低，且可能会有非类型安全问题。顺序存储结构常有缺点这里都有。</p>\n<p>数组List：顺序存储结构，综合Array和ArrayList的优点，所以List也不是线程安全的。<br>        优点：无需指定长度，长度自增。需声明存放类型，内部用Array实现，保证了类型安全。<br>        缺点：顺序存储结构常有缺点都有。<br>    所以现在基本上不使用Array和ArrayList，而是使用List。</p>\n<p>双向链表LinkList：链式存储结构,非线程安全，可自己加锁实现线程安全。<br>        优点：插入，删除效率高，只需修改指针域的前驱节点和后继节点即可进行插入删除。<br>        缺点：无法基于位置索引，必须从头结点依次遍历。</p>\n<p>队列Queue：顺序存储结构，先进先出集合。由官方文档得知，非线程安全，但是其有线程安全的的队列实现为ConcurrentQueue<T>。<br>        默认容量为32，容量自增为4(.net framework 4.8)，其他版本可能会有变化。</p>\n<p>栈Stack：顺序存储结构，后进先出集合，默认容量10，容量自增2倍。非线程安全。</p>\n<p><img src=\"/img/1586415301619.png\" alt=\"递归算法\"></p>\n<ul>\n<li><p>公式法求复杂度：</p>\n</li>\n<li><p><img src=\"/img/1586415991649.png\" alt=\"公式法\"></p>\n</li>\n<li><p><img src=\"/img/1586416006714.png\" alt=\"三种情况\"></p>\n</li>\n<li><p><img src=\"/img/1586416029304.png\" alt=\"例一\"></p>\n</li>\n<li><p><img src=\"/img/1586416055487.png\" alt=\"例二\"></p>\n</li>\n<li><p><img src=\"/img/1586416101201.png\" alt=\"例三\"></p>\n</li>\n</ul>\n<p><img src=\"/img/1586416261865.png\" alt=\"回溯法\"></p>\n<p><img src=\"/img/1586416480976.png\" alt=\"经典找集合总和的算法\"></p>\n<p>NQueen算法：<br><img src=\"/img/1586418715552.png\" alt=\"回溯法NQueen\"></p>\n<p>算法复杂度：<br><img src=\"/img/1586419084172.png\" alt=\"NQueen算法复杂度\"></p>\n<ul>\n<li>题外：关于ref, out的区别<br>1、ref指定的参数在函数调用时候必须初始化，不能为空的引用。而out指定的参数在函数调用时候可以不初始化；</li>\n</ul>\n<p>2、out指定的参数在进入函数时会清空自己，必须在函数内部赋初值。而ref指定的参数不需要。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>数组Array：顺序存储结构<br>        优点：按位置索引很快，修改效率高。<br>        缺点：需声明存放类型，且只能存放相同类型，必须指定长度（过长浪费，过短溢出），插入与删除很慢（排除特殊情况）。</p>\n<p>数组ArrayList：顺序存储结构，解决了Array的缺点，由源码得知，默认容量为4，容量自增2倍。<br>        不过由于容量是类成员，自增机制会引发线程安全问题，所以ArrayList不是线程安全的。<br>        优点：无需指定长度，无需声明存放类型，可存放不同类型元素，底层是object,顺序存储结构常有优点这里都有。<br>        缺点：由于底层元素是object，当为值类型时，存在装箱/拆箱操作，效率降低，且可能会有非类型安全问题。顺序存储结构常有缺点这里都有。</p>\n<p>数组List：顺序存储结构，综合Array和ArrayList的优点，所以List也不是线程安全的。<br>        优点：无需指定长度，长度自增。需声明存放类型，内部用Array实现，保证了类型安全。<br>        缺点：顺序存储结构常有缺点都有。<br>    所以现在基本上不使用Array和ArrayList，而是使用List。</p>\n<p>双向链表LinkList：链式存储结构,非线程安全，可自己加锁实现线程安全。<br>        优点：插入，删除效率高，只需修改指针域的前驱节点和后继节点即可进行插入删除。<br>        缺点：无法基于位置索引，必须从头结点依次遍历。</p>\n<p>队列Queue：顺序存储结构，先进先出集合。由官方文档得知，非线程安全，但是其有线程安全的的队列实现为ConcurrentQueue<T>。<br>        默认容量为32，容量自增为4(.net framework 4.8)，其他版本可能会有变化。</p>\n<p>栈Stack：顺序存储结构，后进先出集合，默认容量10，容量自增2倍。非线程安全。</p>\n<p><img src=\"/img/1586415301619.png\" alt=\"递归算法\"></p>\n<ul>\n<li><p>公式法求复杂度：</p>\n</li>\n<li><p><img src=\"/img/1586415991649.png\" alt=\"公式法\"></p>\n</li>\n<li><p><img src=\"/img/1586416006714.png\" alt=\"三种情况\"></p>\n</li>\n<li><p><img src=\"/img/1586416029304.png\" alt=\"例一\"></p>\n</li>\n<li><p><img src=\"/img/1586416055487.png\" alt=\"例二\"></p>\n</li>\n<li><p><img src=\"/img/1586416101201.png\" alt=\"例三\"></p>\n</li>\n</ul>\n<p><img src=\"/img/1586416261865.png\" alt=\"回溯法\"></p>\n<p><img src=\"/img/1586416480976.png\" alt=\"经典找集合总和的算法\"></p>\n<p>NQueen算法：<br><img src=\"/img/1586418715552.png\" alt=\"回溯法NQueen\"></p>\n<p>算法复杂度：<br><img src=\"/img/1586419084172.png\" alt=\"NQueen算法复杂度\"></p>\n<ul>\n<li>题外：关于ref, out的区别<br>1、ref指定的参数在函数调用时候必须初始化，不能为空的引用。而out指定的参数在函数调用时候可以不初始化；</li>\n</ul>\n<p>2、out指定的参数在进入函数时会清空自己，必须在函数内部赋初值。而ref指定的参数不需要。</p>\n"},{"title":"深度优先与广度优先算法","_content":"\n### 深度优先搜索:\n* 以递归的形式实现\n\n![递归实现](/img/1586434191932.png)\n> 递归实现特点：\n\n![特点](/img/1586434219909.png)\n\n* 栈的实现（非递归实现）\n\n![栈的实现](/img/1586434247273.png)\n\n![实现](/img/1586434291192.png)\n\n> 图的时间\n![图的时间复杂度](/img/1586434361642.png)\n\n> DFS迷宫算法：\n![算法分析](/img/1586434407387.png)\n\n* 最小路径问题\n\n![最短路径查找](/img/1586434733368.png)\n![最短路径的DFS算法](/img/1586434756126.png)\n\n\n### 广度优先搜索\n\n![特点](/img/1586434845632.png)\n\n> 队列的实现描述：\n![描述](/img/1586434970193.png)\n\n> 算法实现：\n![实现描述](/img/1586435106444.png)\n\n> 复杂度分析：\n![复杂度分析](/img/1586435164143.png)\n\n> 迷宫的复杂度分析：\n![迷宫复杂度分析](/img/1586435194085.png)\n\n> 最小开墙数的最短路径：\n> ![开墙最小路径算法1](/img/1586435618505.png)\n> ![开墙最小路径算法2](/img/1586435636294.png)\n> ![开墙最小路径算法3](/img/1586435663044.png)","source":"_posts/深度优先与广度优先算法.md","raw":"---\ntitle: 深度优先与广度优先算法\ncategories:\n- 算法\n---\n\n### 深度优先搜索:\n* 以递归的形式实现\n\n![递归实现](/img/1586434191932.png)\n> 递归实现特点：\n\n![特点](/img/1586434219909.png)\n\n* 栈的实现（非递归实现）\n\n![栈的实现](/img/1586434247273.png)\n\n![实现](/img/1586434291192.png)\n\n> 图的时间\n![图的时间复杂度](/img/1586434361642.png)\n\n> DFS迷宫算法：\n![算法分析](/img/1586434407387.png)\n\n* 最小路径问题\n\n![最短路径查找](/img/1586434733368.png)\n![最短路径的DFS算法](/img/1586434756126.png)\n\n\n### 广度优先搜索\n\n![特点](/img/1586434845632.png)\n\n> 队列的实现描述：\n![描述](/img/1586434970193.png)\n\n> 算法实现：\n![实现描述](/img/1586435106444.png)\n\n> 复杂度分析：\n![复杂度分析](/img/1586435164143.png)\n\n> 迷宫的复杂度分析：\n![迷宫复杂度分析](/img/1586435194085.png)\n\n> 最小开墙数的最短路径：\n> ![开墙最小路径算法1](/img/1586435618505.png)\n> ![开墙最小路径算法2](/img/1586435636294.png)\n> ![开墙最小路径算法3](/img/1586435663044.png)","slug":"深度优先与广度优先算法","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh13n005q4wf0ordlelpq","content":"<h3 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索:\"></a>深度优先搜索:</h3><ul>\n<li>以递归的形式实现</li>\n</ul>\n<p><img src=\"/img/1586434191932.png\" alt=\"递归实现\"></p>\n<blockquote>\n<p>递归实现特点：</p>\n</blockquote>\n<p><img src=\"/img/1586434219909.png\" alt=\"特点\"></p>\n<ul>\n<li>栈的实现（非递归实现）</li>\n</ul>\n<p><img src=\"/img/1586434247273.png\" alt=\"栈的实现\"></p>\n<p><img src=\"/img/1586434291192.png\" alt=\"实现\"></p>\n<blockquote>\n<p>图的时间<br><img src=\"/img/1586434361642.png\" alt=\"图的时间复杂度\"></p>\n</blockquote>\n<blockquote>\n<p>DFS迷宫算法：<br><img src=\"/img/1586434407387.png\" alt=\"算法分析\"></p>\n</blockquote>\n<ul>\n<li>最小路径问题</li>\n</ul>\n<p><img src=\"/img/1586434733368.png\" alt=\"最短路径查找\"><br><img src=\"/img/1586434756126.png\" alt=\"最短路径的DFS算法\"></p>\n<h3 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h3><p><img src=\"/img/1586434845632.png\" alt=\"特点\"></p>\n<blockquote>\n<p>队列的实现描述：<br><img src=\"/img/1586434970193.png\" alt=\"描述\"></p>\n</blockquote>\n<blockquote>\n<p>算法实现：<br><img src=\"/img/1586435106444.png\" alt=\"实现描述\"></p>\n</blockquote>\n<blockquote>\n<p>复杂度分析：<br><img src=\"/img/1586435164143.png\" alt=\"复杂度分析\"></p>\n</blockquote>\n<blockquote>\n<p>迷宫的复杂度分析：<br><img src=\"/img/1586435194085.png\" alt=\"迷宫复杂度分析\"></p>\n</blockquote>\n<blockquote>\n<p>最小开墙数的最短路径：<br><img src=\"/img/1586435618505.png\" alt=\"开墙最小路径算法1\"><br><img src=\"/img/1586435636294.png\" alt=\"开墙最小路径算法2\"><br><img src=\"/img/1586435663044.png\" alt=\"开墙最小路径算法3\"></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索:\"></a>深度优先搜索:</h3><ul>\n<li>以递归的形式实现</li>\n</ul>\n<p><img src=\"/img/1586434191932.png\" alt=\"递归实现\"></p>\n<blockquote>\n<p>递归实现特点：</p>\n</blockquote>\n<p><img src=\"/img/1586434219909.png\" alt=\"特点\"></p>\n<ul>\n<li>栈的实现（非递归实现）</li>\n</ul>\n<p><img src=\"/img/1586434247273.png\" alt=\"栈的实现\"></p>\n<p><img src=\"/img/1586434291192.png\" alt=\"实现\"></p>\n<blockquote>\n<p>图的时间<br><img src=\"/img/1586434361642.png\" alt=\"图的时间复杂度\"></p>\n</blockquote>\n<blockquote>\n<p>DFS迷宫算法：<br><img src=\"/img/1586434407387.png\" alt=\"算法分析\"></p>\n</blockquote>\n<ul>\n<li>最小路径问题</li>\n</ul>\n<p><img src=\"/img/1586434733368.png\" alt=\"最短路径查找\"><br><img src=\"/img/1586434756126.png\" alt=\"最短路径的DFS算法\"></p>\n<h3 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h3><p><img src=\"/img/1586434845632.png\" alt=\"特点\"></p>\n<blockquote>\n<p>队列的实现描述：<br><img src=\"/img/1586434970193.png\" alt=\"描述\"></p>\n</blockquote>\n<blockquote>\n<p>算法实现：<br><img src=\"/img/1586435106444.png\" alt=\"实现描述\"></p>\n</blockquote>\n<blockquote>\n<p>复杂度分析：<br><img src=\"/img/1586435164143.png\" alt=\"复杂度分析\"></p>\n</blockquote>\n<blockquote>\n<p>迷宫的复杂度分析：<br><img src=\"/img/1586435194085.png\" alt=\"迷宫复杂度分析\"></p>\n</blockquote>\n<blockquote>\n<p>最小开墙数的最短路径：<br><img src=\"/img/1586435618505.png\" alt=\"开墙最小路径算法1\"><br><img src=\"/img/1586435636294.png\" alt=\"开墙最小路径算法2\"><br><img src=\"/img/1586435663044.png\" alt=\"开墙最小路径算法3\"></p>\n</blockquote>\n"},{"title":"计算机图形学编程笔记1","_content":"\n#### 一、搭建OPENGL 的C++环境\n\n* 1.1 准备工作\n 1. VS下的C++环境\n 2. 窗口显示库： GLFW \n>GLFW 安装编译的方法，32位使用编译会有问题，这里如果用64的话是： [具体细节](https://www.cnblogs.com/collectionne/p/6937644.html)\n>1. 进入GLFW官方网站glfw.org，下载源码\n>2.  安装CMAKE，使用CMAKE编译源码生成工程\n>3.生成完工程，打开工程，编译生成lib文件\n\n3.扩展库： GLEW，[官网下载]( http://glew.sourceforge.net/) 取出lib和dll文件即可\n4.数学库：GLM， 官网下载完即可。\n5.纹理库：SOIL2\n>SOIL2 安装方法：[具体细节](https://blog.csdn.net/Wonz5130/article/details/82828817)\n>1. 下载SOIL2源码\n>2.下载premake4\n>3.将premake4放到SOIL2的文件夹\n>4.终端cd到SOIL2的文件夹，执行命令： premake4 vs2012， 将生成工程文件\n>5.打开上面生成的VS工程，编译即可得到库\n\n* 1.2 制作项目模板\n1.准备lib文件夹，放glew,glfw, soil2的lib文件\n2.准备include文件夹，放GLEW的GL文件夹，GLFW的GLFW文件夹，glm文件夹， SOIL2的SOIL2文件夹。\n3.新建VS空C++项目，配置为win32\n4.配置项目的VC++的常规里的包含目录，添加Include文件夹\n5.链接器配置，常规添加lib文件夹，输入配置前面三个lib文件名加上opengl32.lib\n\n* 1.3 正式的项目开发\n1. 使用1.2创建的模板新建工程\n2. 拷贝glew32.dll到项目的debug或release目录中。\n\n#### 二、3D图形数据\n\n2.1 绘制流程描述：\n* init() 初始化时\n* 1. 创建一个缓冲区\n* 2. 将顶点数据复制到缓冲区\n* display()每帧刷新时。\n* 1. 启用缓冲区\n* 2. 将缓冲区数据绑定至顶点属性\n* 3. 启用顶点\n* 4. 使用glDrawArray画出来。\n\n2.2 VAO（Vertex Array Object）, VBO(Vertex Buffer Object)\n顶点数据会先放在一个缓冲区，而这个缓冲区就存储在VBO里。同场景可能有多个VBO。\n顶点数组对象则是opengl3.0引入的类似于VAO的组织性结构。\n>例： 当绘制两个对象时，可以声明两个VBO，一个VAO，glGenVertexArray生成VAO，glBindVertexArray激活VAO与顶点属性关联，再使用glGenBuffers生成缓冲区。\n\n2.3 使用统一变量\n在shader中将变量标记为Uniform后，在opengl中使用glGetuniformlocation得到对应的GL 的id。这样再通过glm::value_ptr取出对应的数值指针设值！。\n> 统一变量在每次从顶点缓存区拿值时都是不变的，可以理解为常量\n\n2.4 绘制立方体\n* 1.VAO,VBO初始化\n* 2.从相机的位置获取视角矩阵，V_MATRIX。 使用glm:translate\n* 3.从物体位置获取模型矩阵，M_MATRIX。 使用glm:translate\n* 4.从窗口，获取到P_MATRIX透视矩阵.。 使用glm:perspective\n* 5.将MV,P矩阵传到顶点shader里\n \n> 矩阵变换从右往左变换，将transMatrix * rotMatrix。先旋转再变位置。\n\n> 注意shader中的设值：\n> ```c++\n> \t//VBO关联，顶点着色器的location为0的值被找出来。并从第一个VBO库中将值给过去\n> \tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\n> \tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\n> \tglEnableVertexAttribArray(0);\n> ```\n\n>注意Opengl的glm与GLSL中矩阵的定义规则：\n> GLSL中的矩阵与GLM都是以列读取的！\n\n```c++\n//glm的定义矩阵，以下两个矩阵变量是相同的，且以1,2,3,4为列往后排\nglm::mat4 test = {\n\t{1,2,3,4},\n\t{5,6,7,8},\n\t{9,10,11,12},\n\t{13,14,15,16},\n};\nglm::mat4 test2 = {\n\t1,2,3,4,\n\t5,6,7,8,\n\t9,10,11,12,\n\t13,14,15,16,\n};\n```\n\n2.5 使用矩阵栈来处理分层模型\n* 例 ：行星系统的实现流程\n* 1. 初始栈，实例一个vMatrix视觉矩阵\n* 2. 实现太阳：复制一个到栈顶，生成太阳的MV矩阵，复制一个到栈顶，生成太阳的旋转。画太阳，然后POP出太阳的旋转。\n* 3. 当前栈顶的是太阳的MV矩阵。以此复制到栈顶，生成行星的MV矩阵，复制到栈顶，生成行星的旋转。画行星，然后POP出行得的旋转。\n* 4. 当前栈顶是行星的MV矩阵，以此复制到栈顶，生成月亮的MV矩阵，生成旋转，生成缩放。\n* 5.前面四个步骤，此时栈，共有四个元素。从顶到底分别是，月亮，行星，太阳，视觉矩阵。依次弹出清空栈。\n  \n2.6 优化策略\n  * display帧刷新函数中不要定义或申请变量内存\n  * 背面剔除：\n  * 1.使用glEnable(GL_CULL_FACE) 激活此功能\n  * 2.使用glFrontFace(GL_CCW)设置逆时针为正向\n  * 3.使用glCullFace(GL_BACK)将背面剔除（默认）。 GL_FRONT 和GL_FRONT_AND_BACK\n   \n#### 纹理贴图-使用SOIL2\n\n3.1 使用纹理贴图\n* 1.使用SOIL_LOAD_TEXTURE获取到texture ID\n* 2.构建纹理坐标，以左下角为0,0为定，右上角为1,1。把纹理2D坐标点与3D模型坐标相映射。\n* 3.在display中使用glActiveTexture激活，用glBindTexture(GL_TEXTURE_2D, \"注：1中的texture ID\")\n* 4.vertex shader 收到纹理坐标传至 fragment shader\n* 5.fragmenet shader中使用sampler2d采样器，利用4中得到的坐标点取颜色值返回。\n\n3.2 多级渐远纹理贴图 Mipmapping - 避免校正采样误差伪影\n* 纹理中存储相同图像的连续一系列较低分辨率副本 。大小将比原图像大1/3\n* 如何在OpenGL使用：\n* 1.激活纹理。glBindTexture(GL_TEXTURE_2D, textureRef);\n* 2.使用glTexParameteri的GL_TEXTURE_MIN_FILTER 指明，四个方法：\n* GL_NEAREST_MIPMAP_NEAREST//取最近的纹素\n* GL_LINEAR_MIPMAP_NEAREST//线性\n* GL_NEAREST_MIPMAP_LINEAR//双线性\n* GL_LINEAR_MIPMAP_LINEAR //三线性\n\n3.3 各向异性过滤-AF\n恢复MIPMAPPING丢失的细节，标准MipMapping使用正方形分辨率MIP纹理，而AF可以使用各种矩形分辨率来采样。\n```c++\nif (glewIsSupported(\"GL_EXT_texture_filter_anisotropic\")) {\n\tcout<<\"支持各向异性！\"<<endl;\n}\n\n```\n3.4 环绕和平辅\n* 当纹理坐标不是\\[0, 1]\\的范围时，需要设置填充参数：\n* GL_REPEAT, GL_MIRRORED_REPEAT（当奇数时坐标反转）, GL_CLAMP_TO_EDGE（0，1以外强设成边界值）, GL_CLAMP_TO_BORDER(0，1以外的设成颜色)\n\n3.5 透视变形\n考虑情形如：矩形棋盘结构的纹理填充，在X轴旋转时将导致三角面交接处发生变形。\n默认opengl将会开启透视修复。\n> 使用noperspective 禁止opengl透视修复\n> ```c++\n> noperspective out texcoord;//顶点\n> noperspective in texcoord;//片面\n> ```\n\n\n","source":"_posts/计算机图形学编程笔记1.md","raw":"---\ntitle: 计算机图形学编程笔记1\ncategories:\n- 图形学\ntags: \n- 图形学\n---\n\n#### 一、搭建OPENGL 的C++环境\n\n* 1.1 准备工作\n 1. VS下的C++环境\n 2. 窗口显示库： GLFW \n>GLFW 安装编译的方法，32位使用编译会有问题，这里如果用64的话是： [具体细节](https://www.cnblogs.com/collectionne/p/6937644.html)\n>1. 进入GLFW官方网站glfw.org，下载源码\n>2.  安装CMAKE，使用CMAKE编译源码生成工程\n>3.生成完工程，打开工程，编译生成lib文件\n\n3.扩展库： GLEW，[官网下载]( http://glew.sourceforge.net/) 取出lib和dll文件即可\n4.数学库：GLM， 官网下载完即可。\n5.纹理库：SOIL2\n>SOIL2 安装方法：[具体细节](https://blog.csdn.net/Wonz5130/article/details/82828817)\n>1. 下载SOIL2源码\n>2.下载premake4\n>3.将premake4放到SOIL2的文件夹\n>4.终端cd到SOIL2的文件夹，执行命令： premake4 vs2012， 将生成工程文件\n>5.打开上面生成的VS工程，编译即可得到库\n\n* 1.2 制作项目模板\n1.准备lib文件夹，放glew,glfw, soil2的lib文件\n2.准备include文件夹，放GLEW的GL文件夹，GLFW的GLFW文件夹，glm文件夹， SOIL2的SOIL2文件夹。\n3.新建VS空C++项目，配置为win32\n4.配置项目的VC++的常规里的包含目录，添加Include文件夹\n5.链接器配置，常规添加lib文件夹，输入配置前面三个lib文件名加上opengl32.lib\n\n* 1.3 正式的项目开发\n1. 使用1.2创建的模板新建工程\n2. 拷贝glew32.dll到项目的debug或release目录中。\n\n#### 二、3D图形数据\n\n2.1 绘制流程描述：\n* init() 初始化时\n* 1. 创建一个缓冲区\n* 2. 将顶点数据复制到缓冲区\n* display()每帧刷新时。\n* 1. 启用缓冲区\n* 2. 将缓冲区数据绑定至顶点属性\n* 3. 启用顶点\n* 4. 使用glDrawArray画出来。\n\n2.2 VAO（Vertex Array Object）, VBO(Vertex Buffer Object)\n顶点数据会先放在一个缓冲区，而这个缓冲区就存储在VBO里。同场景可能有多个VBO。\n顶点数组对象则是opengl3.0引入的类似于VAO的组织性结构。\n>例： 当绘制两个对象时，可以声明两个VBO，一个VAO，glGenVertexArray生成VAO，glBindVertexArray激活VAO与顶点属性关联，再使用glGenBuffers生成缓冲区。\n\n2.3 使用统一变量\n在shader中将变量标记为Uniform后，在opengl中使用glGetuniformlocation得到对应的GL 的id。这样再通过glm::value_ptr取出对应的数值指针设值！。\n> 统一变量在每次从顶点缓存区拿值时都是不变的，可以理解为常量\n\n2.4 绘制立方体\n* 1.VAO,VBO初始化\n* 2.从相机的位置获取视角矩阵，V_MATRIX。 使用glm:translate\n* 3.从物体位置获取模型矩阵，M_MATRIX。 使用glm:translate\n* 4.从窗口，获取到P_MATRIX透视矩阵.。 使用glm:perspective\n* 5.将MV,P矩阵传到顶点shader里\n \n> 矩阵变换从右往左变换，将transMatrix * rotMatrix。先旋转再变位置。\n\n> 注意shader中的设值：\n> ```c++\n> \t//VBO关联，顶点着色器的location为0的值被找出来。并从第一个VBO库中将值给过去\n> \tglBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\n> \tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\n> \tglEnableVertexAttribArray(0);\n> ```\n\n>注意Opengl的glm与GLSL中矩阵的定义规则：\n> GLSL中的矩阵与GLM都是以列读取的！\n\n```c++\n//glm的定义矩阵，以下两个矩阵变量是相同的，且以1,2,3,4为列往后排\nglm::mat4 test = {\n\t{1,2,3,4},\n\t{5,6,7,8},\n\t{9,10,11,12},\n\t{13,14,15,16},\n};\nglm::mat4 test2 = {\n\t1,2,3,4,\n\t5,6,7,8,\n\t9,10,11,12,\n\t13,14,15,16,\n};\n```\n\n2.5 使用矩阵栈来处理分层模型\n* 例 ：行星系统的实现流程\n* 1. 初始栈，实例一个vMatrix视觉矩阵\n* 2. 实现太阳：复制一个到栈顶，生成太阳的MV矩阵，复制一个到栈顶，生成太阳的旋转。画太阳，然后POP出太阳的旋转。\n* 3. 当前栈顶的是太阳的MV矩阵。以此复制到栈顶，生成行星的MV矩阵，复制到栈顶，生成行星的旋转。画行星，然后POP出行得的旋转。\n* 4. 当前栈顶是行星的MV矩阵，以此复制到栈顶，生成月亮的MV矩阵，生成旋转，生成缩放。\n* 5.前面四个步骤，此时栈，共有四个元素。从顶到底分别是，月亮，行星，太阳，视觉矩阵。依次弹出清空栈。\n  \n2.6 优化策略\n  * display帧刷新函数中不要定义或申请变量内存\n  * 背面剔除：\n  * 1.使用glEnable(GL_CULL_FACE) 激活此功能\n  * 2.使用glFrontFace(GL_CCW)设置逆时针为正向\n  * 3.使用glCullFace(GL_BACK)将背面剔除（默认）。 GL_FRONT 和GL_FRONT_AND_BACK\n   \n#### 纹理贴图-使用SOIL2\n\n3.1 使用纹理贴图\n* 1.使用SOIL_LOAD_TEXTURE获取到texture ID\n* 2.构建纹理坐标，以左下角为0,0为定，右上角为1,1。把纹理2D坐标点与3D模型坐标相映射。\n* 3.在display中使用glActiveTexture激活，用glBindTexture(GL_TEXTURE_2D, \"注：1中的texture ID\")\n* 4.vertex shader 收到纹理坐标传至 fragment shader\n* 5.fragmenet shader中使用sampler2d采样器，利用4中得到的坐标点取颜色值返回。\n\n3.2 多级渐远纹理贴图 Mipmapping - 避免校正采样误差伪影\n* 纹理中存储相同图像的连续一系列较低分辨率副本 。大小将比原图像大1/3\n* 如何在OpenGL使用：\n* 1.激活纹理。glBindTexture(GL_TEXTURE_2D, textureRef);\n* 2.使用glTexParameteri的GL_TEXTURE_MIN_FILTER 指明，四个方法：\n* GL_NEAREST_MIPMAP_NEAREST//取最近的纹素\n* GL_LINEAR_MIPMAP_NEAREST//线性\n* GL_NEAREST_MIPMAP_LINEAR//双线性\n* GL_LINEAR_MIPMAP_LINEAR //三线性\n\n3.3 各向异性过滤-AF\n恢复MIPMAPPING丢失的细节，标准MipMapping使用正方形分辨率MIP纹理，而AF可以使用各种矩形分辨率来采样。\n```c++\nif (glewIsSupported(\"GL_EXT_texture_filter_anisotropic\")) {\n\tcout<<\"支持各向异性！\"<<endl;\n}\n\n```\n3.4 环绕和平辅\n* 当纹理坐标不是\\[0, 1]\\的范围时，需要设置填充参数：\n* GL_REPEAT, GL_MIRRORED_REPEAT（当奇数时坐标反转）, GL_CLAMP_TO_EDGE（0，1以外强设成边界值）, GL_CLAMP_TO_BORDER(0，1以外的设成颜色)\n\n3.5 透视变形\n考虑情形如：矩形棋盘结构的纹理填充，在X轴旋转时将导致三角面交接处发生变形。\n默认opengl将会开启透视修复。\n> 使用noperspective 禁止opengl透视修复\n> ```c++\n> noperspective out texcoord;//顶点\n> noperspective in texcoord;//片面\n> ```\n\n\n","slug":"计算机图形学编程笔记1","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh13o005u4wf0rbu2gfvq","content":"<h4 id=\"一、搭建OPENGL-的C-环境\"><a href=\"#一、搭建OPENGL-的C-环境\" class=\"headerlink\" title=\"一、搭建OPENGL 的C++环境\"></a>一、搭建OPENGL 的C++环境</h4><ul>\n<li>1.1 准备工作<ol>\n<li>VS下的C++环境</li>\n<li>窗口显示库： GLFW <blockquote>\n<p>GLFW 安装编译的方法，32位使用编译会有问题，这里如果用64的话是： <a href=\"https://www.cnblogs.com/collectionne/p/6937644.html\">具体细节</a></p>\n<ol>\n<li>进入GLFW官方网站glfw.org，下载源码</li>\n<li>安装CMAKE，使用CMAKE编译源码生成工程</li>\n<li>生成完工程，打开工程，编译生成lib文件</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<p>3.扩展库： GLEW，<a href=\"http://glew.sourceforge.net/\">官网下载</a> 取出lib和dll文件即可<br>4.数学库：GLM， 官网下载完即可。<br>5.纹理库：SOIL2</p>\n<blockquote>\n<p>SOIL2 安装方法：<a href=\"https://blog.csdn.net/Wonz5130/article/details/82828817\">具体细节</a></p>\n<ol>\n<li>下载SOIL2源码</li>\n<li>下载premake4</li>\n<li>将premake4放到SOIL2的文件夹</li>\n<li>终端cd到SOIL2的文件夹，执行命令： premake4 vs2012， 将生成工程文件</li>\n<li>打开上面生成的VS工程，编译即可得到库</li>\n</ol>\n</blockquote>\n<ul>\n<li>1.2 制作项目模板</li>\n</ul>\n<p>1.准备lib文件夹，放glew,glfw, soil2的lib文件<br>2.准备include文件夹，放GLEW的GL文件夹，GLFW的GLFW文件夹，glm文件夹， SOIL2的SOIL2文件夹。<br>3.新建VS空C++项目，配置为win32<br>4.配置项目的VC++的常规里的包含目录，添加Include文件夹<br>5.链接器配置，常规添加lib文件夹，输入配置前面三个lib文件名加上opengl32.lib</p>\n<ul>\n<li>1.3 正式的项目开发</li>\n</ul>\n<ol>\n<li>使用1.2创建的模板新建工程</li>\n<li>拷贝glew32.dll到项目的debug或release目录中。</li>\n</ol>\n<h4 id=\"二、3D图形数据\"><a href=\"#二、3D图形数据\" class=\"headerlink\" title=\"二、3D图形数据\"></a>二、3D图形数据</h4><p>2.1 绘制流程描述：</p>\n<ul>\n<li>init() 初始化时</li>\n<li><ol>\n<li>创建一个缓冲区</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>将顶点数据复制到缓冲区</li>\n</ol>\n</li>\n<li>display()每帧刷新时。</li>\n<li><ol>\n<li>启用缓冲区</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>将缓冲区数据绑定至顶点属性</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>启用顶点</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>使用glDrawArray画出来。</li>\n</ol>\n</li>\n</ul>\n<p>2.2 VAO（Vertex Array Object）, VBO(Vertex Buffer Object)<br>顶点数据会先放在一个缓冲区，而这个缓冲区就存储在VBO里。同场景可能有多个VBO。<br>顶点数组对象则是opengl3.0引入的类似于VAO的组织性结构。</p>\n<blockquote>\n<p>例： 当绘制两个对象时，可以声明两个VBO，一个VAO，glGenVertexArray生成VAO，glBindVertexArray激活VAO与顶点属性关联，再使用glGenBuffers生成缓冲区。</p>\n</blockquote>\n<p>2.3 使用统一变量<br>在shader中将变量标记为Uniform后，在opengl中使用glGetuniformlocation得到对应的GL 的id。这样再通过glm::value_ptr取出对应的数值指针设值！。</p>\n<blockquote>\n<p>统一变量在每次从顶点缓存区拿值时都是不变的，可以理解为常量</p>\n</blockquote>\n<p>2.4 绘制立方体</p>\n<ul>\n<li>1.VAO,VBO初始化</li>\n<li>2.从相机的位置获取视角矩阵，V_MATRIX。 使用glm:translate</li>\n<li>3.从物体位置获取模型矩阵，M_MATRIX。 使用glm:translate</li>\n<li>4.从窗口，获取到P_MATRIX透视矩阵.。 使用glm:perspective</li>\n<li>5.将MV,P矩阵传到顶点shader里</li>\n</ul>\n<blockquote>\n<p>矩阵变换从右往左变换，将transMatrix * rotMatrix。先旋转再变位置。</p>\n</blockquote>\n<blockquote>\n<p>注意shader中的设值：</p>\n<pre><code class=\"c++\">    //VBO关联，顶点着色器的location为0的值被找出来。并从第一个VBO库中将值给过去\n    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\n    glEnableVertexAttribArray(0);</code></pre>\n</blockquote>\n<blockquote>\n<p>注意Opengl的glm与GLSL中矩阵的定义规则：<br>GLSL中的矩阵与GLM都是以列读取的！</p>\n</blockquote>\n<pre><code class=\"c++\">//glm的定义矩阵，以下两个矩阵变量是相同的，且以1,2,3,4为列往后排\nglm::mat4 test = {\n    {1,2,3,4},\n    {5,6,7,8},\n    {9,10,11,12},\n    {13,14,15,16},\n};\nglm::mat4 test2 = {\n    1,2,3,4,\n    5,6,7,8,\n    9,10,11,12,\n    13,14,15,16,\n};</code></pre>\n<p>2.5 使用矩阵栈来处理分层模型</p>\n<ul>\n<li>例 ：行星系统的实现流程</li>\n<li><ol>\n<li>初始栈，实例一个vMatrix视觉矩阵</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>实现太阳：复制一个到栈顶，生成太阳的MV矩阵，复制一个到栈顶，生成太阳的旋转。画太阳，然后POP出太阳的旋转。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>当前栈顶的是太阳的MV矩阵。以此复制到栈顶，生成行星的MV矩阵，复制到栈顶，生成行星的旋转。画行星，然后POP出行得的旋转。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>当前栈顶是行星的MV矩阵，以此复制到栈顶，生成月亮的MV矩阵，生成旋转，生成缩放。</li>\n</ol>\n</li>\n<li>5.前面四个步骤，此时栈，共有四个元素。从顶到底分别是，月亮，行星，太阳，视觉矩阵。依次弹出清空栈。</li>\n</ul>\n<p>2.6 优化策略</p>\n<ul>\n<li>display帧刷新函数中不要定义或申请变量内存</li>\n<li>背面剔除：</li>\n<li>1.使用glEnable(GL_CULL_FACE) 激活此功能</li>\n<li>2.使用glFrontFace(GL_CCW)设置逆时针为正向</li>\n<li>3.使用glCullFace(GL_BACK)将背面剔除（默认）。 GL_FRONT 和GL_FRONT_AND_BACK</li>\n</ul>\n<h4 id=\"纹理贴图-使用SOIL2\"><a href=\"#纹理贴图-使用SOIL2\" class=\"headerlink\" title=\"纹理贴图-使用SOIL2\"></a>纹理贴图-使用SOIL2</h4><p>3.1 使用纹理贴图</p>\n<ul>\n<li>1.使用SOIL_LOAD_TEXTURE获取到texture ID</li>\n<li>2.构建纹理坐标，以左下角为0,0为定，右上角为1,1。把纹理2D坐标点与3D模型坐标相映射。</li>\n<li>3.在display中使用glActiveTexture激活，用glBindTexture(GL_TEXTURE_2D, “注：1中的texture ID”)</li>\n<li>4.vertex shader 收到纹理坐标传至 fragment shader</li>\n<li>5.fragmenet shader中使用sampler2d采样器，利用4中得到的坐标点取颜色值返回。</li>\n</ul>\n<p>3.2 多级渐远纹理贴图 Mipmapping - 避免校正采样误差伪影</p>\n<ul>\n<li>纹理中存储相同图像的连续一系列较低分辨率副本 。大小将比原图像大1/3</li>\n<li>如何在OpenGL使用：</li>\n<li>1.激活纹理。glBindTexture(GL_TEXTURE_2D, textureRef);</li>\n<li>2.使用glTexParameteri的GL_TEXTURE_MIN_FILTER 指明，四个方法：</li>\n<li>GL_NEAREST_MIPMAP_NEAREST//取最近的纹素</li>\n<li>GL_LINEAR_MIPMAP_NEAREST//线性</li>\n<li>GL_NEAREST_MIPMAP_LINEAR//双线性</li>\n<li>GL_LINEAR_MIPMAP_LINEAR //三线性</li>\n</ul>\n<p>3.3 各向异性过滤-AF<br>恢复MIPMAPPING丢失的细节，标准MipMapping使用正方形分辨率MIP纹理，而AF可以使用各种矩形分辨率来采样。</p>\n<pre><code class=\"c++\">if (glewIsSupported(&quot;GL_EXT_texture_filter_anisotropic&quot;)) {\n    cout&lt;&lt;&quot;支持各向异性！&quot;&lt;&lt;endl;\n}\n</code></pre>\n<p>3.4 环绕和平辅</p>\n<ul>\n<li>当纹理坐标不是[0, 1]\\的范围时，需要设置填充参数：</li>\n<li>GL_REPEAT, GL_MIRRORED_REPEAT（当奇数时坐标反转）, GL_CLAMP_TO_EDGE（0，1以外强设成边界值）, GL_CLAMP_TO_BORDER(0，1以外的设成颜色)</li>\n</ul>\n<p>3.5 透视变形<br>考虑情形如：矩形棋盘结构的纹理填充，在X轴旋转时将导致三角面交接处发生变形。<br>默认opengl将会开启透视修复。</p>\n<blockquote>\n<p>使用noperspective 禁止opengl透视修复</p>\n<pre><code class=\"c++\">noperspective out texcoord;//顶点\nnoperspective in texcoord;//片面</code></pre>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、搭建OPENGL-的C-环境\"><a href=\"#一、搭建OPENGL-的C-环境\" class=\"headerlink\" title=\"一、搭建OPENGL 的C++环境\"></a>一、搭建OPENGL 的C++环境</h4><ul>\n<li>1.1 准备工作<ol>\n<li>VS下的C++环境</li>\n<li>窗口显示库： GLFW <blockquote>\n<p>GLFW 安装编译的方法，32位使用编译会有问题，这里如果用64的话是： <a href=\"https://www.cnblogs.com/collectionne/p/6937644.html\">具体细节</a></p>\n<ol>\n<li>进入GLFW官方网站glfw.org，下载源码</li>\n<li>安装CMAKE，使用CMAKE编译源码生成工程</li>\n<li>生成完工程，打开工程，编译生成lib文件</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<p>3.扩展库： GLEW，<a href=\"http://glew.sourceforge.net/\">官网下载</a> 取出lib和dll文件即可<br>4.数学库：GLM， 官网下载完即可。<br>5.纹理库：SOIL2</p>\n<blockquote>\n<p>SOIL2 安装方法：<a href=\"https://blog.csdn.net/Wonz5130/article/details/82828817\">具体细节</a></p>\n<ol>\n<li>下载SOIL2源码</li>\n<li>下载premake4</li>\n<li>将premake4放到SOIL2的文件夹</li>\n<li>终端cd到SOIL2的文件夹，执行命令： premake4 vs2012， 将生成工程文件</li>\n<li>打开上面生成的VS工程，编译即可得到库</li>\n</ol>\n</blockquote>\n<ul>\n<li>1.2 制作项目模板</li>\n</ul>\n<p>1.准备lib文件夹，放glew,glfw, soil2的lib文件<br>2.准备include文件夹，放GLEW的GL文件夹，GLFW的GLFW文件夹，glm文件夹， SOIL2的SOIL2文件夹。<br>3.新建VS空C++项目，配置为win32<br>4.配置项目的VC++的常规里的包含目录，添加Include文件夹<br>5.链接器配置，常规添加lib文件夹，输入配置前面三个lib文件名加上opengl32.lib</p>\n<ul>\n<li>1.3 正式的项目开发</li>\n</ul>\n<ol>\n<li>使用1.2创建的模板新建工程</li>\n<li>拷贝glew32.dll到项目的debug或release目录中。</li>\n</ol>\n<h4 id=\"二、3D图形数据\"><a href=\"#二、3D图形数据\" class=\"headerlink\" title=\"二、3D图形数据\"></a>二、3D图形数据</h4><p>2.1 绘制流程描述：</p>\n<ul>\n<li>init() 初始化时</li>\n<li><ol>\n<li>创建一个缓冲区</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>将顶点数据复制到缓冲区</li>\n</ol>\n</li>\n<li>display()每帧刷新时。</li>\n<li><ol>\n<li>启用缓冲区</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>将缓冲区数据绑定至顶点属性</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>启用顶点</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>使用glDrawArray画出来。</li>\n</ol>\n</li>\n</ul>\n<p>2.2 VAO（Vertex Array Object）, VBO(Vertex Buffer Object)<br>顶点数据会先放在一个缓冲区，而这个缓冲区就存储在VBO里。同场景可能有多个VBO。<br>顶点数组对象则是opengl3.0引入的类似于VAO的组织性结构。</p>\n<blockquote>\n<p>例： 当绘制两个对象时，可以声明两个VBO，一个VAO，glGenVertexArray生成VAO，glBindVertexArray激活VAO与顶点属性关联，再使用glGenBuffers生成缓冲区。</p>\n</blockquote>\n<p>2.3 使用统一变量<br>在shader中将变量标记为Uniform后，在opengl中使用glGetuniformlocation得到对应的GL 的id。这样再通过glm::value_ptr取出对应的数值指针设值！。</p>\n<blockquote>\n<p>统一变量在每次从顶点缓存区拿值时都是不变的，可以理解为常量</p>\n</blockquote>\n<p>2.4 绘制立方体</p>\n<ul>\n<li>1.VAO,VBO初始化</li>\n<li>2.从相机的位置获取视角矩阵，V_MATRIX。 使用glm:translate</li>\n<li>3.从物体位置获取模型矩阵，M_MATRIX。 使用glm:translate</li>\n<li>4.从窗口，获取到P_MATRIX透视矩阵.。 使用glm:perspective</li>\n<li>5.将MV,P矩阵传到顶点shader里</li>\n</ul>\n<blockquote>\n<p>矩阵变换从右往左变换，将transMatrix * rotMatrix。先旋转再变位置。</p>\n</blockquote>\n<blockquote>\n<p>注意shader中的设值：</p>\n<pre><code class=\"c++\">    //VBO关联，顶点着色器的location为0的值被找出来。并从第一个VBO库中将值给过去\n    glBindBuffer(GL_ARRAY_BUFFER, vbo[0]);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\n    glEnableVertexAttribArray(0);</code></pre>\n</blockquote>\n<blockquote>\n<p>注意Opengl的glm与GLSL中矩阵的定义规则：<br>GLSL中的矩阵与GLM都是以列读取的！</p>\n</blockquote>\n<pre><code class=\"c++\">//glm的定义矩阵，以下两个矩阵变量是相同的，且以1,2,3,4为列往后排\nglm::mat4 test = {\n    {1,2,3,4},\n    {5,6,7,8},\n    {9,10,11,12},\n    {13,14,15,16},\n};\nglm::mat4 test2 = {\n    1,2,3,4,\n    5,6,7,8,\n    9,10,11,12,\n    13,14,15,16,\n};</code></pre>\n<p>2.5 使用矩阵栈来处理分层模型</p>\n<ul>\n<li>例 ：行星系统的实现流程</li>\n<li><ol>\n<li>初始栈，实例一个vMatrix视觉矩阵</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>实现太阳：复制一个到栈顶，生成太阳的MV矩阵，复制一个到栈顶，生成太阳的旋转。画太阳，然后POP出太阳的旋转。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>当前栈顶的是太阳的MV矩阵。以此复制到栈顶，生成行星的MV矩阵，复制到栈顶，生成行星的旋转。画行星，然后POP出行得的旋转。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>当前栈顶是行星的MV矩阵，以此复制到栈顶，生成月亮的MV矩阵，生成旋转，生成缩放。</li>\n</ol>\n</li>\n<li>5.前面四个步骤，此时栈，共有四个元素。从顶到底分别是，月亮，行星，太阳，视觉矩阵。依次弹出清空栈。</li>\n</ul>\n<p>2.6 优化策略</p>\n<ul>\n<li>display帧刷新函数中不要定义或申请变量内存</li>\n<li>背面剔除：</li>\n<li>1.使用glEnable(GL_CULL_FACE) 激活此功能</li>\n<li>2.使用glFrontFace(GL_CCW)设置逆时针为正向</li>\n<li>3.使用glCullFace(GL_BACK)将背面剔除（默认）。 GL_FRONT 和GL_FRONT_AND_BACK</li>\n</ul>\n<h4 id=\"纹理贴图-使用SOIL2\"><a href=\"#纹理贴图-使用SOIL2\" class=\"headerlink\" title=\"纹理贴图-使用SOIL2\"></a>纹理贴图-使用SOIL2</h4><p>3.1 使用纹理贴图</p>\n<ul>\n<li>1.使用SOIL_LOAD_TEXTURE获取到texture ID</li>\n<li>2.构建纹理坐标，以左下角为0,0为定，右上角为1,1。把纹理2D坐标点与3D模型坐标相映射。</li>\n<li>3.在display中使用glActiveTexture激活，用glBindTexture(GL_TEXTURE_2D, “注：1中的texture ID”)</li>\n<li>4.vertex shader 收到纹理坐标传至 fragment shader</li>\n<li>5.fragmenet shader中使用sampler2d采样器，利用4中得到的坐标点取颜色值返回。</li>\n</ul>\n<p>3.2 多级渐远纹理贴图 Mipmapping - 避免校正采样误差伪影</p>\n<ul>\n<li>纹理中存储相同图像的连续一系列较低分辨率副本 。大小将比原图像大1/3</li>\n<li>如何在OpenGL使用：</li>\n<li>1.激活纹理。glBindTexture(GL_TEXTURE_2D, textureRef);</li>\n<li>2.使用glTexParameteri的GL_TEXTURE_MIN_FILTER 指明，四个方法：</li>\n<li>GL_NEAREST_MIPMAP_NEAREST//取最近的纹素</li>\n<li>GL_LINEAR_MIPMAP_NEAREST//线性</li>\n<li>GL_NEAREST_MIPMAP_LINEAR//双线性</li>\n<li>GL_LINEAR_MIPMAP_LINEAR //三线性</li>\n</ul>\n<p>3.3 各向异性过滤-AF<br>恢复MIPMAPPING丢失的细节，标准MipMapping使用正方形分辨率MIP纹理，而AF可以使用各种矩形分辨率来采样。</p>\n<pre><code class=\"c++\">if (glewIsSupported(&quot;GL_EXT_texture_filter_anisotropic&quot;)) {\n    cout&lt;&lt;&quot;支持各向异性！&quot;&lt;&lt;endl;\n}\n</code></pre>\n<p>3.4 环绕和平辅</p>\n<ul>\n<li>当纹理坐标不是[0, 1]\\的范围时，需要设置填充参数：</li>\n<li>GL_REPEAT, GL_MIRRORED_REPEAT（当奇数时坐标反转）, GL_CLAMP_TO_EDGE（0，1以外强设成边界值）, GL_CLAMP_TO_BORDER(0，1以外的设成颜色)</li>\n</ul>\n<p>3.5 透视变形<br>考虑情形如：矩形棋盘结构的纹理填充，在X轴旋转时将导致三角面交接处发生变形。<br>默认opengl将会开启透视修复。</p>\n<blockquote>\n<p>使用noperspective 禁止opengl透视修复</p>\n<pre><code class=\"c++\">noperspective out texcoord;//顶点\nnoperspective in texcoord;//片面</code></pre>\n</blockquote>\n"},{"title":"Coursera算法课笔记1","_content":"\n## UnionFind\n\n### 描述\nDynamic Connectivity 动态连通性问题\n 1.给定任意N数据集\n 2.判断p到q是否连通\n\n> 假定的前提： p连q，则q也连p。 \n\n### 算法1： Quick Find -快速查找\n\n* 数据结构\n数组，将每个元素存储一个id[]下\n\n* 算法思路\n将相连通的所有元素存储为一个相同的ID\n![存储结果](/img/1598259821964.png)\n\n* 分析\n ![分析](/img/1598260733232.png)\n \n ### 算法2： Quick Union -快速交集\n \n * 数据结构\n   与Quick Find一样，采取 数组\n   \n * 算法思路\n   1.每位数仅记录其根结点\n   2.Union函数调用时，设第一个数为p，第二数为q。 将p的root赋值为q的root，即q的root为p的root的新root\n\n  * 分析：\n   ![分析](/img/1598273584691.png)\n   \n   ### 算法优化一： 使用权重\n   \n   * 永远只将小树往大树挂。这样不会产生过深的树层次！\n   \n   ![示例结果](/img/1598273763851.png)\n  \n  * 实现：额外定义一个数组，存储树的权重，在添加时判定，只将权重小的往权重大的加\n\n### 算法优化二： 压缩\n\n * Union函数调用时，对于多于一层的树，全部将真正的root改为当前的上级\n\n![示例结果](/img/1598273932723.png)\n\n\n\n### C++实例、例子：\n\n```c++\n\n////////////////// Quick Find /////////////\nQuickFind_UF::QuickFind_UF(int N) {\n\t\n\tthis->length = N;\n\tthis->id = new int[N];\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tthis->id[i] = i;\n\t}\n}\n\nQuickFind_UF::~QuickFind_UF() {\n\tthis->length = 0;\n\tdelete[] this->id;\n}\n\nvoid QuickFind_UF::Union(int p, int q) {\n\tint pid = this->id[p];\n\tint qid = this->id[q];//以此为准\n\n\tfor (int i = 0; i < this->length; i++)\n\t{\n\t\tif (this->id[i] == pid)\n\t\t\tthis->id[i] = qid;\n\t}\n\tPrint();\n}\n\nbool QuickFind_UF::Connected(int p, int q) {\n\treturn this->id[p] == this->id[q];\n}\n\n////////////////// Quick Union & Weight & Compression /////////////\n\nQuickUnion_UF::QuickUnion_UF(int N) {\n\n\tthis->length = N;\n\tthis->id = new int[N];\n\tthis->sz = new int[N];\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tthis->sz[i] = 1;\n\t\tthis->id[i] = i;\n\t}\t\n}\n\nQuickUnion_UF::~QuickUnion_UF() {\n\tdelete[] this->id;\n}\n\nvoid QuickUnion_UF::SetUseWeight(bool use) {\n\tthis->useWeight = use;\n}\n\nvoid QuickUnion_UF::SetUseCompression(bool use) {\n\tthis->useCompression = use;\n}\n\nint QuickUnion_UF::Root(int i) {\n\n\twhile (this->id[i] != i) {\n\t\tif (this->useCompression) {\n\t\t\tthis->id[i] = this->id[this->id[i]];\n\t\t}\n\t\ti = this->id[i];\n\t}\n\treturn i;\n}\n\nvoid QuickUnion_UF::Union(int p, int q) {\n\tint pid = this->Root(p);\n\tint qid = this->Root(q);\n\tif (this->useWeight) {\n\t\tif (pid == qid)\n\t\t\treturn;\n\t\tif (this->sz[pid] < this->sz[qid]) {\n\t\t\tthis->id[pid] = qid;\n\t\t\tthis->sz[qid] += this->sz[pid];\n\t\t}\n\t\telse {\n\t\t\tthis->id[qid] = pid;\n\t\t\tthis->sz[pid] += this->sz[qid];\n\t\t}\n\t}\n\telse {\n\t\tthis->id[pid] = this->id[qid];\n\t}\n\t\n}\n\nbool QuickUnion_UF::Connected(int p, int q) {\n\treturn this->Root(p) == this->Root(q);\n}\n\n```\n> 测试：数组为0-9，输入union:  (4,3),(3,8),(6,5),(9,4),(2,1),(8,9),(5,0),(7,2), (6,1)\n\n> Quick Find 结果：\n![QuickFind](/img/1598274190104.png)\n\n> 多一个测试union: ,(7,3). Quick Union 结果：\n![QuickUnion](/img/1598274216079.png)\n\n> 多一个测试union: ,(7,3). Quick Union+ Weight结果：\n![QuickUnion+Weight](/img/1598274276096.png)\n\n\n## C++ 玫举与玫举类：\n\n* 普通玫举是以（int）值进行比较，而玫举类可以根据不同名字来避免相同：\n  \n ```c++\n  enum Color { red, green, blue };                    // plain enum \nenum Card { red_card, green_card, yellow_card };    // another plain enum \nenum class Animal { dog, deer, cat, bird, human };  // enum class\nenum class Mammal { kangaroo, deer, human };        // another enum class\n\nvoid fun() {\n\n    // examples of bad use of plain enums:\n    Color color = Color::red;\n    Card card = Card::green_card;\n\n    int num = color;    // no problem\n\n    if (color == Card::red_card) // no problem (bad)\n        cout << \"bad\" << endl;\n\n    if (card == Color::green)   // no problem (bad)\n        cout << \"bad\" << endl;\n\n    // examples of good use of enum classes (safe)\n    Animal a = Animal::deer;\n    Mammal m = Mammal::deer;\n\n    int num2 = a;   // error\n    if (m == a)         // error (good)\n        cout << \"bad\" << endl;\n\n    if (a == Mammal::deer) // error (good)\n        cout << \"bad\" << endl;\n\n}\n ```\n \n ## 希尔排序\n  \n  * 选用Knuth的一增量序列 3X+1\n \n   * 先排大段，再排小段，一直到1段：\n\n![分级排序](/img/1598514940240.png)\n\n![优势](/img/1598516074235.png)\n\n```c++\n/// <summary>\n/// 希尔排序 \n/// </summary>\n/// <param name=\"a\"></param>\n/// <param name=\"len\"></param>\nvoid ShellSort(int *a, int len){\n\n\tint isSorted = true;\n\t//优化一：提前做一个相邻位置排序\n\tfor (int i = len-1; i > 0; i--)\n\t{\n\t\tif (a[i] < a[i - 1]) {\n\t\t\tSortHelper::Exch(a, i, i - 1);\n\t\t\tisSorted = false;\n\t\t}\n\t}\n\tif (isSorted) return;\n\n\tint h = 1;\n\t//得到一个最高的分级值\n\twhile (h <= len / 3)\n\t\th = 3 * h + 1;\n\n\twhile (h >= 1) {\n\t\t//插入排序\n\t\tfor (int i = h; i < len; i++)\n\t\t{\n\t\t\tfor (int j = i; (j >= h) && (a[j] < a[j - h]); j -= h)\n\t\t\t{\n\t\t\t\tSortHelper::Exch(a, j, j - h);\n\t\t\t}\n\t\t}\n\t\th = h / 3;\n\t}\n}\n```\n\n## 堆排序\n\n![java示例](/img/1598929159605.png)\n","source":"_posts/算法课程笔记1.md","raw":"---\ntitle: Coursera算法课笔记1\ncategories:\n- 算法\n---\n\n## UnionFind\n\n### 描述\nDynamic Connectivity 动态连通性问题\n 1.给定任意N数据集\n 2.判断p到q是否连通\n\n> 假定的前提： p连q，则q也连p。 \n\n### 算法1： Quick Find -快速查找\n\n* 数据结构\n数组，将每个元素存储一个id[]下\n\n* 算法思路\n将相连通的所有元素存储为一个相同的ID\n![存储结果](/img/1598259821964.png)\n\n* 分析\n ![分析](/img/1598260733232.png)\n \n ### 算法2： Quick Union -快速交集\n \n * 数据结构\n   与Quick Find一样，采取 数组\n   \n * 算法思路\n   1.每位数仅记录其根结点\n   2.Union函数调用时，设第一个数为p，第二数为q。 将p的root赋值为q的root，即q的root为p的root的新root\n\n  * 分析：\n   ![分析](/img/1598273584691.png)\n   \n   ### 算法优化一： 使用权重\n   \n   * 永远只将小树往大树挂。这样不会产生过深的树层次！\n   \n   ![示例结果](/img/1598273763851.png)\n  \n  * 实现：额外定义一个数组，存储树的权重，在添加时判定，只将权重小的往权重大的加\n\n### 算法优化二： 压缩\n\n * Union函数调用时，对于多于一层的树，全部将真正的root改为当前的上级\n\n![示例结果](/img/1598273932723.png)\n\n\n\n### C++实例、例子：\n\n```c++\n\n////////////////// Quick Find /////////////\nQuickFind_UF::QuickFind_UF(int N) {\n\t\n\tthis->length = N;\n\tthis->id = new int[N];\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tthis->id[i] = i;\n\t}\n}\n\nQuickFind_UF::~QuickFind_UF() {\n\tthis->length = 0;\n\tdelete[] this->id;\n}\n\nvoid QuickFind_UF::Union(int p, int q) {\n\tint pid = this->id[p];\n\tint qid = this->id[q];//以此为准\n\n\tfor (int i = 0; i < this->length; i++)\n\t{\n\t\tif (this->id[i] == pid)\n\t\t\tthis->id[i] = qid;\n\t}\n\tPrint();\n}\n\nbool QuickFind_UF::Connected(int p, int q) {\n\treturn this->id[p] == this->id[q];\n}\n\n////////////////// Quick Union & Weight & Compression /////////////\n\nQuickUnion_UF::QuickUnion_UF(int N) {\n\n\tthis->length = N;\n\tthis->id = new int[N];\n\tthis->sz = new int[N];\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tthis->sz[i] = 1;\n\t\tthis->id[i] = i;\n\t}\t\n}\n\nQuickUnion_UF::~QuickUnion_UF() {\n\tdelete[] this->id;\n}\n\nvoid QuickUnion_UF::SetUseWeight(bool use) {\n\tthis->useWeight = use;\n}\n\nvoid QuickUnion_UF::SetUseCompression(bool use) {\n\tthis->useCompression = use;\n}\n\nint QuickUnion_UF::Root(int i) {\n\n\twhile (this->id[i] != i) {\n\t\tif (this->useCompression) {\n\t\t\tthis->id[i] = this->id[this->id[i]];\n\t\t}\n\t\ti = this->id[i];\n\t}\n\treturn i;\n}\n\nvoid QuickUnion_UF::Union(int p, int q) {\n\tint pid = this->Root(p);\n\tint qid = this->Root(q);\n\tif (this->useWeight) {\n\t\tif (pid == qid)\n\t\t\treturn;\n\t\tif (this->sz[pid] < this->sz[qid]) {\n\t\t\tthis->id[pid] = qid;\n\t\t\tthis->sz[qid] += this->sz[pid];\n\t\t}\n\t\telse {\n\t\t\tthis->id[qid] = pid;\n\t\t\tthis->sz[pid] += this->sz[qid];\n\t\t}\n\t}\n\telse {\n\t\tthis->id[pid] = this->id[qid];\n\t}\n\t\n}\n\nbool QuickUnion_UF::Connected(int p, int q) {\n\treturn this->Root(p) == this->Root(q);\n}\n\n```\n> 测试：数组为0-9，输入union:  (4,3),(3,8),(6,5),(9,4),(2,1),(8,9),(5,0),(7,2), (6,1)\n\n> Quick Find 结果：\n![QuickFind](/img/1598274190104.png)\n\n> 多一个测试union: ,(7,3). Quick Union 结果：\n![QuickUnion](/img/1598274216079.png)\n\n> 多一个测试union: ,(7,3). Quick Union+ Weight结果：\n![QuickUnion+Weight](/img/1598274276096.png)\n\n\n## C++ 玫举与玫举类：\n\n* 普通玫举是以（int）值进行比较，而玫举类可以根据不同名字来避免相同：\n  \n ```c++\n  enum Color { red, green, blue };                    // plain enum \nenum Card { red_card, green_card, yellow_card };    // another plain enum \nenum class Animal { dog, deer, cat, bird, human };  // enum class\nenum class Mammal { kangaroo, deer, human };        // another enum class\n\nvoid fun() {\n\n    // examples of bad use of plain enums:\n    Color color = Color::red;\n    Card card = Card::green_card;\n\n    int num = color;    // no problem\n\n    if (color == Card::red_card) // no problem (bad)\n        cout << \"bad\" << endl;\n\n    if (card == Color::green)   // no problem (bad)\n        cout << \"bad\" << endl;\n\n    // examples of good use of enum classes (safe)\n    Animal a = Animal::deer;\n    Mammal m = Mammal::deer;\n\n    int num2 = a;   // error\n    if (m == a)         // error (good)\n        cout << \"bad\" << endl;\n\n    if (a == Mammal::deer) // error (good)\n        cout << \"bad\" << endl;\n\n}\n ```\n \n ## 希尔排序\n  \n  * 选用Knuth的一增量序列 3X+1\n \n   * 先排大段，再排小段，一直到1段：\n\n![分级排序](/img/1598514940240.png)\n\n![优势](/img/1598516074235.png)\n\n```c++\n/// <summary>\n/// 希尔排序 \n/// </summary>\n/// <param name=\"a\"></param>\n/// <param name=\"len\"></param>\nvoid ShellSort(int *a, int len){\n\n\tint isSorted = true;\n\t//优化一：提前做一个相邻位置排序\n\tfor (int i = len-1; i > 0; i--)\n\t{\n\t\tif (a[i] < a[i - 1]) {\n\t\t\tSortHelper::Exch(a, i, i - 1);\n\t\t\tisSorted = false;\n\t\t}\n\t}\n\tif (isSorted) return;\n\n\tint h = 1;\n\t//得到一个最高的分级值\n\twhile (h <= len / 3)\n\t\th = 3 * h + 1;\n\n\twhile (h >= 1) {\n\t\t//插入排序\n\t\tfor (int i = h; i < len; i++)\n\t\t{\n\t\t\tfor (int j = i; (j >= h) && (a[j] < a[j - h]); j -= h)\n\t\t\t{\n\t\t\t\tSortHelper::Exch(a, j, j - h);\n\t\t\t}\n\t\t}\n\t\th = h / 3;\n\t}\n}\n```\n\n## 堆排序\n\n![java示例](/img/1598929159605.png)\n","slug":"算法课程笔记1","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh13r005x4wf0fryo7tzx","content":"<h2 id=\"UnionFind\"><a href=\"#UnionFind\" class=\"headerlink\" title=\"UnionFind\"></a>UnionFind</h2><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>Dynamic Connectivity 动态连通性问题<br> 1.给定任意N数据集<br> 2.判断p到q是否连通</p>\n<blockquote>\n<p>假定的前提： p连q，则q也连p。 </p>\n</blockquote>\n<h3 id=\"算法1：-Quick-Find-快速查找\"><a href=\"#算法1：-Quick-Find-快速查找\" class=\"headerlink\" title=\"算法1： Quick Find -快速查找\"></a>算法1： Quick Find -快速查找</h3><ul>\n<li><p>数据结构<br>数组，将每个元素存储一个id[]下</p>\n</li>\n<li><p>算法思路<br>将相连通的所有元素存储为一个相同的ID<br><img src=\"/img/1598259821964.png\" alt=\"存储结果\"></p>\n</li>\n<li><p>分析<br><img src=\"/img/1598260733232.png\" alt=\"分析\"></p>\n<h3 id=\"算法2：-Quick-Union-快速交集\"><a href=\"#算法2：-Quick-Union-快速交集\" class=\"headerlink\" title=\"算法2： Quick Union -快速交集\"></a>算法2： Quick Union -快速交集</h3><ul>\n<li><p>数据结构<br>与Quick Find一样，采取 数组</p>\n</li>\n<li><p>算法思路<br>1.每位数仅记录其根结点<br>2.Union函数调用时，设第一个数为p，第二数为q。 将p的root赋值为q的root，即q的root为p的root的新root</p>\n</li>\n<li><p>分析：<br><img src=\"/img/1598273584691.png\" alt=\"分析\"></p>\n<h3 id=\"算法优化一：-使用权重\"><a href=\"#算法优化一：-使用权重\" class=\"headerlink\" title=\"算法优化一： 使用权重\"></a>算法优化一： 使用权重</h3><ul>\n<li>永远只将小树往大树挂。这样不会产生过深的树层次！</li>\n</ul>\n<p><img src=\"/img/1598273763851.png\" alt=\"示例结果\"></p>\n</li>\n<li><p>实现：额外定义一个数组，存储树的权重，在添加时判定，只将权重小的往权重大的加</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法优化二：-压缩\"><a href=\"#算法优化二：-压缩\" class=\"headerlink\" title=\"算法优化二： 压缩\"></a>算法优化二： 压缩</h3><ul>\n<li>Union函数调用时，对于多于一层的树，全部将真正的root改为当前的上级</li>\n</ul>\n<p><img src=\"/img/1598273932723.png\" alt=\"示例结果\"></p>\n<h3 id=\"C-实例、例子：\"><a href=\"#C-实例、例子：\" class=\"headerlink\" title=\"C++实例、例子：\"></a>C++实例、例子：</h3><pre><code class=\"c++\">\n////////////////// Quick Find /////////////\nQuickFind_UF::QuickFind_UF(int N) {\n\n    this-&gt;length = N;\n    this-&gt;id = new int[N];\n    for (int i = 0; i &lt; N; i++)\n    {\n        this-&gt;id[i] = i;\n    }\n}\n\nQuickFind_UF::~QuickFind_UF() {\n    this-&gt;length = 0;\n    delete[] this-&gt;id;\n}\n\nvoid QuickFind_UF::Union(int p, int q) {\n    int pid = this-&gt;id[p];\n    int qid = this-&gt;id[q];//以此为准\n\n    for (int i = 0; i &lt; this-&gt;length; i++)\n    {\n        if (this-&gt;id[i] == pid)\n            this-&gt;id[i] = qid;\n    }\n    Print();\n}\n\nbool QuickFind_UF::Connected(int p, int q) {\n    return this-&gt;id[p] == this-&gt;id[q];\n}\n\n////////////////// Quick Union &amp; Weight &amp; Compression /////////////\n\nQuickUnion_UF::QuickUnion_UF(int N) {\n\n    this-&gt;length = N;\n    this-&gt;id = new int[N];\n    this-&gt;sz = new int[N];\n    for (int i = 0; i &lt; N; i++)\n    {\n        this-&gt;sz[i] = 1;\n        this-&gt;id[i] = i;\n    }    \n}\n\nQuickUnion_UF::~QuickUnion_UF() {\n    delete[] this-&gt;id;\n}\n\nvoid QuickUnion_UF::SetUseWeight(bool use) {\n    this-&gt;useWeight = use;\n}\n\nvoid QuickUnion_UF::SetUseCompression(bool use) {\n    this-&gt;useCompression = use;\n}\n\nint QuickUnion_UF::Root(int i) {\n\n    while (this-&gt;id[i] != i) {\n        if (this-&gt;useCompression) {\n            this-&gt;id[i] = this-&gt;id[this-&gt;id[i]];\n        }\n        i = this-&gt;id[i];\n    }\n    return i;\n}\n\nvoid QuickUnion_UF::Union(int p, int q) {\n    int pid = this-&gt;Root(p);\n    int qid = this-&gt;Root(q);\n    if (this-&gt;useWeight) {\n        if (pid == qid)\n            return;\n        if (this-&gt;sz[pid] &lt; this-&gt;sz[qid]) {\n            this-&gt;id[pid] = qid;\n            this-&gt;sz[qid] += this-&gt;sz[pid];\n        }\n        else {\n            this-&gt;id[qid] = pid;\n            this-&gt;sz[pid] += this-&gt;sz[qid];\n        }\n    }\n    else {\n        this-&gt;id[pid] = this-&gt;id[qid];\n    }\n\n}\n\nbool QuickUnion_UF::Connected(int p, int q) {\n    return this-&gt;Root(p) == this-&gt;Root(q);\n}\n</code></pre>\n<blockquote>\n<p>测试：数组为0-9，输入union:  (4,3),(3,8),(6,5),(9,4),(2,1),(8,9),(5,0),(7,2), (6,1)</p>\n</blockquote>\n<blockquote>\n<p>Quick Find 结果：<br><img src=\"/img/1598274190104.png\" alt=\"QuickFind\"></p>\n</blockquote>\n<blockquote>\n<p>多一个测试union: ,(7,3). Quick Union 结果：<br><img src=\"/img/1598274216079.png\" alt=\"QuickUnion\"></p>\n</blockquote>\n<blockquote>\n<p>多一个测试union: ,(7,3). Quick Union+ Weight结果：<br><img src=\"/img/1598274276096.png\" alt=\"QuickUnion+Weight\"></p>\n</blockquote>\n<h2 id=\"C-玫举与玫举类：\"><a href=\"#C-玫举与玫举类：\" class=\"headerlink\" title=\"C++ 玫举与玫举类：\"></a>C++ 玫举与玫举类：</h2><ul>\n<li><p>普通玫举是以（int）值进行比较，而玫举类可以根据不同名字来避免相同：</p>\n<pre><code class=\"c++\">enum Color { red, green, blue };                    // plain enum \nenum Card { red_card, green_card, yellow_card };    // another plain enum \nenum class Animal { dog, deer, cat, bird, human };  // enum class\nenum class Mammal { kangaroo, deer, human };        // another enum class\n</code></pre>\n</li>\n</ul>\n<p>void fun() {</p>\n<pre><code>// examples of bad use of plain enums:\nColor color = Color::red;\nCard card = Card::green_card;\n\nint num = color;    // no problem\n\nif (color == Card::red_card) // no problem (bad)\n    cout &lt;&lt; &quot;bad&quot; &lt;&lt; endl;\n\nif (card == Color::green)   // no problem (bad)\n    cout &lt;&lt; &quot;bad&quot; &lt;&lt; endl;\n\n// examples of good use of enum classes (safe)\nAnimal a = Animal::deer;\nMammal m = Mammal::deer;\n\nint num2 = a;   // error\nif (m == a)         // error (good)\n    cout &lt;&lt; &quot;bad&quot; &lt;&lt; endl;\n\nif (a == Mammal::deer) // error (good)\n    cout &lt;&lt; &quot;bad&quot; &lt;&lt; endl;</code></pre><p>}</p>\n<pre><code>\n ## 希尔排序\n\n  * 选用Knuth的一增量序列 3X+1\n\n   * 先排大段，再排小段，一直到1段：\n\n![分级排序](/img/1598514940240.png)\n\n![优势](/img/1598516074235.png)\n\n```c++\n/// &lt;summary&gt;\n/// 希尔排序 \n/// &lt;/summary&gt;\n/// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt;\n/// &lt;param name=&quot;len&quot;&gt;&lt;/param&gt;\nvoid ShellSort(int *a, int len){\n\n    int isSorted = true;\n    //优化一：提前做一个相邻位置排序\n    for (int i = len-1; i &gt; 0; i--)\n    {\n        if (a[i] &lt; a[i - 1]) {\n            SortHelper::Exch(a, i, i - 1);\n            isSorted = false;\n        }\n    }\n    if (isSorted) return;\n\n    int h = 1;\n    //得到一个最高的分级值\n    while (h &lt;= len / 3)\n        h = 3 * h + 1;\n\n    while (h &gt;= 1) {\n        //插入排序\n        for (int i = h; i &lt; len; i++)\n        {\n            for (int j = i; (j &gt;= h) &amp;&amp; (a[j] &lt; a[j - h]); j -= h)\n            {\n                SortHelper::Exch(a, j, j - h);\n            }\n        }\n        h = h / 3;\n    }\n}</code></pre><h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p><img src=\"/img/1598929159605.png\" alt=\"java示例\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"UnionFind\"><a href=\"#UnionFind\" class=\"headerlink\" title=\"UnionFind\"></a>UnionFind</h2><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>Dynamic Connectivity 动态连通性问题<br> 1.给定任意N数据集<br> 2.判断p到q是否连通</p>\n<blockquote>\n<p>假定的前提： p连q，则q也连p。 </p>\n</blockquote>\n<h3 id=\"算法1：-Quick-Find-快速查找\"><a href=\"#算法1：-Quick-Find-快速查找\" class=\"headerlink\" title=\"算法1： Quick Find -快速查找\"></a>算法1： Quick Find -快速查找</h3><ul>\n<li><p>数据结构<br>数组，将每个元素存储一个id[]下</p>\n</li>\n<li><p>算法思路<br>将相连通的所有元素存储为一个相同的ID<br><img src=\"/img/1598259821964.png\" alt=\"存储结果\"></p>\n</li>\n<li><p>分析<br><img src=\"/img/1598260733232.png\" alt=\"分析\"></p>\n<h3 id=\"算法2：-Quick-Union-快速交集\"><a href=\"#算法2：-Quick-Union-快速交集\" class=\"headerlink\" title=\"算法2： Quick Union -快速交集\"></a>算法2： Quick Union -快速交集</h3><ul>\n<li><p>数据结构<br>与Quick Find一样，采取 数组</p>\n</li>\n<li><p>算法思路<br>1.每位数仅记录其根结点<br>2.Union函数调用时，设第一个数为p，第二数为q。 将p的root赋值为q的root，即q的root为p的root的新root</p>\n</li>\n<li><p>分析：<br><img src=\"/img/1598273584691.png\" alt=\"分析\"></p>\n<h3 id=\"算法优化一：-使用权重\"><a href=\"#算法优化一：-使用权重\" class=\"headerlink\" title=\"算法优化一： 使用权重\"></a>算法优化一： 使用权重</h3><ul>\n<li>永远只将小树往大树挂。这样不会产生过深的树层次！</li>\n</ul>\n<p><img src=\"/img/1598273763851.png\" alt=\"示例结果\"></p>\n</li>\n<li><p>实现：额外定义一个数组，存储树的权重，在添加时判定，只将权重小的往权重大的加</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法优化二：-压缩\"><a href=\"#算法优化二：-压缩\" class=\"headerlink\" title=\"算法优化二： 压缩\"></a>算法优化二： 压缩</h3><ul>\n<li>Union函数调用时，对于多于一层的树，全部将真正的root改为当前的上级</li>\n</ul>\n<p><img src=\"/img/1598273932723.png\" alt=\"示例结果\"></p>\n<h3 id=\"C-实例、例子：\"><a href=\"#C-实例、例子：\" class=\"headerlink\" title=\"C++实例、例子：\"></a>C++实例、例子：</h3><pre><code class=\"c++\">\n////////////////// Quick Find /////////////\nQuickFind_UF::QuickFind_UF(int N) {\n\n    this-&gt;length = N;\n    this-&gt;id = new int[N];\n    for (int i = 0; i &lt; N; i++)\n    {\n        this-&gt;id[i] = i;\n    }\n}\n\nQuickFind_UF::~QuickFind_UF() {\n    this-&gt;length = 0;\n    delete[] this-&gt;id;\n}\n\nvoid QuickFind_UF::Union(int p, int q) {\n    int pid = this-&gt;id[p];\n    int qid = this-&gt;id[q];//以此为准\n\n    for (int i = 0; i &lt; this-&gt;length; i++)\n    {\n        if (this-&gt;id[i] == pid)\n            this-&gt;id[i] = qid;\n    }\n    Print();\n}\n\nbool QuickFind_UF::Connected(int p, int q) {\n    return this-&gt;id[p] == this-&gt;id[q];\n}\n\n////////////////// Quick Union &amp; Weight &amp; Compression /////////////\n\nQuickUnion_UF::QuickUnion_UF(int N) {\n\n    this-&gt;length = N;\n    this-&gt;id = new int[N];\n    this-&gt;sz = new int[N];\n    for (int i = 0; i &lt; N; i++)\n    {\n        this-&gt;sz[i] = 1;\n        this-&gt;id[i] = i;\n    }    \n}\n\nQuickUnion_UF::~QuickUnion_UF() {\n    delete[] this-&gt;id;\n}\n\nvoid QuickUnion_UF::SetUseWeight(bool use) {\n    this-&gt;useWeight = use;\n}\n\nvoid QuickUnion_UF::SetUseCompression(bool use) {\n    this-&gt;useCompression = use;\n}\n\nint QuickUnion_UF::Root(int i) {\n\n    while (this-&gt;id[i] != i) {\n        if (this-&gt;useCompression) {\n            this-&gt;id[i] = this-&gt;id[this-&gt;id[i]];\n        }\n        i = this-&gt;id[i];\n    }\n    return i;\n}\n\nvoid QuickUnion_UF::Union(int p, int q) {\n    int pid = this-&gt;Root(p);\n    int qid = this-&gt;Root(q);\n    if (this-&gt;useWeight) {\n        if (pid == qid)\n            return;\n        if (this-&gt;sz[pid] &lt; this-&gt;sz[qid]) {\n            this-&gt;id[pid] = qid;\n            this-&gt;sz[qid] += this-&gt;sz[pid];\n        }\n        else {\n            this-&gt;id[qid] = pid;\n            this-&gt;sz[pid] += this-&gt;sz[qid];\n        }\n    }\n    else {\n        this-&gt;id[pid] = this-&gt;id[qid];\n    }\n\n}\n\nbool QuickUnion_UF::Connected(int p, int q) {\n    return this-&gt;Root(p) == this-&gt;Root(q);\n}\n</code></pre>\n<blockquote>\n<p>测试：数组为0-9，输入union:  (4,3),(3,8),(6,5),(9,4),(2,1),(8,9),(5,0),(7,2), (6,1)</p>\n</blockquote>\n<blockquote>\n<p>Quick Find 结果：<br><img src=\"/img/1598274190104.png\" alt=\"QuickFind\"></p>\n</blockquote>\n<blockquote>\n<p>多一个测试union: ,(7,3). Quick Union 结果：<br><img src=\"/img/1598274216079.png\" alt=\"QuickUnion\"></p>\n</blockquote>\n<blockquote>\n<p>多一个测试union: ,(7,3). Quick Union+ Weight结果：<br><img src=\"/img/1598274276096.png\" alt=\"QuickUnion+Weight\"></p>\n</blockquote>\n<h2 id=\"C-玫举与玫举类：\"><a href=\"#C-玫举与玫举类：\" class=\"headerlink\" title=\"C++ 玫举与玫举类：\"></a>C++ 玫举与玫举类：</h2><ul>\n<li><p>普通玫举是以（int）值进行比较，而玫举类可以根据不同名字来避免相同：</p>\n<pre><code class=\"c++\">enum Color { red, green, blue };                    // plain enum \nenum Card { red_card, green_card, yellow_card };    // another plain enum \nenum class Animal { dog, deer, cat, bird, human };  // enum class\nenum class Mammal { kangaroo, deer, human };        // another enum class\n</code></pre>\n</li>\n</ul>\n<p>void fun() {</p>\n<pre><code>// examples of bad use of plain enums:\nColor color = Color::red;\nCard card = Card::green_card;\n\nint num = color;    // no problem\n\nif (color == Card::red_card) // no problem (bad)\n    cout &lt;&lt; &quot;bad&quot; &lt;&lt; endl;\n\nif (card == Color::green)   // no problem (bad)\n    cout &lt;&lt; &quot;bad&quot; &lt;&lt; endl;\n\n// examples of good use of enum classes (safe)\nAnimal a = Animal::deer;\nMammal m = Mammal::deer;\n\nint num2 = a;   // error\nif (m == a)         // error (good)\n    cout &lt;&lt; &quot;bad&quot; &lt;&lt; endl;\n\nif (a == Mammal::deer) // error (good)\n    cout &lt;&lt; &quot;bad&quot; &lt;&lt; endl;</code></pre><p>}</p>\n<pre><code>\n ## 希尔排序\n\n  * 选用Knuth的一增量序列 3X+1\n\n   * 先排大段，再排小段，一直到1段：\n\n![分级排序](/img/1598514940240.png)\n\n![优势](/img/1598516074235.png)\n\n```c++\n/// &lt;summary&gt;\n/// 希尔排序 \n/// &lt;/summary&gt;\n/// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt;\n/// &lt;param name=&quot;len&quot;&gt;&lt;/param&gt;\nvoid ShellSort(int *a, int len){\n\n    int isSorted = true;\n    //优化一：提前做一个相邻位置排序\n    for (int i = len-1; i &gt; 0; i--)\n    {\n        if (a[i] &lt; a[i - 1]) {\n            SortHelper::Exch(a, i, i - 1);\n            isSorted = false;\n        }\n    }\n    if (isSorted) return;\n\n    int h = 1;\n    //得到一个最高的分级值\n    while (h &lt;= len / 3)\n        h = 3 * h + 1;\n\n    while (h &gt;= 1) {\n        //插入排序\n        for (int i = h; i &lt; len; i++)\n        {\n            for (int j = i; (j &gt;= h) &amp;&amp; (a[j] &lt; a[j - h]); j -= h)\n            {\n                SortHelper::Exch(a, j, j - h);\n            }\n        }\n        h = h / 3;\n    }\n}</code></pre><h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p><img src=\"/img/1598929159605.png\" alt=\"java示例\"></p>\n"},{"title":"线性代数-笔记1","_content":"\n\n#### 第一章、线性代数中的线性方程组\n\n##### \n1.线性方程组等价⇔解集相同⇔增广矩阵行等价\n2.线性方程组的解：null/one/infinite\n3.线性方程组相容：有解（one/infinite）\n4.行初等变换：\n倍加：加上另一行的倍数\n对换：两行互换\n倍乘：一行各元素乘一个标量\n5.行初等变换是可逆的\n6.（行）阶梯形矩阵（缩写为REF）\n每一非零行在每一零行之上\n下方的行的先导元素在右方\n> 推论：先导元素（一行的最左非零元素）所在列的下面全是零\n\n7.简化（行）阶梯形（缩写为RREF）\n先导元素都是1\n先导元素是所在列唯一的非零元素\n简化阶梯形是唯一的\n\n8. 主元位置：阶梯形中先导元素的位置；主元列*：含主元位置的列\n主元列对应基本变量，非主元列对应自由变量\n9.线性方程组相容⇔增广矩阵最右列不是主元列（没有0=b情况出现，其中b为非零常数）\n10.**向量方程**： 以向量的方式代表一个单列矩阵，如：（3，-1）对应2x1列矩阵\n11.证明某个向量c在其他两个向量a,b组成的面上，只需要证明存在r1,r2为实数让c = r1a + r2b成立。\n12.向量方程与矩阵方程：\n向量方程以向量加未知数的形式组成部成方程。矩阵方程将方程组写成矩阵 乘 向量组成的方程。\n\n\n","source":"_posts/线性代数-笔记1.md","raw":"---\ntitle: 线性代数-笔记1\ncategories:\n- 数学\n---\n\n\n#### 第一章、线性代数中的线性方程组\n\n##### \n1.线性方程组等价⇔解集相同⇔增广矩阵行等价\n2.线性方程组的解：null/one/infinite\n3.线性方程组相容：有解（one/infinite）\n4.行初等变换：\n倍加：加上另一行的倍数\n对换：两行互换\n倍乘：一行各元素乘一个标量\n5.行初等变换是可逆的\n6.（行）阶梯形矩阵（缩写为REF）\n每一非零行在每一零行之上\n下方的行的先导元素在右方\n> 推论：先导元素（一行的最左非零元素）所在列的下面全是零\n\n7.简化（行）阶梯形（缩写为RREF）\n先导元素都是1\n先导元素是所在列唯一的非零元素\n简化阶梯形是唯一的\n\n8. 主元位置：阶梯形中先导元素的位置；主元列*：含主元位置的列\n主元列对应基本变量，非主元列对应自由变量\n9.线性方程组相容⇔增广矩阵最右列不是主元列（没有0=b情况出现，其中b为非零常数）\n10.**向量方程**： 以向量的方式代表一个单列矩阵，如：（3，-1）对应2x1列矩阵\n11.证明某个向量c在其他两个向量a,b组成的面上，只需要证明存在r1,r2为实数让c = r1a + r2b成立。\n12.向量方程与矩阵方程：\n向量方程以向量加未知数的形式组成部成方程。矩阵方程将方程组写成矩阵 乘 向量组成的方程。\n\n\n","slug":"线性代数-笔记1","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh13t00624wf08sayl1lk","content":"<h4 id=\"第一章、线性代数中的线性方程组\"><a href=\"#第一章、线性代数中的线性方程组\" class=\"headerlink\" title=\"第一章、线性代数中的线性方程组\"></a>第一章、线性代数中的线性方程组</h4><h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h5><p>1.线性方程组等价⇔解集相同⇔增广矩阵行等价<br>2.线性方程组的解：null/one/infinite<br>3.线性方程组相容：有解（one/infinite）<br>4.行初等变换：<br>倍加：加上另一行的倍数<br>对换：两行互换<br>倍乘：一行各元素乘一个标量<br>5.行初等变换是可逆的<br>6.（行）阶梯形矩阵（缩写为REF）<br>每一非零行在每一零行之上<br>下方的行的先导元素在右方</p>\n<blockquote>\n<p>推论：先导元素（一行的最左非零元素）所在列的下面全是零</p>\n</blockquote>\n<p>7.简化（行）阶梯形（缩写为RREF）<br>先导元素都是1<br>先导元素是所在列唯一的非零元素<br>简化阶梯形是唯一的</p>\n<ol start=\"8\">\n<li>主元位置：阶梯形中先导元素的位置；主元列*：含主元位置的列<br>主元列对应基本变量，非主元列对应自由变量</li>\n<li>线性方程组相容⇔增广矩阵最右列不是主元列（没有0=b情况出现，其中b为非零常数）</li>\n<li><strong>向量方程</strong>： 以向量的方式代表一个单列矩阵，如：（3，-1）对应2x1列矩阵</li>\n<li>证明某个向量c在其他两个向量a,b组成的面上，只需要证明存在r1,r2为实数让c = r1a + r2b成立。</li>\n<li>向量方程与矩阵方程：<br>向量方程以向量加未知数的形式组成部成方程。矩阵方程将方程组写成矩阵 乘 向量组成的方程。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"第一章、线性代数中的线性方程组\"><a href=\"#第一章、线性代数中的线性方程组\" class=\"headerlink\" title=\"第一章、线性代数中的线性方程组\"></a>第一章、线性代数中的线性方程组</h4><h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h5><p>1.线性方程组等价⇔解集相同⇔增广矩阵行等价<br>2.线性方程组的解：null/one/infinite<br>3.线性方程组相容：有解（one/infinite）<br>4.行初等变换：<br>倍加：加上另一行的倍数<br>对换：两行互换<br>倍乘：一行各元素乘一个标量<br>5.行初等变换是可逆的<br>6.（行）阶梯形矩阵（缩写为REF）<br>每一非零行在每一零行之上<br>下方的行的先导元素在右方</p>\n<blockquote>\n<p>推论：先导元素（一行的最左非零元素）所在列的下面全是零</p>\n</blockquote>\n<p>7.简化（行）阶梯形（缩写为RREF）<br>先导元素都是1<br>先导元素是所在列唯一的非零元素<br>简化阶梯形是唯一的</p>\n<ol start=\"8\">\n<li>主元位置：阶梯形中先导元素的位置；主元列*：含主元位置的列<br>主元列对应基本变量，非主元列对应自由变量</li>\n<li>线性方程组相容⇔增广矩阵最右列不是主元列（没有0=b情况出现，其中b为非零常数）</li>\n<li><strong>向量方程</strong>： 以向量的方式代表一个单列矩阵，如：（3，-1）对应2x1列矩阵</li>\n<li>证明某个向量c在其他两个向量a,b组成的面上，只需要证明存在r1,r2为实数让c = r1a + r2b成立。</li>\n<li>向量方程与矩阵方程：<br>向量方程以向量加未知数的形式组成部成方程。矩阵方程将方程组写成矩阵 乘 向量组成的方程。</li>\n</ol>\n"},{"title":"计算机图形学编程笔记2","_content":"\n==本篇主要针对shader #2196F3==\n\n## 参考文献\n[Unity] - Technical Artist in Shading and Effects\nhttps://certification.unity.com/products/expert-technical-artist-shading-effects\n[虚幻] - 虚幻引擎职业讲堂：技术美术师\nhttps://www.unrealengine.com/zh-CN/tech-blog/jobs-in-unreal-engine---technical-artist?sessionInvalidated=true\n[Catlike] - Catlike大神的Unity系列教程\nhttps://catlikecoding.com/unity/tutorials/\n[霜狼_may] - TA技术美术学习体系框架\nhttps://www.bilibili.com/video/av77755500\n[毛星云] - 浅墨的游戏编程\nhttps://zhuanlan.zhihu.com/game-programming\n[云影] - 技术美术的魔法工坊\nhttps://zhuanlan.zhihu.com/c_1082217056598007808\n[一只大熊猫]-中国特色技术美术\nhttps://zhuanlan.zhihu.com/c_1078237708161363968\n[知乎] - 技术美术会是一个长期存在的职业吗？\nhttps://www.zhihu.com/question/325535382/answer/1149431577\n[马甲] - 总结一些TA（技术美术）学习的网站\nhttps://zhuanlan.zhihu.com/p/84550677\n[书籍] - 《OpenGL 编程指南》红宝书\nhttps://book.douban.com/subject/26220248/\n[书籍] - 《OpenGL 超级宝典》蓝宝书\nhttps://book.douban.com/subject/10774590/\n[书籍] - 《DirectX 9.0 3D游戏开发编程基础》\nhttps://book.douban.com/subject/2111771/\n[书籍] - 計算機圖形: 入門/API類\nhttps://www.douban.com/doulist/1445744/\n\n## 一、内置shader库\n\n### Unity支持的語義\n\n* 1，从应用阶段传递模型数据给顶点着色器时支持的语义如下表\n  \n  \n|语义\t|描述|\n| ------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n|POSITION\t  |模型空间中的顶点位置 通常float4  |\n|NORMAL\t  |   顶点法线 通常float3|\n|TANGENT\t|顶点切线 通常float4|\nTEXCOORD(n)\t|该顶点的纹理坐标 n组|\n|COLOR\t|顶点颜色 通常fixed4 float4|\n\n* 2，丛顶点着色器传递到片元着色器时支持的语义如下表：\n \n|语义\t|描述|\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| SV_POSITION\t| 裁剪空间中的顶点坐标 结构体必须包含一个该词修饰的变量| \n| COLOR0\t| 通常用于输出第一组顶点颜色| \n| COLOR1\t| 通常用于输出第二组顶点颜色| \n| TEXCOORDN（0~7）\t| 通常用于输出纹理坐标| \n  \n  \n* 3，片元着色器输出时支持的语义\n  \n|语义\t|描述|\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| SV_Target| \t输出值将会存储到渲染目标中| \n\n* 4. 數據類型對比\n\n|类型\t|精度|\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n|float\t|最高精度 通常32位|\n|half\t|中等精度 通常16位|\n|fixed\t|最低精度 通常11位|\n\n### 常用数学函数\n\n| 函数\t| 说明\t| 实例| \n| ----------|----------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| radians(degree)\t| 角度变弧度(一般默认都用弧度)\t|  \n| degrees(radian)\t| 弧度变角度\t|  \n| sin(angle), cos(angle), tan(angle)\t| 三角函数\t|  \n| asin(x)| \tarc sine, 返回弧度 \\[-PI/2, PI/2];\t|  \n| acos(x)\t| arc cosine,返回弧度 \\[0, PI]\t|  \n| atan(y, x)\t| arc tangent, 返回弧度 \\[-PI, PI];\t|  \n| atan(y/x)\t| arc tangent, 返回弧度 \\[-PI/2, PI/2];\t|  \n| pow(x, y)\t| x的y次方\t|  \n| exp(x)\t| 指数, log(x)\t|  \n| exp2(x)| \t2的x次方， log2(x)\t|  \n| sqrt(x)\t| x的根号；\t|  \n| inversesqrt(x)| \tx根号的倒数\t|  \n| abs(x)| \t绝对值\t|  \n| sign(x)| \t取当前数值的正负符号,返回 1, 0 或 -1\t|  （x>0;x=0;x<0）|  \n| floor(x)\t| 底部取整\t|  \n| ceil(x)\t| 顶部取整\t|  \n| fract(x)\t| 取小数部分\t|  \n| mod(x, y)\t| 取模， x - y\\*floor(x/y)\t|  \n| min(x, y)\t| 取最小值\t|  \n| max(x, y)| \t取最大值\t|  \n| clamp(x, min, max)\t| min(max(x, min), max);\t|  \n| mix(x, y, a)| \tx, y的线性混叠， x(1-a) + y\\*a;\t|  \n| step(edge, x)| \t如 x smoothstep(edge0, edge1, x): threshod smooth transition时使用。 edge0<=edge0时为0.0， x>=edge1时为1.0\t|  \n| length(x)\t| 向量长度\t|  \n| distance(p0, p1)| \t两点距离， length(p0-p1);\t|  \n| dot(x, y)\t| 点积，各分量分别相乘 后 相加\t|  \n| cross(x, y)\t| 差积 | \tx\\[1]\\*y\\[2]-y\\[1]\\*x\\[2], x\\[2]\\*y\\[0] - y\\[2]\\*x\\[0], x\\[0]\\*y\\[1] - y\\[0]\\*x\\[1] |  \n| normalize(x)\t| 归一化| \tlength(x)=1;| \n| faceforward(N, I, Nref)| \t如 dot(Nref, I)< 0则N, 否则 -N\t| \n| reflect(I, N)\t| I的反射方向| \tI -2\\*dot(N, I)\\*N, N必须先归一化| \n| refract(I, N, eta)| \t折射\t| k=1.0-etaeta(1.0 - dot(N, I) * dot(N, I)); 如k<0.0 则0.0，否则 etaI - (etadot(N, I)+sqrt(k))\\*N| \n| matrixCompMult(matX, matY)| \t矩阵相乘, 每个分量 自行相乘\t| r\\[j] = x\\[j]\\*y\\[j];| \n| lessThan(vecX, vecY)\t| 向量 每个分量比较 x < y\t| \n| lessThanEqual(vecX, vecY)| \t向量 每个分量比较 x<=y\t| \n| greaterThan(vecX, vecY)\t| 向量 每个分量比较 x>y\t| \n| greaterThanEqual(vecX, vecY)\t| 向量 每个分量比较 x>=y\t| \n| equal(vecX, vecY)\t| 向量 每个分量比较 x==y\t| \n| notEqual(vecX, vexY)| \t向量 每个分量比较 x!=y| \t\n| any(bvecX)\t| 只要有一个分量是true， 则true\t| \n| all(bvecX)\t| 所有分量是true， 则true\t| \n| not(bvecX)\t| 所有分量取反| \n\n\n### 1. UnityCG.cginc \n* 包含最常用的帮助函数，宏，结构钵\n*  数据结构:\nstruct appdata_base：顶点着色器输入，包含位置、法线和一个纹理坐标。\nstruct appdata_tan：顶点着色器输入，包含位置、法线、切线和一个纹理坐标。\nstruct appdata_full：顶点着色器输入，包含位置、法线、切线、顶点颜色和两个纹理坐标。\nstruct appdata_img: 顶点着色器输入，包含位置和一个纹理坐标。\n\n* 顶点变换函数\n \n\n| 功能                                    | 描述                                                                                                                       |\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| float4 UnityObjectToClipPos(float3 pos) | 将对象空间中的点变换到齐次坐标中的摄像机裁剪空间。这等效于 mul(UNITY_MATRIX_MVP, float4(pos, 1.0))，应该在适当的位置使用。 |\n| float3 UnityObjectToViewPos(float3 pos) | 将对象空间中的点变换到视图空间。这等效于 mul(UNITY_MATRIX_MV, float4(pos, 1.0)).xyz，应该在适当的位置使用。                |\n\n\n* 通用helper函数\n  \n| 功能\t| 描述| \n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| float3 WorldSpaceViewDir (float4 v)\t| 返回从给定对象空间顶点位置朝向摄像机的世界空间方向（未标准化）。| \n| float3 ObjSpaceViewDir (float4 v)\t| 返回从给定对象空间顶点位置朝向摄像机的对象空间方向（未标准化）。| \n| float2 ParallaxOffset (half h, half height, half3 viewDir)\t| 计算视差法线贴图的 UV 偏移。| \n| fixed Luminance (fixed3 c)\t| 将颜色转换为亮度（灰阶）。| \n| fixed3 DecodeLightmap (fixed4 color)\t| 从 Unity 光照贴图（RGBM 或 dLDR，具体取决于平台）解码颜色。| \n| float4 EncodeFloatRGBA (float v)\t| 将 \\[0..1) 范围浮点数编码为 RGBA 颜色，用于存储在低精度渲染目标中。| \n| float DecodeFloatRGBA (float4 enc)\t| 将 RGBA 颜色解码为浮点数。| \n| float2 EncodeFloatRG (float v)\t| 将 \\[0..1) 范围浮点数编码为 float2。| \n| float DecodeFloatRG (float2 enc)\t| 解码先前编码的 RG 浮点数。| \n| float2 EncodeViewNormalStereo (float3 n)\t| 将视图空间法线编码为 0 到 1 范围内的两个数字。| \n| float3 DecodeViewNormalStereo (float4 enc4)\t| 从 enc4.xy 解码视图空间法线。| \n\n* 仅支持前向渲染的helper函数， 仅当使用前向渲染（ForwardBase 或 ForwardAdd 通道类型）时，这些函数才有用。\n\n| 功能\t| 描述| \n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| float3 WorldSpaceLightDir (float4 v)\t| 根据给定的对象空间顶点位置计算朝向光源的世界空间方向（未标准化）。| \n| float3 ObjSpaceLightDir (float4 v)\t| 根据给定对象空间顶点位置计算朝向光源的对象空间方向（未标准化）。| \n| float3 Shade4PointLights (...)\t| 计算四个点光源的光照，将光源数据紧密打包到矢量中。前向渲染使用它来计算每顶点光照。| \n\n* 屏幕空间用的helper函数\n* 以下 helper 函数可计算用于采样屏幕空间纹理的坐标。它们返回 float4，其中用于纹理采样的最终坐标可以通过透视除法（例如 xy/w）计算得出。\n \n | 功能\t| 描述| \n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n|float4 ComputeScreenPos (float4 clipPos)\t| 计算用于执行屏幕空间贴图纹理采样的纹理坐标。输入是裁剪空间位置。| \n|float4 ComputeGrabScreenPos (float4 clipPos)\t| 计算用于 GrabPass 纹理采样的纹理坐标。输入是裁剪空间位置。| \n\n* UnityCG.cginc 中的顶点光照 helper 函数：\n* 仅当使用每顶点光照着色器（“Vertex”通道类型）时，这些函数才有用。\n\n | 功能\t| 描述| \n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| float3 ShadeVertexLights (float4 vertex, float3 normal)\t| 根据给定的对象空间位置和法线计算四个每顶点光源和环境光的光照。| \n\n### 2. UnityShaderVariables.cginc 【自动添加】\n * 包含常用的内置全局变量，如UNITY_MATRIX_MVP\n\n### 3. HLSLSupport.cginc 【自动添加】\n * 跨平台用的宏和帮助定义\n  \n### 4. AutoLight.cginc 【表面着色器使用】\n* 光照和阴影的函数库\n\n### 5. Lighting.cginc 【表面着色器自动添加】\n * 包含标准表面着色器的光照模型\n   \n### 6. TerrainEngine.cginc \n* 提供为地形vegetation相关shader的帮助函数\n\n\n\n## 二、 基础的光照模型\n\n### Unlit 頂點著色器模板：\n\n``` c\nShader \"Unlit/MyShader\"\n{\n    Properties\n    {\n        _MainTex (\"Texture\", 2D) = \"white\" {}\n\t\t_SpecularColor(\"Specular\",color)=(1,1,1,1)\n\t\t_Shininess(\"Shininess\",range(1,64))=8\n    }\n    SubShader\n    {\n        Tags { \"RenderType\"=\"Opaque\" }\n        LOD 100\n\n        Pass\n        {\n             CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\t\t\t#include \"Lighting.cginc\"\n            struct v2f\n            {\n            \tfloat3 normal:NORMAL;\n                float2 uv : TEXCOORD0;\n                float4 pos : SV_POSITION;\n                float4 vertex : TEXCOORD1;\n            };\n\n            sampler2D _MainTex;\n            float4 _MainTex_ST;\n\t\t\tfloat4 _SpecularColor;\n\t\t\tfloat _Shininess;\n\n            v2f vert (appdata_base v)\n            {\n                v2f o;\n                o.pos = UnityObjectToClipPos(v.vertex);\n                o.vertex = v.vertex;\n                o.normal = v.normal;\n                o.uv = TRANSFORM_TEX(v.texcoord.xy, _MainTex);\n                return o;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                // sample the texture\n                fixed4 col = tex2D(_MainTex, i.uv);\n\n                // 在这里实现光照\n\n                return col;\n            }\n            ENDCG\n        }\n    }\n}\n\n```\n\n### 1. Lambert 漫反射模型\n* 最基础的光照模型: 法向量与入射光的点积作为反射光\n* 将反射光乘上主色再乘上环境即可\n\n``` c\n fixed4 frag (v2f i) : SV_Target\n{\n\t// sample the texture\n\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t//获取法向量\n\tfloat3 N = UnityObjectToWorldNormal(i.normal);\n\t//获取入射光\n\tfloat3 L = normalize(WorldSpaceLightDir(i.vertex));\n\n\t// Diffuse:\n\tfloat diffuseScale = saturate(dot(N,L));\n\tcol = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n\n\treturn col;\n}\n```\n\n### 2. Phong 镜面反射模型\n``` c\nfixed4 frag (v2f i) : SV_Target\n{\n\t// sample the texture\n\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t//获取法向量\n\tfloat3 N = UnityObjectToWorldNormal(i.normal);\n\t//获取入射光\n\tfloat3 L = normalize(WorldSpaceLightDir(i.vertex));\n\t//视角坐标\n\tfloat3 V = normalize(WorldSpaceViewDir(i.vertex));\n\n\t// Diffuse:\n\tfloat diffuseScale = saturate(dot(N,L));\n\tcol = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n\t//Phong:\n\tfloat3 R = -reflect(L,N); // reflect(I,N) = 2* dot(N,L)*N - L;\n\tR = normalize(R);\n\tfloat specularScale = pow(saturate(dot(V,R)),_Shininess);\n\tcol += _SpecularColor*specularScale;\n\n\treturn col;\n}\n```\n\n### 3. Blin-Phong 半角镜面反射模型\n\n``` c\nfixed4 frag (v2f i) : SV_Target\n{\n\t// sample the texture\n\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t//获取法向量\n\tfloat3 N = UnityObjectToWorldNormal(i.normal);\n\t//获取入射光\n\tfloat3 L = normalize(WorldSpaceLightDir(i.vertex));\n\t//视角坐标\n\tfloat3 V = normalize(WorldSpaceViewDir(i.vertex));\n\n\t// Diffuse:\n\tfloat diffuseScale = saturate(dot(N,L));\n\tcol = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n\t//Phong:\n\t// float3 R = -reflect(L,N); // reflect(I,N) = 2* dot(N,L)*N - L;\n\t// R = normalize(R);\n\t// float specularScale = pow(saturate(dot(V,R)),_Shininess);\n\t// col += _SpecularColor*specularScale;\n\n\t//Blin-Phong:\n\tfloat3 H =  normalize(L+V);\n\tfloat specularScale = pow(saturate(dot(H,N)),_Shininess);\n\tcol += _SpecularColor*specularScale;\n\n\treturn col;\n}\n```\n\n\n### 4. 菲涅尔环境反射\n\n``` c\n....\nProperties\n  {\n\t  _Color(\"Color Tint\", Color) = (1,1,1,1)\n\t  _ReflectColor(\"Reflection Color\",Color) = (1,1,1,1)\n\t  _FresnelScale(\"Fresnel Scale\",range(0,1)) = 0.5\n\t  _CubeMap(\"Reflection CubeMap\",cube) = \"_skybox\"{}\n}\n.......\n fixed4 frag(v2f i) : SV_Target\n    {\n        fixed3 worldNormal = normalize(i.worldNormal);\n        fixed3 worldViewDir = normalize(i.worldViewDir);\n        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));\n\n        fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;\n        fixed3 col = texCUBE(_CubeMap, i.worldRef).rgb;\n        fixed3 reflection = col * _ReflectColor.rgb;\n\n        fixed3 diffuse = _LightColor0.rgb*_Color.rgb*saturate(dot(worldNormal, worldLightDir));\n        fixed fresnel = _FresnelScale + (1 - _FresnelScale)*pow(1 - dot(worldViewDir, worldNormal), 5);\n\n        UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);\n        fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel))*atten;\n        return fixed4(color,1.0);\n    }\n```","source":"_posts/计算机图形学编程笔记2.md","raw":"---\ntitle: 计算机图形学编程笔记2\ncategories:\n- 图形学\ntags: \n- 图形学\n---\n\n==本篇主要针对shader #2196F3==\n\n## 参考文献\n[Unity] - Technical Artist in Shading and Effects\nhttps://certification.unity.com/products/expert-technical-artist-shading-effects\n[虚幻] - 虚幻引擎职业讲堂：技术美术师\nhttps://www.unrealengine.com/zh-CN/tech-blog/jobs-in-unreal-engine---technical-artist?sessionInvalidated=true\n[Catlike] - Catlike大神的Unity系列教程\nhttps://catlikecoding.com/unity/tutorials/\n[霜狼_may] - TA技术美术学习体系框架\nhttps://www.bilibili.com/video/av77755500\n[毛星云] - 浅墨的游戏编程\nhttps://zhuanlan.zhihu.com/game-programming\n[云影] - 技术美术的魔法工坊\nhttps://zhuanlan.zhihu.com/c_1082217056598007808\n[一只大熊猫]-中国特色技术美术\nhttps://zhuanlan.zhihu.com/c_1078237708161363968\n[知乎] - 技术美术会是一个长期存在的职业吗？\nhttps://www.zhihu.com/question/325535382/answer/1149431577\n[马甲] - 总结一些TA（技术美术）学习的网站\nhttps://zhuanlan.zhihu.com/p/84550677\n[书籍] - 《OpenGL 编程指南》红宝书\nhttps://book.douban.com/subject/26220248/\n[书籍] - 《OpenGL 超级宝典》蓝宝书\nhttps://book.douban.com/subject/10774590/\n[书籍] - 《DirectX 9.0 3D游戏开发编程基础》\nhttps://book.douban.com/subject/2111771/\n[书籍] - 計算機圖形: 入門/API類\nhttps://www.douban.com/doulist/1445744/\n\n## 一、内置shader库\n\n### Unity支持的語義\n\n* 1，从应用阶段传递模型数据给顶点着色器时支持的语义如下表\n  \n  \n|语义\t|描述|\n| ------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n|POSITION\t  |模型空间中的顶点位置 通常float4  |\n|NORMAL\t  |   顶点法线 通常float3|\n|TANGENT\t|顶点切线 通常float4|\nTEXCOORD(n)\t|该顶点的纹理坐标 n组|\n|COLOR\t|顶点颜色 通常fixed4 float4|\n\n* 2，丛顶点着色器传递到片元着色器时支持的语义如下表：\n \n|语义\t|描述|\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| SV_POSITION\t| 裁剪空间中的顶点坐标 结构体必须包含一个该词修饰的变量| \n| COLOR0\t| 通常用于输出第一组顶点颜色| \n| COLOR1\t| 通常用于输出第二组顶点颜色| \n| TEXCOORDN（0~7）\t| 通常用于输出纹理坐标| \n  \n  \n* 3，片元着色器输出时支持的语义\n  \n|语义\t|描述|\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| SV_Target| \t输出值将会存储到渲染目标中| \n\n* 4. 數據類型對比\n\n|类型\t|精度|\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n|float\t|最高精度 通常32位|\n|half\t|中等精度 通常16位|\n|fixed\t|最低精度 通常11位|\n\n### 常用数学函数\n\n| 函数\t| 说明\t| 实例| \n| ----------|----------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| radians(degree)\t| 角度变弧度(一般默认都用弧度)\t|  \n| degrees(radian)\t| 弧度变角度\t|  \n| sin(angle), cos(angle), tan(angle)\t| 三角函数\t|  \n| asin(x)| \tarc sine, 返回弧度 \\[-PI/2, PI/2];\t|  \n| acos(x)\t| arc cosine,返回弧度 \\[0, PI]\t|  \n| atan(y, x)\t| arc tangent, 返回弧度 \\[-PI, PI];\t|  \n| atan(y/x)\t| arc tangent, 返回弧度 \\[-PI/2, PI/2];\t|  \n| pow(x, y)\t| x的y次方\t|  \n| exp(x)\t| 指数, log(x)\t|  \n| exp2(x)| \t2的x次方， log2(x)\t|  \n| sqrt(x)\t| x的根号；\t|  \n| inversesqrt(x)| \tx根号的倒数\t|  \n| abs(x)| \t绝对值\t|  \n| sign(x)| \t取当前数值的正负符号,返回 1, 0 或 -1\t|  （x>0;x=0;x<0）|  \n| floor(x)\t| 底部取整\t|  \n| ceil(x)\t| 顶部取整\t|  \n| fract(x)\t| 取小数部分\t|  \n| mod(x, y)\t| 取模， x - y\\*floor(x/y)\t|  \n| min(x, y)\t| 取最小值\t|  \n| max(x, y)| \t取最大值\t|  \n| clamp(x, min, max)\t| min(max(x, min), max);\t|  \n| mix(x, y, a)| \tx, y的线性混叠， x(1-a) + y\\*a;\t|  \n| step(edge, x)| \t如 x smoothstep(edge0, edge1, x): threshod smooth transition时使用。 edge0<=edge0时为0.0， x>=edge1时为1.0\t|  \n| length(x)\t| 向量长度\t|  \n| distance(p0, p1)| \t两点距离， length(p0-p1);\t|  \n| dot(x, y)\t| 点积，各分量分别相乘 后 相加\t|  \n| cross(x, y)\t| 差积 | \tx\\[1]\\*y\\[2]-y\\[1]\\*x\\[2], x\\[2]\\*y\\[0] - y\\[2]\\*x\\[0], x\\[0]\\*y\\[1] - y\\[0]\\*x\\[1] |  \n| normalize(x)\t| 归一化| \tlength(x)=1;| \n| faceforward(N, I, Nref)| \t如 dot(Nref, I)< 0则N, 否则 -N\t| \n| reflect(I, N)\t| I的反射方向| \tI -2\\*dot(N, I)\\*N, N必须先归一化| \n| refract(I, N, eta)| \t折射\t| k=1.0-etaeta(1.0 - dot(N, I) * dot(N, I)); 如k<0.0 则0.0，否则 etaI - (etadot(N, I)+sqrt(k))\\*N| \n| matrixCompMult(matX, matY)| \t矩阵相乘, 每个分量 自行相乘\t| r\\[j] = x\\[j]\\*y\\[j];| \n| lessThan(vecX, vecY)\t| 向量 每个分量比较 x < y\t| \n| lessThanEqual(vecX, vecY)| \t向量 每个分量比较 x<=y\t| \n| greaterThan(vecX, vecY)\t| 向量 每个分量比较 x>y\t| \n| greaterThanEqual(vecX, vecY)\t| 向量 每个分量比较 x>=y\t| \n| equal(vecX, vecY)\t| 向量 每个分量比较 x==y\t| \n| notEqual(vecX, vexY)| \t向量 每个分量比较 x!=y| \t\n| any(bvecX)\t| 只要有一个分量是true， 则true\t| \n| all(bvecX)\t| 所有分量是true， 则true\t| \n| not(bvecX)\t| 所有分量取反| \n\n\n### 1. UnityCG.cginc \n* 包含最常用的帮助函数，宏，结构钵\n*  数据结构:\nstruct appdata_base：顶点着色器输入，包含位置、法线和一个纹理坐标。\nstruct appdata_tan：顶点着色器输入，包含位置、法线、切线和一个纹理坐标。\nstruct appdata_full：顶点着色器输入，包含位置、法线、切线、顶点颜色和两个纹理坐标。\nstruct appdata_img: 顶点着色器输入，包含位置和一个纹理坐标。\n\n* 顶点变换函数\n \n\n| 功能                                    | 描述                                                                                                                       |\n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| float4 UnityObjectToClipPos(float3 pos) | 将对象空间中的点变换到齐次坐标中的摄像机裁剪空间。这等效于 mul(UNITY_MATRIX_MVP, float4(pos, 1.0))，应该在适当的位置使用。 |\n| float3 UnityObjectToViewPos(float3 pos) | 将对象空间中的点变换到视图空间。这等效于 mul(UNITY_MATRIX_MV, float4(pos, 1.0)).xyz，应该在适当的位置使用。                |\n\n\n* 通用helper函数\n  \n| 功能\t| 描述| \n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| float3 WorldSpaceViewDir (float4 v)\t| 返回从给定对象空间顶点位置朝向摄像机的世界空间方向（未标准化）。| \n| float3 ObjSpaceViewDir (float4 v)\t| 返回从给定对象空间顶点位置朝向摄像机的对象空间方向（未标准化）。| \n| float2 ParallaxOffset (half h, half height, half3 viewDir)\t| 计算视差法线贴图的 UV 偏移。| \n| fixed Luminance (fixed3 c)\t| 将颜色转换为亮度（灰阶）。| \n| fixed3 DecodeLightmap (fixed4 color)\t| 从 Unity 光照贴图（RGBM 或 dLDR，具体取决于平台）解码颜色。| \n| float4 EncodeFloatRGBA (float v)\t| 将 \\[0..1) 范围浮点数编码为 RGBA 颜色，用于存储在低精度渲染目标中。| \n| float DecodeFloatRGBA (float4 enc)\t| 将 RGBA 颜色解码为浮点数。| \n| float2 EncodeFloatRG (float v)\t| 将 \\[0..1) 范围浮点数编码为 float2。| \n| float DecodeFloatRG (float2 enc)\t| 解码先前编码的 RG 浮点数。| \n| float2 EncodeViewNormalStereo (float3 n)\t| 将视图空间法线编码为 0 到 1 范围内的两个数字。| \n| float3 DecodeViewNormalStereo (float4 enc4)\t| 从 enc4.xy 解码视图空间法线。| \n\n* 仅支持前向渲染的helper函数， 仅当使用前向渲染（ForwardBase 或 ForwardAdd 通道类型）时，这些函数才有用。\n\n| 功能\t| 描述| \n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| float3 WorldSpaceLightDir (float4 v)\t| 根据给定的对象空间顶点位置计算朝向光源的世界空间方向（未标准化）。| \n| float3 ObjSpaceLightDir (float4 v)\t| 根据给定对象空间顶点位置计算朝向光源的对象空间方向（未标准化）。| \n| float3 Shade4PointLights (...)\t| 计算四个点光源的光照，将光源数据紧密打包到矢量中。前向渲染使用它来计算每顶点光照。| \n\n* 屏幕空间用的helper函数\n* 以下 helper 函数可计算用于采样屏幕空间纹理的坐标。它们返回 float4，其中用于纹理采样的最终坐标可以通过透视除法（例如 xy/w）计算得出。\n \n | 功能\t| 描述| \n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n|float4 ComputeScreenPos (float4 clipPos)\t| 计算用于执行屏幕空间贴图纹理采样的纹理坐标。输入是裁剪空间位置。| \n|float4 ComputeGrabScreenPos (float4 clipPos)\t| 计算用于 GrabPass 纹理采样的纹理坐标。输入是裁剪空间位置。| \n\n* UnityCG.cginc 中的顶点光照 helper 函数：\n* 仅当使用每顶点光照着色器（“Vertex”通道类型）时，这些函数才有用。\n\n | 功能\t| 描述| \n| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| float3 ShadeVertexLights (float4 vertex, float3 normal)\t| 根据给定的对象空间位置和法线计算四个每顶点光源和环境光的光照。| \n\n### 2. UnityShaderVariables.cginc 【自动添加】\n * 包含常用的内置全局变量，如UNITY_MATRIX_MVP\n\n### 3. HLSLSupport.cginc 【自动添加】\n * 跨平台用的宏和帮助定义\n  \n### 4. AutoLight.cginc 【表面着色器使用】\n* 光照和阴影的函数库\n\n### 5. Lighting.cginc 【表面着色器自动添加】\n * 包含标准表面着色器的光照模型\n   \n### 6. TerrainEngine.cginc \n* 提供为地形vegetation相关shader的帮助函数\n\n\n\n## 二、 基础的光照模型\n\n### Unlit 頂點著色器模板：\n\n``` c\nShader \"Unlit/MyShader\"\n{\n    Properties\n    {\n        _MainTex (\"Texture\", 2D) = \"white\" {}\n\t\t_SpecularColor(\"Specular\",color)=(1,1,1,1)\n\t\t_Shininess(\"Shininess\",range(1,64))=8\n    }\n    SubShader\n    {\n        Tags { \"RenderType\"=\"Opaque\" }\n        LOD 100\n\n        Pass\n        {\n             CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"UnityCG.cginc\"\n\t\t\t#include \"Lighting.cginc\"\n            struct v2f\n            {\n            \tfloat3 normal:NORMAL;\n                float2 uv : TEXCOORD0;\n                float4 pos : SV_POSITION;\n                float4 vertex : TEXCOORD1;\n            };\n\n            sampler2D _MainTex;\n            float4 _MainTex_ST;\n\t\t\tfloat4 _SpecularColor;\n\t\t\tfloat _Shininess;\n\n            v2f vert (appdata_base v)\n            {\n                v2f o;\n                o.pos = UnityObjectToClipPos(v.vertex);\n                o.vertex = v.vertex;\n                o.normal = v.normal;\n                o.uv = TRANSFORM_TEX(v.texcoord.xy, _MainTex);\n                return o;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                // sample the texture\n                fixed4 col = tex2D(_MainTex, i.uv);\n\n                // 在这里实现光照\n\n                return col;\n            }\n            ENDCG\n        }\n    }\n}\n\n```\n\n### 1. Lambert 漫反射模型\n* 最基础的光照模型: 法向量与入射光的点积作为反射光\n* 将反射光乘上主色再乘上环境即可\n\n``` c\n fixed4 frag (v2f i) : SV_Target\n{\n\t// sample the texture\n\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t//获取法向量\n\tfloat3 N = UnityObjectToWorldNormal(i.normal);\n\t//获取入射光\n\tfloat3 L = normalize(WorldSpaceLightDir(i.vertex));\n\n\t// Diffuse:\n\tfloat diffuseScale = saturate(dot(N,L));\n\tcol = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n\n\treturn col;\n}\n```\n\n### 2. Phong 镜面反射模型\n``` c\nfixed4 frag (v2f i) : SV_Target\n{\n\t// sample the texture\n\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t//获取法向量\n\tfloat3 N = UnityObjectToWorldNormal(i.normal);\n\t//获取入射光\n\tfloat3 L = normalize(WorldSpaceLightDir(i.vertex));\n\t//视角坐标\n\tfloat3 V = normalize(WorldSpaceViewDir(i.vertex));\n\n\t// Diffuse:\n\tfloat diffuseScale = saturate(dot(N,L));\n\tcol = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n\t//Phong:\n\tfloat3 R = -reflect(L,N); // reflect(I,N) = 2* dot(N,L)*N - L;\n\tR = normalize(R);\n\tfloat specularScale = pow(saturate(dot(V,R)),_Shininess);\n\tcol += _SpecularColor*specularScale;\n\n\treturn col;\n}\n```\n\n### 3. Blin-Phong 半角镜面反射模型\n\n``` c\nfixed4 frag (v2f i) : SV_Target\n{\n\t// sample the texture\n\tfixed4 col = tex2D(_MainTex, i.uv);\n\n\t//获取法向量\n\tfloat3 N = UnityObjectToWorldNormal(i.normal);\n\t//获取入射光\n\tfloat3 L = normalize(WorldSpaceLightDir(i.vertex));\n\t//视角坐标\n\tfloat3 V = normalize(WorldSpaceViewDir(i.vertex));\n\n\t// Diffuse:\n\tfloat diffuseScale = saturate(dot(N,L));\n\tcol = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n\t//Phong:\n\t// float3 R = -reflect(L,N); // reflect(I,N) = 2* dot(N,L)*N - L;\n\t// R = normalize(R);\n\t// float specularScale = pow(saturate(dot(V,R)),_Shininess);\n\t// col += _SpecularColor*specularScale;\n\n\t//Blin-Phong:\n\tfloat3 H =  normalize(L+V);\n\tfloat specularScale = pow(saturate(dot(H,N)),_Shininess);\n\tcol += _SpecularColor*specularScale;\n\n\treturn col;\n}\n```\n\n\n### 4. 菲涅尔环境反射\n\n``` c\n....\nProperties\n  {\n\t  _Color(\"Color Tint\", Color) = (1,1,1,1)\n\t  _ReflectColor(\"Reflection Color\",Color) = (1,1,1,1)\n\t  _FresnelScale(\"Fresnel Scale\",range(0,1)) = 0.5\n\t  _CubeMap(\"Reflection CubeMap\",cube) = \"_skybox\"{}\n}\n.......\n fixed4 frag(v2f i) : SV_Target\n    {\n        fixed3 worldNormal = normalize(i.worldNormal);\n        fixed3 worldViewDir = normalize(i.worldViewDir);\n        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));\n\n        fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;\n        fixed3 col = texCUBE(_CubeMap, i.worldRef).rgb;\n        fixed3 reflection = col * _ReflectColor.rgb;\n\n        fixed3 diffuse = _LightColor0.rgb*_Color.rgb*saturate(dot(worldNormal, worldLightDir));\n        fixed fresnel = _FresnelScale + (1 - _FresnelScale)*pow(1 - dot(worldViewDir, worldNormal), 5);\n\n        UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);\n        fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel))*atten;\n        return fixed4(color,1.0);\n    }\n```","slug":"计算机图形学编程笔记2","published":1,"date":"2020-09-27T10:19:22.431Z","updated":"2020-09-27T10:19:22.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh13v00654wf07aip7ze1","content":"<p>==本篇主要针对shader #2196F3==</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[Unity] - Technical Artist in Shading and Effects<br><a href=\"https://certification.unity.com/products/expert-technical-artist-shading-effects\">https://certification.unity.com/products/expert-technical-artist-shading-effects</a><br>[虚幻] - 虚幻引擎职业讲堂：技术美术师<br><a href=\"https://www.unrealengine.com/zh-CN/tech-blog/jobs-in-unreal-engine---technical-artist?sessionInvalidated=true\">https://www.unrealengine.com/zh-CN/tech-blog/jobs-in-unreal-engine---technical-artist?sessionInvalidated=true</a><br>[Catlike] - Catlike大神的Unity系列教程<br><a href=\"https://catlikecoding.com/unity/tutorials/\">https://catlikecoding.com/unity/tutorials/</a><br>[霜狼_may] - TA技术美术学习体系框架<br><a href=\"https://www.bilibili.com/video/av77755500\">https://www.bilibili.com/video/av77755500</a><br>[毛星云] - 浅墨的游戏编程<br><a href=\"https://zhuanlan.zhihu.com/game-programming\">https://zhuanlan.zhihu.com/game-programming</a><br>[云影] - 技术美术的魔法工坊<br><a href=\"https://zhuanlan.zhihu.com/c_1082217056598007808\">https://zhuanlan.zhihu.com/c_1082217056598007808</a><br>[一只大熊猫]-中国特色技术美术<br><a href=\"https://zhuanlan.zhihu.com/c_1078237708161363968\">https://zhuanlan.zhihu.com/c_1078237708161363968</a><br>[知乎] - 技术美术会是一个长期存在的职业吗？<br><a href=\"https://www.zhihu.com/question/325535382/answer/1149431577\">https://www.zhihu.com/question/325535382/answer/1149431577</a><br>[马甲] - 总结一些TA（技术美术）学习的网站<br><a href=\"https://zhuanlan.zhihu.com/p/84550677\">https://zhuanlan.zhihu.com/p/84550677</a><br>[书籍] - 《OpenGL 编程指南》红宝书<br><a href=\"https://book.douban.com/subject/26220248/\">https://book.douban.com/subject/26220248/</a><br>[书籍] - 《OpenGL 超级宝典》蓝宝书<br><a href=\"https://book.douban.com/subject/10774590/\">https://book.douban.com/subject/10774590/</a><br>[书籍] - 《DirectX 9.0 3D游戏开发编程基础》<br><a href=\"https://book.douban.com/subject/2111771/\">https://book.douban.com/subject/2111771/</a><br>[书籍] - 計算機圖形: 入門/API類<br><a href=\"https://www.douban.com/doulist/1445744/\">https://www.douban.com/doulist/1445744/</a></p>\n<h2 id=\"一、内置shader库\"><a href=\"#一、内置shader库\" class=\"headerlink\" title=\"一、内置shader库\"></a>一、内置shader库</h2><h3 id=\"Unity支持的語義\"><a href=\"#Unity支持的語義\" class=\"headerlink\" title=\"Unity支持的語義\"></a>Unity支持的語義</h3><ul>\n<li>1，从应用阶段传递模型数据给顶点着色器时支持的语义如下表</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>语义</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>POSITION</td>\n<td>模型空间中的顶点位置 通常float4</td>\n</tr>\n<tr>\n<td>NORMAL</td>\n<td>顶点法线 通常float3</td>\n</tr>\n<tr>\n<td>TANGENT</td>\n<td>顶点切线 通常float4</td>\n</tr>\n<tr>\n<td>TEXCOORD(n)</td>\n<td>该顶点的纹理坐标 n组</td>\n</tr>\n<tr>\n<td>COLOR</td>\n<td>顶点颜色 通常fixed4 float4</td>\n</tr>\n</tbody></table>\n<ul>\n<li>2，丛顶点着色器传递到片元着色器时支持的语义如下表：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>语义</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SV_POSITION</td>\n<td>裁剪空间中的顶点坐标 结构体必须包含一个该词修饰的变量</td>\n</tr>\n<tr>\n<td>COLOR0</td>\n<td>通常用于输出第一组顶点颜色</td>\n</tr>\n<tr>\n<td>COLOR1</td>\n<td>通常用于输出第二组顶点颜色</td>\n</tr>\n<tr>\n<td>TEXCOORDN（0~7）</td>\n<td>通常用于输出纹理坐标</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3，片元着色器输出时支持的语义</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>语义</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SV_Target</td>\n<td>输出值将会存储到渲染目标中</td>\n</tr>\n</tbody></table>\n<ul>\n<li><ol start=\"4\">\n<li>數據類型對比</li>\n</ol>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>精度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float</td>\n<td>最高精度 通常32位</td>\n</tr>\n<tr>\n<td>half</td>\n<td>中等精度 通常16位</td>\n</tr>\n<tr>\n<td>fixed</td>\n<td>最低精度 通常11位</td>\n</tr>\n</tbody></table>\n<h3 id=\"常用数学函数\"><a href=\"#常用数学函数\" class=\"headerlink\" title=\"常用数学函数\"></a>常用数学函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>radians(degree)</td>\n<td>角度变弧度(一般默认都用弧度)</td>\n<td></td>\n</tr>\n<tr>\n<td>degrees(radian)</td>\n<td>弧度变角度</td>\n<td></td>\n</tr>\n<tr>\n<td>sin(angle), cos(angle), tan(angle)</td>\n<td>三角函数</td>\n<td></td>\n</tr>\n<tr>\n<td>asin(x)</td>\n<td>arc sine, 返回弧度 [-PI/2, PI/2];</td>\n<td></td>\n</tr>\n<tr>\n<td>acos(x)</td>\n<td>arc cosine,返回弧度 [0, PI]</td>\n<td></td>\n</tr>\n<tr>\n<td>atan(y, x)</td>\n<td>arc tangent, 返回弧度 [-PI, PI];</td>\n<td></td>\n</tr>\n<tr>\n<td>atan(y/x)</td>\n<td>arc tangent, 返回弧度 [-PI/2, PI/2];</td>\n<td></td>\n</tr>\n<tr>\n<td>pow(x, y)</td>\n<td>x的y次方</td>\n<td></td>\n</tr>\n<tr>\n<td>exp(x)</td>\n<td>指数, log(x)</td>\n<td></td>\n</tr>\n<tr>\n<td>exp2(x)</td>\n<td>2的x次方， log2(x)</td>\n<td></td>\n</tr>\n<tr>\n<td>sqrt(x)</td>\n<td>x的根号；</td>\n<td></td>\n</tr>\n<tr>\n<td>inversesqrt(x)</td>\n<td>x根号的倒数</td>\n<td></td>\n</tr>\n<tr>\n<td>abs(x)</td>\n<td>绝对值</td>\n<td></td>\n</tr>\n<tr>\n<td>sign(x)</td>\n<td>取当前数值的正负符号,返回 1, 0 或 -1</td>\n<td>（x&gt;0;x=0;x&lt;0）</td>\n</tr>\n<tr>\n<td>floor(x)</td>\n<td>底部取整</td>\n<td></td>\n</tr>\n<tr>\n<td>ceil(x)</td>\n<td>顶部取整</td>\n<td></td>\n</tr>\n<tr>\n<td>fract(x)</td>\n<td>取小数部分</td>\n<td></td>\n</tr>\n<tr>\n<td>mod(x, y)</td>\n<td>取模， x - y*floor(x/y)</td>\n<td></td>\n</tr>\n<tr>\n<td>min(x, y)</td>\n<td>取最小值</td>\n<td></td>\n</tr>\n<tr>\n<td>max(x, y)</td>\n<td>取最大值</td>\n<td></td>\n</tr>\n<tr>\n<td>clamp(x, min, max)</td>\n<td>min(max(x, min), max);</td>\n<td></td>\n</tr>\n<tr>\n<td>mix(x, y, a)</td>\n<td>x, y的线性混叠， x(1-a) + y*a;</td>\n<td></td>\n</tr>\n<tr>\n<td>step(edge, x)</td>\n<td>如 x smoothstep(edge0, edge1, x): threshod smooth transition时使用。 edge0&lt;=edge0时为0.0， x&gt;=edge1时为1.0</td>\n<td></td>\n</tr>\n<tr>\n<td>length(x)</td>\n<td>向量长度</td>\n<td></td>\n</tr>\n<tr>\n<td>distance(p0, p1)</td>\n<td>两点距离， length(p0-p1);</td>\n<td></td>\n</tr>\n<tr>\n<td>dot(x, y)</td>\n<td>点积，各分量分别相乘 后 相加</td>\n<td></td>\n</tr>\n<tr>\n<td>cross(x, y)</td>\n<td>差积</td>\n<td>x[1]*y[2]-y[1]*x[2], x[2]*y[0] - y[2]*x[0], x[0]*y[1] - y[0]*x[1]</td>\n</tr>\n<tr>\n<td>normalize(x)</td>\n<td>归一化</td>\n<td>length(x)=1;</td>\n</tr>\n<tr>\n<td>faceforward(N, I, Nref)</td>\n<td>如 dot(Nref, I)&lt; 0则N, 否则 -N</td>\n<td></td>\n</tr>\n<tr>\n<td>reflect(I, N)</td>\n<td>I的反射方向</td>\n<td>I -2*dot(N, I)*N, N必须先归一化</td>\n</tr>\n<tr>\n<td>refract(I, N, eta)</td>\n<td>折射</td>\n<td>k=1.0-etaeta(1.0 - dot(N, I) * dot(N, I)); 如k&lt;0.0 则0.0，否则 etaI - (etadot(N, I)+sqrt(k))*N</td>\n</tr>\n<tr>\n<td>matrixCompMult(matX, matY)</td>\n<td>矩阵相乘, 每个分量 自行相乘</td>\n<td>r[j] = x[j]*y[j];</td>\n</tr>\n<tr>\n<td>lessThan(vecX, vecY)</td>\n<td>向量 每个分量比较 x &lt; y</td>\n<td></td>\n</tr>\n<tr>\n<td>lessThanEqual(vecX, vecY)</td>\n<td>向量 每个分量比较 x&lt;=y</td>\n<td></td>\n</tr>\n<tr>\n<td>greaterThan(vecX, vecY)</td>\n<td>向量 每个分量比较 x&gt;y</td>\n<td></td>\n</tr>\n<tr>\n<td>greaterThanEqual(vecX, vecY)</td>\n<td>向量 每个分量比较 x&gt;=y</td>\n<td></td>\n</tr>\n<tr>\n<td>equal(vecX, vecY)</td>\n<td>向量 每个分量比较 x==y</td>\n<td></td>\n</tr>\n<tr>\n<td>notEqual(vecX, vexY)</td>\n<td>向量 每个分量比较 x!=y</td>\n<td></td>\n</tr>\n<tr>\n<td>any(bvecX)</td>\n<td>只要有一个分量是true， 则true</td>\n<td></td>\n</tr>\n<tr>\n<td>all(bvecX)</td>\n<td>所有分量是true， 则true</td>\n<td></td>\n</tr>\n<tr>\n<td>not(bvecX)</td>\n<td>所有分量取反</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"1-UnityCG-cginc\"><a href=\"#1-UnityCG-cginc\" class=\"headerlink\" title=\"1. UnityCG.cginc\"></a>1. UnityCG.cginc</h3><ul>\n<li><p>包含最常用的帮助函数，宏，结构钵</p>\n</li>\n<li><p>数据结构:<br>struct appdata_base：顶点着色器输入，包含位置、法线和一个纹理坐标。<br>struct appdata_tan：顶点着色器输入，包含位置、法线、切线和一个纹理坐标。<br>struct appdata_full：顶点着色器输入，包含位置、法线、切线、顶点颜色和两个纹理坐标。<br>struct appdata_img: 顶点着色器输入，包含位置和一个纹理坐标。</p>\n</li>\n<li><p>顶点变换函数</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float4 UnityObjectToClipPos(float3 pos)</td>\n<td>将对象空间中的点变换到齐次坐标中的摄像机裁剪空间。这等效于 mul(UNITY_MATRIX_MVP, float4(pos, 1.0))，应该在适当的位置使用。</td>\n</tr>\n<tr>\n<td>float3 UnityObjectToViewPos(float3 pos)</td>\n<td>将对象空间中的点变换到视图空间。这等效于 mul(UNITY_MATRIX_MV, float4(pos, 1.0)).xyz，应该在适当的位置使用。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>通用helper函数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float3 WorldSpaceViewDir (float4 v)</td>\n<td>返回从给定对象空间顶点位置朝向摄像机的世界空间方向（未标准化）。</td>\n</tr>\n<tr>\n<td>float3 ObjSpaceViewDir (float4 v)</td>\n<td>返回从给定对象空间顶点位置朝向摄像机的对象空间方向（未标准化）。</td>\n</tr>\n<tr>\n<td>float2 ParallaxOffset (half h, half height, half3 viewDir)</td>\n<td>计算视差法线贴图的 UV 偏移。</td>\n</tr>\n<tr>\n<td>fixed Luminance (fixed3 c)</td>\n<td>将颜色转换为亮度（灰阶）。</td>\n</tr>\n<tr>\n<td>fixed3 DecodeLightmap (fixed4 color)</td>\n<td>从 Unity 光照贴图（RGBM 或 dLDR，具体取决于平台）解码颜色。</td>\n</tr>\n<tr>\n<td>float4 EncodeFloatRGBA (float v)</td>\n<td>将 [0..1) 范围浮点数编码为 RGBA 颜色，用于存储在低精度渲染目标中。</td>\n</tr>\n<tr>\n<td>float DecodeFloatRGBA (float4 enc)</td>\n<td>将 RGBA 颜色解码为浮点数。</td>\n</tr>\n<tr>\n<td>float2 EncodeFloatRG (float v)</td>\n<td>将 [0..1) 范围浮点数编码为 float2。</td>\n</tr>\n<tr>\n<td>float DecodeFloatRG (float2 enc)</td>\n<td>解码先前编码的 RG 浮点数。</td>\n</tr>\n<tr>\n<td>float2 EncodeViewNormalStereo (float3 n)</td>\n<td>将视图空间法线编码为 0 到 1 范围内的两个数字。</td>\n</tr>\n<tr>\n<td>float3 DecodeViewNormalStereo (float4 enc4)</td>\n<td>从 enc4.xy 解码视图空间法线。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>仅支持前向渲染的helper函数， 仅当使用前向渲染（ForwardBase 或 ForwardAdd 通道类型）时，这些函数才有用。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float3 WorldSpaceLightDir (float4 v)</td>\n<td>根据给定的对象空间顶点位置计算朝向光源的世界空间方向（未标准化）。</td>\n</tr>\n<tr>\n<td>float3 ObjSpaceLightDir (float4 v)</td>\n<td>根据给定对象空间顶点位置计算朝向光源的对象空间方向（未标准化）。</td>\n</tr>\n<tr>\n<td>float3 Shade4PointLights (…)</td>\n<td>计算四个点光源的光照，将光源数据紧密打包到矢量中。前向渲染使用它来计算每顶点光照。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>屏幕空间用的helper函数</p>\n</li>\n<li><p>以下 helper 函数可计算用于采样屏幕空间纹理的坐标。它们返回 float4，其中用于纹理采样的最终坐标可以通过透视除法（例如 xy/w）计算得出。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float4 ComputeScreenPos (float4 clipPos)</td>\n<td>计算用于执行屏幕空间贴图纹理采样的纹理坐标。输入是裁剪空间位置。</td>\n</tr>\n<tr>\n<td>float4 ComputeGrabScreenPos (float4 clipPos)</td>\n<td>计算用于 GrabPass 纹理采样的纹理坐标。输入是裁剪空间位置。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>UnityCG.cginc 中的顶点光照 helper 函数：</p>\n</li>\n<li><p>仅当使用每顶点光照着色器（“Vertex”通道类型）时，这些函数才有用。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float3 ShadeVertexLights (float4 vertex, float3 normal)</td>\n<td>根据给定的对象空间位置和法线计算四个每顶点光源和环境光的光照。</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"2-UnityShaderVariables-cginc-【自动添加】\"><a href=\"#2-UnityShaderVariables-cginc-【自动添加】\" class=\"headerlink\" title=\"2. UnityShaderVariables.cginc 【自动添加】\"></a>2. UnityShaderVariables.cginc 【自动添加】</h3><ul>\n<li>包含常用的内置全局变量，如UNITY_MATRIX_MVP</li>\n</ul>\n<h3 id=\"3-HLSLSupport-cginc-【自动添加】\"><a href=\"#3-HLSLSupport-cginc-【自动添加】\" class=\"headerlink\" title=\"3. HLSLSupport.cginc 【自动添加】\"></a>3. HLSLSupport.cginc 【自动添加】</h3><ul>\n<li>跨平台用的宏和帮助定义</li>\n</ul>\n<h3 id=\"4-AutoLight-cginc-【表面着色器使用】\"><a href=\"#4-AutoLight-cginc-【表面着色器使用】\" class=\"headerlink\" title=\"4. AutoLight.cginc 【表面着色器使用】\"></a>4. AutoLight.cginc 【表面着色器使用】</h3><ul>\n<li>光照和阴影的函数库</li>\n</ul>\n<h3 id=\"5-Lighting-cginc-【表面着色器自动添加】\"><a href=\"#5-Lighting-cginc-【表面着色器自动添加】\" class=\"headerlink\" title=\"5. Lighting.cginc 【表面着色器自动添加】\"></a>5. Lighting.cginc 【表面着色器自动添加】</h3><ul>\n<li>包含标准表面着色器的光照模型</li>\n</ul>\n<h3 id=\"6-TerrainEngine-cginc\"><a href=\"#6-TerrainEngine-cginc\" class=\"headerlink\" title=\"6. TerrainEngine.cginc\"></a>6. TerrainEngine.cginc</h3><ul>\n<li>提供为地形vegetation相关shader的帮助函数</li>\n</ul>\n<h2 id=\"二、-基础的光照模型\"><a href=\"#二、-基础的光照模型\" class=\"headerlink\" title=\"二、 基础的光照模型\"></a>二、 基础的光照模型</h2><h3 id=\"Unlit-頂點著色器模板：\"><a href=\"#Unlit-頂點著色器模板：\" class=\"headerlink\" title=\"Unlit 頂點著色器模板：\"></a>Unlit 頂點著色器模板：</h3><pre><code class=\"c\">Shader &quot;Unlit/MyShader&quot;\n{\n    Properties\n    {\n        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}\n        _SpecularColor(&quot;Specular&quot;,color)=(1,1,1,1)\n        _Shininess(&quot;Shininess&quot;,range(1,64))=8\n    }\n    SubShader\n    {\n        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }\n        LOD 100\n\n        Pass\n        {\n             CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include &quot;UnityCG.cginc&quot;\n            #include &quot;Lighting.cginc&quot;\n            struct v2f\n            {\n                float3 normal:NORMAL;\n                float2 uv : TEXCOORD0;\n                float4 pos : SV_POSITION;\n                float4 vertex : TEXCOORD1;\n            };\n\n            sampler2D _MainTex;\n            float4 _MainTex_ST;\n            float4 _SpecularColor;\n            float _Shininess;\n\n            v2f vert (appdata_base v)\n            {\n                v2f o;\n                o.pos = UnityObjectToClipPos(v.vertex);\n                o.vertex = v.vertex;\n                o.normal = v.normal;\n                o.uv = TRANSFORM_TEX(v.texcoord.xy, _MainTex);\n                return o;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                // sample the texture\n                fixed4 col = tex2D(_MainTex, i.uv);\n\n                // 在这里实现光照\n\n                return col;\n            }\n            ENDCG\n        }\n    }\n}\n</code></pre>\n<h3 id=\"1-Lambert-漫反射模型\"><a href=\"#1-Lambert-漫反射模型\" class=\"headerlink\" title=\"1. Lambert 漫反射模型\"></a>1. Lambert 漫反射模型</h3><ul>\n<li>最基础的光照模型: 法向量与入射光的点积作为反射光</li>\n<li>将反射光乘上主色再乘上环境即可</li>\n</ul>\n<pre><code class=\"c\"> fixed4 frag (v2f i) : SV_Target\n{\n    // sample the texture\n    fixed4 col = tex2D(_MainTex, i.uv);\n\n    //获取法向量\n    float3 N = UnityObjectToWorldNormal(i.normal);\n    //获取入射光\n    float3 L = normalize(WorldSpaceLightDir(i.vertex));\n\n    // Diffuse:\n    float diffuseScale = saturate(dot(N,L));\n    col = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n\n    return col;\n}</code></pre>\n<h3 id=\"2-Phong-镜面反射模型\"><a href=\"#2-Phong-镜面反射模型\" class=\"headerlink\" title=\"2. Phong 镜面反射模型\"></a>2. Phong 镜面反射模型</h3><pre><code class=\"c\">fixed4 frag (v2f i) : SV_Target\n{\n    // sample the texture\n    fixed4 col = tex2D(_MainTex, i.uv);\n\n    //获取法向量\n    float3 N = UnityObjectToWorldNormal(i.normal);\n    //获取入射光\n    float3 L = normalize(WorldSpaceLightDir(i.vertex));\n    //视角坐标\n    float3 V = normalize(WorldSpaceViewDir(i.vertex));\n\n    // Diffuse:\n    float diffuseScale = saturate(dot(N,L));\n    col = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n    //Phong:\n    float3 R = -reflect(L,N); // reflect(I,N) = 2* dot(N,L)*N - L;\n    R = normalize(R);\n    float specularScale = pow(saturate(dot(V,R)),_Shininess);\n    col += _SpecularColor*specularScale;\n\n    return col;\n}</code></pre>\n<h3 id=\"3-Blin-Phong-半角镜面反射模型\"><a href=\"#3-Blin-Phong-半角镜面反射模型\" class=\"headerlink\" title=\"3. Blin-Phong 半角镜面反射模型\"></a>3. Blin-Phong 半角镜面反射模型</h3><pre><code class=\"c\">fixed4 frag (v2f i) : SV_Target\n{\n    // sample the texture\n    fixed4 col = tex2D(_MainTex, i.uv);\n\n    //获取法向量\n    float3 N = UnityObjectToWorldNormal(i.normal);\n    //获取入射光\n    float3 L = normalize(WorldSpaceLightDir(i.vertex));\n    //视角坐标\n    float3 V = normalize(WorldSpaceViewDir(i.vertex));\n\n    // Diffuse:\n    float diffuseScale = saturate(dot(N,L));\n    col = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n    //Phong:\n    // float3 R = -reflect(L,N); // reflect(I,N) = 2* dot(N,L)*N - L;\n    // R = normalize(R);\n    // float specularScale = pow(saturate(dot(V,R)),_Shininess);\n    // col += _SpecularColor*specularScale;\n\n    //Blin-Phong:\n    float3 H =  normalize(L+V);\n    float specularScale = pow(saturate(dot(H,N)),_Shininess);\n    col += _SpecularColor*specularScale;\n\n    return col;\n}</code></pre>\n<h3 id=\"4-菲涅尔环境反射\"><a href=\"#4-菲涅尔环境反射\" class=\"headerlink\" title=\"4. 菲涅尔环境反射\"></a>4. 菲涅尔环境反射</h3><pre><code class=\"c\">....\nProperties\n  {\n      _Color(&quot;Color Tint&quot;, Color) = (1,1,1,1)\n      _ReflectColor(&quot;Reflection Color&quot;,Color) = (1,1,1,1)\n      _FresnelScale(&quot;Fresnel Scale&quot;,range(0,1)) = 0.5\n      _CubeMap(&quot;Reflection CubeMap&quot;,cube) = &quot;_skybox&quot;{}\n}\n.......\n fixed4 frag(v2f i) : SV_Target\n    {\n        fixed3 worldNormal = normalize(i.worldNormal);\n        fixed3 worldViewDir = normalize(i.worldViewDir);\n        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));\n\n        fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;\n        fixed3 col = texCUBE(_CubeMap, i.worldRef).rgb;\n        fixed3 reflection = col * _ReflectColor.rgb;\n\n        fixed3 diffuse = _LightColor0.rgb*_Color.rgb*saturate(dot(worldNormal, worldLightDir));\n        fixed fresnel = _FresnelScale + (1 - _FresnelScale)*pow(1 - dot(worldViewDir, worldNormal), 5);\n\n        UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);\n        fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel))*atten;\n        return fixed4(color,1.0);\n    }</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>==本篇主要针对shader #2196F3==</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[Unity] - Technical Artist in Shading and Effects<br><a href=\"https://certification.unity.com/products/expert-technical-artist-shading-effects\">https://certification.unity.com/products/expert-technical-artist-shading-effects</a><br>[虚幻] - 虚幻引擎职业讲堂：技术美术师<br><a href=\"https://www.unrealengine.com/zh-CN/tech-blog/jobs-in-unreal-engine---technical-artist?sessionInvalidated=true\">https://www.unrealengine.com/zh-CN/tech-blog/jobs-in-unreal-engine---technical-artist?sessionInvalidated=true</a><br>[Catlike] - Catlike大神的Unity系列教程<br><a href=\"https://catlikecoding.com/unity/tutorials/\">https://catlikecoding.com/unity/tutorials/</a><br>[霜狼_may] - TA技术美术学习体系框架<br><a href=\"https://www.bilibili.com/video/av77755500\">https://www.bilibili.com/video/av77755500</a><br>[毛星云] - 浅墨的游戏编程<br><a href=\"https://zhuanlan.zhihu.com/game-programming\">https://zhuanlan.zhihu.com/game-programming</a><br>[云影] - 技术美术的魔法工坊<br><a href=\"https://zhuanlan.zhihu.com/c_1082217056598007808\">https://zhuanlan.zhihu.com/c_1082217056598007808</a><br>[一只大熊猫]-中国特色技术美术<br><a href=\"https://zhuanlan.zhihu.com/c_1078237708161363968\">https://zhuanlan.zhihu.com/c_1078237708161363968</a><br>[知乎] - 技术美术会是一个长期存在的职业吗？<br><a href=\"https://www.zhihu.com/question/325535382/answer/1149431577\">https://www.zhihu.com/question/325535382/answer/1149431577</a><br>[马甲] - 总结一些TA（技术美术）学习的网站<br><a href=\"https://zhuanlan.zhihu.com/p/84550677\">https://zhuanlan.zhihu.com/p/84550677</a><br>[书籍] - 《OpenGL 编程指南》红宝书<br><a href=\"https://book.douban.com/subject/26220248/\">https://book.douban.com/subject/26220248/</a><br>[书籍] - 《OpenGL 超级宝典》蓝宝书<br><a href=\"https://book.douban.com/subject/10774590/\">https://book.douban.com/subject/10774590/</a><br>[书籍] - 《DirectX 9.0 3D游戏开发编程基础》<br><a href=\"https://book.douban.com/subject/2111771/\">https://book.douban.com/subject/2111771/</a><br>[书籍] - 計算機圖形: 入門/API類<br><a href=\"https://www.douban.com/doulist/1445744/\">https://www.douban.com/doulist/1445744/</a></p>\n<h2 id=\"一、内置shader库\"><a href=\"#一、内置shader库\" class=\"headerlink\" title=\"一、内置shader库\"></a>一、内置shader库</h2><h3 id=\"Unity支持的語義\"><a href=\"#Unity支持的語義\" class=\"headerlink\" title=\"Unity支持的語義\"></a>Unity支持的語義</h3><ul>\n<li>1，从应用阶段传递模型数据给顶点着色器时支持的语义如下表</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>语义</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>POSITION</td>\n<td>模型空间中的顶点位置 通常float4</td>\n</tr>\n<tr>\n<td>NORMAL</td>\n<td>顶点法线 通常float3</td>\n</tr>\n<tr>\n<td>TANGENT</td>\n<td>顶点切线 通常float4</td>\n</tr>\n<tr>\n<td>TEXCOORD(n)</td>\n<td>该顶点的纹理坐标 n组</td>\n</tr>\n<tr>\n<td>COLOR</td>\n<td>顶点颜色 通常fixed4 float4</td>\n</tr>\n</tbody></table>\n<ul>\n<li>2，丛顶点着色器传递到片元着色器时支持的语义如下表：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>语义</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SV_POSITION</td>\n<td>裁剪空间中的顶点坐标 结构体必须包含一个该词修饰的变量</td>\n</tr>\n<tr>\n<td>COLOR0</td>\n<td>通常用于输出第一组顶点颜色</td>\n</tr>\n<tr>\n<td>COLOR1</td>\n<td>通常用于输出第二组顶点颜色</td>\n</tr>\n<tr>\n<td>TEXCOORDN（0~7）</td>\n<td>通常用于输出纹理坐标</td>\n</tr>\n</tbody></table>\n<ul>\n<li>3，片元着色器输出时支持的语义</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>语义</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SV_Target</td>\n<td>输出值将会存储到渲染目标中</td>\n</tr>\n</tbody></table>\n<ul>\n<li><ol start=\"4\">\n<li>數據類型對比</li>\n</ol>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>精度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float</td>\n<td>最高精度 通常32位</td>\n</tr>\n<tr>\n<td>half</td>\n<td>中等精度 通常16位</td>\n</tr>\n<tr>\n<td>fixed</td>\n<td>最低精度 通常11位</td>\n</tr>\n</tbody></table>\n<h3 id=\"常用数学函数\"><a href=\"#常用数学函数\" class=\"headerlink\" title=\"常用数学函数\"></a>常用数学函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>radians(degree)</td>\n<td>角度变弧度(一般默认都用弧度)</td>\n<td></td>\n</tr>\n<tr>\n<td>degrees(radian)</td>\n<td>弧度变角度</td>\n<td></td>\n</tr>\n<tr>\n<td>sin(angle), cos(angle), tan(angle)</td>\n<td>三角函数</td>\n<td></td>\n</tr>\n<tr>\n<td>asin(x)</td>\n<td>arc sine, 返回弧度 [-PI/2, PI/2];</td>\n<td></td>\n</tr>\n<tr>\n<td>acos(x)</td>\n<td>arc cosine,返回弧度 [0, PI]</td>\n<td></td>\n</tr>\n<tr>\n<td>atan(y, x)</td>\n<td>arc tangent, 返回弧度 [-PI, PI];</td>\n<td></td>\n</tr>\n<tr>\n<td>atan(y/x)</td>\n<td>arc tangent, 返回弧度 [-PI/2, PI/2];</td>\n<td></td>\n</tr>\n<tr>\n<td>pow(x, y)</td>\n<td>x的y次方</td>\n<td></td>\n</tr>\n<tr>\n<td>exp(x)</td>\n<td>指数, log(x)</td>\n<td></td>\n</tr>\n<tr>\n<td>exp2(x)</td>\n<td>2的x次方， log2(x)</td>\n<td></td>\n</tr>\n<tr>\n<td>sqrt(x)</td>\n<td>x的根号；</td>\n<td></td>\n</tr>\n<tr>\n<td>inversesqrt(x)</td>\n<td>x根号的倒数</td>\n<td></td>\n</tr>\n<tr>\n<td>abs(x)</td>\n<td>绝对值</td>\n<td></td>\n</tr>\n<tr>\n<td>sign(x)</td>\n<td>取当前数值的正负符号,返回 1, 0 或 -1</td>\n<td>（x&gt;0;x=0;x&lt;0）</td>\n</tr>\n<tr>\n<td>floor(x)</td>\n<td>底部取整</td>\n<td></td>\n</tr>\n<tr>\n<td>ceil(x)</td>\n<td>顶部取整</td>\n<td></td>\n</tr>\n<tr>\n<td>fract(x)</td>\n<td>取小数部分</td>\n<td></td>\n</tr>\n<tr>\n<td>mod(x, y)</td>\n<td>取模， x - y*floor(x/y)</td>\n<td></td>\n</tr>\n<tr>\n<td>min(x, y)</td>\n<td>取最小值</td>\n<td></td>\n</tr>\n<tr>\n<td>max(x, y)</td>\n<td>取最大值</td>\n<td></td>\n</tr>\n<tr>\n<td>clamp(x, min, max)</td>\n<td>min(max(x, min), max);</td>\n<td></td>\n</tr>\n<tr>\n<td>mix(x, y, a)</td>\n<td>x, y的线性混叠， x(1-a) + y*a;</td>\n<td></td>\n</tr>\n<tr>\n<td>step(edge, x)</td>\n<td>如 x smoothstep(edge0, edge1, x): threshod smooth transition时使用。 edge0&lt;=edge0时为0.0， x&gt;=edge1时为1.0</td>\n<td></td>\n</tr>\n<tr>\n<td>length(x)</td>\n<td>向量长度</td>\n<td></td>\n</tr>\n<tr>\n<td>distance(p0, p1)</td>\n<td>两点距离， length(p0-p1);</td>\n<td></td>\n</tr>\n<tr>\n<td>dot(x, y)</td>\n<td>点积，各分量分别相乘 后 相加</td>\n<td></td>\n</tr>\n<tr>\n<td>cross(x, y)</td>\n<td>差积</td>\n<td>x[1]*y[2]-y[1]*x[2], x[2]*y[0] - y[2]*x[0], x[0]*y[1] - y[0]*x[1]</td>\n</tr>\n<tr>\n<td>normalize(x)</td>\n<td>归一化</td>\n<td>length(x)=1;</td>\n</tr>\n<tr>\n<td>faceforward(N, I, Nref)</td>\n<td>如 dot(Nref, I)&lt; 0则N, 否则 -N</td>\n<td></td>\n</tr>\n<tr>\n<td>reflect(I, N)</td>\n<td>I的反射方向</td>\n<td>I -2*dot(N, I)*N, N必须先归一化</td>\n</tr>\n<tr>\n<td>refract(I, N, eta)</td>\n<td>折射</td>\n<td>k=1.0-etaeta(1.0 - dot(N, I) * dot(N, I)); 如k&lt;0.0 则0.0，否则 etaI - (etadot(N, I)+sqrt(k))*N</td>\n</tr>\n<tr>\n<td>matrixCompMult(matX, matY)</td>\n<td>矩阵相乘, 每个分量 自行相乘</td>\n<td>r[j] = x[j]*y[j];</td>\n</tr>\n<tr>\n<td>lessThan(vecX, vecY)</td>\n<td>向量 每个分量比较 x &lt; y</td>\n<td></td>\n</tr>\n<tr>\n<td>lessThanEqual(vecX, vecY)</td>\n<td>向量 每个分量比较 x&lt;=y</td>\n<td></td>\n</tr>\n<tr>\n<td>greaterThan(vecX, vecY)</td>\n<td>向量 每个分量比较 x&gt;y</td>\n<td></td>\n</tr>\n<tr>\n<td>greaterThanEqual(vecX, vecY)</td>\n<td>向量 每个分量比较 x&gt;=y</td>\n<td></td>\n</tr>\n<tr>\n<td>equal(vecX, vecY)</td>\n<td>向量 每个分量比较 x==y</td>\n<td></td>\n</tr>\n<tr>\n<td>notEqual(vecX, vexY)</td>\n<td>向量 每个分量比较 x!=y</td>\n<td></td>\n</tr>\n<tr>\n<td>any(bvecX)</td>\n<td>只要有一个分量是true， 则true</td>\n<td></td>\n</tr>\n<tr>\n<td>all(bvecX)</td>\n<td>所有分量是true， 则true</td>\n<td></td>\n</tr>\n<tr>\n<td>not(bvecX)</td>\n<td>所有分量取反</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"1-UnityCG-cginc\"><a href=\"#1-UnityCG-cginc\" class=\"headerlink\" title=\"1. UnityCG.cginc\"></a>1. UnityCG.cginc</h3><ul>\n<li><p>包含最常用的帮助函数，宏，结构钵</p>\n</li>\n<li><p>数据结构:<br>struct appdata_base：顶点着色器输入，包含位置、法线和一个纹理坐标。<br>struct appdata_tan：顶点着色器输入，包含位置、法线、切线和一个纹理坐标。<br>struct appdata_full：顶点着色器输入，包含位置、法线、切线、顶点颜色和两个纹理坐标。<br>struct appdata_img: 顶点着色器输入，包含位置和一个纹理坐标。</p>\n</li>\n<li><p>顶点变换函数</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float4 UnityObjectToClipPos(float3 pos)</td>\n<td>将对象空间中的点变换到齐次坐标中的摄像机裁剪空间。这等效于 mul(UNITY_MATRIX_MVP, float4(pos, 1.0))，应该在适当的位置使用。</td>\n</tr>\n<tr>\n<td>float3 UnityObjectToViewPos(float3 pos)</td>\n<td>将对象空间中的点变换到视图空间。这等效于 mul(UNITY_MATRIX_MV, float4(pos, 1.0)).xyz，应该在适当的位置使用。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>通用helper函数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float3 WorldSpaceViewDir (float4 v)</td>\n<td>返回从给定对象空间顶点位置朝向摄像机的世界空间方向（未标准化）。</td>\n</tr>\n<tr>\n<td>float3 ObjSpaceViewDir (float4 v)</td>\n<td>返回从给定对象空间顶点位置朝向摄像机的对象空间方向（未标准化）。</td>\n</tr>\n<tr>\n<td>float2 ParallaxOffset (half h, half height, half3 viewDir)</td>\n<td>计算视差法线贴图的 UV 偏移。</td>\n</tr>\n<tr>\n<td>fixed Luminance (fixed3 c)</td>\n<td>将颜色转换为亮度（灰阶）。</td>\n</tr>\n<tr>\n<td>fixed3 DecodeLightmap (fixed4 color)</td>\n<td>从 Unity 光照贴图（RGBM 或 dLDR，具体取决于平台）解码颜色。</td>\n</tr>\n<tr>\n<td>float4 EncodeFloatRGBA (float v)</td>\n<td>将 [0..1) 范围浮点数编码为 RGBA 颜色，用于存储在低精度渲染目标中。</td>\n</tr>\n<tr>\n<td>float DecodeFloatRGBA (float4 enc)</td>\n<td>将 RGBA 颜色解码为浮点数。</td>\n</tr>\n<tr>\n<td>float2 EncodeFloatRG (float v)</td>\n<td>将 [0..1) 范围浮点数编码为 float2。</td>\n</tr>\n<tr>\n<td>float DecodeFloatRG (float2 enc)</td>\n<td>解码先前编码的 RG 浮点数。</td>\n</tr>\n<tr>\n<td>float2 EncodeViewNormalStereo (float3 n)</td>\n<td>将视图空间法线编码为 0 到 1 范围内的两个数字。</td>\n</tr>\n<tr>\n<td>float3 DecodeViewNormalStereo (float4 enc4)</td>\n<td>从 enc4.xy 解码视图空间法线。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>仅支持前向渲染的helper函数， 仅当使用前向渲染（ForwardBase 或 ForwardAdd 通道类型）时，这些函数才有用。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float3 WorldSpaceLightDir (float4 v)</td>\n<td>根据给定的对象空间顶点位置计算朝向光源的世界空间方向（未标准化）。</td>\n</tr>\n<tr>\n<td>float3 ObjSpaceLightDir (float4 v)</td>\n<td>根据给定对象空间顶点位置计算朝向光源的对象空间方向（未标准化）。</td>\n</tr>\n<tr>\n<td>float3 Shade4PointLights (…)</td>\n<td>计算四个点光源的光照，将光源数据紧密打包到矢量中。前向渲染使用它来计算每顶点光照。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>屏幕空间用的helper函数</p>\n</li>\n<li><p>以下 helper 函数可计算用于采样屏幕空间纹理的坐标。它们返回 float4，其中用于纹理采样的最终坐标可以通过透视除法（例如 xy/w）计算得出。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float4 ComputeScreenPos (float4 clipPos)</td>\n<td>计算用于执行屏幕空间贴图纹理采样的纹理坐标。输入是裁剪空间位置。</td>\n</tr>\n<tr>\n<td>float4 ComputeGrabScreenPos (float4 clipPos)</td>\n<td>计算用于 GrabPass 纹理采样的纹理坐标。输入是裁剪空间位置。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>UnityCG.cginc 中的顶点光照 helper 函数：</p>\n</li>\n<li><p>仅当使用每顶点光照着色器（“Vertex”通道类型）时，这些函数才有用。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>float3 ShadeVertexLights (float4 vertex, float3 normal)</td>\n<td>根据给定的对象空间位置和法线计算四个每顶点光源和环境光的光照。</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"2-UnityShaderVariables-cginc-【自动添加】\"><a href=\"#2-UnityShaderVariables-cginc-【自动添加】\" class=\"headerlink\" title=\"2. UnityShaderVariables.cginc 【自动添加】\"></a>2. UnityShaderVariables.cginc 【自动添加】</h3><ul>\n<li>包含常用的内置全局变量，如UNITY_MATRIX_MVP</li>\n</ul>\n<h3 id=\"3-HLSLSupport-cginc-【自动添加】\"><a href=\"#3-HLSLSupport-cginc-【自动添加】\" class=\"headerlink\" title=\"3. HLSLSupport.cginc 【自动添加】\"></a>3. HLSLSupport.cginc 【自动添加】</h3><ul>\n<li>跨平台用的宏和帮助定义</li>\n</ul>\n<h3 id=\"4-AutoLight-cginc-【表面着色器使用】\"><a href=\"#4-AutoLight-cginc-【表面着色器使用】\" class=\"headerlink\" title=\"4. AutoLight.cginc 【表面着色器使用】\"></a>4. AutoLight.cginc 【表面着色器使用】</h3><ul>\n<li>光照和阴影的函数库</li>\n</ul>\n<h3 id=\"5-Lighting-cginc-【表面着色器自动添加】\"><a href=\"#5-Lighting-cginc-【表面着色器自动添加】\" class=\"headerlink\" title=\"5. Lighting.cginc 【表面着色器自动添加】\"></a>5. Lighting.cginc 【表面着色器自动添加】</h3><ul>\n<li>包含标准表面着色器的光照模型</li>\n</ul>\n<h3 id=\"6-TerrainEngine-cginc\"><a href=\"#6-TerrainEngine-cginc\" class=\"headerlink\" title=\"6. TerrainEngine.cginc\"></a>6. TerrainEngine.cginc</h3><ul>\n<li>提供为地形vegetation相关shader的帮助函数</li>\n</ul>\n<h2 id=\"二、-基础的光照模型\"><a href=\"#二、-基础的光照模型\" class=\"headerlink\" title=\"二、 基础的光照模型\"></a>二、 基础的光照模型</h2><h3 id=\"Unlit-頂點著色器模板：\"><a href=\"#Unlit-頂點著色器模板：\" class=\"headerlink\" title=\"Unlit 頂點著色器模板：\"></a>Unlit 頂點著色器模板：</h3><pre><code class=\"c\">Shader &quot;Unlit/MyShader&quot;\n{\n    Properties\n    {\n        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}\n        _SpecularColor(&quot;Specular&quot;,color)=(1,1,1,1)\n        _Shininess(&quot;Shininess&quot;,range(1,64))=8\n    }\n    SubShader\n    {\n        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }\n        LOD 100\n\n        Pass\n        {\n             CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include &quot;UnityCG.cginc&quot;\n            #include &quot;Lighting.cginc&quot;\n            struct v2f\n            {\n                float3 normal:NORMAL;\n                float2 uv : TEXCOORD0;\n                float4 pos : SV_POSITION;\n                float4 vertex : TEXCOORD1;\n            };\n\n            sampler2D _MainTex;\n            float4 _MainTex_ST;\n            float4 _SpecularColor;\n            float _Shininess;\n\n            v2f vert (appdata_base v)\n            {\n                v2f o;\n                o.pos = UnityObjectToClipPos(v.vertex);\n                o.vertex = v.vertex;\n                o.normal = v.normal;\n                o.uv = TRANSFORM_TEX(v.texcoord.xy, _MainTex);\n                return o;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                // sample the texture\n                fixed4 col = tex2D(_MainTex, i.uv);\n\n                // 在这里实现光照\n\n                return col;\n            }\n            ENDCG\n        }\n    }\n}\n</code></pre>\n<h3 id=\"1-Lambert-漫反射模型\"><a href=\"#1-Lambert-漫反射模型\" class=\"headerlink\" title=\"1. Lambert 漫反射模型\"></a>1. Lambert 漫反射模型</h3><ul>\n<li>最基础的光照模型: 法向量与入射光的点积作为反射光</li>\n<li>将反射光乘上主色再乘上环境即可</li>\n</ul>\n<pre><code class=\"c\"> fixed4 frag (v2f i) : SV_Target\n{\n    // sample the texture\n    fixed4 col = tex2D(_MainTex, i.uv);\n\n    //获取法向量\n    float3 N = UnityObjectToWorldNormal(i.normal);\n    //获取入射光\n    float3 L = normalize(WorldSpaceLightDir(i.vertex));\n\n    // Diffuse:\n    float diffuseScale = saturate(dot(N,L));\n    col = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n\n    return col;\n}</code></pre>\n<h3 id=\"2-Phong-镜面反射模型\"><a href=\"#2-Phong-镜面反射模型\" class=\"headerlink\" title=\"2. Phong 镜面反射模型\"></a>2. Phong 镜面反射模型</h3><pre><code class=\"c\">fixed4 frag (v2f i) : SV_Target\n{\n    // sample the texture\n    fixed4 col = tex2D(_MainTex, i.uv);\n\n    //获取法向量\n    float3 N = UnityObjectToWorldNormal(i.normal);\n    //获取入射光\n    float3 L = normalize(WorldSpaceLightDir(i.vertex));\n    //视角坐标\n    float3 V = normalize(WorldSpaceViewDir(i.vertex));\n\n    // Diffuse:\n    float diffuseScale = saturate(dot(N,L));\n    col = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n    //Phong:\n    float3 R = -reflect(L,N); // reflect(I,N) = 2* dot(N,L)*N - L;\n    R = normalize(R);\n    float specularScale = pow(saturate(dot(V,R)),_Shininess);\n    col += _SpecularColor*specularScale;\n\n    return col;\n}</code></pre>\n<h3 id=\"3-Blin-Phong-半角镜面反射模型\"><a href=\"#3-Blin-Phong-半角镜面反射模型\" class=\"headerlink\" title=\"3. Blin-Phong 半角镜面反射模型\"></a>3. Blin-Phong 半角镜面反射模型</h3><pre><code class=\"c\">fixed4 frag (v2f i) : SV_Target\n{\n    // sample the texture\n    fixed4 col = tex2D(_MainTex, i.uv);\n\n    //获取法向量\n    float3 N = UnityObjectToWorldNormal(i.normal);\n    //获取入射光\n    float3 L = normalize(WorldSpaceLightDir(i.vertex));\n    //视角坐标\n    float3 V = normalize(WorldSpaceViewDir(i.vertex));\n\n    // Diffuse:\n    float diffuseScale = saturate(dot(N,L));\n    col = UNITY_LIGHTMODEL_AMBIENT + _LightColor0* col * diffuseScale;\n\n    //Phong:\n    // float3 R = -reflect(L,N); // reflect(I,N) = 2* dot(N,L)*N - L;\n    // R = normalize(R);\n    // float specularScale = pow(saturate(dot(V,R)),_Shininess);\n    // col += _SpecularColor*specularScale;\n\n    //Blin-Phong:\n    float3 H =  normalize(L+V);\n    float specularScale = pow(saturate(dot(H,N)),_Shininess);\n    col += _SpecularColor*specularScale;\n\n    return col;\n}</code></pre>\n<h3 id=\"4-菲涅尔环境反射\"><a href=\"#4-菲涅尔环境反射\" class=\"headerlink\" title=\"4. 菲涅尔环境反射\"></a>4. 菲涅尔环境反射</h3><pre><code class=\"c\">....\nProperties\n  {\n      _Color(&quot;Color Tint&quot;, Color) = (1,1,1,1)\n      _ReflectColor(&quot;Reflection Color&quot;,Color) = (1,1,1,1)\n      _FresnelScale(&quot;Fresnel Scale&quot;,range(0,1)) = 0.5\n      _CubeMap(&quot;Reflection CubeMap&quot;,cube) = &quot;_skybox&quot;{}\n}\n.......\n fixed4 frag(v2f i) : SV_Target\n    {\n        fixed3 worldNormal = normalize(i.worldNormal);\n        fixed3 worldViewDir = normalize(i.worldViewDir);\n        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));\n\n        fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;\n        fixed3 col = texCUBE(_CubeMap, i.worldRef).rgb;\n        fixed3 reflection = col * _ReflectColor.rgb;\n\n        fixed3 diffuse = _LightColor0.rgb*_Color.rgb*saturate(dot(worldNormal, worldLightDir));\n        fixed fresnel = _FresnelScale + (1 - _FresnelScale)*pow(1 - dot(worldViewDir, worldNormal), 5);\n\n        UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);\n        fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel))*atten;\n        return fixed4(color,1.0);\n    }</code></pre>\n"},{"title":"递归算法","_content":"\n![递归算法](/img/1586415301619.png)\n* 公式法求复杂度：\n* ![公式法](/img/1586415991649.png)\n* ![三种情况](/img/1586416006714.png)\n\n* ![例一](/img/1586416029304.png)\n* ![例二](/img/1586416055487.png)\n* ![例三](/img/1586416101201.png)\n\n![回溯法](/img/1586416261865.png)\n\n![经典找集合总和的算法](/img/1586416480976.png)\n\nNQueen算法：\n![回溯法NQueen](/img/1586418715552.png)\n\n算法复杂度：\n![NQueen算法复杂度](/img/1586419084172.png)\n\n#### 皇后算法：\n![分析](/img/1586423622273.png)\n![规律总结](/img/1586423672607.png)\n\n![流程解析](/img/1586423705879.png)\n\n![算法思路](/img/1586423739245.png)\n![算法思路2](/img/1586423782860.png)\n\n\n![Python实现](/img/1586423973441.png)","source":"_posts/递归算法.md","raw":"---\ntitle: 递归算法\ncategories:\n- 数据结构\n---\n\n![递归算法](/img/1586415301619.png)\n* 公式法求复杂度：\n* ![公式法](/img/1586415991649.png)\n* ![三种情况](/img/1586416006714.png)\n\n* ![例一](/img/1586416029304.png)\n* ![例二](/img/1586416055487.png)\n* ![例三](/img/1586416101201.png)\n\n![回溯法](/img/1586416261865.png)\n\n![经典找集合总和的算法](/img/1586416480976.png)\n\nNQueen算法：\n![回溯法NQueen](/img/1586418715552.png)\n\n算法复杂度：\n![NQueen算法复杂度](/img/1586419084172.png)\n\n#### 皇后算法：\n![分析](/img/1586423622273.png)\n![规律总结](/img/1586423672607.png)\n\n![流程解析](/img/1586423705879.png)\n\n![算法思路](/img/1586423739245.png)\n![算法思路2](/img/1586423782860.png)\n\n\n![Python实现](/img/1586423973441.png)","slug":"递归算法","published":1,"date":"2020-09-08T03:23:20.891Z","updated":"2020-09-08T03:23:20.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgssh13y00694wf0b7tfttn9","content":"<p><img src=\"/img/1586415301619.png\" alt=\"递归算法\"></p>\n<ul>\n<li><p>公式法求复杂度：</p>\n</li>\n<li><p><img src=\"/img/1586415991649.png\" alt=\"公式法\"></p>\n</li>\n<li><p><img src=\"/img/1586416006714.png\" alt=\"三种情况\"></p>\n</li>\n<li><p><img src=\"/img/1586416029304.png\" alt=\"例一\"></p>\n</li>\n<li><p><img src=\"/img/1586416055487.png\" alt=\"例二\"></p>\n</li>\n<li><p><img src=\"/img/1586416101201.png\" alt=\"例三\"></p>\n</li>\n</ul>\n<p><img src=\"/img/1586416261865.png\" alt=\"回溯法\"></p>\n<p><img src=\"/img/1586416480976.png\" alt=\"经典找集合总和的算法\"></p>\n<p>NQueen算法：<br><img src=\"/img/1586418715552.png\" alt=\"回溯法NQueen\"></p>\n<p>算法复杂度：<br><img src=\"/img/1586419084172.png\" alt=\"NQueen算法复杂度\"></p>\n<h4 id=\"皇后算法：\"><a href=\"#皇后算法：\" class=\"headerlink\" title=\"皇后算法：\"></a>皇后算法：</h4><p><img src=\"/img/1586423622273.png\" alt=\"分析\"><br><img src=\"/img/1586423672607.png\" alt=\"规律总结\"></p>\n<p><img src=\"/img/1586423705879.png\" alt=\"流程解析\"></p>\n<p><img src=\"/img/1586423739245.png\" alt=\"算法思路\"><br><img src=\"/img/1586423782860.png\" alt=\"算法思路2\"></p>\n<p><img src=\"/img/1586423973441.png\" alt=\"Python实现\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/img/1586415301619.png\" alt=\"递归算法\"></p>\n<ul>\n<li><p>公式法求复杂度：</p>\n</li>\n<li><p><img src=\"/img/1586415991649.png\" alt=\"公式法\"></p>\n</li>\n<li><p><img src=\"/img/1586416006714.png\" alt=\"三种情况\"></p>\n</li>\n<li><p><img src=\"/img/1586416029304.png\" alt=\"例一\"></p>\n</li>\n<li><p><img src=\"/img/1586416055487.png\" alt=\"例二\"></p>\n</li>\n<li><p><img src=\"/img/1586416101201.png\" alt=\"例三\"></p>\n</li>\n</ul>\n<p><img src=\"/img/1586416261865.png\" alt=\"回溯法\"></p>\n<p><img src=\"/img/1586416480976.png\" alt=\"经典找集合总和的算法\"></p>\n<p>NQueen算法：<br><img src=\"/img/1586418715552.png\" alt=\"回溯法NQueen\"></p>\n<p>算法复杂度：<br><img src=\"/img/1586419084172.png\" alt=\"NQueen算法复杂度\"></p>\n<h4 id=\"皇后算法：\"><a href=\"#皇后算法：\" class=\"headerlink\" title=\"皇后算法：\"></a>皇后算法：</h4><p><img src=\"/img/1586423622273.png\" alt=\"分析\"><br><img src=\"/img/1586423672607.png\" alt=\"规律总结\"></p>\n<p><img src=\"/img/1586423705879.png\" alt=\"流程解析\"></p>\n<p><img src=\"/img/1586423739245.png\" alt=\"算法思路\"><br><img src=\"/img/1586423782860.png\" alt=\"算法思路2\"></p>\n<p><img src=\"/img/1586423973441.png\" alt=\"Python实现\"></p>\n"},{"title":"Playable动画系统研究","_content":"\n## 1. Playable是什么\nPlayable是一组API，可以用来组合、混合、修改多个数据源，然后通过一个输出，将这些数据源处理完的结果播放出来。\n\n## 2. 简单使用：播放单个动画\n* PlayableGraph的AnimationOutput依然是基于Animator组件的，不过你可以不用关心它了。\n* 主要实现目的是可以不创建animationcontroller，用代码实现其中的一些功能\n\n``` csharp\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n \npublic class PlayClipOnObject : MonoBehaviour\n{\n   public AnimationClip myClip;\n   private PlayableGraph graph;\n \n   void Start () {\n      PlayAnimation(gameObject, myClip);\n   }\n   \n   public void PlayAnimation(GameObject target, AnimationClip clip) {\n      // Create the PlayableGraph, which is the root of the Playable API stuff\n      graph = PlayableGraph.Create();\n \n      //We need an Animator to play stuff, even if we're not using an AnimatorController. So just add one:\n      var animator = target.AddComponent<Animator>();\n \n      //Wrap the clip in a thing the Playable system understands:\n      var clipPlayable = AnimationClipPlayable.Create(graph, clip);\n \n      //Create the output, and make the clip be the output's source. This API is a bit wordy :p\n      var animOutput = AnimationPlayableOutput.Create(graph, \"some name\", animator);\n      animOutput.SetSourcePlayable(clipPlayable);\n \n      //play the thing\n      graph.Play();\n    }\n \n   void OnDestroy()\n   {\n      // If you don't destroy the graph, it leaks in the engine (and Unity whines), so destroy it!\n      // IsValid will be false if the graph was never created (ie. this component is never enabled before it's destroyed)\n      if(graph.IsValid())\n         graph.Destroy();\n   }\n}\n```\n\n\n创建步骤：\n1. 创建Graph\n\n```csharp\nplayableGraph = PlayableGraph.Create();\n```\n2. 创建Ouput\n   \n\n``` csharp\nvar playableOutput = AnimationPlayableOutput.Create(playableGraph, \"Animation\", GetComponent<Animator>());\n```\n\n3. 为clip创建针对的Playable对象\n   \n\n``` csharp\n var clipPlayable = AnimationClipPlayable.Create(playableGraph, clip);\n```\n\n4. 设置playable对象到Output中\n   \n\n``` csharp\n playableOutput.SetSourcePlayable(clipPlayable);\n```\n\n5. 让Graph执行play\n   \n\n``` csharp\nplayableGraph.Play();\n```\n\n* 6. 需要在结束时销毁Graph对象\n  \n\n``` csharp\nplayableGraph.Play();\n```\n\n> Playable Output类型\n为了避免GC，所有类型都是使用struct实现的。\n构建PlayableGraph一般有如下的流程：\n\n创建一个PlayableGraph，方法是PlayableGraph.Create(\"graph的名字\")\n创建输出节点，常用的有\n``` csharp\nAnimationPlayableOutput.Create(playableGraph, \"name\", GetComponent<Animator>());\nAudioPlayableOutput.Create(playableGraph, \"name\", GetComponent<AudioSource>());\n```\n\n还可以创建自定义的输出节点\n\n\n创建各种playables。所有的Playable都有一个静态的Create()方法，用来创建playable实例。需要注意的是自定义的PlayableBehaviour需要使用\n``` csharp\nScriptPlayable<T>.Create(playableGraph);\n```\n来创建。\n\n``` csharp\nAnimationClipPlayable.Create(playableGraph, animationClip);\nAudioClipPlayable.Create(playableGraph, audioClip, true);\nScriptPlayable<T>.Create(playableGraph);\n```\n\n连接playable和output：PlayableOutput.SetSourcePlayable()\nplayable之间的连接：PlayableGraph.Connect()。\n播放graph：PlayableGraph.Play()\n如果graph不再使用，记得销毁：PlayableGraph.Destroy()。调用这个方法后会销毁所有的playbles和output。\n\n## 3. 替代AnimationController\n\n1. 创建混合树AnimationMixerPlayable，实现AnimationController之间连线控制功能：\n  \n\n``` csharp\nusing UnityEngine;\n\nusing UnityEngine.Playables;\n\nusing UnityEngine.Animations;\nusing UnityEngine.Experimental.Animations;\n\n[RequireComponent(typeof(Animator))]\n\npublic class PlayAnimationSample : MonoBehaviour\n\n{\n\n    public AnimationClip clip0;\n    public AnimationClip clip1;\n    \n    PlayableGraph playableGraph;\n    private AnimationMixerPlayable m_Mixer;\n\n    public float tranTime = 2;\n    private float leftTime;\n    \n    void Start()\n\n    {\n\n        playableGraph = PlayableGraph.Create(\"测试\");\n\n        playableGraph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);\n\n        var playableOutput = AnimationPlayableOutput.Create(playableGraph, \"Animation\", GetComponent<Animator>());\n\n        // Wrap the clip in a playable\n\n        m_Mixer = AnimationMixerPlayable.Create(playableGraph, 2);\n        \n        AnimationClipPlayable clipPlayable0 = AnimationClipPlayable.Create(playableGraph, clip0);\n        AnimationClipPlayable clipPlayable1 = AnimationClipPlayable.Create(playableGraph, clip1);\n\n        playableGraph.Connect(clipPlayable0, 0, m_Mixer, 0);\n        playableGraph.Connect(clipPlayable1, 0, m_Mixer, 1);\n        \n        m_Mixer.SetInputWeight(0,1);\n        m_Mixer.SetInputWeight(1,0);\n        // Connect the Playable to an output\n\n        playableOutput.SetSourcePlayable(m_Mixer);\n        playableOutput.SetSortingOrder(0);\n            \n            // Plays the Graph.\n        leftTime = tranTime;\n        playableGraph.Play();\n\n    }\n\n    void Update()\n    {\n        leftTime = Mathf.Clamp(leftTime - Time.deltaTime, 0, 2);\n        float weight = leftTime / tranTime;\n        Debug.Log(\"weight:\"+weight);\n        m_Mixer.SetInputWeight(0, 1 - weight);\n        m_Mixer.SetInputWeight(1, weight);\n    }\n    \n    void OnDestroy()\n    {\n        // Destroys all Playables and PlayableOutputs created by the graph.\n        playableGraph.Destroy();\n    }\n}\n```\n\n## 5. 实现自定义的PlayableBehaviour\n\n实现\n* 1.继承 PlayableBehaviour \n* 2.在初始化函数中传入graph, playable对象，分别为每个动画创建Playable并添加到mixer中，设置weight\n\n调用\n* 1.使用ScriptPlayable.Create创建自定义的Playable对象\n* 2.从Playable中获取behaviour并利用此behaviour调用初始化函数\n\n``` csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class CustomPlayable : PlayableBehaviour\n{\n    private int m_CurrentClipIndex = -1;\n    private float m_TimeToNextClip;\n    private Playable mixer;\n    public void Initialize(AnimationClip[] clipsToPlay, Playable owner, PlayableGraph graph)\n    {\n        owner.SetInputCount(1);\n        mixer = AnimationMixerPlayable.Create(graph, clipsToPlay.Length);\n        graph.Connect(mixer, 0, owner, 0);\n        owner.SetInputWeight(0, 1);\n        for (int clipIndex = 0 ; clipIndex < mixer.GetInputCount() ; ++clipIndex)\n        {\n            graph.Connect(AnimationClipPlayable.Create(graph, clipsToPlay[clipIndex]), 0, mixer, clipIndex);\n            mixer.SetInputWeight(clipIndex, 1.0f);\n        }\n    }\n    \n    override public void PrepareFrame(Playable owner, FrameData info)\n    {\n        if (mixer.GetInputCount() == 0)\n            return;\n        // Advance to next clip if necessary\n        m_TimeToNextClip -= (float)info.deltaTime;\n        if (m_TimeToNextClip <= 0.0f)\n        {\n            m_CurrentClipIndex++;\n            if (m_CurrentClipIndex >= mixer.GetInputCount())\n                m_CurrentClipIndex = 0;\n            var currentClip = (AnimationClipPlayable)mixer.GetInput(m_CurrentClipIndex);\n            // Reset the time so that the next clip starts at the correct position\n            currentClip.SetTime(0);\n            m_TimeToNextClip = currentClip.GetAnimationClip().length;\n        }\n        // Adjust the weight of the inputs\n        for (int clipIndex = 0 ; clipIndex < mixer.GetInputCount(); ++clipIndex)\n        {\n            if (clipIndex == m_CurrentClipIndex)\n                mixer.SetInputWeight(clipIndex, 1.0f);\n            else\n                mixer.SetInputWeight(clipIndex, 0.0f);\n        }\n    }\n}\n\n```\n\n``` csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class PlayCustomPlayableSample : MonoBehaviour\n{\n    public AnimationClip[] clipsToPlay;\n\n    PlayableGraph m_Graph;\n\n    void Start()\n    {\n        m_Graph = PlayableGraph.Create();\n        var custPlayable = ScriptPlayable<CustomPlayable>.Create(m_Graph);\n\n        var playQueue = custPlayable.GetBehaviour();\n\n        playQueue.Initialize(clipsToPlay, custPlayable, m_Graph);\n\n        var playableOutput = AnimationPlayableOutput.Create(m_Graph, \"Animation\", GetComponent<Animator>());\n\n        playableOutput.SetSourcePlayable(custPlayable);\n        playableOutput.SetSourceInputPort(0);\n\n        m_Graph.Play();\n    }\n\n    void OnDisable()\n\n    {\n\n        // Destroys all Playables and Outputs created by the graph.\n\n        m_Graph.Destroy();\n\n    }\n}\n\n```\n\n\n## 4. 工具：  PlayableGraph Visiualizer\n  * 停止更新于去年4月\n    \n>在场景中的Animator运行时，将自动映射动画到Visiualizer中显示\n>在创建好的PlayableGraph ，运行时也会在其中显示\n\n\n","source":"_posts/Playable动画系统研究.md","raw":"---\ntitle: Playable动画系统研究\ncategories:\n- Unity学习\ntags: \n- Unity学习\n---\n\n## 1. Playable是什么\nPlayable是一组API，可以用来组合、混合、修改多个数据源，然后通过一个输出，将这些数据源处理完的结果播放出来。\n\n## 2. 简单使用：播放单个动画\n* PlayableGraph的AnimationOutput依然是基于Animator组件的，不过你可以不用关心它了。\n* 主要实现目的是可以不创建animationcontroller，用代码实现其中的一些功能\n\n``` csharp\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n \npublic class PlayClipOnObject : MonoBehaviour\n{\n   public AnimationClip myClip;\n   private PlayableGraph graph;\n \n   void Start () {\n      PlayAnimation(gameObject, myClip);\n   }\n   \n   public void PlayAnimation(GameObject target, AnimationClip clip) {\n      // Create the PlayableGraph, which is the root of the Playable API stuff\n      graph = PlayableGraph.Create();\n \n      //We need an Animator to play stuff, even if we're not using an AnimatorController. So just add one:\n      var animator = target.AddComponent<Animator>();\n \n      //Wrap the clip in a thing the Playable system understands:\n      var clipPlayable = AnimationClipPlayable.Create(graph, clip);\n \n      //Create the output, and make the clip be the output's source. This API is a bit wordy :p\n      var animOutput = AnimationPlayableOutput.Create(graph, \"some name\", animator);\n      animOutput.SetSourcePlayable(clipPlayable);\n \n      //play the thing\n      graph.Play();\n    }\n \n   void OnDestroy()\n   {\n      // If you don't destroy the graph, it leaks in the engine (and Unity whines), so destroy it!\n      // IsValid will be false if the graph was never created (ie. this component is never enabled before it's destroyed)\n      if(graph.IsValid())\n         graph.Destroy();\n   }\n}\n```\n\n\n创建步骤：\n1. 创建Graph\n\n```csharp\nplayableGraph = PlayableGraph.Create();\n```\n2. 创建Ouput\n   \n\n``` csharp\nvar playableOutput = AnimationPlayableOutput.Create(playableGraph, \"Animation\", GetComponent<Animator>());\n```\n\n3. 为clip创建针对的Playable对象\n   \n\n``` csharp\n var clipPlayable = AnimationClipPlayable.Create(playableGraph, clip);\n```\n\n4. 设置playable对象到Output中\n   \n\n``` csharp\n playableOutput.SetSourcePlayable(clipPlayable);\n```\n\n5. 让Graph执行play\n   \n\n``` csharp\nplayableGraph.Play();\n```\n\n* 6. 需要在结束时销毁Graph对象\n  \n\n``` csharp\nplayableGraph.Play();\n```\n\n> Playable Output类型\n为了避免GC，所有类型都是使用struct实现的。\n构建PlayableGraph一般有如下的流程：\n\n创建一个PlayableGraph，方法是PlayableGraph.Create(\"graph的名字\")\n创建输出节点，常用的有\n``` csharp\nAnimationPlayableOutput.Create(playableGraph, \"name\", GetComponent<Animator>());\nAudioPlayableOutput.Create(playableGraph, \"name\", GetComponent<AudioSource>());\n```\n\n还可以创建自定义的输出节点\n\n\n创建各种playables。所有的Playable都有一个静态的Create()方法，用来创建playable实例。需要注意的是自定义的PlayableBehaviour需要使用\n``` csharp\nScriptPlayable<T>.Create(playableGraph);\n```\n来创建。\n\n``` csharp\nAnimationClipPlayable.Create(playableGraph, animationClip);\nAudioClipPlayable.Create(playableGraph, audioClip, true);\nScriptPlayable<T>.Create(playableGraph);\n```\n\n连接playable和output：PlayableOutput.SetSourcePlayable()\nplayable之间的连接：PlayableGraph.Connect()。\n播放graph：PlayableGraph.Play()\n如果graph不再使用，记得销毁：PlayableGraph.Destroy()。调用这个方法后会销毁所有的playbles和output。\n\n## 3. 替代AnimationController\n\n1. 创建混合树AnimationMixerPlayable，实现AnimationController之间连线控制功能：\n  \n\n``` csharp\nusing UnityEngine;\n\nusing UnityEngine.Playables;\n\nusing UnityEngine.Animations;\nusing UnityEngine.Experimental.Animations;\n\n[RequireComponent(typeof(Animator))]\n\npublic class PlayAnimationSample : MonoBehaviour\n\n{\n\n    public AnimationClip clip0;\n    public AnimationClip clip1;\n    \n    PlayableGraph playableGraph;\n    private AnimationMixerPlayable m_Mixer;\n\n    public float tranTime = 2;\n    private float leftTime;\n    \n    void Start()\n\n    {\n\n        playableGraph = PlayableGraph.Create(\"测试\");\n\n        playableGraph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);\n\n        var playableOutput = AnimationPlayableOutput.Create(playableGraph, \"Animation\", GetComponent<Animator>());\n\n        // Wrap the clip in a playable\n\n        m_Mixer = AnimationMixerPlayable.Create(playableGraph, 2);\n        \n        AnimationClipPlayable clipPlayable0 = AnimationClipPlayable.Create(playableGraph, clip0);\n        AnimationClipPlayable clipPlayable1 = AnimationClipPlayable.Create(playableGraph, clip1);\n\n        playableGraph.Connect(clipPlayable0, 0, m_Mixer, 0);\n        playableGraph.Connect(clipPlayable1, 0, m_Mixer, 1);\n        \n        m_Mixer.SetInputWeight(0,1);\n        m_Mixer.SetInputWeight(1,0);\n        // Connect the Playable to an output\n\n        playableOutput.SetSourcePlayable(m_Mixer);\n        playableOutput.SetSortingOrder(0);\n            \n            // Plays the Graph.\n        leftTime = tranTime;\n        playableGraph.Play();\n\n    }\n\n    void Update()\n    {\n        leftTime = Mathf.Clamp(leftTime - Time.deltaTime, 0, 2);\n        float weight = leftTime / tranTime;\n        Debug.Log(\"weight:\"+weight);\n        m_Mixer.SetInputWeight(0, 1 - weight);\n        m_Mixer.SetInputWeight(1, weight);\n    }\n    \n    void OnDestroy()\n    {\n        // Destroys all Playables and PlayableOutputs created by the graph.\n        playableGraph.Destroy();\n    }\n}\n```\n\n## 5. 实现自定义的PlayableBehaviour\n\n实现\n* 1.继承 PlayableBehaviour \n* 2.在初始化函数中传入graph, playable对象，分别为每个动画创建Playable并添加到mixer中，设置weight\n\n调用\n* 1.使用ScriptPlayable.Create创建自定义的Playable对象\n* 2.从Playable中获取behaviour并利用此behaviour调用初始化函数\n\n``` csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class CustomPlayable : PlayableBehaviour\n{\n    private int m_CurrentClipIndex = -1;\n    private float m_TimeToNextClip;\n    private Playable mixer;\n    public void Initialize(AnimationClip[] clipsToPlay, Playable owner, PlayableGraph graph)\n    {\n        owner.SetInputCount(1);\n        mixer = AnimationMixerPlayable.Create(graph, clipsToPlay.Length);\n        graph.Connect(mixer, 0, owner, 0);\n        owner.SetInputWeight(0, 1);\n        for (int clipIndex = 0 ; clipIndex < mixer.GetInputCount() ; ++clipIndex)\n        {\n            graph.Connect(AnimationClipPlayable.Create(graph, clipsToPlay[clipIndex]), 0, mixer, clipIndex);\n            mixer.SetInputWeight(clipIndex, 1.0f);\n        }\n    }\n    \n    override public void PrepareFrame(Playable owner, FrameData info)\n    {\n        if (mixer.GetInputCount() == 0)\n            return;\n        // Advance to next clip if necessary\n        m_TimeToNextClip -= (float)info.deltaTime;\n        if (m_TimeToNextClip <= 0.0f)\n        {\n            m_CurrentClipIndex++;\n            if (m_CurrentClipIndex >= mixer.GetInputCount())\n                m_CurrentClipIndex = 0;\n            var currentClip = (AnimationClipPlayable)mixer.GetInput(m_CurrentClipIndex);\n            // Reset the time so that the next clip starts at the correct position\n            currentClip.SetTime(0);\n            m_TimeToNextClip = currentClip.GetAnimationClip().length;\n        }\n        // Adjust the weight of the inputs\n        for (int clipIndex = 0 ; clipIndex < mixer.GetInputCount(); ++clipIndex)\n        {\n            if (clipIndex == m_CurrentClipIndex)\n                mixer.SetInputWeight(clipIndex, 1.0f);\n            else\n                mixer.SetInputWeight(clipIndex, 0.0f);\n        }\n    }\n}\n\n```\n\n``` csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class PlayCustomPlayableSample : MonoBehaviour\n{\n    public AnimationClip[] clipsToPlay;\n\n    PlayableGraph m_Graph;\n\n    void Start()\n    {\n        m_Graph = PlayableGraph.Create();\n        var custPlayable = ScriptPlayable<CustomPlayable>.Create(m_Graph);\n\n        var playQueue = custPlayable.GetBehaviour();\n\n        playQueue.Initialize(clipsToPlay, custPlayable, m_Graph);\n\n        var playableOutput = AnimationPlayableOutput.Create(m_Graph, \"Animation\", GetComponent<Animator>());\n\n        playableOutput.SetSourcePlayable(custPlayable);\n        playableOutput.SetSourceInputPort(0);\n\n        m_Graph.Play();\n    }\n\n    void OnDisable()\n\n    {\n\n        // Destroys all Playables and Outputs created by the graph.\n\n        m_Graph.Destroy();\n\n    }\n}\n\n```\n\n\n## 4. 工具：  PlayableGraph Visiualizer\n  * 停止更新于去年4月\n    \n>在场景中的Animator运行时，将自动映射动画到Visiualizer中显示\n>在创建好的PlayableGraph ，运行时也会在其中显示\n\n\n","slug":"Playable动画系统研究","published":1,"date":"2020-11-18T10:30:28.606Z","updated":"2020-11-18T10:30:28.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhng3etm0000taf0pu4kpvro","content":"<h2 id=\"1-Playable是什么\"><a href=\"#1-Playable是什么\" class=\"headerlink\" title=\"1. Playable是什么\"></a>1. Playable是什么</h2><p>Playable是一组API，可以用来组合、混合、修改多个数据源，然后通过一个输出，将这些数据源处理完的结果播放出来。</p>\n<h2 id=\"2-简单使用：播放单个动画\"><a href=\"#2-简单使用：播放单个动画\" class=\"headerlink\" title=\"2. 简单使用：播放单个动画\"></a>2. 简单使用：播放单个动画</h2><ul>\n<li>PlayableGraph的AnimationOutput依然是基于Animator组件的，不过你可以不用关心它了。</li>\n<li>主要实现目的是可以不创建animationcontroller，用代码实现其中的一些功能</li>\n</ul>\n<pre><code class=\"csharp\">using UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class PlayClipOnObject : MonoBehaviour\n{\n   public AnimationClip myClip;\n   private PlayableGraph graph;\n\n   void Start () {\n      PlayAnimation(gameObject, myClip);\n   }\n\n   public void PlayAnimation(GameObject target, AnimationClip clip) {\n      // Create the PlayableGraph, which is the root of the Playable API stuff\n      graph = PlayableGraph.Create();\n\n      //We need an Animator to play stuff, even if we&#39;re not using an AnimatorController. So just add one:\n      var animator = target.AddComponent&lt;Animator&gt;();\n\n      //Wrap the clip in a thing the Playable system understands:\n      var clipPlayable = AnimationClipPlayable.Create(graph, clip);\n\n      //Create the output, and make the clip be the output&#39;s source. This API is a bit wordy :p\n      var animOutput = AnimationPlayableOutput.Create(graph, &quot;some name&quot;, animator);\n      animOutput.SetSourcePlayable(clipPlayable);\n\n      //play the thing\n      graph.Play();\n    }\n\n   void OnDestroy()\n   {\n      // If you don&#39;t destroy the graph, it leaks in the engine (and Unity whines), so destroy it!\n      // IsValid will be false if the graph was never created (ie. this component is never enabled before it&#39;s destroyed)\n      if(graph.IsValid())\n         graph.Destroy();\n   }\n}</code></pre>\n<p>创建步骤：</p>\n<ol>\n<li>创建Graph</li>\n</ol>\n<pre><code class=\"csharp\">playableGraph = PlayableGraph.Create();</code></pre>\n<ol start=\"2\">\n<li>创建Ouput</li>\n</ol>\n<pre><code class=\"csharp\">var playableOutput = AnimationPlayableOutput.Create(playableGraph, &quot;Animation&quot;, GetComponent&lt;Animator&gt;());</code></pre>\n<ol start=\"3\">\n<li>为clip创建针对的Playable对象</li>\n</ol>\n<pre><code class=\"csharp\"> var clipPlayable = AnimationClipPlayable.Create(playableGraph, clip);</code></pre>\n<ol start=\"4\">\n<li>设置playable对象到Output中</li>\n</ol>\n<pre><code class=\"csharp\"> playableOutput.SetSourcePlayable(clipPlayable);</code></pre>\n<ol start=\"5\">\n<li>让Graph执行play</li>\n</ol>\n<pre><code class=\"csharp\">playableGraph.Play();</code></pre>\n<ul>\n<li><ol start=\"6\">\n<li>需要在结束时销毁Graph对象</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"csharp\">playableGraph.Play();</code></pre>\n<blockquote>\n<p>Playable Output类型<br>为了避免GC，所有类型都是使用struct实现的。<br>构建PlayableGraph一般有如下的流程：</p>\n</blockquote>\n<p>创建一个PlayableGraph，方法是PlayableGraph.Create(“graph的名字”)<br>创建输出节点，常用的有</p>\n<pre><code class=\"csharp\">AnimationPlayableOutput.Create(playableGraph, &quot;name&quot;, GetComponent&lt;Animator&gt;());\nAudioPlayableOutput.Create(playableGraph, &quot;name&quot;, GetComponent&lt;AudioSource&gt;());</code></pre>\n<p>还可以创建自定义的输出节点</p>\n<p>创建各种playables。所有的Playable都有一个静态的Create()方法，用来创建playable实例。需要注意的是自定义的PlayableBehaviour需要使用</p>\n<pre><code class=\"csharp\">ScriptPlayable&lt;T&gt;.Create(playableGraph);</code></pre>\n<p>来创建。</p>\n<pre><code class=\"csharp\">AnimationClipPlayable.Create(playableGraph, animationClip);\nAudioClipPlayable.Create(playableGraph, audioClip, true);\nScriptPlayable&lt;T&gt;.Create(playableGraph);</code></pre>\n<p>连接playable和output：PlayableOutput.SetSourcePlayable()<br>playable之间的连接：PlayableGraph.Connect()。<br>播放graph：PlayableGraph.Play()<br>如果graph不再使用，记得销毁：PlayableGraph.Destroy()。调用这个方法后会销毁所有的playbles和output。</p>\n<h2 id=\"3-替代AnimationController\"><a href=\"#3-替代AnimationController\" class=\"headerlink\" title=\"3. 替代AnimationController\"></a>3. 替代AnimationController</h2><ol>\n<li>创建混合树AnimationMixerPlayable，实现AnimationController之间连线控制功能：</li>\n</ol>\n<pre><code class=\"csharp\">using UnityEngine;\n\nusing UnityEngine.Playables;\n\nusing UnityEngine.Animations;\nusing UnityEngine.Experimental.Animations;\n\n[RequireComponent(typeof(Animator))]\n\npublic class PlayAnimationSample : MonoBehaviour\n\n{\n\n    public AnimationClip clip0;\n    public AnimationClip clip1;\n\n    PlayableGraph playableGraph;\n    private AnimationMixerPlayable m_Mixer;\n\n    public float tranTime = 2;\n    private float leftTime;\n\n    void Start()\n\n    {\n\n        playableGraph = PlayableGraph.Create(&quot;测试&quot;);\n\n        playableGraph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);\n\n        var playableOutput = AnimationPlayableOutput.Create(playableGraph, &quot;Animation&quot;, GetComponent&lt;Animator&gt;());\n\n        // Wrap the clip in a playable\n\n        m_Mixer = AnimationMixerPlayable.Create(playableGraph, 2);\n\n        AnimationClipPlayable clipPlayable0 = AnimationClipPlayable.Create(playableGraph, clip0);\n        AnimationClipPlayable clipPlayable1 = AnimationClipPlayable.Create(playableGraph, clip1);\n\n        playableGraph.Connect(clipPlayable0, 0, m_Mixer, 0);\n        playableGraph.Connect(clipPlayable1, 0, m_Mixer, 1);\n\n        m_Mixer.SetInputWeight(0,1);\n        m_Mixer.SetInputWeight(1,0);\n        // Connect the Playable to an output\n\n        playableOutput.SetSourcePlayable(m_Mixer);\n        playableOutput.SetSortingOrder(0);\n\n            // Plays the Graph.\n        leftTime = tranTime;\n        playableGraph.Play();\n\n    }\n\n    void Update()\n    {\n        leftTime = Mathf.Clamp(leftTime - Time.deltaTime, 0, 2);\n        float weight = leftTime / tranTime;\n        Debug.Log(&quot;weight:&quot;+weight);\n        m_Mixer.SetInputWeight(0, 1 - weight);\n        m_Mixer.SetInputWeight(1, weight);\n    }\n\n    void OnDestroy()\n    {\n        // Destroys all Playables and PlayableOutputs created by the graph.\n        playableGraph.Destroy();\n    }\n}</code></pre>\n<h2 id=\"5-实现自定义的PlayableBehaviour\"><a href=\"#5-实现自定义的PlayableBehaviour\" class=\"headerlink\" title=\"5. 实现自定义的PlayableBehaviour\"></a>5. 实现自定义的PlayableBehaviour</h2><p>实现</p>\n<ul>\n<li>1.继承 PlayableBehaviour </li>\n<li>2.在初始化函数中传入graph, playable对象，分别为每个动画创建Playable并添加到mixer中，设置weight</li>\n</ul>\n<p>调用</p>\n<ul>\n<li>1.使用ScriptPlayable.Create创建自定义的Playable对象</li>\n<li>2.从Playable中获取behaviour并利用此behaviour调用初始化函数</li>\n</ul>\n<pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class CustomPlayable : PlayableBehaviour\n{\n    private int m_CurrentClipIndex = -1;\n    private float m_TimeToNextClip;\n    private Playable mixer;\n    public void Initialize(AnimationClip[] clipsToPlay, Playable owner, PlayableGraph graph)\n    {\n        owner.SetInputCount(1);\n        mixer = AnimationMixerPlayable.Create(graph, clipsToPlay.Length);\n        graph.Connect(mixer, 0, owner, 0);\n        owner.SetInputWeight(0, 1);\n        for (int clipIndex = 0 ; clipIndex &lt; mixer.GetInputCount() ; ++clipIndex)\n        {\n            graph.Connect(AnimationClipPlayable.Create(graph, clipsToPlay[clipIndex]), 0, mixer, clipIndex);\n            mixer.SetInputWeight(clipIndex, 1.0f);\n        }\n    }\n\n    override public void PrepareFrame(Playable owner, FrameData info)\n    {\n        if (mixer.GetInputCount() == 0)\n            return;\n        // Advance to next clip if necessary\n        m_TimeToNextClip -= (float)info.deltaTime;\n        if (m_TimeToNextClip &lt;= 0.0f)\n        {\n            m_CurrentClipIndex++;\n            if (m_CurrentClipIndex &gt;= mixer.GetInputCount())\n                m_CurrentClipIndex = 0;\n            var currentClip = (AnimationClipPlayable)mixer.GetInput(m_CurrentClipIndex);\n            // Reset the time so that the next clip starts at the correct position\n            currentClip.SetTime(0);\n            m_TimeToNextClip = currentClip.GetAnimationClip().length;\n        }\n        // Adjust the weight of the inputs\n        for (int clipIndex = 0 ; clipIndex &lt; mixer.GetInputCount(); ++clipIndex)\n        {\n            if (clipIndex == m_CurrentClipIndex)\n                mixer.SetInputWeight(clipIndex, 1.0f);\n            else\n                mixer.SetInputWeight(clipIndex, 0.0f);\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class PlayCustomPlayableSample : MonoBehaviour\n{\n    public AnimationClip[] clipsToPlay;\n\n    PlayableGraph m_Graph;\n\n    void Start()\n    {\n        m_Graph = PlayableGraph.Create();\n        var custPlayable = ScriptPlayable&lt;CustomPlayable&gt;.Create(m_Graph);\n\n        var playQueue = custPlayable.GetBehaviour();\n\n        playQueue.Initialize(clipsToPlay, custPlayable, m_Graph);\n\n        var playableOutput = AnimationPlayableOutput.Create(m_Graph, &quot;Animation&quot;, GetComponent&lt;Animator&gt;());\n\n        playableOutput.SetSourcePlayable(custPlayable);\n        playableOutput.SetSourceInputPort(0);\n\n        m_Graph.Play();\n    }\n\n    void OnDisable()\n\n    {\n\n        // Destroys all Playables and Outputs created by the graph.\n\n        m_Graph.Destroy();\n\n    }\n}\n</code></pre>\n<h2 id=\"4-工具：-PlayableGraph-Visiualizer\"><a href=\"#4-工具：-PlayableGraph-Visiualizer\" class=\"headerlink\" title=\"4. 工具：  PlayableGraph Visiualizer\"></a>4. 工具：  PlayableGraph Visiualizer</h2><ul>\n<li>停止更新于去年4月</li>\n</ul>\n<blockquote>\n<p>在场景中的Animator运行时，将自动映射动画到Visiualizer中显示<br>在创建好的PlayableGraph ，运行时也会在其中显示</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Playable是什么\"><a href=\"#1-Playable是什么\" class=\"headerlink\" title=\"1. Playable是什么\"></a>1. Playable是什么</h2><p>Playable是一组API，可以用来组合、混合、修改多个数据源，然后通过一个输出，将这些数据源处理完的结果播放出来。</p>\n<h2 id=\"2-简单使用：播放单个动画\"><a href=\"#2-简单使用：播放单个动画\" class=\"headerlink\" title=\"2. 简单使用：播放单个动画\"></a>2. 简单使用：播放单个动画</h2><ul>\n<li>PlayableGraph的AnimationOutput依然是基于Animator组件的，不过你可以不用关心它了。</li>\n<li>主要实现目的是可以不创建animationcontroller，用代码实现其中的一些功能</li>\n</ul>\n<pre><code class=\"csharp\">using UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class PlayClipOnObject : MonoBehaviour\n{\n   public AnimationClip myClip;\n   private PlayableGraph graph;\n\n   void Start () {\n      PlayAnimation(gameObject, myClip);\n   }\n\n   public void PlayAnimation(GameObject target, AnimationClip clip) {\n      // Create the PlayableGraph, which is the root of the Playable API stuff\n      graph = PlayableGraph.Create();\n\n      //We need an Animator to play stuff, even if we&#39;re not using an AnimatorController. So just add one:\n      var animator = target.AddComponent&lt;Animator&gt;();\n\n      //Wrap the clip in a thing the Playable system understands:\n      var clipPlayable = AnimationClipPlayable.Create(graph, clip);\n\n      //Create the output, and make the clip be the output&#39;s source. This API is a bit wordy :p\n      var animOutput = AnimationPlayableOutput.Create(graph, &quot;some name&quot;, animator);\n      animOutput.SetSourcePlayable(clipPlayable);\n\n      //play the thing\n      graph.Play();\n    }\n\n   void OnDestroy()\n   {\n      // If you don&#39;t destroy the graph, it leaks in the engine (and Unity whines), so destroy it!\n      // IsValid will be false if the graph was never created (ie. this component is never enabled before it&#39;s destroyed)\n      if(graph.IsValid())\n         graph.Destroy();\n   }\n}</code></pre>\n<p>创建步骤：</p>\n<ol>\n<li>创建Graph</li>\n</ol>\n<pre><code class=\"csharp\">playableGraph = PlayableGraph.Create();</code></pre>\n<ol start=\"2\">\n<li>创建Ouput</li>\n</ol>\n<pre><code class=\"csharp\">var playableOutput = AnimationPlayableOutput.Create(playableGraph, &quot;Animation&quot;, GetComponent&lt;Animator&gt;());</code></pre>\n<ol start=\"3\">\n<li>为clip创建针对的Playable对象</li>\n</ol>\n<pre><code class=\"csharp\"> var clipPlayable = AnimationClipPlayable.Create(playableGraph, clip);</code></pre>\n<ol start=\"4\">\n<li>设置playable对象到Output中</li>\n</ol>\n<pre><code class=\"csharp\"> playableOutput.SetSourcePlayable(clipPlayable);</code></pre>\n<ol start=\"5\">\n<li>让Graph执行play</li>\n</ol>\n<pre><code class=\"csharp\">playableGraph.Play();</code></pre>\n<ul>\n<li><ol start=\"6\">\n<li>需要在结束时销毁Graph对象</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"csharp\">playableGraph.Play();</code></pre>\n<blockquote>\n<p>Playable Output类型<br>为了避免GC，所有类型都是使用struct实现的。<br>构建PlayableGraph一般有如下的流程：</p>\n</blockquote>\n<p>创建一个PlayableGraph，方法是PlayableGraph.Create(“graph的名字”)<br>创建输出节点，常用的有</p>\n<pre><code class=\"csharp\">AnimationPlayableOutput.Create(playableGraph, &quot;name&quot;, GetComponent&lt;Animator&gt;());\nAudioPlayableOutput.Create(playableGraph, &quot;name&quot;, GetComponent&lt;AudioSource&gt;());</code></pre>\n<p>还可以创建自定义的输出节点</p>\n<p>创建各种playables。所有的Playable都有一个静态的Create()方法，用来创建playable实例。需要注意的是自定义的PlayableBehaviour需要使用</p>\n<pre><code class=\"csharp\">ScriptPlayable&lt;T&gt;.Create(playableGraph);</code></pre>\n<p>来创建。</p>\n<pre><code class=\"csharp\">AnimationClipPlayable.Create(playableGraph, animationClip);\nAudioClipPlayable.Create(playableGraph, audioClip, true);\nScriptPlayable&lt;T&gt;.Create(playableGraph);</code></pre>\n<p>连接playable和output：PlayableOutput.SetSourcePlayable()<br>playable之间的连接：PlayableGraph.Connect()。<br>播放graph：PlayableGraph.Play()<br>如果graph不再使用，记得销毁：PlayableGraph.Destroy()。调用这个方法后会销毁所有的playbles和output。</p>\n<h2 id=\"3-替代AnimationController\"><a href=\"#3-替代AnimationController\" class=\"headerlink\" title=\"3. 替代AnimationController\"></a>3. 替代AnimationController</h2><ol>\n<li>创建混合树AnimationMixerPlayable，实现AnimationController之间连线控制功能：</li>\n</ol>\n<pre><code class=\"csharp\">using UnityEngine;\n\nusing UnityEngine.Playables;\n\nusing UnityEngine.Animations;\nusing UnityEngine.Experimental.Animations;\n\n[RequireComponent(typeof(Animator))]\n\npublic class PlayAnimationSample : MonoBehaviour\n\n{\n\n    public AnimationClip clip0;\n    public AnimationClip clip1;\n\n    PlayableGraph playableGraph;\n    private AnimationMixerPlayable m_Mixer;\n\n    public float tranTime = 2;\n    private float leftTime;\n\n    void Start()\n\n    {\n\n        playableGraph = PlayableGraph.Create(&quot;测试&quot;);\n\n        playableGraph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);\n\n        var playableOutput = AnimationPlayableOutput.Create(playableGraph, &quot;Animation&quot;, GetComponent&lt;Animator&gt;());\n\n        // Wrap the clip in a playable\n\n        m_Mixer = AnimationMixerPlayable.Create(playableGraph, 2);\n\n        AnimationClipPlayable clipPlayable0 = AnimationClipPlayable.Create(playableGraph, clip0);\n        AnimationClipPlayable clipPlayable1 = AnimationClipPlayable.Create(playableGraph, clip1);\n\n        playableGraph.Connect(clipPlayable0, 0, m_Mixer, 0);\n        playableGraph.Connect(clipPlayable1, 0, m_Mixer, 1);\n\n        m_Mixer.SetInputWeight(0,1);\n        m_Mixer.SetInputWeight(1,0);\n        // Connect the Playable to an output\n\n        playableOutput.SetSourcePlayable(m_Mixer);\n        playableOutput.SetSortingOrder(0);\n\n            // Plays the Graph.\n        leftTime = tranTime;\n        playableGraph.Play();\n\n    }\n\n    void Update()\n    {\n        leftTime = Mathf.Clamp(leftTime - Time.deltaTime, 0, 2);\n        float weight = leftTime / tranTime;\n        Debug.Log(&quot;weight:&quot;+weight);\n        m_Mixer.SetInputWeight(0, 1 - weight);\n        m_Mixer.SetInputWeight(1, weight);\n    }\n\n    void OnDestroy()\n    {\n        // Destroys all Playables and PlayableOutputs created by the graph.\n        playableGraph.Destroy();\n    }\n}</code></pre>\n<h2 id=\"5-实现自定义的PlayableBehaviour\"><a href=\"#5-实现自定义的PlayableBehaviour\" class=\"headerlink\" title=\"5. 实现自定义的PlayableBehaviour\"></a>5. 实现自定义的PlayableBehaviour</h2><p>实现</p>\n<ul>\n<li>1.继承 PlayableBehaviour </li>\n<li>2.在初始化函数中传入graph, playable对象，分别为每个动画创建Playable并添加到mixer中，设置weight</li>\n</ul>\n<p>调用</p>\n<ul>\n<li>1.使用ScriptPlayable.Create创建自定义的Playable对象</li>\n<li>2.从Playable中获取behaviour并利用此behaviour调用初始化函数</li>\n</ul>\n<pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class CustomPlayable : PlayableBehaviour\n{\n    private int m_CurrentClipIndex = -1;\n    private float m_TimeToNextClip;\n    private Playable mixer;\n    public void Initialize(AnimationClip[] clipsToPlay, Playable owner, PlayableGraph graph)\n    {\n        owner.SetInputCount(1);\n        mixer = AnimationMixerPlayable.Create(graph, clipsToPlay.Length);\n        graph.Connect(mixer, 0, owner, 0);\n        owner.SetInputWeight(0, 1);\n        for (int clipIndex = 0 ; clipIndex &lt; mixer.GetInputCount() ; ++clipIndex)\n        {\n            graph.Connect(AnimationClipPlayable.Create(graph, clipsToPlay[clipIndex]), 0, mixer, clipIndex);\n            mixer.SetInputWeight(clipIndex, 1.0f);\n        }\n    }\n\n    override public void PrepareFrame(Playable owner, FrameData info)\n    {\n        if (mixer.GetInputCount() == 0)\n            return;\n        // Advance to next clip if necessary\n        m_TimeToNextClip -= (float)info.deltaTime;\n        if (m_TimeToNextClip &lt;= 0.0f)\n        {\n            m_CurrentClipIndex++;\n            if (m_CurrentClipIndex &gt;= mixer.GetInputCount())\n                m_CurrentClipIndex = 0;\n            var currentClip = (AnimationClipPlayable)mixer.GetInput(m_CurrentClipIndex);\n            // Reset the time so that the next clip starts at the correct position\n            currentClip.SetTime(0);\n            m_TimeToNextClip = currentClip.GetAnimationClip().length;\n        }\n        // Adjust the weight of the inputs\n        for (int clipIndex = 0 ; clipIndex &lt; mixer.GetInputCount(); ++clipIndex)\n        {\n            if (clipIndex == m_CurrentClipIndex)\n                mixer.SetInputWeight(clipIndex, 1.0f);\n            else\n                mixer.SetInputWeight(clipIndex, 0.0f);\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Animations;\nusing UnityEngine.Playables;\n\npublic class PlayCustomPlayableSample : MonoBehaviour\n{\n    public AnimationClip[] clipsToPlay;\n\n    PlayableGraph m_Graph;\n\n    void Start()\n    {\n        m_Graph = PlayableGraph.Create();\n        var custPlayable = ScriptPlayable&lt;CustomPlayable&gt;.Create(m_Graph);\n\n        var playQueue = custPlayable.GetBehaviour();\n\n        playQueue.Initialize(clipsToPlay, custPlayable, m_Graph);\n\n        var playableOutput = AnimationPlayableOutput.Create(m_Graph, &quot;Animation&quot;, GetComponent&lt;Animator&gt;());\n\n        playableOutput.SetSourcePlayable(custPlayable);\n        playableOutput.SetSourceInputPort(0);\n\n        m_Graph.Play();\n    }\n\n    void OnDisable()\n\n    {\n\n        // Destroys all Playables and Outputs created by the graph.\n\n        m_Graph.Destroy();\n\n    }\n}\n</code></pre>\n<h2 id=\"4-工具：-PlayableGraph-Visiualizer\"><a href=\"#4-工具：-PlayableGraph-Visiualizer\" class=\"headerlink\" title=\"4. 工具：  PlayableGraph Visiualizer\"></a>4. 工具：  PlayableGraph Visiualizer</h2><ul>\n<li>停止更新于去年4月</li>\n</ul>\n<blockquote>\n<p>在场景中的Animator运行时，将自动映射动画到Visiualizer中显示<br>在创建好的PlayableGraph ，运行时也会在其中显示</p>\n</blockquote>\n"},{"title":"腾讯云开发-使用Unity开发服务器逻辑并自动部署","_content":"\n![联机功能简述](/img/1605700406892.png)\n\n\n## 客户端\n![客户端接收函数](/img/1605700473654.png)\n\n## 服务端\n\n![核心价值](/img/1605701291767.png)\n\n![应用场景](/img/1605701305959.png)\n\n![场景服务](/img/1605701442216.png)","source":"_posts/腾讯云开发-使用Unity开发服务器逻辑并自动部署.md","raw":"---\ntitle: 腾讯云开发-使用Unity开发服务器逻辑并自动部署\ncategories:\n- Unity学习\ntags: \n- Unity学习\n---\n\n![联机功能简述](/img/1605700406892.png)\n\n\n## 客户端\n![客户端接收函数](/img/1605700473654.png)\n\n## 服务端\n\n![核心价值](/img/1605701291767.png)\n\n![应用场景](/img/1605701305959.png)\n\n![场景服务](/img/1605701442216.png)","slug":"腾讯云开发-使用Unity开发服务器逻辑并自动部署","published":1,"date":"2020-11-18T13:32:05.383Z","updated":"2020-11-18T13:32:05.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhng3eu50001taf00vnayg5a","content":"<p><img src=\"/img/1605700406892.png\" alt=\"联机功能简述\"></p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p><img src=\"/img/1605700473654.png\" alt=\"客户端接收函数\"></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p><img src=\"/img/1605701291767.png\" alt=\"核心价值\"></p>\n<p><img src=\"/img/1605701305959.png\" alt=\"应用场景\"></p>\n<p><img src=\"/img/1605701442216.png\" alt=\"场景服务\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/img/1605700406892.png\" alt=\"联机功能简述\"></p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p><img src=\"/img/1605700473654.png\" alt=\"客户端接收函数\"></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p><img src=\"/img/1605701291767.png\" alt=\"核心价值\"></p>\n<p><img src=\"/img/1605701305959.png\" alt=\"应用场景\"></p>\n<p><img src=\"/img/1605701442216.png\" alt=\"场景服务\"></p>\n"},{"title":"ECSSamples研究","_content":"\n## FixedTimestepSystemUpdate \n\n![FixedTimestepSystemUpdate结构分析](/img/1606017767279.png)\n\n\n## VirtualMemory\n\n![VirtualMemory结构分析](/img/1606017719921.png)\n\n\n\n## SubsceneWithBuildConfigurations\n![SubsceneWithBuildConfigurations结构分析](img/1606017848540.png)","source":"_posts/ECSSamples研究.md","raw":"---\ntitle: ECSSamples研究\ncategories:\n- Unity学习\ntags: \n- Unity学习\n---\n\n## FixedTimestepSystemUpdate \n\n![FixedTimestepSystemUpdate结构分析](/img/1606017767279.png)\n\n\n## VirtualMemory\n\n![VirtualMemory结构分析](/img/1606017719921.png)\n\n\n\n## SubsceneWithBuildConfigurations\n![SubsceneWithBuildConfigurations结构分析](img/1606017848540.png)","slug":"ECSSamples研究","published":1,"date":"2020-12-18T04:25:18.340Z","updated":"2020-12-18T04:25:18.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckitrsiij00013wf0xqg3afv0","content":"<h2 id=\"FixedTimestepSystemUpdate\"><a href=\"#FixedTimestepSystemUpdate\" class=\"headerlink\" title=\"FixedTimestepSystemUpdate\"></a>FixedTimestepSystemUpdate</h2><p><img src=\"/img/1606017767279.png\" alt=\"FixedTimestepSystemUpdate结构分析\"></p>\n<h2 id=\"VirtualMemory\"><a href=\"#VirtualMemory\" class=\"headerlink\" title=\"VirtualMemory\"></a>VirtualMemory</h2><p><img src=\"/img/1606017719921.png\" alt=\"VirtualMemory结构分析\"></p>\n<h2 id=\"SubsceneWithBuildConfigurations\"><a href=\"#SubsceneWithBuildConfigurations\" class=\"headerlink\" title=\"SubsceneWithBuildConfigurations\"></a>SubsceneWithBuildConfigurations</h2><p><img src=\"img/1606017848540.png\" alt=\"SubsceneWithBuildConfigurations结构分析\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"FixedTimestepSystemUpdate\"><a href=\"#FixedTimestepSystemUpdate\" class=\"headerlink\" title=\"FixedTimestepSystemUpdate\"></a>FixedTimestepSystemUpdate</h2><p><img src=\"/img/1606017767279.png\" alt=\"FixedTimestepSystemUpdate结构分析\"></p>\n<h2 id=\"VirtualMemory\"><a href=\"#VirtualMemory\" class=\"headerlink\" title=\"VirtualMemory\"></a>VirtualMemory</h2><p><img src=\"/img/1606017719921.png\" alt=\"VirtualMemory结构分析\"></p>\n<h2 id=\"SubsceneWithBuildConfigurations\"><a href=\"#SubsceneWithBuildConfigurations\" class=\"headerlink\" title=\"SubsceneWithBuildConfigurations\"></a>SubsceneWithBuildConfigurations</h2><p><img src=\"img/1606017848540.png\" alt=\"SubsceneWithBuildConfigurations结构分析\"></p>\n"},{"title":"Unity内存剖析","_content":"\n\n本文欢迎转载，但烦请保留此行出处信息：https://www.onevcat.com/2012/11/memory-in-unity3d/\n\nUnity3D在内存占用上一直被人诟病，特别是对于面向移动设备的游戏开发，动辄内存占用飙上一两百兆，导致内存资源耗尽，从而被系统强退造成极差的体验。类似这种情况并不少见，但是绝大部分都是可以避免的。虽然理论上Unity的内存管理系统应当为开发者分忧解难，让大家投身到更有意义的事情中去，但是对于Unity对内存的管理方式，官方文档中并没有太多的说明，基本需要依靠自己摸索。最近在接手的项目中存在严重的内存问题，在参照文档和Unity Answer众多猜测和证实之后，稍微总结了下Unity中的内存的分配和管理的基本方式，在此共享。\n\n虽然Unity标榜自己的内存使用全都是“Managed Memory”，但是事实上你必须正确地使用内存，以保证回收机制正确运行。如果没有做应当做的事情，那么场景和代码很有可能造成很多非必要内存的占用，这也是很多Unity开发者抱怨内存占用太大的原因。接下来我会介绍Unity使用内存的种类，以及相应每个种类的优化和使用的技巧。遵循使用原则，可以让非必要资源尽快得到释放，从而降低内存占用。\n\n## Unity中的内存种类\n实际上Unity游戏使用的内存一共有三种：程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。\n\n程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库，稍后再说。\n\n托管堆是被Mono使用的一部分内存。Mono项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。\n\n最后，本机堆是Unity引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。\n\n## 优化程序代码的内存占用\n这部分的优化相对简单，因为能做的事情并不多：主要就是减少打包时的引用库，改一改build设置即可。对于一个新项目来说不会有太大问题，但是如果是已经存在的项目，可能改变会导致原来所需要的库的缺失（虽说一般来说这种可能性不大），因此有可能无法做到最优。\n\n\n\n当使用Unity开发时，默认的Mono包含库可以说大部分用不上，在Player Setting（Edit->Project Setting->;Player或者Shift+Ctrl(Command)+B里的Player Setting按钮）面板里，将最下方的Optimization栏目中“Api Compatibility Level”选为.NET 2.0 Subset，表示你只会使用到部分的.NET 2.0 Subset，不需要Unity将全部.NET的Api包含进去。接下来的“Stripping Level”表示从build的库中剥离的力度，每一个剥离选项都将从打包好的库中去掉一部分内容。你需要保证你的代码没有用到这部分被剥离的功能，选为“Use micro mscorlib”的话将使用最小的库（一般来说也没啥问题，不行的话可以试试之前的两个）。库剥离可以极大地降低打包后的程序的尺寸以及程序代码的内存占用，唯一的缺点是这个功能只支持Pro版的Unity。\n\n这部分优化的力度需要根据代码所用到的.NET的功能来进行调整，有可能不能使用Subset或者最大的剥离力度。如果超出了限度，很可能会在需要该功能时因为找不到相应的库而crash掉（iOS的话很可能在Xcode编译时就报错了）。比较好地解决方案是仍然用最强的剥离，并辅以较小的第三方的类库来完成所需功能。一个最常见问题是最大剥离时Sysytem.Xml是不被Subset和micro支持的，如果只是为了xml，完全可以导入一个轻量级的xml库来解决依赖（Unity官方推荐这个）。\n\n关于每个设定对应支持的库的详细列表，可以在这里找到。关于每个剥离级别到底做了什么，Unity的文档也有说明。实际上，在游戏开发中绝大多数被剥离的功能使用不上的，因此不管如何，库剥离的优化方法都值得一试。\n\n## 托管堆优化\nUnity有一篇不错的关于托管堆代码如何写比较好的说明，在此基础上我个人有一些补充。\n\n首先需要明确，托管堆中存储的是你在你的代码中申请的内存（不论是用js，C#还是Boo写的）。一般来说，无非是new或者Instantiate两种生成object的方法（事实上Instantiate中也是调用了new）。在接收到alloc请求后，托管堆在其上为要新生成的对象实例以及其实例变量分配内存，如果可用空间不足，则向系统申请更多空间。\n\n当你使用完一个实例对象之后，通常来说在脚本中就不会再有对该对象的引用了（这包括将变量设置为null或其他引用，超出了变量的作用域，或者对Unity对象发送Destory()）。在每隔一段时间，Mono的垃圾回收机制将检测内存，将没有再被引用的内存释放回收。总的来说，你要做的就是在尽可能早的时间将不需要的引用去除掉，这样回收机制才能正确地把不需要的内存清理出来。但是需要注意在内存清理时有可能造成游戏的短时间卡顿，这将会很影响游戏体验，因此如果有大量的内存回收工作要进行的话，需要尽量选择合适的时间。\n\n如果在你的游戏里，有特别多的类似实例，并需要对它们经常发送Destroy()的话，游戏性能上会相当难看。比如小熊推金币中的金币实例，按理说每枚金币落下台子后都需要对其Destory()，然后新的金币进入台子时又需要Instantiate，这对性能是极大的浪费。一种通常的做法是在不需要时，不摧毁这个GameObject，而只是隐藏它，并将其放入一个重用数组中。之后需要时，再从重用数组中找到可用的实例并显示。这将极大地改善游戏的性能，相应的代价是消耗部分内存，一般来说这是可以接受的。关于对象重用，可以参考Unity关于内存方面的文档中Reusable Object Pools部分，或者Prime31有一个是用Linq来建立重用池的视频教程（Youtube，需要翻墙，上半部分，下半部分）。\n\n如果不是必要，应该在游戏进行的过程中尽量减少对GameObject的Instantiate()和Destroy()调用，因为对计算资源会有很大消耗。在便携设备上短时间大量生成和摧毁物体的话，很容易造成瞬时卡顿。如果内存没有问题的话，尽量选择先将他们收集起来，然后在合适的时候（比如按暂停键或者是关卡切换），将它们批量地销毁并且回收内存。Mono的内存回收会在后台自动进行，系统会选择合适的时间进行垃圾回收。在合适的时候，也可以手动地调用System.GC.Collect()来建议系统进行一次垃圾回收。要注意的是这里的调用真的仅仅只是建议，可能系统会在一段时间后在进行回收，也可能完全不理会这条请求，不过在大部分时间里，这个调用还是靠谱的。\n\n## 本机堆的优化\n当你加载完成一个Unity的scene的时候，scene中的所有用到的asset（包括Hierarchy中所有GameObject上以及脚本中赋值了的的材质，贴图，动画，声音等素材），都会被自动加载（这正是Unity的智能之处）。也就是说，当关卡呈现在用户面前的时候，所有Unity编辑器能认识的本关卡的资源都已经被预先加入内存了，这样在本关卡中，用户将有良好的体验，不论是更换贴图，声音，还是播放动画时，都不会有额外的加载，这样的代价是内存占用将变多。Unity最初的设计目的还是面向台式机，几乎无限的内存和虚拟内存使得这样的占用似乎不是问题，但是这样的内存策略在之后移动平台的兴起和大量移动设备游戏的制作中出现了弊端，因为移动设备能使用的资源始终非常有限。因此在面向移动设备游戏的制作时，尽量减少在Hierarchy对资源的直接引用，而是使用Resource.Load的方法，在需要的时候从硬盘中读取资源，在使用后用Resource.UnloadAsset()和Resources.UnloadUnusedAssets()尽快将其卸载掉。总之，这里是一个处理时间和占用内存空间的trade off，如何达到最好的效果没有标准答案，需要自己权衡。\n\n在关卡结束的时候，这个关卡中所使用的所有资源将会被卸载掉（除非被标记了DontDestroyOnLoad）的资源。注意不仅是DontDestroyOnLoad的资源本身，其相关的所有资源在关卡切换时都不会被卸载。DontDestroyOnLoad一般被用来在关卡之间保存一些玩家的状态，比如分数，级别等偏向文本的信息。如果DontDestroyOnLoad了一个包含很多资源（比如大量贴图或者声音等大内存占用的东西）的话，这部分资源在场景切换时无法卸载，将一直占用内存，这种情况应该尽量避免。\n\n另外一种需要注意的情况是脚本中对资源的引用。大部分脚本将在场景转换时随之失效并被回收，但是，在场景之间被保持的脚本不在此列（通常情况是被附着在DontDestroyOnLoad的GameObject上了）。而这些脚本很可能含有对其他物体的Component或者资源的引用，这样相关的资源就都得不到释放，这绝对是不想要的情况。另外，static的单例（singleton）在场景切换时也不会被摧毁，同样地，如果这种单例含有大量的对资源的引用，也会成为大问题。因此，尽量减少代码的耦合和对其他脚本的依赖是十分有必要的。如果确实无法避免这种情况，那应当手动地对这些不再使用的引用对象调用Destroy()或者将其设置为null。这样在垃圾回收的时候，这些内存将被认为已经无用而被回收。\n\n需要注意的是，Unity在一个场景开始时，根据场景构成和引用关系所自动读取的资源，只有在读取一个新的场景或者reset当前场景时，才会得到清理。因此这部分内存占用是不可避免的。在小内存环境中，这部分初始内存的占用十分重要，因为它决定了你的关卡是否能够被正常加载。因此在计算资源充足或是关卡开始之后还有机会进行加载时，尽量减少Hierarchy中的引用，变为手动用Resource.Load，将大大减少内存占用。在Resource.UnloadAsset()和Resources.UnloadUnusedAssets()时，只有那些真正没有任何引用指向的资源会被回收，因此请确保在资源不再使用时，将所有对该资源的引用设置为null或者Destroy。同样需要注意，这两个Unload方法仅仅对Resource.Load拿到的资源有效，而不能回收任何场景开始时自动加载的资源。与此类似的还有AssetBundle的Load和Unload方法，灵活使用这些手动自愿加载和卸载的方法，是优化Unity内存占用的不二法则～","source":"_posts/Unity内存剖析.md","raw":"---\ntitle: Unity内存剖析\ncategories:\n- Unity\n---\n\n\n本文欢迎转载，但烦请保留此行出处信息：https://www.onevcat.com/2012/11/memory-in-unity3d/\n\nUnity3D在内存占用上一直被人诟病，特别是对于面向移动设备的游戏开发，动辄内存占用飙上一两百兆，导致内存资源耗尽，从而被系统强退造成极差的体验。类似这种情况并不少见，但是绝大部分都是可以避免的。虽然理论上Unity的内存管理系统应当为开发者分忧解难，让大家投身到更有意义的事情中去，但是对于Unity对内存的管理方式，官方文档中并没有太多的说明，基本需要依靠自己摸索。最近在接手的项目中存在严重的内存问题，在参照文档和Unity Answer众多猜测和证实之后，稍微总结了下Unity中的内存的分配和管理的基本方式，在此共享。\n\n虽然Unity标榜自己的内存使用全都是“Managed Memory”，但是事实上你必须正确地使用内存，以保证回收机制正确运行。如果没有做应当做的事情，那么场景和代码很有可能造成很多非必要内存的占用，这也是很多Unity开发者抱怨内存占用太大的原因。接下来我会介绍Unity使用内存的种类，以及相应每个种类的优化和使用的技巧。遵循使用原则，可以让非必要资源尽快得到释放，从而降低内存占用。\n\n## Unity中的内存种类\n实际上Unity游戏使用的内存一共有三种：程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。\n\n程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库，稍后再说。\n\n托管堆是被Mono使用的一部分内存。Mono项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。\n\n最后，本机堆是Unity引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。\n\n## 优化程序代码的内存占用\n这部分的优化相对简单，因为能做的事情并不多：主要就是减少打包时的引用库，改一改build设置即可。对于一个新项目来说不会有太大问题，但是如果是已经存在的项目，可能改变会导致原来所需要的库的缺失（虽说一般来说这种可能性不大），因此有可能无法做到最优。\n\n\n\n当使用Unity开发时，默认的Mono包含库可以说大部分用不上，在Player Setting（Edit->Project Setting->;Player或者Shift+Ctrl(Command)+B里的Player Setting按钮）面板里，将最下方的Optimization栏目中“Api Compatibility Level”选为.NET 2.0 Subset，表示你只会使用到部分的.NET 2.0 Subset，不需要Unity将全部.NET的Api包含进去。接下来的“Stripping Level”表示从build的库中剥离的力度，每一个剥离选项都将从打包好的库中去掉一部分内容。你需要保证你的代码没有用到这部分被剥离的功能，选为“Use micro mscorlib”的话将使用最小的库（一般来说也没啥问题，不行的话可以试试之前的两个）。库剥离可以极大地降低打包后的程序的尺寸以及程序代码的内存占用，唯一的缺点是这个功能只支持Pro版的Unity。\n\n这部分优化的力度需要根据代码所用到的.NET的功能来进行调整，有可能不能使用Subset或者最大的剥离力度。如果超出了限度，很可能会在需要该功能时因为找不到相应的库而crash掉（iOS的话很可能在Xcode编译时就报错了）。比较好地解决方案是仍然用最强的剥离，并辅以较小的第三方的类库来完成所需功能。一个最常见问题是最大剥离时Sysytem.Xml是不被Subset和micro支持的，如果只是为了xml，完全可以导入一个轻量级的xml库来解决依赖（Unity官方推荐这个）。\n\n关于每个设定对应支持的库的详细列表，可以在这里找到。关于每个剥离级别到底做了什么，Unity的文档也有说明。实际上，在游戏开发中绝大多数被剥离的功能使用不上的，因此不管如何，库剥离的优化方法都值得一试。\n\n## 托管堆优化\nUnity有一篇不错的关于托管堆代码如何写比较好的说明，在此基础上我个人有一些补充。\n\n首先需要明确，托管堆中存储的是你在你的代码中申请的内存（不论是用js，C#还是Boo写的）。一般来说，无非是new或者Instantiate两种生成object的方法（事实上Instantiate中也是调用了new）。在接收到alloc请求后，托管堆在其上为要新生成的对象实例以及其实例变量分配内存，如果可用空间不足，则向系统申请更多空间。\n\n当你使用完一个实例对象之后，通常来说在脚本中就不会再有对该对象的引用了（这包括将变量设置为null或其他引用，超出了变量的作用域，或者对Unity对象发送Destory()）。在每隔一段时间，Mono的垃圾回收机制将检测内存，将没有再被引用的内存释放回收。总的来说，你要做的就是在尽可能早的时间将不需要的引用去除掉，这样回收机制才能正确地把不需要的内存清理出来。但是需要注意在内存清理时有可能造成游戏的短时间卡顿，这将会很影响游戏体验，因此如果有大量的内存回收工作要进行的话，需要尽量选择合适的时间。\n\n如果在你的游戏里，有特别多的类似实例，并需要对它们经常发送Destroy()的话，游戏性能上会相当难看。比如小熊推金币中的金币实例，按理说每枚金币落下台子后都需要对其Destory()，然后新的金币进入台子时又需要Instantiate，这对性能是极大的浪费。一种通常的做法是在不需要时，不摧毁这个GameObject，而只是隐藏它，并将其放入一个重用数组中。之后需要时，再从重用数组中找到可用的实例并显示。这将极大地改善游戏的性能，相应的代价是消耗部分内存，一般来说这是可以接受的。关于对象重用，可以参考Unity关于内存方面的文档中Reusable Object Pools部分，或者Prime31有一个是用Linq来建立重用池的视频教程（Youtube，需要翻墙，上半部分，下半部分）。\n\n如果不是必要，应该在游戏进行的过程中尽量减少对GameObject的Instantiate()和Destroy()调用，因为对计算资源会有很大消耗。在便携设备上短时间大量生成和摧毁物体的话，很容易造成瞬时卡顿。如果内存没有问题的话，尽量选择先将他们收集起来，然后在合适的时候（比如按暂停键或者是关卡切换），将它们批量地销毁并且回收内存。Mono的内存回收会在后台自动进行，系统会选择合适的时间进行垃圾回收。在合适的时候，也可以手动地调用System.GC.Collect()来建议系统进行一次垃圾回收。要注意的是这里的调用真的仅仅只是建议，可能系统会在一段时间后在进行回收，也可能完全不理会这条请求，不过在大部分时间里，这个调用还是靠谱的。\n\n## 本机堆的优化\n当你加载完成一个Unity的scene的时候，scene中的所有用到的asset（包括Hierarchy中所有GameObject上以及脚本中赋值了的的材质，贴图，动画，声音等素材），都会被自动加载（这正是Unity的智能之处）。也就是说，当关卡呈现在用户面前的时候，所有Unity编辑器能认识的本关卡的资源都已经被预先加入内存了，这样在本关卡中，用户将有良好的体验，不论是更换贴图，声音，还是播放动画时，都不会有额外的加载，这样的代价是内存占用将变多。Unity最初的设计目的还是面向台式机，几乎无限的内存和虚拟内存使得这样的占用似乎不是问题，但是这样的内存策略在之后移动平台的兴起和大量移动设备游戏的制作中出现了弊端，因为移动设备能使用的资源始终非常有限。因此在面向移动设备游戏的制作时，尽量减少在Hierarchy对资源的直接引用，而是使用Resource.Load的方法，在需要的时候从硬盘中读取资源，在使用后用Resource.UnloadAsset()和Resources.UnloadUnusedAssets()尽快将其卸载掉。总之，这里是一个处理时间和占用内存空间的trade off，如何达到最好的效果没有标准答案，需要自己权衡。\n\n在关卡结束的时候，这个关卡中所使用的所有资源将会被卸载掉（除非被标记了DontDestroyOnLoad）的资源。注意不仅是DontDestroyOnLoad的资源本身，其相关的所有资源在关卡切换时都不会被卸载。DontDestroyOnLoad一般被用来在关卡之间保存一些玩家的状态，比如分数，级别等偏向文本的信息。如果DontDestroyOnLoad了一个包含很多资源（比如大量贴图或者声音等大内存占用的东西）的话，这部分资源在场景切换时无法卸载，将一直占用内存，这种情况应该尽量避免。\n\n另外一种需要注意的情况是脚本中对资源的引用。大部分脚本将在场景转换时随之失效并被回收，但是，在场景之间被保持的脚本不在此列（通常情况是被附着在DontDestroyOnLoad的GameObject上了）。而这些脚本很可能含有对其他物体的Component或者资源的引用，这样相关的资源就都得不到释放，这绝对是不想要的情况。另外，static的单例（singleton）在场景切换时也不会被摧毁，同样地，如果这种单例含有大量的对资源的引用，也会成为大问题。因此，尽量减少代码的耦合和对其他脚本的依赖是十分有必要的。如果确实无法避免这种情况，那应当手动地对这些不再使用的引用对象调用Destroy()或者将其设置为null。这样在垃圾回收的时候，这些内存将被认为已经无用而被回收。\n\n需要注意的是，Unity在一个场景开始时，根据场景构成和引用关系所自动读取的资源，只有在读取一个新的场景或者reset当前场景时，才会得到清理。因此这部分内存占用是不可避免的。在小内存环境中，这部分初始内存的占用十分重要，因为它决定了你的关卡是否能够被正常加载。因此在计算资源充足或是关卡开始之后还有机会进行加载时，尽量减少Hierarchy中的引用，变为手动用Resource.Load，将大大减少内存占用。在Resource.UnloadAsset()和Resources.UnloadUnusedAssets()时，只有那些真正没有任何引用指向的资源会被回收，因此请确保在资源不再使用时，将所有对该资源的引用设置为null或者Destroy。同样需要注意，这两个Unload方法仅仅对Resource.Load拿到的资源有效，而不能回收任何场景开始时自动加载的资源。与此类似的还有AssetBundle的Load和Unload方法，灵活使用这些手动自愿加载和卸载的方法，是优化Unity内存占用的不二法则～","slug":"Unity内存剖析","published":1,"date":"2020-12-18T04:25:18.340Z","updated":"2020-12-18T04:25:18.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckitrsiip00033wf0kcouf43r","content":"<p>本文欢迎转载，但烦请保留此行出处信息：<a href=\"https://www.onevcat.com/2012/11/memory-in-unity3d/\">https://www.onevcat.com/2012/11/memory-in-unity3d/</a></p>\n<p>Unity3D在内存占用上一直被人诟病，特别是对于面向移动设备的游戏开发，动辄内存占用飙上一两百兆，导致内存资源耗尽，从而被系统强退造成极差的体验。类似这种情况并不少见，但是绝大部分都是可以避免的。虽然理论上Unity的内存管理系统应当为开发者分忧解难，让大家投身到更有意义的事情中去，但是对于Unity对内存的管理方式，官方文档中并没有太多的说明，基本需要依靠自己摸索。最近在接手的项目中存在严重的内存问题，在参照文档和Unity Answer众多猜测和证实之后，稍微总结了下Unity中的内存的分配和管理的基本方式，在此共享。</p>\n<p>虽然Unity标榜自己的内存使用全都是“Managed Memory”，但是事实上你必须正确地使用内存，以保证回收机制正确运行。如果没有做应当做的事情，那么场景和代码很有可能造成很多非必要内存的占用，这也是很多Unity开发者抱怨内存占用太大的原因。接下来我会介绍Unity使用内存的种类，以及相应每个种类的优化和使用的技巧。遵循使用原则，可以让非必要资源尽快得到释放，从而降低内存占用。</p>\n<h2 id=\"Unity中的内存种类\"><a href=\"#Unity中的内存种类\" class=\"headerlink\" title=\"Unity中的内存种类\"></a>Unity中的内存种类</h2><p>实际上Unity游戏使用的内存一共有三种：程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。</p>\n<p>程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库，稍后再说。</p>\n<p>托管堆是被Mono使用的一部分内存。Mono项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。</p>\n<p>最后，本机堆是Unity引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。</p>\n<h2 id=\"优化程序代码的内存占用\"><a href=\"#优化程序代码的内存占用\" class=\"headerlink\" title=\"优化程序代码的内存占用\"></a>优化程序代码的内存占用</h2><p>这部分的优化相对简单，因为能做的事情并不多：主要就是减少打包时的引用库，改一改build设置即可。对于一个新项目来说不会有太大问题，但是如果是已经存在的项目，可能改变会导致原来所需要的库的缺失（虽说一般来说这种可能性不大），因此有可能无法做到最优。</p>\n<p>当使用Unity开发时，默认的Mono包含库可以说大部分用不上，在Player Setting（Edit-&gt;Project Setting-&gt;;Player或者Shift+Ctrl(Command)+B里的Player Setting按钮）面板里，将最下方的Optimization栏目中“Api Compatibility Level”选为.NET 2.0 Subset，表示你只会使用到部分的.NET 2.0 Subset，不需要Unity将全部.NET的Api包含进去。接下来的“Stripping Level”表示从build的库中剥离的力度，每一个剥离选项都将从打包好的库中去掉一部分内容。你需要保证你的代码没有用到这部分被剥离的功能，选为“Use micro mscorlib”的话将使用最小的库（一般来说也没啥问题，不行的话可以试试之前的两个）。库剥离可以极大地降低打包后的程序的尺寸以及程序代码的内存占用，唯一的缺点是这个功能只支持Pro版的Unity。</p>\n<p>这部分优化的力度需要根据代码所用到的.NET的功能来进行调整，有可能不能使用Subset或者最大的剥离力度。如果超出了限度，很可能会在需要该功能时因为找不到相应的库而crash掉（iOS的话很可能在Xcode编译时就报错了）。比较好地解决方案是仍然用最强的剥离，并辅以较小的第三方的类库来完成所需功能。一个最常见问题是最大剥离时Sysytem.Xml是不被Subset和micro支持的，如果只是为了xml，完全可以导入一个轻量级的xml库来解决依赖（Unity官方推荐这个）。</p>\n<p>关于每个设定对应支持的库的详细列表，可以在这里找到。关于每个剥离级别到底做了什么，Unity的文档也有说明。实际上，在游戏开发中绝大多数被剥离的功能使用不上的，因此不管如何，库剥离的优化方法都值得一试。</p>\n<h2 id=\"托管堆优化\"><a href=\"#托管堆优化\" class=\"headerlink\" title=\"托管堆优化\"></a>托管堆优化</h2><p>Unity有一篇不错的关于托管堆代码如何写比较好的说明，在此基础上我个人有一些补充。</p>\n<p>首先需要明确，托管堆中存储的是你在你的代码中申请的内存（不论是用js，C#还是Boo写的）。一般来说，无非是new或者Instantiate两种生成object的方法（事实上Instantiate中也是调用了new）。在接收到alloc请求后，托管堆在其上为要新生成的对象实例以及其实例变量分配内存，如果可用空间不足，则向系统申请更多空间。</p>\n<p>当你使用完一个实例对象之后，通常来说在脚本中就不会再有对该对象的引用了（这包括将变量设置为null或其他引用，超出了变量的作用域，或者对Unity对象发送Destory()）。在每隔一段时间，Mono的垃圾回收机制将检测内存，将没有再被引用的内存释放回收。总的来说，你要做的就是在尽可能早的时间将不需要的引用去除掉，这样回收机制才能正确地把不需要的内存清理出来。但是需要注意在内存清理时有可能造成游戏的短时间卡顿，这将会很影响游戏体验，因此如果有大量的内存回收工作要进行的话，需要尽量选择合适的时间。</p>\n<p>如果在你的游戏里，有特别多的类似实例，并需要对它们经常发送Destroy()的话，游戏性能上会相当难看。比如小熊推金币中的金币实例，按理说每枚金币落下台子后都需要对其Destory()，然后新的金币进入台子时又需要Instantiate，这对性能是极大的浪费。一种通常的做法是在不需要时，不摧毁这个GameObject，而只是隐藏它，并将其放入一个重用数组中。之后需要时，再从重用数组中找到可用的实例并显示。这将极大地改善游戏的性能，相应的代价是消耗部分内存，一般来说这是可以接受的。关于对象重用，可以参考Unity关于内存方面的文档中Reusable Object Pools部分，或者Prime31有一个是用Linq来建立重用池的视频教程（Youtube，需要翻墙，上半部分，下半部分）。</p>\n<p>如果不是必要，应该在游戏进行的过程中尽量减少对GameObject的Instantiate()和Destroy()调用，因为对计算资源会有很大消耗。在便携设备上短时间大量生成和摧毁物体的话，很容易造成瞬时卡顿。如果内存没有问题的话，尽量选择先将他们收集起来，然后在合适的时候（比如按暂停键或者是关卡切换），将它们批量地销毁并且回收内存。Mono的内存回收会在后台自动进行，系统会选择合适的时间进行垃圾回收。在合适的时候，也可以手动地调用System.GC.Collect()来建议系统进行一次垃圾回收。要注意的是这里的调用真的仅仅只是建议，可能系统会在一段时间后在进行回收，也可能完全不理会这条请求，不过在大部分时间里，这个调用还是靠谱的。</p>\n<h2 id=\"本机堆的优化\"><a href=\"#本机堆的优化\" class=\"headerlink\" title=\"本机堆的优化\"></a>本机堆的优化</h2><p>当你加载完成一个Unity的scene的时候，scene中的所有用到的asset（包括Hierarchy中所有GameObject上以及脚本中赋值了的的材质，贴图，动画，声音等素材），都会被自动加载（这正是Unity的智能之处）。也就是说，当关卡呈现在用户面前的时候，所有Unity编辑器能认识的本关卡的资源都已经被预先加入内存了，这样在本关卡中，用户将有良好的体验，不论是更换贴图，声音，还是播放动画时，都不会有额外的加载，这样的代价是内存占用将变多。Unity最初的设计目的还是面向台式机，几乎无限的内存和虚拟内存使得这样的占用似乎不是问题，但是这样的内存策略在之后移动平台的兴起和大量移动设备游戏的制作中出现了弊端，因为移动设备能使用的资源始终非常有限。因此在面向移动设备游戏的制作时，尽量减少在Hierarchy对资源的直接引用，而是使用Resource.Load的方法，在需要的时候从硬盘中读取资源，在使用后用Resource.UnloadAsset()和Resources.UnloadUnusedAssets()尽快将其卸载掉。总之，这里是一个处理时间和占用内存空间的trade off，如何达到最好的效果没有标准答案，需要自己权衡。</p>\n<p>在关卡结束的时候，这个关卡中所使用的所有资源将会被卸载掉（除非被标记了DontDestroyOnLoad）的资源。注意不仅是DontDestroyOnLoad的资源本身，其相关的所有资源在关卡切换时都不会被卸载。DontDestroyOnLoad一般被用来在关卡之间保存一些玩家的状态，比如分数，级别等偏向文本的信息。如果DontDestroyOnLoad了一个包含很多资源（比如大量贴图或者声音等大内存占用的东西）的话，这部分资源在场景切换时无法卸载，将一直占用内存，这种情况应该尽量避免。</p>\n<p>另外一种需要注意的情况是脚本中对资源的引用。大部分脚本将在场景转换时随之失效并被回收，但是，在场景之间被保持的脚本不在此列（通常情况是被附着在DontDestroyOnLoad的GameObject上了）。而这些脚本很可能含有对其他物体的Component或者资源的引用，这样相关的资源就都得不到释放，这绝对是不想要的情况。另外，static的单例（singleton）在场景切换时也不会被摧毁，同样地，如果这种单例含有大量的对资源的引用，也会成为大问题。因此，尽量减少代码的耦合和对其他脚本的依赖是十分有必要的。如果确实无法避免这种情况，那应当手动地对这些不再使用的引用对象调用Destroy()或者将其设置为null。这样在垃圾回收的时候，这些内存将被认为已经无用而被回收。</p>\n<p>需要注意的是，Unity在一个场景开始时，根据场景构成和引用关系所自动读取的资源，只有在读取一个新的场景或者reset当前场景时，才会得到清理。因此这部分内存占用是不可避免的。在小内存环境中，这部分初始内存的占用十分重要，因为它决定了你的关卡是否能够被正常加载。因此在计算资源充足或是关卡开始之后还有机会进行加载时，尽量减少Hierarchy中的引用，变为手动用Resource.Load，将大大减少内存占用。在Resource.UnloadAsset()和Resources.UnloadUnusedAssets()时，只有那些真正没有任何引用指向的资源会被回收，因此请确保在资源不再使用时，将所有对该资源的引用设置为null或者Destroy。同样需要注意，这两个Unload方法仅仅对Resource.Load拿到的资源有效，而不能回收任何场景开始时自动加载的资源。与此类似的还有AssetBundle的Load和Unload方法，灵活使用这些手动自愿加载和卸载的方法，是优化Unity内存占用的不二法则～</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文欢迎转载，但烦请保留此行出处信息：<a href=\"https://www.onevcat.com/2012/11/memory-in-unity3d/\">https://www.onevcat.com/2012/11/memory-in-unity3d/</a></p>\n<p>Unity3D在内存占用上一直被人诟病，特别是对于面向移动设备的游戏开发，动辄内存占用飙上一两百兆，导致内存资源耗尽，从而被系统强退造成极差的体验。类似这种情况并不少见，但是绝大部分都是可以避免的。虽然理论上Unity的内存管理系统应当为开发者分忧解难，让大家投身到更有意义的事情中去，但是对于Unity对内存的管理方式，官方文档中并没有太多的说明，基本需要依靠自己摸索。最近在接手的项目中存在严重的内存问题，在参照文档和Unity Answer众多猜测和证实之后，稍微总结了下Unity中的内存的分配和管理的基本方式，在此共享。</p>\n<p>虽然Unity标榜自己的内存使用全都是“Managed Memory”，但是事实上你必须正确地使用内存，以保证回收机制正确运行。如果没有做应当做的事情，那么场景和代码很有可能造成很多非必要内存的占用，这也是很多Unity开发者抱怨内存占用太大的原因。接下来我会介绍Unity使用内存的种类，以及相应每个种类的优化和使用的技巧。遵循使用原则，可以让非必要资源尽快得到释放，从而降低内存占用。</p>\n<h2 id=\"Unity中的内存种类\"><a href=\"#Unity中的内存种类\" class=\"headerlink\" title=\"Unity中的内存种类\"></a>Unity中的内存种类</h2><p>实际上Unity游戏使用的内存一共有三种：程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。</p>\n<p>程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库，稍后再说。</p>\n<p>托管堆是被Mono使用的一部分内存。Mono项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。</p>\n<p>最后，本机堆是Unity引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。</p>\n<h2 id=\"优化程序代码的内存占用\"><a href=\"#优化程序代码的内存占用\" class=\"headerlink\" title=\"优化程序代码的内存占用\"></a>优化程序代码的内存占用</h2><p>这部分的优化相对简单，因为能做的事情并不多：主要就是减少打包时的引用库，改一改build设置即可。对于一个新项目来说不会有太大问题，但是如果是已经存在的项目，可能改变会导致原来所需要的库的缺失（虽说一般来说这种可能性不大），因此有可能无法做到最优。</p>\n<p>当使用Unity开发时，默认的Mono包含库可以说大部分用不上，在Player Setting（Edit-&gt;Project Setting-&gt;;Player或者Shift+Ctrl(Command)+B里的Player Setting按钮）面板里，将最下方的Optimization栏目中“Api Compatibility Level”选为.NET 2.0 Subset，表示你只会使用到部分的.NET 2.0 Subset，不需要Unity将全部.NET的Api包含进去。接下来的“Stripping Level”表示从build的库中剥离的力度，每一个剥离选项都将从打包好的库中去掉一部分内容。你需要保证你的代码没有用到这部分被剥离的功能，选为“Use micro mscorlib”的话将使用最小的库（一般来说也没啥问题，不行的话可以试试之前的两个）。库剥离可以极大地降低打包后的程序的尺寸以及程序代码的内存占用，唯一的缺点是这个功能只支持Pro版的Unity。</p>\n<p>这部分优化的力度需要根据代码所用到的.NET的功能来进行调整，有可能不能使用Subset或者最大的剥离力度。如果超出了限度，很可能会在需要该功能时因为找不到相应的库而crash掉（iOS的话很可能在Xcode编译时就报错了）。比较好地解决方案是仍然用最强的剥离，并辅以较小的第三方的类库来完成所需功能。一个最常见问题是最大剥离时Sysytem.Xml是不被Subset和micro支持的，如果只是为了xml，完全可以导入一个轻量级的xml库来解决依赖（Unity官方推荐这个）。</p>\n<p>关于每个设定对应支持的库的详细列表，可以在这里找到。关于每个剥离级别到底做了什么，Unity的文档也有说明。实际上，在游戏开发中绝大多数被剥离的功能使用不上的，因此不管如何，库剥离的优化方法都值得一试。</p>\n<h2 id=\"托管堆优化\"><a href=\"#托管堆优化\" class=\"headerlink\" title=\"托管堆优化\"></a>托管堆优化</h2><p>Unity有一篇不错的关于托管堆代码如何写比较好的说明，在此基础上我个人有一些补充。</p>\n<p>首先需要明确，托管堆中存储的是你在你的代码中申请的内存（不论是用js，C#还是Boo写的）。一般来说，无非是new或者Instantiate两种生成object的方法（事实上Instantiate中也是调用了new）。在接收到alloc请求后，托管堆在其上为要新生成的对象实例以及其实例变量分配内存，如果可用空间不足，则向系统申请更多空间。</p>\n<p>当你使用完一个实例对象之后，通常来说在脚本中就不会再有对该对象的引用了（这包括将变量设置为null或其他引用，超出了变量的作用域，或者对Unity对象发送Destory()）。在每隔一段时间，Mono的垃圾回收机制将检测内存，将没有再被引用的内存释放回收。总的来说，你要做的就是在尽可能早的时间将不需要的引用去除掉，这样回收机制才能正确地把不需要的内存清理出来。但是需要注意在内存清理时有可能造成游戏的短时间卡顿，这将会很影响游戏体验，因此如果有大量的内存回收工作要进行的话，需要尽量选择合适的时间。</p>\n<p>如果在你的游戏里，有特别多的类似实例，并需要对它们经常发送Destroy()的话，游戏性能上会相当难看。比如小熊推金币中的金币实例，按理说每枚金币落下台子后都需要对其Destory()，然后新的金币进入台子时又需要Instantiate，这对性能是极大的浪费。一种通常的做法是在不需要时，不摧毁这个GameObject，而只是隐藏它，并将其放入一个重用数组中。之后需要时，再从重用数组中找到可用的实例并显示。这将极大地改善游戏的性能，相应的代价是消耗部分内存，一般来说这是可以接受的。关于对象重用，可以参考Unity关于内存方面的文档中Reusable Object Pools部分，或者Prime31有一个是用Linq来建立重用池的视频教程（Youtube，需要翻墙，上半部分，下半部分）。</p>\n<p>如果不是必要，应该在游戏进行的过程中尽量减少对GameObject的Instantiate()和Destroy()调用，因为对计算资源会有很大消耗。在便携设备上短时间大量生成和摧毁物体的话，很容易造成瞬时卡顿。如果内存没有问题的话，尽量选择先将他们收集起来，然后在合适的时候（比如按暂停键或者是关卡切换），将它们批量地销毁并且回收内存。Mono的内存回收会在后台自动进行，系统会选择合适的时间进行垃圾回收。在合适的时候，也可以手动地调用System.GC.Collect()来建议系统进行一次垃圾回收。要注意的是这里的调用真的仅仅只是建议，可能系统会在一段时间后在进行回收，也可能完全不理会这条请求，不过在大部分时间里，这个调用还是靠谱的。</p>\n<h2 id=\"本机堆的优化\"><a href=\"#本机堆的优化\" class=\"headerlink\" title=\"本机堆的优化\"></a>本机堆的优化</h2><p>当你加载完成一个Unity的scene的时候，scene中的所有用到的asset（包括Hierarchy中所有GameObject上以及脚本中赋值了的的材质，贴图，动画，声音等素材），都会被自动加载（这正是Unity的智能之处）。也就是说，当关卡呈现在用户面前的时候，所有Unity编辑器能认识的本关卡的资源都已经被预先加入内存了，这样在本关卡中，用户将有良好的体验，不论是更换贴图，声音，还是播放动画时，都不会有额外的加载，这样的代价是内存占用将变多。Unity最初的设计目的还是面向台式机，几乎无限的内存和虚拟内存使得这样的占用似乎不是问题，但是这样的内存策略在之后移动平台的兴起和大量移动设备游戏的制作中出现了弊端，因为移动设备能使用的资源始终非常有限。因此在面向移动设备游戏的制作时，尽量减少在Hierarchy对资源的直接引用，而是使用Resource.Load的方法，在需要的时候从硬盘中读取资源，在使用后用Resource.UnloadAsset()和Resources.UnloadUnusedAssets()尽快将其卸载掉。总之，这里是一个处理时间和占用内存空间的trade off，如何达到最好的效果没有标准答案，需要自己权衡。</p>\n<p>在关卡结束的时候，这个关卡中所使用的所有资源将会被卸载掉（除非被标记了DontDestroyOnLoad）的资源。注意不仅是DontDestroyOnLoad的资源本身，其相关的所有资源在关卡切换时都不会被卸载。DontDestroyOnLoad一般被用来在关卡之间保存一些玩家的状态，比如分数，级别等偏向文本的信息。如果DontDestroyOnLoad了一个包含很多资源（比如大量贴图或者声音等大内存占用的东西）的话，这部分资源在场景切换时无法卸载，将一直占用内存，这种情况应该尽量避免。</p>\n<p>另外一种需要注意的情况是脚本中对资源的引用。大部分脚本将在场景转换时随之失效并被回收，但是，在场景之间被保持的脚本不在此列（通常情况是被附着在DontDestroyOnLoad的GameObject上了）。而这些脚本很可能含有对其他物体的Component或者资源的引用，这样相关的资源就都得不到释放，这绝对是不想要的情况。另外，static的单例（singleton）在场景切换时也不会被摧毁，同样地，如果这种单例含有大量的对资源的引用，也会成为大问题。因此，尽量减少代码的耦合和对其他脚本的依赖是十分有必要的。如果确实无法避免这种情况，那应当手动地对这些不再使用的引用对象调用Destroy()或者将其设置为null。这样在垃圾回收的时候，这些内存将被认为已经无用而被回收。</p>\n<p>需要注意的是，Unity在一个场景开始时，根据场景构成和引用关系所自动读取的资源，只有在读取一个新的场景或者reset当前场景时，才会得到清理。因此这部分内存占用是不可避免的。在小内存环境中，这部分初始内存的占用十分重要，因为它决定了你的关卡是否能够被正常加载。因此在计算资源充足或是关卡开始之后还有机会进行加载时，尽量减少Hierarchy中的引用，变为手动用Resource.Load，将大大减少内存占用。在Resource.UnloadAsset()和Resources.UnloadUnusedAssets()时，只有那些真正没有任何引用指向的资源会被回收，因此请确保在资源不再使用时，将所有对该资源的引用设置为null或者Destroy。同样需要注意，这两个Unload方法仅仅对Resource.Load拿到的资源有效，而不能回收任何场景开始时自动加载的资源。与此类似的还有AssetBundle的Load和Unload方法，灵活使用这些手动自愿加载和卸载的方法，是优化Unity内存占用的不二法则～</p>\n"},{"title":"骨骼蒙皮动画(SkinnedMesh)的原理解析","_content":"\n取自： https://gameinstitute.qq.com/community/detail/127900\n\n## 一、3D模型动画基本原理和分类\n3D模型动画的基本原理是让模型中各顶点的位置随时间变化。主要种类有Morph（变形）动画，关节动画和骨骼蒙皮动画(SkinnedMesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据是不一样的。\n\n### Morph（变形）动画\n是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。\n\n### 关节动画\n关节动画的模型不是一个整体的Mesh,而是分成很多部分(Mesh)，通过一个父子层次结构将这些分散的Mesh组织在一起，父Mesh带动其下子Mesh的运动，各Mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。\n\n动画帧中设置各子Mesh相对于其父Mesh的变换（主要是旋转，当然也可包括移动和缩放），通过子到父，一级级的变换累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。\n\n关节动画的问题是，各部分Mesh中的顶点是固定在其Mesh坐标系中的，这样在两个Mesh结合处就可能产生裂缝。\n\n### 骨骼蒙皮动画即SkinnedMesh\n骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，发明这个算法的人一定是个天才，因为SkinnedMesh的原理简单的难以置信，而效果却那么好。骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。下面将具体分析。\n\n## 二、SkinnedMesh原理和结构分析\n\n组成：Bone+SkinnedMesh(以下简称mesh)   + 顶点的Skin数据 + 骨骼偏移矩阵(BoneOffsetMatrix)\n\n\n顶点的Skin数据: 包括顶点受哪些骨骼影响以及这些骨骼影响该顶点时的权重(weight)\n骨骼偏移矩阵(BoneOffsetMatrix): 将顶点从Mesh空间变换到骨骼空间\n> 如何消除裂缝： 蒙皮是指将Mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样在关节处的顶点由于同时受到父子骨骼的拉扯而改变位置就消除了裂缝\n\n\n","source":"_posts/骨骼蒙皮动画(SkinnedMesh)的原理解析.md","raw":"---\ntitle: 骨骼蒙皮动画(SkinnedMesh)的原理解析\ncategories:\n- Unity\n---\n\n取自： https://gameinstitute.qq.com/community/detail/127900\n\n## 一、3D模型动画基本原理和分类\n3D模型动画的基本原理是让模型中各顶点的位置随时间变化。主要种类有Morph（变形）动画，关节动画和骨骼蒙皮动画(SkinnedMesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据是不一样的。\n\n### Morph（变形）动画\n是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。\n\n### 关节动画\n关节动画的模型不是一个整体的Mesh,而是分成很多部分(Mesh)，通过一个父子层次结构将这些分散的Mesh组织在一起，父Mesh带动其下子Mesh的运动，各Mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。\n\n动画帧中设置各子Mesh相对于其父Mesh的变换（主要是旋转，当然也可包括移动和缩放），通过子到父，一级级的变换累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。\n\n关节动画的问题是，各部分Mesh中的顶点是固定在其Mesh坐标系中的，这样在两个Mesh结合处就可能产生裂缝。\n\n### 骨骼蒙皮动画即SkinnedMesh\n骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，发明这个算法的人一定是个天才，因为SkinnedMesh的原理简单的难以置信，而效果却那么好。骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。下面将具体分析。\n\n## 二、SkinnedMesh原理和结构分析\n\n组成：Bone+SkinnedMesh(以下简称mesh)   + 顶点的Skin数据 + 骨骼偏移矩阵(BoneOffsetMatrix)\n\n\n顶点的Skin数据: 包括顶点受哪些骨骼影响以及这些骨骼影响该顶点时的权重(weight)\n骨骼偏移矩阵(BoneOffsetMatrix): 将顶点从Mesh空间变换到骨骼空间\n> 如何消除裂缝： 蒙皮是指将Mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样在关节处的顶点由于同时受到父子骨骼的拉扯而改变位置就消除了裂缝\n\n\n","slug":"骨骼蒙皮动画(SkinnedMesh)的原理解析","published":1,"date":"2020-12-18T04:25:18.347Z","updated":"2020-12-18T04:25:18.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckitrsijl00083wf0n5w2gw8m","content":"<p>取自： <a href=\"https://gameinstitute.qq.com/community/detail/127900\">https://gameinstitute.qq.com/community/detail/127900</a></p>\n<h2 id=\"一、3D模型动画基本原理和分类\"><a href=\"#一、3D模型动画基本原理和分类\" class=\"headerlink\" title=\"一、3D模型动画基本原理和分类\"></a>一、3D模型动画基本原理和分类</h2><p>3D模型动画的基本原理是让模型中各顶点的位置随时间变化。主要种类有Morph（变形）动画，关节动画和骨骼蒙皮动画(SkinnedMesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据是不一样的。</p>\n<h3 id=\"Morph（变形）动画\"><a href=\"#Morph（变形）动画\" class=\"headerlink\" title=\"Morph（变形）动画\"></a>Morph（变形）动画</h3><p>是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。</p>\n<h3 id=\"关节动画\"><a href=\"#关节动画\" class=\"headerlink\" title=\"关节动画\"></a>关节动画</h3><p>关节动画的模型不是一个整体的Mesh,而是分成很多部分(Mesh)，通过一个父子层次结构将这些分散的Mesh组织在一起，父Mesh带动其下子Mesh的运动，各Mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。</p>\n<p>动画帧中设置各子Mesh相对于其父Mesh的变换（主要是旋转，当然也可包括移动和缩放），通过子到父，一级级的变换累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。</p>\n<p>关节动画的问题是，各部分Mesh中的顶点是固定在其Mesh坐标系中的，这样在两个Mesh结合处就可能产生裂缝。</p>\n<h3 id=\"骨骼蒙皮动画即SkinnedMesh\"><a href=\"#骨骼蒙皮动画即SkinnedMesh\" class=\"headerlink\" title=\"骨骼蒙皮动画即SkinnedMesh\"></a>骨骼蒙皮动画即SkinnedMesh</h3><p>骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，发明这个算法的人一定是个天才，因为SkinnedMesh的原理简单的难以置信，而效果却那么好。骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。下面将具体分析。</p>\n<h2 id=\"二、SkinnedMesh原理和结构分析\"><a href=\"#二、SkinnedMesh原理和结构分析\" class=\"headerlink\" title=\"二、SkinnedMesh原理和结构分析\"></a>二、SkinnedMesh原理和结构分析</h2><p>组成：Bone+SkinnedMesh(以下简称mesh)   + 顶点的Skin数据 + 骨骼偏移矩阵(BoneOffsetMatrix)</p>\n<p>顶点的Skin数据: 包括顶点受哪些骨骼影响以及这些骨骼影响该顶点时的权重(weight)<br>骨骼偏移矩阵(BoneOffsetMatrix): 将顶点从Mesh空间变换到骨骼空间</p>\n<blockquote>\n<p>如何消除裂缝： 蒙皮是指将Mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样在关节处的顶点由于同时受到父子骨骼的拉扯而改变位置就消除了裂缝</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>取自： <a href=\"https://gameinstitute.qq.com/community/detail/127900\">https://gameinstitute.qq.com/community/detail/127900</a></p>\n<h2 id=\"一、3D模型动画基本原理和分类\"><a href=\"#一、3D模型动画基本原理和分类\" class=\"headerlink\" title=\"一、3D模型动画基本原理和分类\"></a>一、3D模型动画基本原理和分类</h2><p>3D模型动画的基本原理是让模型中各顶点的位置随时间变化。主要种类有Morph（变形）动画，关节动画和骨骼蒙皮动画(SkinnedMesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据是不一样的。</p>\n<h3 id=\"Morph（变形）动画\"><a href=\"#Morph（变形）动画\" class=\"headerlink\" title=\"Morph（变形）动画\"></a>Morph（变形）动画</h3><p>是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。</p>\n<h3 id=\"关节动画\"><a href=\"#关节动画\" class=\"headerlink\" title=\"关节动画\"></a>关节动画</h3><p>关节动画的模型不是一个整体的Mesh,而是分成很多部分(Mesh)，通过一个父子层次结构将这些分散的Mesh组织在一起，父Mesh带动其下子Mesh的运动，各Mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。</p>\n<p>动画帧中设置各子Mesh相对于其父Mesh的变换（主要是旋转，当然也可包括移动和缩放），通过子到父，一级级的变换累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。</p>\n<p>关节动画的问题是，各部分Mesh中的顶点是固定在其Mesh坐标系中的，这样在两个Mesh结合处就可能产生裂缝。</p>\n<h3 id=\"骨骼蒙皮动画即SkinnedMesh\"><a href=\"#骨骼蒙皮动画即SkinnedMesh\" class=\"headerlink\" title=\"骨骼蒙皮动画即SkinnedMesh\"></a>骨骼蒙皮动画即SkinnedMesh</h3><p>骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，发明这个算法的人一定是个天才，因为SkinnedMesh的原理简单的难以置信，而效果却那么好。骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。下面将具体分析。</p>\n<h2 id=\"二、SkinnedMesh原理和结构分析\"><a href=\"#二、SkinnedMesh原理和结构分析\" class=\"headerlink\" title=\"二、SkinnedMesh原理和结构分析\"></a>二、SkinnedMesh原理和结构分析</h2><p>组成：Bone+SkinnedMesh(以下简称mesh)   + 顶点的Skin数据 + 骨骼偏移矩阵(BoneOffsetMatrix)</p>\n<p>顶点的Skin数据: 包括顶点受哪些骨骼影响以及这些骨骼影响该顶点时的权重(weight)<br>骨骼偏移矩阵(BoneOffsetMatrix): 将顶点从Mesh空间变换到骨骼空间</p>\n<blockquote>\n<p>如何消除裂缝： 蒙皮是指将Mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样在关节处的顶点由于同时受到父子骨骼的拉扯而改变位置就消除了裂缝</p>\n</blockquote>\n"},{"title":"基于物理的渲染-PBR","_content":"\n## 一、PBR核心理论\n\n### 1. 基础理念\n* 微平面理论（Microfacet Theory）。微平面理论是将物体表面建模成做无数微观尺度上有随机朝向的理想镜面反射的小平面（microfacet）的理论。在实际的PBR 工作流中，这种物体表面的不规则性用粗糙度贴图或者高光度贴图来表示。\n* 能量守恒（Energy Conservation）。出射光线的能量永远不能超过入射光线的能量。随着粗糙度的上升镜面反射区域的面积会增加，作为平衡，镜面反射区域的平均亮度则会下降。\n* 菲涅尔反射（Fresnel Reflectance）。光线以不同角度入射会有不同的反射率。相同的入射角度，不同的物质也会有不同的反射率。万物皆有菲涅尔反射。F0是即 0 度角入射的菲涅尔反射值。大多数非金属的F0范围是0.02~0.04，大多数金属的F0范围是0.7~1.0。\n* 线性空间（Linear Space）。光照计算必须在线性空间完成，shader 中输入的gamma空间的贴图比如漫反射贴图需要被转成线性空间，在具体操作时需要根据不同引擎和渲染器的不同做不同的操作。而描述物体表面属性的贴图如粗糙度，高光贴图，金属贴图等必须保证是线性空间。\n* 色调映射（Tone Mapping）。也称色调复制（tone reproduction），是将宽范围的照明级别拟合到屏幕有限色域内的过程。因为基于HDR渲染出来的亮度值会超过显示器能够显示最大亮度，所以需要使用色调映射，将光照结果从HDR转换为显示器能够正常显示的LDR。\n* 物质的光学特性（Substance Optical Properties）。现实世界中有不同类型的物质可分为三大类：绝缘体（Insulators），半导体（semi-conductors）和导体（conductors）。在渲染和游戏领域，我们一般只对其中的两个感兴趣：导体（金属）和绝缘体（电解质，非金属）。其中非金属具有单色/灰色镜面反射颜色。而金属具有彩色的镜面反射颜色。\n\n### 2.PBR范畴\n寒霜(Frostbite)引擎在SIGGRAPH 2014的分享《Moving Frostbite to PBR》中提出，基于物理的渲染的范畴，由三部分组成：\n\n* 基于物理的材质（Material）\n* 基于物理的光照（Lighting）\n* 基于物理适配的摄像机（Camera）\n\n\n## 二、渲染方程 BxDF\n\n### 1.渲染方程与反射方程\n\n* 渲染方程\n物理基础是能量守恒定律：　在一个特定的位置和方向，出射光 Lo 是自发光 Le 与反射光线之和，反射光线本身是各个方向的入射光 Li 之和乘以表面反射率及入射角。\n\n![某一点的渲染方程](/img/1608604177769.png)\n\n* 反射方程\n \n 在实时渲染中，我们常用的反射方程(The Reflectance Equation)，则是渲染方程的简化的版本，或者说是一个特例：\n ![某一点的反射方程](/img/1608604253600.png)\n \n ### 2. BxDF\n \n ![BxDF](/img/1608604419905.png)\n \n BxDF一般而言是对BRDF、BTDF、BSDF、BSSRDF等几种双向分布函数的一个统一的表示。\n其中，BSDF可以看做BRDF和BTDF更一般的形式，而且BSDF = BRDF + BTDF。\n而BSSRDF和BRDF的不同之处在于，BSSRDF可以指定不同的光线入射位置和出射位置。\n> 在上述这些BxDF中，BRDF最为简单，也最为常用。因为游戏和电影中的大多数物体都是不透明的，用BRDF就完全足够。而BSDF、BTDF、BSSRDF往往更多用于半透明材质和次表面散射材质。\n\n## 三、迪士尼原则的BxDF\n\n基于物理的渲染，其实早在20世纪就已经在图形学业界有了一些讨论，2010年在SIGGRAPH上就已经有公开讨论的Course 《SIGGRAPH 2010 Course: Physically-Based Shading Models in Film and Game Production》，而直到2012~2013年，才正式进入大众的视野，渐渐被电影和游戏业界广泛使用。\n\n迪士尼动画工作室则是这次PBR革命的重要推动者。迪士尼的Brent Burley于SIGGRAPH 2012上进行了著名的talk《Physically-based shading at Disney》，提出了迪士尼原则的BRDF（Disney Principled BRDF）， 由于其高度的通用性，将材质复杂的物理属性，用非常直观的少量变量表达了出来（如金属度metallic和粗糙度roughness），在电影业界和游戏业界引起了不小的轰动。从此，基于物理的渲染正式进入大众的视野。\n\n## 3.1 迪士尼的BRDF\n在2012年迪士尼原则的BRDF被提出之前，基于物理的渲染都需要大量复杂而不直观的参数，此时PBR的优势，并没有那么明显。\n\n在2012年迪士尼提出，他们的着色模型是艺术导向（Art Directable）的，而不一定要是完全物理正确（physically correct）的，并且对微平面BRDF的各项都进行了严谨的调查，并提出了清晰明确而简单的解决方案。\n\n> 迪士尼的理念是开发一种“原则性”的易用模型，而不是严格的物理模型。正因为这种艺术导向的易用性，能让美术同学用非常直观的少量参数，以及非常标准化的工作流，就能快速实现涉及大量不同材质的真实感的渲染工作。而这对于传统的着色模型来说，是不可能完成的任务。\n\n> 迪士尼原则的BRDF（Disney Principled BRDF）核心理念如下：\n* 应使用直观的参数，而不是物理类的晦涩参数。\n* 参数应尽可能少。\n* 参数在其合理范围内应该为0到1。\n* 允许参数在有意义时超出正常的合理范围。\n* 所有参数组合应尽可能健壮和合理。\n\n颜色参数（baseColor）和下面描述的十个标量参数：\n\n* baseColor（基础色）：表面颜色，通常由纹理贴图提供。\n* subsurface（次表面）：使用次表面近似控制漫反射形状。\n* metallic（金属度）：金属（0 =电介质，1=金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。\n* specular（镜面反射强度）：入射镜面反射量。用于取代折射率。\n* specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（base color）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。\n* roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。\n* anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 =各向同性，1 =最大各向异性）\n* sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。\n* sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。\n* clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。\n* clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 =“缎面（satin）”外观，1 =“光泽（gloss）”外观。\n\n![Disney BRDF](/img/1608606276958.png)\n\n## 四、漫反射BRDF模型（Diffuse BRDF）\n\nDiffuse BRDF可以分为传统型和基于物理型两大类。其中，传统型主要是众所周知的Lambert。\n\n而基于物理型，从1994年的Oren Nayar开始，这里一直统计到今年（2018年）。\n\n其中较新的有GDC 2017上提出的适用于GGX+Smith的基于物理的漫反射模型（PBR diffuse for GGX+Smith），也包含了最近在SIGGRAPH2018上提出的，来自《使命召唤：二战》的多散射漫反射BRDF（MultiScattrering Diffuse BRDF）：\n\nOren Nayar[1994]\nSimplified Oren-Nayar [2012]\nDisney Diffuse[2012]\nRenormalized Disney Diffuse[2014]\nGotanda Diffuse [2014]\nPBR diffuse for GGX+Smith [2017]\nMultiScattrering Diffuse BRDF [2018]\n\n\n## 五、镜面反射BRDF模型（Specular BRDF）\n\n基于物理的渲染领域中最活跃，最主要的部分。\n游戏业界目前最主流的基于物理的镜面反射BRDF模型是基于微平面理论（microfacet theory）的Microfacet Cook-Torrance BRDF。\n\n![Cook-Torrance的BRDF公式](/img/1608610266103.png)\n\n![展开反射方程](/img/1608610379037.png)\n\n由于假设微观几何尺度明显大于可见光波长，因此可以将每个表面点视为光学平坦的。 如上文所述，光学平坦表面将光线分成两个方向：反射和折射。\n\n每个表面点将来自给定进入方向的光反射到单个出射方向，该方向取决于微观几何法线（microgeometry normal）m的方向。 在计算BRDF项时，指定光方向l和视图方向v。 这意味着所有表面点，只有那些恰好正确朝向可以将l反射到v的那些小平面可能有助于BRDF值（其他方向有正有负，积分之后，相互抵消）。\n\n在下图中，我们可以看到这些“正确朝向”的表面点的表面法线m正好位于l和v之间的中间位置。l和v之间的矢量称为半矢量（half-vector）或半角矢量（half-angle vector）; 我们将其表示为h。\n![有效的BRDF贡献点](/img/1608607466758.png)\n\n并非所有m = h的表面点都会积极地对反射做出贡献;一些被l方向（阴影shadowing），v方向（掩蔽masking）或两者的其他表面区域阻挡。Microfacet理论假设所有被遮蔽的光（shadowed light）都从镜面反射项中消失;实际上，由于多次表面反射，其中一些最终将是可见的，但这在目前常见的微平面理论中一般并未去考虑，各种类型的光表面相互作用如下图所示。\n\n![m=h的表面并全是BRDF贡献点](/img/1608607682403.png)\n\n### 5.1 从物理现象到BRDF\n\n其实可理解为金属质感\n![Specular BRDF公式](/img/1608607797277.png)\n\n其中：\n\n* D(h) : 法线分布函数 （Normal Distribution Function），描述微面元法线分布的概率，即正确朝向的法线的浓度。即具有正确朝向，能够将来自l的光反射到v的表面点的相对于表面面积的浓度。\n* F(l,h) : 菲涅尔方程（Fresnel Equation），描述不同的表面角下表面所反射的光线所占的比率。\n* G(l,v,h) : 几何函数（Geometry Function），描述微平面自成阴影的属性，即m = h的未被遮蔽的表面点的百分比。\n* 分母 4(n·l)(n·v）：校正因子（correctionfactor），作为微观几何的局部空间和整个宏观表面的局部空间之间变换的微平面量的校正。\n\n>关于Cook-Torrance BRDF，需要强调的两点注意事项：\n对于分母中的点积，仅仅避免负值是不够的 ,也必须避免零值。通常通过在常规的clamp或绝对值操作之后添加非常小的正值来完成。\nMicrofacet Cook-Torrance BRDF是实践中使用最广泛的模型，实际上也是人们可以想到的最简单的微平面模型。它仅对几何光学系统中的单层微表面上的单个散射进行建模，没有考虑多次散射，分层材质，以及衍射。Microfacet模型，实际上还有很长的路要走。\n\n### 5.2 Specular D\n\n法线分布函数（Normal Distribution Function, NDF）D的常见模型可以总结如下：\n\nBeckmann[1963]\nBlinn-Phong[1977]\nGGX [2007] / Trowbridge-Reitz[1975]\nGeneralized-Trowbridge-Reitz(GTR) [2012]\nAnisotropic Beckmann[2012]\nAnisotropic GGX [2015]\n\n![GGX与blinn-phong效果对比](/img/1608608044790.png)\n\n在这里m表示用来与平面上微平面做比较用的中间向量，而a表示表面粗糙度。\n\n> 另外，需要强调一点。Normal Distribution Function正确的翻译是法线分布函数，而不是正态分布函数。google翻译等翻译软件会将Normal Distribution Function翻译成正态分布函数，而不少中文资料就跟着翻译成了正态分布函数，这是错误的。\n\n>镜面分布，从统计学上近似的表示了与向量m取向一致的微平面的比率。举例来说，假设给定向量m，如果我们的微平面中有35%与向量m取向一致，则正态分布函数或者说NDF将会返回0.35\n### 5.3 Specular F\n菲涅尔效应（Fresnel effect）作为基于物理的渲染理念中的核心理念之一，表示的是看到的光线的反射率与视角相关的现象\n\n菲涅尔项的常见模型可以总结如下：\n\nCook-Torrance [1982]\nSchlick [1994]\nGotanta [2014]\n\n![Schlick公式](/img/1608608155043.png)\n\n![近似方程](/img/1608609564859.png)\n\n![Unity中的F0的线性运算](/img/1608609585831.png)\n## 5.4 Specular G\n\n几何项G的常见模型可以总结如下：\n\nSmith [1967]\nCook-Torrance [1982]\nNeumann [1999]\nKelemen [2001]\nImplicit [2013]\n\n另外，Eric Heitz在[Heitz14]中展示了Smith几何阴影函数是正确且更准确的G项，并将其拓展为Smith联合遮蔽阴影函数（Smith Joint Masking-Shadowing Function），该函数具有四种形式：\n\n分离遮蔽阴影型（Separable Masking and Shadowing）\n高度相关掩蔽阴影型（Height-Correlated Masking and Shadowing）\n方向相关掩蔽阴影型（Direction-Correlated Masking and Shadowing）\n高度-方向相关掩蔽阴影型（Height-Direction-Correlated Masking and Shadowing）\n\n目前较为常用的是其中最为简单的形式，分离遮蔽阴影（Separable Masking and Shadowing Function）。\n\n该形式将几何项G分为两个独立的部分：光线方向（light）和视线方向（view），并对两者用相同的分布函数来描述。根据这种思想，结合法线分布函数（NDF）与Smith几何阴影函数，于是有了以下新的Smith几何项：\n\nSmith-GGX\nSmith-Beckmann\nSmith-Schlick\nSchlick-Beckmann\nSchlick-GGX\n其中UE4的方案是上面列举中的“Schlick-GGX”，即基于Schlick近似，将k映射为 [公式] ,去匹配GGX Smith方程：\n\n![Schlick-GGX方程](/img/1608608340955.png)","source":"_posts/基于物理的渲染-PBR.md","raw":"---\ntitle: 基于物理的渲染-PBR\ncategories:\n- Unity\n---\n\n## 一、PBR核心理论\n\n### 1. 基础理念\n* 微平面理论（Microfacet Theory）。微平面理论是将物体表面建模成做无数微观尺度上有随机朝向的理想镜面反射的小平面（microfacet）的理论。在实际的PBR 工作流中，这种物体表面的不规则性用粗糙度贴图或者高光度贴图来表示。\n* 能量守恒（Energy Conservation）。出射光线的能量永远不能超过入射光线的能量。随着粗糙度的上升镜面反射区域的面积会增加，作为平衡，镜面反射区域的平均亮度则会下降。\n* 菲涅尔反射（Fresnel Reflectance）。光线以不同角度入射会有不同的反射率。相同的入射角度，不同的物质也会有不同的反射率。万物皆有菲涅尔反射。F0是即 0 度角入射的菲涅尔反射值。大多数非金属的F0范围是0.02~0.04，大多数金属的F0范围是0.7~1.0。\n* 线性空间（Linear Space）。光照计算必须在线性空间完成，shader 中输入的gamma空间的贴图比如漫反射贴图需要被转成线性空间，在具体操作时需要根据不同引擎和渲染器的不同做不同的操作。而描述物体表面属性的贴图如粗糙度，高光贴图，金属贴图等必须保证是线性空间。\n* 色调映射（Tone Mapping）。也称色调复制（tone reproduction），是将宽范围的照明级别拟合到屏幕有限色域内的过程。因为基于HDR渲染出来的亮度值会超过显示器能够显示最大亮度，所以需要使用色调映射，将光照结果从HDR转换为显示器能够正常显示的LDR。\n* 物质的光学特性（Substance Optical Properties）。现实世界中有不同类型的物质可分为三大类：绝缘体（Insulators），半导体（semi-conductors）和导体（conductors）。在渲染和游戏领域，我们一般只对其中的两个感兴趣：导体（金属）和绝缘体（电解质，非金属）。其中非金属具有单色/灰色镜面反射颜色。而金属具有彩色的镜面反射颜色。\n\n### 2.PBR范畴\n寒霜(Frostbite)引擎在SIGGRAPH 2014的分享《Moving Frostbite to PBR》中提出，基于物理的渲染的范畴，由三部分组成：\n\n* 基于物理的材质（Material）\n* 基于物理的光照（Lighting）\n* 基于物理适配的摄像机（Camera）\n\n\n## 二、渲染方程 BxDF\n\n### 1.渲染方程与反射方程\n\n* 渲染方程\n物理基础是能量守恒定律：　在一个特定的位置和方向，出射光 Lo 是自发光 Le 与反射光线之和，反射光线本身是各个方向的入射光 Li 之和乘以表面反射率及入射角。\n\n![某一点的渲染方程](/img/1608604177769.png)\n\n* 反射方程\n \n 在实时渲染中，我们常用的反射方程(The Reflectance Equation)，则是渲染方程的简化的版本，或者说是一个特例：\n ![某一点的反射方程](/img/1608604253600.png)\n \n ### 2. BxDF\n \n ![BxDF](/img/1608604419905.png)\n \n BxDF一般而言是对BRDF、BTDF、BSDF、BSSRDF等几种双向分布函数的一个统一的表示。\n其中，BSDF可以看做BRDF和BTDF更一般的形式，而且BSDF = BRDF + BTDF。\n而BSSRDF和BRDF的不同之处在于，BSSRDF可以指定不同的光线入射位置和出射位置。\n> 在上述这些BxDF中，BRDF最为简单，也最为常用。因为游戏和电影中的大多数物体都是不透明的，用BRDF就完全足够。而BSDF、BTDF、BSSRDF往往更多用于半透明材质和次表面散射材质。\n\n## 三、迪士尼原则的BxDF\n\n基于物理的渲染，其实早在20世纪就已经在图形学业界有了一些讨论，2010年在SIGGRAPH上就已经有公开讨论的Course 《SIGGRAPH 2010 Course: Physically-Based Shading Models in Film and Game Production》，而直到2012~2013年，才正式进入大众的视野，渐渐被电影和游戏业界广泛使用。\n\n迪士尼动画工作室则是这次PBR革命的重要推动者。迪士尼的Brent Burley于SIGGRAPH 2012上进行了著名的talk《Physically-based shading at Disney》，提出了迪士尼原则的BRDF（Disney Principled BRDF）， 由于其高度的通用性，将材质复杂的物理属性，用非常直观的少量变量表达了出来（如金属度metallic和粗糙度roughness），在电影业界和游戏业界引起了不小的轰动。从此，基于物理的渲染正式进入大众的视野。\n\n## 3.1 迪士尼的BRDF\n在2012年迪士尼原则的BRDF被提出之前，基于物理的渲染都需要大量复杂而不直观的参数，此时PBR的优势，并没有那么明显。\n\n在2012年迪士尼提出，他们的着色模型是艺术导向（Art Directable）的，而不一定要是完全物理正确（physically correct）的，并且对微平面BRDF的各项都进行了严谨的调查，并提出了清晰明确而简单的解决方案。\n\n> 迪士尼的理念是开发一种“原则性”的易用模型，而不是严格的物理模型。正因为这种艺术导向的易用性，能让美术同学用非常直观的少量参数，以及非常标准化的工作流，就能快速实现涉及大量不同材质的真实感的渲染工作。而这对于传统的着色模型来说，是不可能完成的任务。\n\n> 迪士尼原则的BRDF（Disney Principled BRDF）核心理念如下：\n* 应使用直观的参数，而不是物理类的晦涩参数。\n* 参数应尽可能少。\n* 参数在其合理范围内应该为0到1。\n* 允许参数在有意义时超出正常的合理范围。\n* 所有参数组合应尽可能健壮和合理。\n\n颜色参数（baseColor）和下面描述的十个标量参数：\n\n* baseColor（基础色）：表面颜色，通常由纹理贴图提供。\n* subsurface（次表面）：使用次表面近似控制漫反射形状。\n* metallic（金属度）：金属（0 =电介质，1=金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。\n* specular（镜面反射强度）：入射镜面反射量。用于取代折射率。\n* specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（base color）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。\n* roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。\n* anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 =各向同性，1 =最大各向异性）\n* sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。\n* sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。\n* clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。\n* clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 =“缎面（satin）”外观，1 =“光泽（gloss）”外观。\n\n![Disney BRDF](/img/1608606276958.png)\n\n## 四、漫反射BRDF模型（Diffuse BRDF）\n\nDiffuse BRDF可以分为传统型和基于物理型两大类。其中，传统型主要是众所周知的Lambert。\n\n而基于物理型，从1994年的Oren Nayar开始，这里一直统计到今年（2018年）。\n\n其中较新的有GDC 2017上提出的适用于GGX+Smith的基于物理的漫反射模型（PBR diffuse for GGX+Smith），也包含了最近在SIGGRAPH2018上提出的，来自《使命召唤：二战》的多散射漫反射BRDF（MultiScattrering Diffuse BRDF）：\n\nOren Nayar[1994]\nSimplified Oren-Nayar [2012]\nDisney Diffuse[2012]\nRenormalized Disney Diffuse[2014]\nGotanda Diffuse [2014]\nPBR diffuse for GGX+Smith [2017]\nMultiScattrering Diffuse BRDF [2018]\n\n\n## 五、镜面反射BRDF模型（Specular BRDF）\n\n基于物理的渲染领域中最活跃，最主要的部分。\n游戏业界目前最主流的基于物理的镜面反射BRDF模型是基于微平面理论（microfacet theory）的Microfacet Cook-Torrance BRDF。\n\n![Cook-Torrance的BRDF公式](/img/1608610266103.png)\n\n![展开反射方程](/img/1608610379037.png)\n\n由于假设微观几何尺度明显大于可见光波长，因此可以将每个表面点视为光学平坦的。 如上文所述，光学平坦表面将光线分成两个方向：反射和折射。\n\n每个表面点将来自给定进入方向的光反射到单个出射方向，该方向取决于微观几何法线（microgeometry normal）m的方向。 在计算BRDF项时，指定光方向l和视图方向v。 这意味着所有表面点，只有那些恰好正确朝向可以将l反射到v的那些小平面可能有助于BRDF值（其他方向有正有负，积分之后，相互抵消）。\n\n在下图中，我们可以看到这些“正确朝向”的表面点的表面法线m正好位于l和v之间的中间位置。l和v之间的矢量称为半矢量（half-vector）或半角矢量（half-angle vector）; 我们将其表示为h。\n![有效的BRDF贡献点](/img/1608607466758.png)\n\n并非所有m = h的表面点都会积极地对反射做出贡献;一些被l方向（阴影shadowing），v方向（掩蔽masking）或两者的其他表面区域阻挡。Microfacet理论假设所有被遮蔽的光（shadowed light）都从镜面反射项中消失;实际上，由于多次表面反射，其中一些最终将是可见的，但这在目前常见的微平面理论中一般并未去考虑，各种类型的光表面相互作用如下图所示。\n\n![m=h的表面并全是BRDF贡献点](/img/1608607682403.png)\n\n### 5.1 从物理现象到BRDF\n\n其实可理解为金属质感\n![Specular BRDF公式](/img/1608607797277.png)\n\n其中：\n\n* D(h) : 法线分布函数 （Normal Distribution Function），描述微面元法线分布的概率，即正确朝向的法线的浓度。即具有正确朝向，能够将来自l的光反射到v的表面点的相对于表面面积的浓度。\n* F(l,h) : 菲涅尔方程（Fresnel Equation），描述不同的表面角下表面所反射的光线所占的比率。\n* G(l,v,h) : 几何函数（Geometry Function），描述微平面自成阴影的属性，即m = h的未被遮蔽的表面点的百分比。\n* 分母 4(n·l)(n·v）：校正因子（correctionfactor），作为微观几何的局部空间和整个宏观表面的局部空间之间变换的微平面量的校正。\n\n>关于Cook-Torrance BRDF，需要强调的两点注意事项：\n对于分母中的点积，仅仅避免负值是不够的 ,也必须避免零值。通常通过在常规的clamp或绝对值操作之后添加非常小的正值来完成。\nMicrofacet Cook-Torrance BRDF是实践中使用最广泛的模型，实际上也是人们可以想到的最简单的微平面模型。它仅对几何光学系统中的单层微表面上的单个散射进行建模，没有考虑多次散射，分层材质，以及衍射。Microfacet模型，实际上还有很长的路要走。\n\n### 5.2 Specular D\n\n法线分布函数（Normal Distribution Function, NDF）D的常见模型可以总结如下：\n\nBeckmann[1963]\nBlinn-Phong[1977]\nGGX [2007] / Trowbridge-Reitz[1975]\nGeneralized-Trowbridge-Reitz(GTR) [2012]\nAnisotropic Beckmann[2012]\nAnisotropic GGX [2015]\n\n![GGX与blinn-phong效果对比](/img/1608608044790.png)\n\n在这里m表示用来与平面上微平面做比较用的中间向量，而a表示表面粗糙度。\n\n> 另外，需要强调一点。Normal Distribution Function正确的翻译是法线分布函数，而不是正态分布函数。google翻译等翻译软件会将Normal Distribution Function翻译成正态分布函数，而不少中文资料就跟着翻译成了正态分布函数，这是错误的。\n\n>镜面分布，从统计学上近似的表示了与向量m取向一致的微平面的比率。举例来说，假设给定向量m，如果我们的微平面中有35%与向量m取向一致，则正态分布函数或者说NDF将会返回0.35\n### 5.3 Specular F\n菲涅尔效应（Fresnel effect）作为基于物理的渲染理念中的核心理念之一，表示的是看到的光线的反射率与视角相关的现象\n\n菲涅尔项的常见模型可以总结如下：\n\nCook-Torrance [1982]\nSchlick [1994]\nGotanta [2014]\n\n![Schlick公式](/img/1608608155043.png)\n\n![近似方程](/img/1608609564859.png)\n\n![Unity中的F0的线性运算](/img/1608609585831.png)\n## 5.4 Specular G\n\n几何项G的常见模型可以总结如下：\n\nSmith [1967]\nCook-Torrance [1982]\nNeumann [1999]\nKelemen [2001]\nImplicit [2013]\n\n另外，Eric Heitz在[Heitz14]中展示了Smith几何阴影函数是正确且更准确的G项，并将其拓展为Smith联合遮蔽阴影函数（Smith Joint Masking-Shadowing Function），该函数具有四种形式：\n\n分离遮蔽阴影型（Separable Masking and Shadowing）\n高度相关掩蔽阴影型（Height-Correlated Masking and Shadowing）\n方向相关掩蔽阴影型（Direction-Correlated Masking and Shadowing）\n高度-方向相关掩蔽阴影型（Height-Direction-Correlated Masking and Shadowing）\n\n目前较为常用的是其中最为简单的形式，分离遮蔽阴影（Separable Masking and Shadowing Function）。\n\n该形式将几何项G分为两个独立的部分：光线方向（light）和视线方向（view），并对两者用相同的分布函数来描述。根据这种思想，结合法线分布函数（NDF）与Smith几何阴影函数，于是有了以下新的Smith几何项：\n\nSmith-GGX\nSmith-Beckmann\nSmith-Schlick\nSchlick-Beckmann\nSchlick-GGX\n其中UE4的方案是上面列举中的“Schlick-GGX”，即基于Schlick近似，将k映射为 [公式] ,去匹配GGX Smith方程：\n\n![Schlick-GGX方程](/img/1608608340955.png)","slug":"基于物理的渲染-PBR","published":1,"date":"2020-12-22T04:22:00.823Z","updated":"2020-12-22T04:22:00.823Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckizhf0ai0000hof0gqrhxxwy","content":"<h2 id=\"一、PBR核心理论\"><a href=\"#一、PBR核心理论\" class=\"headerlink\" title=\"一、PBR核心理论\"></a>一、PBR核心理论</h2><h3 id=\"1-基础理念\"><a href=\"#1-基础理念\" class=\"headerlink\" title=\"1. 基础理念\"></a>1. 基础理念</h3><ul>\n<li>微平面理论（Microfacet Theory）。微平面理论是将物体表面建模成做无数微观尺度上有随机朝向的理想镜面反射的小平面（microfacet）的理论。在实际的PBR 工作流中，这种物体表面的不规则性用粗糙度贴图或者高光度贴图来表示。</li>\n<li>能量守恒（Energy Conservation）。出射光线的能量永远不能超过入射光线的能量。随着粗糙度的上升镜面反射区域的面积会增加，作为平衡，镜面反射区域的平均亮度则会下降。</li>\n<li>菲涅尔反射（Fresnel Reflectance）。光线以不同角度入射会有不同的反射率。相同的入射角度，不同的物质也会有不同的反射率。万物皆有菲涅尔反射。F0是即 0 度角入射的菲涅尔反射值。大多数非金属的F0范围是0.02<del>0.04，大多数金属的F0范围是0.7</del>1.0。</li>\n<li>线性空间（Linear Space）。光照计算必须在线性空间完成，shader 中输入的gamma空间的贴图比如漫反射贴图需要被转成线性空间，在具体操作时需要根据不同引擎和渲染器的不同做不同的操作。而描述物体表面属性的贴图如粗糙度，高光贴图，金属贴图等必须保证是线性空间。</li>\n<li>色调映射（Tone Mapping）。也称色调复制（tone reproduction），是将宽范围的照明级别拟合到屏幕有限色域内的过程。因为基于HDR渲染出来的亮度值会超过显示器能够显示最大亮度，所以需要使用色调映射，将光照结果从HDR转换为显示器能够正常显示的LDR。</li>\n<li>物质的光学特性（Substance Optical Properties）。现实世界中有不同类型的物质可分为三大类：绝缘体（Insulators），半导体（semi-conductors）和导体（conductors）。在渲染和游戏领域，我们一般只对其中的两个感兴趣：导体（金属）和绝缘体（电解质，非金属）。其中非金属具有单色/灰色镜面反射颜色。而金属具有彩色的镜面反射颜色。</li>\n</ul>\n<h3 id=\"2-PBR范畴\"><a href=\"#2-PBR范畴\" class=\"headerlink\" title=\"2.PBR范畴\"></a>2.PBR范畴</h3><p>寒霜(Frostbite)引擎在SIGGRAPH 2014的分享《Moving Frostbite to PBR》中提出，基于物理的渲染的范畴，由三部分组成：</p>\n<ul>\n<li>基于物理的材质（Material）</li>\n<li>基于物理的光照（Lighting）</li>\n<li>基于物理适配的摄像机（Camera）</li>\n</ul>\n<h2 id=\"二、渲染方程-BxDF\"><a href=\"#二、渲染方程-BxDF\" class=\"headerlink\" title=\"二、渲染方程 BxDF\"></a>二、渲染方程 BxDF</h2><h3 id=\"1-渲染方程与反射方程\"><a href=\"#1-渲染方程与反射方程\" class=\"headerlink\" title=\"1.渲染方程与反射方程\"></a>1.渲染方程与反射方程</h3><ul>\n<li>渲染方程<br>物理基础是能量守恒定律：　在一个特定的位置和方向，出射光 Lo 是自发光 Le 与反射光线之和，反射光线本身是各个方向的入射光 Li 之和乘以表面反射率及入射角。</li>\n</ul>\n<p><img src=\"/img/1608604177769.png\" alt=\"某一点的渲染方程\"></p>\n<ul>\n<li><p>反射方程</p>\n<p>在实时渲染中，我们常用的反射方程(The Reflectance Equation)，则是渲染方程的简化的版本，或者说是一个特例：<br><img src=\"/img/1608604253600.png\" alt=\"某一点的反射方程\"></p>\n<h3 id=\"2-BxDF\"><a href=\"#2-BxDF\" class=\"headerlink\" title=\"2. BxDF\"></a>2. BxDF</h3><p><img src=\"/img/1608604419905.png\" alt=\"BxDF\"></p>\n<p>BxDF一般而言是对BRDF、BTDF、BSDF、BSSRDF等几种双向分布函数的一个统一的表示。<br>其中，BSDF可以看做BRDF和BTDF更一般的形式，而且BSDF = BRDF + BTDF。<br>而BSSRDF和BRDF的不同之处在于，BSSRDF可以指定不同的光线入射位置和出射位置。</p>\n<blockquote>\n<p>在上述这些BxDF中，BRDF最为简单，也最为常用。因为游戏和电影中的大多数物体都是不透明的，用BRDF就完全足够。而BSDF、BTDF、BSSRDF往往更多用于半透明材质和次表面散射材质。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"三、迪士尼原则的BxDF\"><a href=\"#三、迪士尼原则的BxDF\" class=\"headerlink\" title=\"三、迪士尼原则的BxDF\"></a>三、迪士尼原则的BxDF</h2><p>基于物理的渲染，其实早在20世纪就已经在图形学业界有了一些讨论，2010年在SIGGRAPH上就已经有公开讨论的Course 《SIGGRAPH 2010 Course: Physically-Based Shading Models in Film and Game Production》，而直到2012~2013年，才正式进入大众的视野，渐渐被电影和游戏业界广泛使用。</p>\n<p>迪士尼动画工作室则是这次PBR革命的重要推动者。迪士尼的Brent Burley于SIGGRAPH 2012上进行了著名的talk《Physically-based shading at Disney》，提出了迪士尼原则的BRDF（Disney Principled BRDF）， 由于其高度的通用性，将材质复杂的物理属性，用非常直观的少量变量表达了出来（如金属度metallic和粗糙度roughness），在电影业界和游戏业界引起了不小的轰动。从此，基于物理的渲染正式进入大众的视野。</p>\n<h2 id=\"3-1-迪士尼的BRDF\"><a href=\"#3-1-迪士尼的BRDF\" class=\"headerlink\" title=\"3.1 迪士尼的BRDF\"></a>3.1 迪士尼的BRDF</h2><p>在2012年迪士尼原则的BRDF被提出之前，基于物理的渲染都需要大量复杂而不直观的参数，此时PBR的优势，并没有那么明显。</p>\n<p>在2012年迪士尼提出，他们的着色模型是艺术导向（Art Directable）的，而不一定要是完全物理正确（physically correct）的，并且对微平面BRDF的各项都进行了严谨的调查，并提出了清晰明确而简单的解决方案。</p>\n<blockquote>\n<p>迪士尼的理念是开发一种“原则性”的易用模型，而不是严格的物理模型。正因为这种艺术导向的易用性，能让美术同学用非常直观的少量参数，以及非常标准化的工作流，就能快速实现涉及大量不同材质的真实感的渲染工作。而这对于传统的着色模型来说，是不可能完成的任务。</p>\n</blockquote>\n<blockquote>\n<p>迪士尼原则的BRDF（Disney Principled BRDF）核心理念如下：</p>\n</blockquote>\n<ul>\n<li>应使用直观的参数，而不是物理类的晦涩参数。</li>\n<li>参数应尽可能少。</li>\n<li>参数在其合理范围内应该为0到1。</li>\n<li>允许参数在有意义时超出正常的合理范围。</li>\n<li>所有参数组合应尽可能健壮和合理。</li>\n</ul>\n<p>颜色参数（baseColor）和下面描述的十个标量参数：</p>\n<ul>\n<li>baseColor（基础色）：表面颜色，通常由纹理贴图提供。</li>\n<li>subsurface（次表面）：使用次表面近似控制漫反射形状。</li>\n<li>metallic（金属度）：金属（0 =电介质，1=金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。</li>\n<li>specular（镜面反射强度）：入射镜面反射量。用于取代折射率。</li>\n<li>specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（base color）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。</li>\n<li>roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。</li>\n<li>anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 =各向同性，1 =最大各向异性）</li>\n<li>sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。</li>\n<li>sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。</li>\n<li>clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。</li>\n<li>clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 =“缎面（satin）”外观，1 =“光泽（gloss）”外观。</li>\n</ul>\n<p><img src=\"/img/1608606276958.png\" alt=\"Disney BRDF\"></p>\n<h2 id=\"四、漫反射BRDF模型（Diffuse-BRDF）\"><a href=\"#四、漫反射BRDF模型（Diffuse-BRDF）\" class=\"headerlink\" title=\"四、漫反射BRDF模型（Diffuse BRDF）\"></a>四、漫反射BRDF模型（Diffuse BRDF）</h2><p>Diffuse BRDF可以分为传统型和基于物理型两大类。其中，传统型主要是众所周知的Lambert。</p>\n<p>而基于物理型，从1994年的Oren Nayar开始，这里一直统计到今年（2018年）。</p>\n<p>其中较新的有GDC 2017上提出的适用于GGX+Smith的基于物理的漫反射模型（PBR diffuse for GGX+Smith），也包含了最近在SIGGRAPH2018上提出的，来自《使命召唤：二战》的多散射漫反射BRDF（MultiScattrering Diffuse BRDF）：</p>\n<p>Oren Nayar[1994]<br>Simplified Oren-Nayar [2012]<br>Disney Diffuse[2012]<br>Renormalized Disney Diffuse[2014]<br>Gotanda Diffuse [2014]<br>PBR diffuse for GGX+Smith [2017]<br>MultiScattrering Diffuse BRDF [2018]</p>\n<h2 id=\"五、镜面反射BRDF模型（Specular-BRDF）\"><a href=\"#五、镜面反射BRDF模型（Specular-BRDF）\" class=\"headerlink\" title=\"五、镜面反射BRDF模型（Specular BRDF）\"></a>五、镜面反射BRDF模型（Specular BRDF）</h2><p>基于物理的渲染领域中最活跃，最主要的部分。<br>游戏业界目前最主流的基于物理的镜面反射BRDF模型是基于微平面理论（microfacet theory）的Microfacet Cook-Torrance BRDF。</p>\n<p><img src=\"/img/1608610266103.png\" alt=\"Cook-Torrance的BRDF公式\"></p>\n<p><img src=\"/img/1608610379037.png\" alt=\"展开反射方程\"></p>\n<p>由于假设微观几何尺度明显大于可见光波长，因此可以将每个表面点视为光学平坦的。 如上文所述，光学平坦表面将光线分成两个方向：反射和折射。</p>\n<p>每个表面点将来自给定进入方向的光反射到单个出射方向，该方向取决于微观几何法线（microgeometry normal）m的方向。 在计算BRDF项时，指定光方向l和视图方向v。 这意味着所有表面点，只有那些恰好正确朝向可以将l反射到v的那些小平面可能有助于BRDF值（其他方向有正有负，积分之后，相互抵消）。</p>\n<p>在下图中，我们可以看到这些“正确朝向”的表面点的表面法线m正好位于l和v之间的中间位置。l和v之间的矢量称为半矢量（half-vector）或半角矢量（half-angle vector）; 我们将其表示为h。<br><img src=\"/img/1608607466758.png\" alt=\"有效的BRDF贡献点\"></p>\n<p>并非所有m = h的表面点都会积极地对反射做出贡献;一些被l方向（阴影shadowing），v方向（掩蔽masking）或两者的其他表面区域阻挡。Microfacet理论假设所有被遮蔽的光（shadowed light）都从镜面反射项中消失;实际上，由于多次表面反射，其中一些最终将是可见的，但这在目前常见的微平面理论中一般并未去考虑，各种类型的光表面相互作用如下图所示。</p>\n<p><img src=\"/img/1608607682403.png\" alt=\"m=h的表面并全是BRDF贡献点\"></p>\n<h3 id=\"5-1-从物理现象到BRDF\"><a href=\"#5-1-从物理现象到BRDF\" class=\"headerlink\" title=\"5.1 从物理现象到BRDF\"></a>5.1 从物理现象到BRDF</h3><p>其实可理解为金属质感<br><img src=\"/img/1608607797277.png\" alt=\"Specular BRDF公式\"></p>\n<p>其中：</p>\n<ul>\n<li>D(h) : 法线分布函数 （Normal Distribution Function），描述微面元法线分布的概率，即正确朝向的法线的浓度。即具有正确朝向，能够将来自l的光反射到v的表面点的相对于表面面积的浓度。</li>\n<li>F(l,h) : 菲涅尔方程（Fresnel Equation），描述不同的表面角下表面所反射的光线所占的比率。</li>\n<li>G(l,v,h) : 几何函数（Geometry Function），描述微平面自成阴影的属性，即m = h的未被遮蔽的表面点的百分比。</li>\n<li>分母 4(n·l)(n·v）：校正因子（correctionfactor），作为微观几何的局部空间和整个宏观表面的局部空间之间变换的微平面量的校正。</li>\n</ul>\n<blockquote>\n<p>关于Cook-Torrance BRDF，需要强调的两点注意事项：<br>对于分母中的点积，仅仅避免负值是不够的 ,也必须避免零值。通常通过在常规的clamp或绝对值操作之后添加非常小的正值来完成。<br>Microfacet Cook-Torrance BRDF是实践中使用最广泛的模型，实际上也是人们可以想到的最简单的微平面模型。它仅对几何光学系统中的单层微表面上的单个散射进行建模，没有考虑多次散射，分层材质，以及衍射。Microfacet模型，实际上还有很长的路要走。</p>\n</blockquote>\n<h3 id=\"5-2-Specular-D\"><a href=\"#5-2-Specular-D\" class=\"headerlink\" title=\"5.2 Specular D\"></a>5.2 Specular D</h3><p>法线分布函数（Normal Distribution Function, NDF）D的常见模型可以总结如下：</p>\n<p>Beckmann[1963]<br>Blinn-Phong[1977]<br>GGX [2007] / Trowbridge-Reitz[1975]<br>Generalized-Trowbridge-Reitz(GTR) [2012]<br>Anisotropic Beckmann[2012]<br>Anisotropic GGX [2015]</p>\n<p><img src=\"/img/1608608044790.png\" alt=\"GGX与blinn-phong效果对比\"></p>\n<p>在这里m表示用来与平面上微平面做比较用的中间向量，而a表示表面粗糙度。</p>\n<blockquote>\n<p>另外，需要强调一点。Normal Distribution Function正确的翻译是法线分布函数，而不是正态分布函数。google翻译等翻译软件会将Normal Distribution Function翻译成正态分布函数，而不少中文资料就跟着翻译成了正态分布函数，这是错误的。</p>\n</blockquote>\n<blockquote>\n<p>镜面分布，从统计学上近似的表示了与向量m取向一致的微平面的比率。举例来说，假设给定向量m，如果我们的微平面中有35%与向量m取向一致，则正态分布函数或者说NDF将会返回0.35</p>\n</blockquote>\n<h3 id=\"5-3-Specular-F\"><a href=\"#5-3-Specular-F\" class=\"headerlink\" title=\"5.3 Specular F\"></a>5.3 Specular F</h3><p>菲涅尔效应（Fresnel effect）作为基于物理的渲染理念中的核心理念之一，表示的是看到的光线的反射率与视角相关的现象</p>\n<p>菲涅尔项的常见模型可以总结如下：</p>\n<p>Cook-Torrance [1982]<br>Schlick [1994]<br>Gotanta [2014]</p>\n<p><img src=\"/img/1608608155043.png\" alt=\"Schlick公式\"></p>\n<p><img src=\"/img/1608609564859.png\" alt=\"近似方程\"></p>\n<p><img src=\"/img/1608609585831.png\" alt=\"Unity中的F0的线性运算\"></p>\n<h2 id=\"5-4-Specular-G\"><a href=\"#5-4-Specular-G\" class=\"headerlink\" title=\"5.4 Specular G\"></a>5.4 Specular G</h2><p>几何项G的常见模型可以总结如下：</p>\n<p>Smith [1967]<br>Cook-Torrance [1982]<br>Neumann [1999]<br>Kelemen [2001]<br>Implicit [2013]</p>\n<p>另外，Eric Heitz在[Heitz14]中展示了Smith几何阴影函数是正确且更准确的G项，并将其拓展为Smith联合遮蔽阴影函数（Smith Joint Masking-Shadowing Function），该函数具有四种形式：</p>\n<p>分离遮蔽阴影型（Separable Masking and Shadowing）<br>高度相关掩蔽阴影型（Height-Correlated Masking and Shadowing）<br>方向相关掩蔽阴影型（Direction-Correlated Masking and Shadowing）<br>高度-方向相关掩蔽阴影型（Height-Direction-Correlated Masking and Shadowing）</p>\n<p>目前较为常用的是其中最为简单的形式，分离遮蔽阴影（Separable Masking and Shadowing Function）。</p>\n<p>该形式将几何项G分为两个独立的部分：光线方向（light）和视线方向（view），并对两者用相同的分布函数来描述。根据这种思想，结合法线分布函数（NDF）与Smith几何阴影函数，于是有了以下新的Smith几何项：</p>\n<p>Smith-GGX<br>Smith-Beckmann<br>Smith-Schlick<br>Schlick-Beckmann<br>Schlick-GGX<br>其中UE4的方案是上面列举中的“Schlick-GGX”，即基于Schlick近似，将k映射为 [公式] ,去匹配GGX Smith方程：</p>\n<p><img src=\"/img/1608608340955.png\" alt=\"Schlick-GGX方程\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、PBR核心理论\"><a href=\"#一、PBR核心理论\" class=\"headerlink\" title=\"一、PBR核心理论\"></a>一、PBR核心理论</h2><h3 id=\"1-基础理念\"><a href=\"#1-基础理念\" class=\"headerlink\" title=\"1. 基础理念\"></a>1. 基础理念</h3><ul>\n<li>微平面理论（Microfacet Theory）。微平面理论是将物体表面建模成做无数微观尺度上有随机朝向的理想镜面反射的小平面（microfacet）的理论。在实际的PBR 工作流中，这种物体表面的不规则性用粗糙度贴图或者高光度贴图来表示。</li>\n<li>能量守恒（Energy Conservation）。出射光线的能量永远不能超过入射光线的能量。随着粗糙度的上升镜面反射区域的面积会增加，作为平衡，镜面反射区域的平均亮度则会下降。</li>\n<li>菲涅尔反射（Fresnel Reflectance）。光线以不同角度入射会有不同的反射率。相同的入射角度，不同的物质也会有不同的反射率。万物皆有菲涅尔反射。F0是即 0 度角入射的菲涅尔反射值。大多数非金属的F0范围是0.02<del>0.04，大多数金属的F0范围是0.7</del>1.0。</li>\n<li>线性空间（Linear Space）。光照计算必须在线性空间完成，shader 中输入的gamma空间的贴图比如漫反射贴图需要被转成线性空间，在具体操作时需要根据不同引擎和渲染器的不同做不同的操作。而描述物体表面属性的贴图如粗糙度，高光贴图，金属贴图等必须保证是线性空间。</li>\n<li>色调映射（Tone Mapping）。也称色调复制（tone reproduction），是将宽范围的照明级别拟合到屏幕有限色域内的过程。因为基于HDR渲染出来的亮度值会超过显示器能够显示最大亮度，所以需要使用色调映射，将光照结果从HDR转换为显示器能够正常显示的LDR。</li>\n<li>物质的光学特性（Substance Optical Properties）。现实世界中有不同类型的物质可分为三大类：绝缘体（Insulators），半导体（semi-conductors）和导体（conductors）。在渲染和游戏领域，我们一般只对其中的两个感兴趣：导体（金属）和绝缘体（电解质，非金属）。其中非金属具有单色/灰色镜面反射颜色。而金属具有彩色的镜面反射颜色。</li>\n</ul>\n<h3 id=\"2-PBR范畴\"><a href=\"#2-PBR范畴\" class=\"headerlink\" title=\"2.PBR范畴\"></a>2.PBR范畴</h3><p>寒霜(Frostbite)引擎在SIGGRAPH 2014的分享《Moving Frostbite to PBR》中提出，基于物理的渲染的范畴，由三部分组成：</p>\n<ul>\n<li>基于物理的材质（Material）</li>\n<li>基于物理的光照（Lighting）</li>\n<li>基于物理适配的摄像机（Camera）</li>\n</ul>\n<h2 id=\"二、渲染方程-BxDF\"><a href=\"#二、渲染方程-BxDF\" class=\"headerlink\" title=\"二、渲染方程 BxDF\"></a>二、渲染方程 BxDF</h2><h3 id=\"1-渲染方程与反射方程\"><a href=\"#1-渲染方程与反射方程\" class=\"headerlink\" title=\"1.渲染方程与反射方程\"></a>1.渲染方程与反射方程</h3><ul>\n<li>渲染方程<br>物理基础是能量守恒定律：　在一个特定的位置和方向，出射光 Lo 是自发光 Le 与反射光线之和，反射光线本身是各个方向的入射光 Li 之和乘以表面反射率及入射角。</li>\n</ul>\n<p><img src=\"/img/1608604177769.png\" alt=\"某一点的渲染方程\"></p>\n<ul>\n<li><p>反射方程</p>\n<p>在实时渲染中，我们常用的反射方程(The Reflectance Equation)，则是渲染方程的简化的版本，或者说是一个特例：<br><img src=\"/img/1608604253600.png\" alt=\"某一点的反射方程\"></p>\n<h3 id=\"2-BxDF\"><a href=\"#2-BxDF\" class=\"headerlink\" title=\"2. BxDF\"></a>2. BxDF</h3><p><img src=\"/img/1608604419905.png\" alt=\"BxDF\"></p>\n<p>BxDF一般而言是对BRDF、BTDF、BSDF、BSSRDF等几种双向分布函数的一个统一的表示。<br>其中，BSDF可以看做BRDF和BTDF更一般的形式，而且BSDF = BRDF + BTDF。<br>而BSSRDF和BRDF的不同之处在于，BSSRDF可以指定不同的光线入射位置和出射位置。</p>\n<blockquote>\n<p>在上述这些BxDF中，BRDF最为简单，也最为常用。因为游戏和电影中的大多数物体都是不透明的，用BRDF就完全足够。而BSDF、BTDF、BSSRDF往往更多用于半透明材质和次表面散射材质。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"三、迪士尼原则的BxDF\"><a href=\"#三、迪士尼原则的BxDF\" class=\"headerlink\" title=\"三、迪士尼原则的BxDF\"></a>三、迪士尼原则的BxDF</h2><p>基于物理的渲染，其实早在20世纪就已经在图形学业界有了一些讨论，2010年在SIGGRAPH上就已经有公开讨论的Course 《SIGGRAPH 2010 Course: Physically-Based Shading Models in Film and Game Production》，而直到2012~2013年，才正式进入大众的视野，渐渐被电影和游戏业界广泛使用。</p>\n<p>迪士尼动画工作室则是这次PBR革命的重要推动者。迪士尼的Brent Burley于SIGGRAPH 2012上进行了著名的talk《Physically-based shading at Disney》，提出了迪士尼原则的BRDF（Disney Principled BRDF）， 由于其高度的通用性，将材质复杂的物理属性，用非常直观的少量变量表达了出来（如金属度metallic和粗糙度roughness），在电影业界和游戏业界引起了不小的轰动。从此，基于物理的渲染正式进入大众的视野。</p>\n<h2 id=\"3-1-迪士尼的BRDF\"><a href=\"#3-1-迪士尼的BRDF\" class=\"headerlink\" title=\"3.1 迪士尼的BRDF\"></a>3.1 迪士尼的BRDF</h2><p>在2012年迪士尼原则的BRDF被提出之前，基于物理的渲染都需要大量复杂而不直观的参数，此时PBR的优势，并没有那么明显。</p>\n<p>在2012年迪士尼提出，他们的着色模型是艺术导向（Art Directable）的，而不一定要是完全物理正确（physically correct）的，并且对微平面BRDF的各项都进行了严谨的调查，并提出了清晰明确而简单的解决方案。</p>\n<blockquote>\n<p>迪士尼的理念是开发一种“原则性”的易用模型，而不是严格的物理模型。正因为这种艺术导向的易用性，能让美术同学用非常直观的少量参数，以及非常标准化的工作流，就能快速实现涉及大量不同材质的真实感的渲染工作。而这对于传统的着色模型来说，是不可能完成的任务。</p>\n</blockquote>\n<blockquote>\n<p>迪士尼原则的BRDF（Disney Principled BRDF）核心理念如下：</p>\n</blockquote>\n<ul>\n<li>应使用直观的参数，而不是物理类的晦涩参数。</li>\n<li>参数应尽可能少。</li>\n<li>参数在其合理范围内应该为0到1。</li>\n<li>允许参数在有意义时超出正常的合理范围。</li>\n<li>所有参数组合应尽可能健壮和合理。</li>\n</ul>\n<p>颜色参数（baseColor）和下面描述的十个标量参数：</p>\n<ul>\n<li>baseColor（基础色）：表面颜色，通常由纹理贴图提供。</li>\n<li>subsurface（次表面）：使用次表面近似控制漫反射形状。</li>\n<li>metallic（金属度）：金属（0 =电介质，1=金属）。这是两种不同模型之间的线性混合。金属模型没有漫反射成分，并且还具有等于基础色的着色入射镜面反射。</li>\n<li>specular（镜面反射强度）：入射镜面反射量。用于取代折射率。</li>\n<li>specularTint（镜面反射颜色）：对美术控制的让步，用于对基础色（base color）的入射镜面反射进行颜色控制。掠射镜面反射仍然是非彩色的。</li>\n<li>roughness（粗糙度）：表面粗糙度，控制漫反射和镜面反射。</li>\n<li>anisotropic（各向异性强度）：各向异性程度。用于控制镜面反射高光的纵横比。（0 =各向同性，1 =最大各向异性）</li>\n<li>sheen（光泽度）：一种额外的掠射分量（grazing component），主要用于布料。</li>\n<li>sheenTint（光泽颜色）：对sheen（光泽度）的颜色控制。</li>\n<li>clearcoat（清漆强度）：有特殊用途的第二个镜面波瓣（specular lobe）。</li>\n<li>clearcoatGloss（清漆光泽度）：控制透明涂层光泽度，0 =“缎面（satin）”外观，1 =“光泽（gloss）”外观。</li>\n</ul>\n<p><img src=\"/img/1608606276958.png\" alt=\"Disney BRDF\"></p>\n<h2 id=\"四、漫反射BRDF模型（Diffuse-BRDF）\"><a href=\"#四、漫反射BRDF模型（Diffuse-BRDF）\" class=\"headerlink\" title=\"四、漫反射BRDF模型（Diffuse BRDF）\"></a>四、漫反射BRDF模型（Diffuse BRDF）</h2><p>Diffuse BRDF可以分为传统型和基于物理型两大类。其中，传统型主要是众所周知的Lambert。</p>\n<p>而基于物理型，从1994年的Oren Nayar开始，这里一直统计到今年（2018年）。</p>\n<p>其中较新的有GDC 2017上提出的适用于GGX+Smith的基于物理的漫反射模型（PBR diffuse for GGX+Smith），也包含了最近在SIGGRAPH2018上提出的，来自《使命召唤：二战》的多散射漫反射BRDF（MultiScattrering Diffuse BRDF）：</p>\n<p>Oren Nayar[1994]<br>Simplified Oren-Nayar [2012]<br>Disney Diffuse[2012]<br>Renormalized Disney Diffuse[2014]<br>Gotanda Diffuse [2014]<br>PBR diffuse for GGX+Smith [2017]<br>MultiScattrering Diffuse BRDF [2018]</p>\n<h2 id=\"五、镜面反射BRDF模型（Specular-BRDF）\"><a href=\"#五、镜面反射BRDF模型（Specular-BRDF）\" class=\"headerlink\" title=\"五、镜面反射BRDF模型（Specular BRDF）\"></a>五、镜面反射BRDF模型（Specular BRDF）</h2><p>基于物理的渲染领域中最活跃，最主要的部分。<br>游戏业界目前最主流的基于物理的镜面反射BRDF模型是基于微平面理论（microfacet theory）的Microfacet Cook-Torrance BRDF。</p>\n<p><img src=\"/img/1608610266103.png\" alt=\"Cook-Torrance的BRDF公式\"></p>\n<p><img src=\"/img/1608610379037.png\" alt=\"展开反射方程\"></p>\n<p>由于假设微观几何尺度明显大于可见光波长，因此可以将每个表面点视为光学平坦的。 如上文所述，光学平坦表面将光线分成两个方向：反射和折射。</p>\n<p>每个表面点将来自给定进入方向的光反射到单个出射方向，该方向取决于微观几何法线（microgeometry normal）m的方向。 在计算BRDF项时，指定光方向l和视图方向v。 这意味着所有表面点，只有那些恰好正确朝向可以将l反射到v的那些小平面可能有助于BRDF值（其他方向有正有负，积分之后，相互抵消）。</p>\n<p>在下图中，我们可以看到这些“正确朝向”的表面点的表面法线m正好位于l和v之间的中间位置。l和v之间的矢量称为半矢量（half-vector）或半角矢量（half-angle vector）; 我们将其表示为h。<br><img src=\"/img/1608607466758.png\" alt=\"有效的BRDF贡献点\"></p>\n<p>并非所有m = h的表面点都会积极地对反射做出贡献;一些被l方向（阴影shadowing），v方向（掩蔽masking）或两者的其他表面区域阻挡。Microfacet理论假设所有被遮蔽的光（shadowed light）都从镜面反射项中消失;实际上，由于多次表面反射，其中一些最终将是可见的，但这在目前常见的微平面理论中一般并未去考虑，各种类型的光表面相互作用如下图所示。</p>\n<p><img src=\"/img/1608607682403.png\" alt=\"m=h的表面并全是BRDF贡献点\"></p>\n<h3 id=\"5-1-从物理现象到BRDF\"><a href=\"#5-1-从物理现象到BRDF\" class=\"headerlink\" title=\"5.1 从物理现象到BRDF\"></a>5.1 从物理现象到BRDF</h3><p>其实可理解为金属质感<br><img src=\"/img/1608607797277.png\" alt=\"Specular BRDF公式\"></p>\n<p>其中：</p>\n<ul>\n<li>D(h) : 法线分布函数 （Normal Distribution Function），描述微面元法线分布的概率，即正确朝向的法线的浓度。即具有正确朝向，能够将来自l的光反射到v的表面点的相对于表面面积的浓度。</li>\n<li>F(l,h) : 菲涅尔方程（Fresnel Equation），描述不同的表面角下表面所反射的光线所占的比率。</li>\n<li>G(l,v,h) : 几何函数（Geometry Function），描述微平面自成阴影的属性，即m = h的未被遮蔽的表面点的百分比。</li>\n<li>分母 4(n·l)(n·v）：校正因子（correctionfactor），作为微观几何的局部空间和整个宏观表面的局部空间之间变换的微平面量的校正。</li>\n</ul>\n<blockquote>\n<p>关于Cook-Torrance BRDF，需要强调的两点注意事项：<br>对于分母中的点积，仅仅避免负值是不够的 ,也必须避免零值。通常通过在常规的clamp或绝对值操作之后添加非常小的正值来完成。<br>Microfacet Cook-Torrance BRDF是实践中使用最广泛的模型，实际上也是人们可以想到的最简单的微平面模型。它仅对几何光学系统中的单层微表面上的单个散射进行建模，没有考虑多次散射，分层材质，以及衍射。Microfacet模型，实际上还有很长的路要走。</p>\n</blockquote>\n<h3 id=\"5-2-Specular-D\"><a href=\"#5-2-Specular-D\" class=\"headerlink\" title=\"5.2 Specular D\"></a>5.2 Specular D</h3><p>法线分布函数（Normal Distribution Function, NDF）D的常见模型可以总结如下：</p>\n<p>Beckmann[1963]<br>Blinn-Phong[1977]<br>GGX [2007] / Trowbridge-Reitz[1975]<br>Generalized-Trowbridge-Reitz(GTR) [2012]<br>Anisotropic Beckmann[2012]<br>Anisotropic GGX [2015]</p>\n<p><img src=\"/img/1608608044790.png\" alt=\"GGX与blinn-phong效果对比\"></p>\n<p>在这里m表示用来与平面上微平面做比较用的中间向量，而a表示表面粗糙度。</p>\n<blockquote>\n<p>另外，需要强调一点。Normal Distribution Function正确的翻译是法线分布函数，而不是正态分布函数。google翻译等翻译软件会将Normal Distribution Function翻译成正态分布函数，而不少中文资料就跟着翻译成了正态分布函数，这是错误的。</p>\n</blockquote>\n<blockquote>\n<p>镜面分布，从统计学上近似的表示了与向量m取向一致的微平面的比率。举例来说，假设给定向量m，如果我们的微平面中有35%与向量m取向一致，则正态分布函数或者说NDF将会返回0.35</p>\n</blockquote>\n<h3 id=\"5-3-Specular-F\"><a href=\"#5-3-Specular-F\" class=\"headerlink\" title=\"5.3 Specular F\"></a>5.3 Specular F</h3><p>菲涅尔效应（Fresnel effect）作为基于物理的渲染理念中的核心理念之一，表示的是看到的光线的反射率与视角相关的现象</p>\n<p>菲涅尔项的常见模型可以总结如下：</p>\n<p>Cook-Torrance [1982]<br>Schlick [1994]<br>Gotanta [2014]</p>\n<p><img src=\"/img/1608608155043.png\" alt=\"Schlick公式\"></p>\n<p><img src=\"/img/1608609564859.png\" alt=\"近似方程\"></p>\n<p><img src=\"/img/1608609585831.png\" alt=\"Unity中的F0的线性运算\"></p>\n<h2 id=\"5-4-Specular-G\"><a href=\"#5-4-Specular-G\" class=\"headerlink\" title=\"5.4 Specular G\"></a>5.4 Specular G</h2><p>几何项G的常见模型可以总结如下：</p>\n<p>Smith [1967]<br>Cook-Torrance [1982]<br>Neumann [1999]<br>Kelemen [2001]<br>Implicit [2013]</p>\n<p>另外，Eric Heitz在[Heitz14]中展示了Smith几何阴影函数是正确且更准确的G项，并将其拓展为Smith联合遮蔽阴影函数（Smith Joint Masking-Shadowing Function），该函数具有四种形式：</p>\n<p>分离遮蔽阴影型（Separable Masking and Shadowing）<br>高度相关掩蔽阴影型（Height-Correlated Masking and Shadowing）<br>方向相关掩蔽阴影型（Direction-Correlated Masking and Shadowing）<br>高度-方向相关掩蔽阴影型（Height-Direction-Correlated Masking and Shadowing）</p>\n<p>目前较为常用的是其中最为简单的形式，分离遮蔽阴影（Separable Masking and Shadowing Function）。</p>\n<p>该形式将几何项G分为两个独立的部分：光线方向（light）和视线方向（view），并对两者用相同的分布函数来描述。根据这种思想，结合法线分布函数（NDF）与Smith几何阴影函数，于是有了以下新的Smith几何项：</p>\n<p>Smith-GGX<br>Smith-Beckmann<br>Smith-Schlick<br>Schlick-Beckmann<br>Schlick-GGX<br>其中UE4的方案是上面列举中的“Schlick-GGX”，即基于Schlick近似，将k映射为 [公式] ,去匹配GGX Smith方程：</p>\n<p><img src=\"/img/1608608340955.png\" alt=\"Schlick-GGX方程\"></p>\n"},{"title":"Lua源码研究","_content":"\n\n## 一、版本更替\n\nLua 5.4 : Lua 5.4 was released on 29 Jun 2020     The current release is Lua 5.4.2, released on 03 Dec 2020.\n> Main changes\nnew generational mode for garbage collection           垃圾收集的新分代模式\nto-be-closed variables           可close的变量\nconst variables                  常量变量\nuserdata can have multiple user values Userdata                    可以有多个用户值\nnew implementation for math.random                          Math.random 的新实现\nwarning system               报警系统\ndebug information about function arguments and returns     有关函数参数和返回值的调试信息\nnew semantics for the integer 'for' loop                 整数‘ for’循环的新语义\noptional 'init' argument to 'string.gmatch'           可选的“ init”参数设置为“ string.gmatch”\nnew functions 'lua_resetthread' and 'coroutine.close'        新函数‘ lua _ resetthread’和‘ coroutine.close’\nstring-to-number coercions moved to the string library       字符串到数字的强制转移到字符串库\nallocation function allowed to fail when shrinking a memory block          缩小内存块时允许失败的分配函数\nnew format '%p' in 'string.format'                      新格式“% p”中的“ string.format”\nutf8 library accepts codepoints up to 2^31                          Utf8库接受最多2 ^ 31的代码点\n\n\nLua 5.3 : Lua 5.3 was released on 12 Jan 2015    The current release is Lua 5.3.6, released on 25 Sep 2020\n>There will probably be no further releases of Lua 5.3.\nintegers (64-bit by default)  整数(默认为64位)  Lua5.2中所有数字都是浮点数\nofficial support for 32-bit numbers  32位数字的官方支持\nbitwise operators    按位运算符\nbasic utf-8 support 基本 utf-8支持\nfunctions for packing and unpacking values   包装和拆包 数值的函数\n垃圾收集器的分代模式被删除了\n\nLua 5.2 : was released on 16 Dec 2011.  The last release was Lua 5.2.4, released on 07 Mar 2015. There will be no further releases of Lua 5.2.\n> Main changes:\nyieldable pcall and metamethods\nnew lexical scheme for globals:  全局变量的新词法模式\nephemeron tables : \nnew library for bitwise operations\nlight C functions\nemergency garbage collector\ngoto statement\nfinalizers for tables\n> module函数已被弃用。使用常规的Lua代码设置一个模块很容易。不再期望模块设置全局变量。\nsetfenv和getfenv函数被删除，因为环境概念的更改。\nmath.log10函数已被弃用。可以使用math.log并向第2个参数传入10来代替。\nloadstring函数已被弃用。使用load代替，它现在可以接受字符串参数且等同于loadstring。\ntable.maxn函数已被弃用。如果你确实需要请在Lua中自己实现。\nos.execute函数现在如果命令成功终止则返回true，否则返回nil和一个错误消息。\nunpack函数被移到table库中，因此要改成这样调用 table.unpack。\n模式中的字符类%z已被弃用，因为现在模式可以包含\\0作为正常字符。\n表package.loaders重命名为package.searchers。\nLua不再有字节码验证。所以，所有加载代码的函数(load和loadfile)在加载不信任的二进制数据时都可能有潜在的不安全。(实际上，由于验证算法的缺陷，这些函数一直都是不安全的)。如有疑惑，请将这些函数的mode参数限制为只加载文本的块。\n官方发布包中的标准路径可能会在不同版本间修改。\n\n\nLua jit: \nLuaJIT 是按照 5.1 的语法设计的，并且在可以预期的将来也永远不会适配 5.2，LuaJIT 作者声称会增加 5.2 所增加的那些功能，但永远不会适配 5.2 的语法，换句话说，他的发展思路是语法与兼容性不变，仅仅在 5.1 的语法基础之上增加后续 Lua 版本的新特性，LuaJIT 在 API/ABI 方面都只兼容 Lua 5.1.4。\n\n## 二、LUA 5.4新特性\n\n参考： https://zhuanlan.zhihu.com/p/283055561\n\nLua 5.4语法上最大的变化是增加了const和TBC变量，前者完全由编译器支持，后者则由专门的TBC指令支持。Lua 5.4对整数for循环语义进行了调整，控制变量溢出会导致循环结束。算术和按位运算在Lua 5.3里会自动将字符串转换为浮点数，在Lua 5.4里，这一自动转换不再由语言直接支持，改为由string标准库的元方法支持（仅支持算术运算，且转换时会保留整数类型）。Lua 5.4不再使用__lt模拟__le元方法（但可通过配置兼容Lua 5.3）。此外，Lua 5.4还增加了新的分代GC模式，重新实现了math.random()函数，等等。\n\n### 1. const语法\n\n``` lua\nlocal a <const> = 4\nlocal b = a + 7\nprint(b)\n```\n编译器会把a消除掉，直接给b赋11。这种优化是有限的，对于基本类型和字符串，能够有效减少寄存器的访问，但对于table貌似益处不大。代码文件如果需要一些数值常量，可以写成const变量，比如：\n\n``` lua\nlocal MAX_LEN <const> = 20\nfunction check_name(name)\n    return #name <= MAX_LEN\nend\n```\n在check_name中就没有upvalue的访问，而是直接转换成和20的比较。\n\n### 2. close语法\n\nclose变量(To-be-closed Variables)需要和close元方法结合使用，在变量超出作用域时，会调用变量的close元方法，这听起来是不是有点像C++的RAII用法。下面是一个例子：\n\n``` lua\nlocal function newlock()\n    local lock = {\n        acquire = function()\n            print(\"acquire lock\")\n        end,\n        release = function()\n            print(\"release lock\")\n        end,\n    }\n    return lock\nend\n\nlocal function lockguard(lock)\n    local wrap = {\n        lock = lock\n    }\n    lock.acquire()\n    return setmetatable(wrap, {__close = function(t, err)\n        t.lock.release()\n    end})\nend\n\nlocal lock = newlock()\ndo\n    for i = 1, 3 do\n        local l <close> = lockguard(lock)\n        print(i)\n        error(\"err\")\n    end\nend\n```\n定义local l /<close/>后，无论是否有错误，release都能得到调用；从这个例子也可以看出，close变量一般用于需要及时释放资源的情况；否则Lua的GC可以应付大多数情况。\n\n### 3.userdata\nuserdata现在可以关联多个user值，C的API也有相应的修改，如果我们新建的userdata没有关联值，则尽量使用lua_newuserdatauv，这样更高效，lua_newuserdata仅仅为了兼容，且默认会关联1个值。\n\n### 4. math.random\nmath.random使用了新的实现，会从某个随机种子开始，简单说即程序启动后第1次调用math.random会得到不同值；以前版本都从相同值开始。\n\n### 5.协程库新API\n协程库提供了新的APIcoroutine.close和lua_resetthread，coroutine.close只能在挂起或死亡状态下调用，挂起状态下会使用协程进入死亡状态，并且关闭所有的close变量。\n\n\n### 6.整数for循环\n循环达到最近的整数就会停止\n\n如果在Lua 5.3里执行这段代码，那么会进入死循环。但是在Lua 5.4里，只打印4个整数就结束循环了：\n\n``` lua\n$ lua-5.4.1/lua -\nfor i = math.maxinteger - 10, math.maxinteger, 3 do\n  print(i)\nend\n^D\n9223372036854775797\n9223372036854775800\n9223372036854775803\n9223372036854775806\n```\n\n### 7.str-to-num语言特性变更\n变化一： 在Lua 5.3里，str-to-num类型转换是由语言（和虚拟机）直接支持的。在Lua 5.4里，改为由string标准库通过元方法支持。\n\n以下代码在5.3中只输出一个index元方法，5.4中却输出很多\n``` lua\nlocal s = \"foo\"\nlocal mt = getmetatable(s)\nprint(mt)\nfor k,v in pairs(mt) do\n  print(k,v)\nend\n```\n\n``` lua\n--5.4输出\ntable: 0133A450\n__idiv  function: 0033AA40\n__index table: 0133A590\n__pow   function: 0033A960\n__div   function: 0033A9D0\n__mul   function: 0033A880\n__sub   function: 0033A810\n__unm   function: 0033AAB0\n__add   function: 0033A7A0\n__mod   function: 0033A8F0\n```\n变化二：在一的元方法列表中并未找到按位运算的元方法，因此会导致自动按位运算不支持\n变化三：str-to-num会尽量为整数类型返回\n\n### 8. le元方法\nLua 5.3认为a <= b和not (b < a)等价，因此如果元表没有提供__le元方法，那么将尝试用__lt元方法进行模拟。Lua 5.4不再认同这个假设，因此必要时必须显示提供__le元方法。下面来看一个例子：\n\n``` lua\nlocal mt = {\n  __lt = function(a, b)\n    print(\"__lt\", a, b)\n    return #a < #b\n  end\n}\nlocal a = {1, 2, 3}\nlocal b = {1, 2, 3, 4}\nsetmetatable(a, mt)\nsetmetatable(b, mt)\nprint(a < b)\nprint(a <= b)\n```\nLua 5.4源代码提供了一个LUA_COMPAT_LT_LE宏，用来控制__le的行为是否和Lua 5.3保持一致，所以上面这个例子的具体执行结果取决于lua被编译时给定的配置。这个宏在Lua 5.3的构建文件（Makefile）里默认是被打开的。\n\n### 9.警告系统\n\nLua 5.4增加了warn()标准库函数，用于发布警告，用法为：warn (msg1, ···)。相应的，lua命令增加了一个-W选项。只有该选项开启，警告才会被打印到控制台。下面是一个简单的例子：\n\n``` lua\nwarn(\"foo\", \"bar\")\n^D\nLua warning: foobar\n```\n\n### 10.string库\n\n#### gmatch()函数\n增加了可选的init参数，用法如下所示：\n\n``` lua\nstring.gmatch (s, pattern)          -- Lua 5.3\nstring.gmatch (s, pattern [, init]) -- Lua 5.4\n\ns = \"hello world from Lua\"\nfor w in string.gmatch(s, \"%a+\", 3) do\n  print(w)\nend\n```\n在Lua 5.4里执行，结果如下所示（注意第一行的llo）：\nllo\nworld\nfrom\nLua\n\n#### format()函数\n\n增加了%p格式，可以打印指针，下面是一个例子：\n\n``` lua\nlocal t = {1, 2, 3}\nprint(t, \",\", string.format('%p', t))\n```\n\n在Lua 5.4里执行，打印出的结果看起来是下面这样：\n\n``` lua\ntable: 0x7fde1cd04a30   ,   0x7fde1cd04a30\n```\n### 11.垃圾回收\nLua 5.4给垃圾收集器（GC）增加了分代模式，可以通过collectgarbage()函数在老的增量模式和新模式之间切换（以及调整控制GC的参数）：\n\n``` lua\n-- Change the collector mode to generational.\ncollectgarbage(\"generational\", minor_mul, major_mul)\n-- Change the collector mode to incremental.\ncollectgarbage(\"incremental\", pause, step_mul, step_size)\n--同时，原先的两个选项setpause和setstepmul已经被废弃：\n\ncollectgarbage(\"setpause\", pause)      -- deprecated\ncollectgarbage(\"setstepmul\", step_mul) -- deprecated\n```\n\n## 三、相关知识点复习\n\n### 元表与元方法\n\n1. index元方法\n这是metatable最常用的键\n\n当你通过键来访问table的时候，如果这个键没有值，那么Lua就会寻找该table的metatable(假定有metatable)中的__index键。如果index 包含一个表格，Lua会在表格中查找对应的键。\n\n如果index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。\n\n> !!! 取值的时候，查看是否存在，如果有值则显示值 ，没有则调用index元方法，找元方法中的值 \n\n``` lua\nmytable = setmetatable({key1 = \"value1\"},\n\t{__index = function(mytable,key)\n\tif key == \"key2\" then \n\t\treturn \"metatablevalue\"\n\telse \n\t\treturn nil\n\tend \nend \n})\nprint(mytable.key1,mytable.key2)\n\n--实际输出结果为：\n--value1 metatablevalue\n```\n\n\n2. newindex元方法\n\n> 赋值的时候，如果有值 ，则取值，没有值，则会触发newindex元方法，如果元方法是一个table，则会用此table替代原table\n\n``` lua\nmymetatable = {}\nmytable = setmetatable({key1 = \"value1\"},{__newindex = mymetatable})\nprint(mytable.key1)\nmytable.newkey = \"新值2\"\nprint(mytable.newkey,mymetatable.newkey)\nmytable.key1 = \"新值1\"\nprint(mytable.key1,mymetatable.key1)\n--以下实例执行输出结构为：\n\n--value1\n--nil    新值2\n--新值1    nil\n```\n\n\n## 四、LUA GC\nLua是一门自动内存管理的语言，它使用的是经典的标记和清扫算法。\n\n### 4.1 标记和清除模式\n在标记阶段，从根集对象开始标记，把整个对象层级都标记完，这些被标记到的对象称为可到达的对象。\n在清扫阶段，遍历上面提到的对象链表，如果对象被标记过则擦除标记并跳过，如果对象没被标记，说明它不可到达，那就把它释放掉。\n\n> Lua 5.0之前，垃圾回收是一个stop the world的过程，即在执行GC的时候要一次性完成，它的好处是代码相对简单，5.0的GC代码不过几百行，如果你想了解GC算法本身，看一下5.0的lgc.h|c是非常好的。\n这种stop the world的GC在轻量的应用中不是什么问题，如果遇到程序非常大，对象特别多的情况，效率就很成问题了。因此在5.1之后，Lua进化成一个步进的GC，原理还是标记和清扫，但是把一个GC周期分成很多步，一次只执行一步。这对GC的效率是一个很大的提升，代价就是GC代码变得很复杂，Lua 5.3已经有一千多行。\n从代码上看，除了GC分步，还有upvalues，弱表，终结对象(有__gc元方法的对象)的处理，这些都加大了垃圾回收的复杂度。\n\n\n#### 三色标记\n一个GC对象分成三种颜色(三种状态):\n\n白色：表示对象未被标记，在GC周期开始之前对象为白色，如果到清扫阶段还是白色，那就说明该对象不可到达，要被清除掉。\n灰色：表示对象本身已标记，但它引用的对象未被标记，比如一个表已被标记，它的键值对象还未标记。这表示对象标记的一个中间状态。\n黑色：表示对象和它引用的对象都已被标记，在清扫阶段黑色对象为可到达对象。\n\nmarked就是对象的标记状态，它的位含义如下：\n\n第0位：第1种白\n第1位：第2种白\n第2位：黑\n第3位：标记为终结对象\n灰色为0, 1, 2位都清0的情况。\n\n我们注意到白色有两个状态，这是为了解决分步GC的中间新建对象的问题。比如在标记阶段和清扫阶段的中间，有一个新建的对象，它默认为白色；清扫的时候会因为它是白色而把它给释放掉。引入两种白色之后这样处理：\n\n>g->currentwhite表示当前白，它是两种白色中的任意一种，我们假定为白1，在清扫阶段之前，所有白对象都是白1。\n>在标记阶段结束的时候，g->currentwhite切换为白2，现在之前那些白对象和g->currentwhite就是不同白了(因为它们是白1)。\n>在标记结束之后，清扫开始之前，新建一个对象，默认标记当g->currentwhite，也就是白2。\n>>在清扫的时候，只会清扫和g->currentwhite不同的白，即白1。这样那些新建的对象就不会在清扫阶段被释放。而在清扫结束之后，这些新建的对象也会变成白2。等待下一个周期。\n要被终结对象就是那些有__gc元方法的对象。\n\n\n#### 对象链表\nglobal_State有好多和GC相关的字段，其中有一些重要链表。所有GC对象总是在下面的一个链表中：\n\nallgc 所有未被标记为终结的对象\nfinobj 所有被标记为终结的对象\ntobefnz 所有准备终结的对象(准备调用__gc的对象)\nfixedgc 不会被回收的对象\n\n> gfasttm(g,mt, TM_GC)函数: 如果给对象设置一个元表，且元表有__gc元方法，那么它会从allgc取出，加入到finobj去，并设置对象的FINALIZEDBIT标记位(就是上面说的第3个marked位)。 \n\n在标记阶段，finobj中的白对象会移到tobefnz链表去，然后标记这些对象，这样当前周期不会释放这些对象；清扫完之后会进入GCScallfin阶段，在这里调用tobefnz对象的gc方法，同时把对象移回allgc链表；如果gc中使对象重新变成可到达，则对象复活过来；否则下个周期这个对象就会被正常清除。\n\nfixedgc 是那些不会被回收的对象，在新建完对象后，必须马上调用luaC_fix把对象从allgc移到fixedgc去。GC的过程不会对fixedgc进行清扫。\n\n对于灰对象还有好几个链表：\n\ngray 普通的灰对象链表\ngrayagain 在GCSatomic阶段(是标记阶段的一个子阶段)中重新访问的灰对象，这些灰对象包括：\n进行写屏蔽的黑对象\n在传播阶段的弱表\n所有线程对象\n\nweak 待清理的弱值表\nallweak 待清理的弱键值表\nephemeron 弱键表\n可以看出这些灰对象链表是由分步和弱表引入的附加数据结构，这也是GC中较为复杂的部分。\n\n#### 写屏障\n从前文的描述知道，Lua的GC不断的遍历灰对象并把它们变黑，在遍历的过程中又有新的灰对象产生，一直重复这个过程到没有灰对象为止。此时黑对象就是可到达的对象，剩下的白对象就是不可到达的对象，要被清扫掉的。\n\n在标记阶段中有一个重要的不变条件是：黑对象不能指向白对象。比如我们有一个普通的表是黑色的，那这个表必然已经被遍历过了，所以它里面的键值一定不是白色的。\n\n但这个假设只是在一次性标记这个前提下成立。如果是增量式的，每次只标记一部分，那在标记的中间有一些修改，可能会打破这个不变式。比如t被标记为黑色，后面有一个赋值t.x = {}使得t指向了白色对象。","source":"_posts/Lua源码研究.md","raw":"---\ntitle: Lua源码研究\ncategories:\n- Unity\n---\n\n\n## 一、版本更替\n\nLua 5.4 : Lua 5.4 was released on 29 Jun 2020     The current release is Lua 5.4.2, released on 03 Dec 2020.\n> Main changes\nnew generational mode for garbage collection           垃圾收集的新分代模式\nto-be-closed variables           可close的变量\nconst variables                  常量变量\nuserdata can have multiple user values Userdata                    可以有多个用户值\nnew implementation for math.random                          Math.random 的新实现\nwarning system               报警系统\ndebug information about function arguments and returns     有关函数参数和返回值的调试信息\nnew semantics for the integer 'for' loop                 整数‘ for’循环的新语义\noptional 'init' argument to 'string.gmatch'           可选的“ init”参数设置为“ string.gmatch”\nnew functions 'lua_resetthread' and 'coroutine.close'        新函数‘ lua _ resetthread’和‘ coroutine.close’\nstring-to-number coercions moved to the string library       字符串到数字的强制转移到字符串库\nallocation function allowed to fail when shrinking a memory block          缩小内存块时允许失败的分配函数\nnew format '%p' in 'string.format'                      新格式“% p”中的“ string.format”\nutf8 library accepts codepoints up to 2^31                          Utf8库接受最多2 ^ 31的代码点\n\n\nLua 5.3 : Lua 5.3 was released on 12 Jan 2015    The current release is Lua 5.3.6, released on 25 Sep 2020\n>There will probably be no further releases of Lua 5.3.\nintegers (64-bit by default)  整数(默认为64位)  Lua5.2中所有数字都是浮点数\nofficial support for 32-bit numbers  32位数字的官方支持\nbitwise operators    按位运算符\nbasic utf-8 support 基本 utf-8支持\nfunctions for packing and unpacking values   包装和拆包 数值的函数\n垃圾收集器的分代模式被删除了\n\nLua 5.2 : was released on 16 Dec 2011.  The last release was Lua 5.2.4, released on 07 Mar 2015. There will be no further releases of Lua 5.2.\n> Main changes:\nyieldable pcall and metamethods\nnew lexical scheme for globals:  全局变量的新词法模式\nephemeron tables : \nnew library for bitwise operations\nlight C functions\nemergency garbage collector\ngoto statement\nfinalizers for tables\n> module函数已被弃用。使用常规的Lua代码设置一个模块很容易。不再期望模块设置全局变量。\nsetfenv和getfenv函数被删除，因为环境概念的更改。\nmath.log10函数已被弃用。可以使用math.log并向第2个参数传入10来代替。\nloadstring函数已被弃用。使用load代替，它现在可以接受字符串参数且等同于loadstring。\ntable.maxn函数已被弃用。如果你确实需要请在Lua中自己实现。\nos.execute函数现在如果命令成功终止则返回true，否则返回nil和一个错误消息。\nunpack函数被移到table库中，因此要改成这样调用 table.unpack。\n模式中的字符类%z已被弃用，因为现在模式可以包含\\0作为正常字符。\n表package.loaders重命名为package.searchers。\nLua不再有字节码验证。所以，所有加载代码的函数(load和loadfile)在加载不信任的二进制数据时都可能有潜在的不安全。(实际上，由于验证算法的缺陷，这些函数一直都是不安全的)。如有疑惑，请将这些函数的mode参数限制为只加载文本的块。\n官方发布包中的标准路径可能会在不同版本间修改。\n\n\nLua jit: \nLuaJIT 是按照 5.1 的语法设计的，并且在可以预期的将来也永远不会适配 5.2，LuaJIT 作者声称会增加 5.2 所增加的那些功能，但永远不会适配 5.2 的语法，换句话说，他的发展思路是语法与兼容性不变，仅仅在 5.1 的语法基础之上增加后续 Lua 版本的新特性，LuaJIT 在 API/ABI 方面都只兼容 Lua 5.1.4。\n\n## 二、LUA 5.4新特性\n\n参考： https://zhuanlan.zhihu.com/p/283055561\n\nLua 5.4语法上最大的变化是增加了const和TBC变量，前者完全由编译器支持，后者则由专门的TBC指令支持。Lua 5.4对整数for循环语义进行了调整，控制变量溢出会导致循环结束。算术和按位运算在Lua 5.3里会自动将字符串转换为浮点数，在Lua 5.4里，这一自动转换不再由语言直接支持，改为由string标准库的元方法支持（仅支持算术运算，且转换时会保留整数类型）。Lua 5.4不再使用__lt模拟__le元方法（但可通过配置兼容Lua 5.3）。此外，Lua 5.4还增加了新的分代GC模式，重新实现了math.random()函数，等等。\n\n### 1. const语法\n\n``` lua\nlocal a <const> = 4\nlocal b = a + 7\nprint(b)\n```\n编译器会把a消除掉，直接给b赋11。这种优化是有限的，对于基本类型和字符串，能够有效减少寄存器的访问，但对于table貌似益处不大。代码文件如果需要一些数值常量，可以写成const变量，比如：\n\n``` lua\nlocal MAX_LEN <const> = 20\nfunction check_name(name)\n    return #name <= MAX_LEN\nend\n```\n在check_name中就没有upvalue的访问，而是直接转换成和20的比较。\n\n### 2. close语法\n\nclose变量(To-be-closed Variables)需要和close元方法结合使用，在变量超出作用域时，会调用变量的close元方法，这听起来是不是有点像C++的RAII用法。下面是一个例子：\n\n``` lua\nlocal function newlock()\n    local lock = {\n        acquire = function()\n            print(\"acquire lock\")\n        end,\n        release = function()\n            print(\"release lock\")\n        end,\n    }\n    return lock\nend\n\nlocal function lockguard(lock)\n    local wrap = {\n        lock = lock\n    }\n    lock.acquire()\n    return setmetatable(wrap, {__close = function(t, err)\n        t.lock.release()\n    end})\nend\n\nlocal lock = newlock()\ndo\n    for i = 1, 3 do\n        local l <close> = lockguard(lock)\n        print(i)\n        error(\"err\")\n    end\nend\n```\n定义local l /<close/>后，无论是否有错误，release都能得到调用；从这个例子也可以看出，close变量一般用于需要及时释放资源的情况；否则Lua的GC可以应付大多数情况。\n\n### 3.userdata\nuserdata现在可以关联多个user值，C的API也有相应的修改，如果我们新建的userdata没有关联值，则尽量使用lua_newuserdatauv，这样更高效，lua_newuserdata仅仅为了兼容，且默认会关联1个值。\n\n### 4. math.random\nmath.random使用了新的实现，会从某个随机种子开始，简单说即程序启动后第1次调用math.random会得到不同值；以前版本都从相同值开始。\n\n### 5.协程库新API\n协程库提供了新的APIcoroutine.close和lua_resetthread，coroutine.close只能在挂起或死亡状态下调用，挂起状态下会使用协程进入死亡状态，并且关闭所有的close变量。\n\n\n### 6.整数for循环\n循环达到最近的整数就会停止\n\n如果在Lua 5.3里执行这段代码，那么会进入死循环。但是在Lua 5.4里，只打印4个整数就结束循环了：\n\n``` lua\n$ lua-5.4.1/lua -\nfor i = math.maxinteger - 10, math.maxinteger, 3 do\n  print(i)\nend\n^D\n9223372036854775797\n9223372036854775800\n9223372036854775803\n9223372036854775806\n```\n\n### 7.str-to-num语言特性变更\n变化一： 在Lua 5.3里，str-to-num类型转换是由语言（和虚拟机）直接支持的。在Lua 5.4里，改为由string标准库通过元方法支持。\n\n以下代码在5.3中只输出一个index元方法，5.4中却输出很多\n``` lua\nlocal s = \"foo\"\nlocal mt = getmetatable(s)\nprint(mt)\nfor k,v in pairs(mt) do\n  print(k,v)\nend\n```\n\n``` lua\n--5.4输出\ntable: 0133A450\n__idiv  function: 0033AA40\n__index table: 0133A590\n__pow   function: 0033A960\n__div   function: 0033A9D0\n__mul   function: 0033A880\n__sub   function: 0033A810\n__unm   function: 0033AAB0\n__add   function: 0033A7A0\n__mod   function: 0033A8F0\n```\n变化二：在一的元方法列表中并未找到按位运算的元方法，因此会导致自动按位运算不支持\n变化三：str-to-num会尽量为整数类型返回\n\n### 8. le元方法\nLua 5.3认为a <= b和not (b < a)等价，因此如果元表没有提供__le元方法，那么将尝试用__lt元方法进行模拟。Lua 5.4不再认同这个假设，因此必要时必须显示提供__le元方法。下面来看一个例子：\n\n``` lua\nlocal mt = {\n  __lt = function(a, b)\n    print(\"__lt\", a, b)\n    return #a < #b\n  end\n}\nlocal a = {1, 2, 3}\nlocal b = {1, 2, 3, 4}\nsetmetatable(a, mt)\nsetmetatable(b, mt)\nprint(a < b)\nprint(a <= b)\n```\nLua 5.4源代码提供了一个LUA_COMPAT_LT_LE宏，用来控制__le的行为是否和Lua 5.3保持一致，所以上面这个例子的具体执行结果取决于lua被编译时给定的配置。这个宏在Lua 5.3的构建文件（Makefile）里默认是被打开的。\n\n### 9.警告系统\n\nLua 5.4增加了warn()标准库函数，用于发布警告，用法为：warn (msg1, ···)。相应的，lua命令增加了一个-W选项。只有该选项开启，警告才会被打印到控制台。下面是一个简单的例子：\n\n``` lua\nwarn(\"foo\", \"bar\")\n^D\nLua warning: foobar\n```\n\n### 10.string库\n\n#### gmatch()函数\n增加了可选的init参数，用法如下所示：\n\n``` lua\nstring.gmatch (s, pattern)          -- Lua 5.3\nstring.gmatch (s, pattern [, init]) -- Lua 5.4\n\ns = \"hello world from Lua\"\nfor w in string.gmatch(s, \"%a+\", 3) do\n  print(w)\nend\n```\n在Lua 5.4里执行，结果如下所示（注意第一行的llo）：\nllo\nworld\nfrom\nLua\n\n#### format()函数\n\n增加了%p格式，可以打印指针，下面是一个例子：\n\n``` lua\nlocal t = {1, 2, 3}\nprint(t, \",\", string.format('%p', t))\n```\n\n在Lua 5.4里执行，打印出的结果看起来是下面这样：\n\n``` lua\ntable: 0x7fde1cd04a30   ,   0x7fde1cd04a30\n```\n### 11.垃圾回收\nLua 5.4给垃圾收集器（GC）增加了分代模式，可以通过collectgarbage()函数在老的增量模式和新模式之间切换（以及调整控制GC的参数）：\n\n``` lua\n-- Change the collector mode to generational.\ncollectgarbage(\"generational\", minor_mul, major_mul)\n-- Change the collector mode to incremental.\ncollectgarbage(\"incremental\", pause, step_mul, step_size)\n--同时，原先的两个选项setpause和setstepmul已经被废弃：\n\ncollectgarbage(\"setpause\", pause)      -- deprecated\ncollectgarbage(\"setstepmul\", step_mul) -- deprecated\n```\n\n## 三、相关知识点复习\n\n### 元表与元方法\n\n1. index元方法\n这是metatable最常用的键\n\n当你通过键来访问table的时候，如果这个键没有值，那么Lua就会寻找该table的metatable(假定有metatable)中的__index键。如果index 包含一个表格，Lua会在表格中查找对应的键。\n\n如果index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。\n\n> !!! 取值的时候，查看是否存在，如果有值则显示值 ，没有则调用index元方法，找元方法中的值 \n\n``` lua\nmytable = setmetatable({key1 = \"value1\"},\n\t{__index = function(mytable,key)\n\tif key == \"key2\" then \n\t\treturn \"metatablevalue\"\n\telse \n\t\treturn nil\n\tend \nend \n})\nprint(mytable.key1,mytable.key2)\n\n--实际输出结果为：\n--value1 metatablevalue\n```\n\n\n2. newindex元方法\n\n> 赋值的时候，如果有值 ，则取值，没有值，则会触发newindex元方法，如果元方法是一个table，则会用此table替代原table\n\n``` lua\nmymetatable = {}\nmytable = setmetatable({key1 = \"value1\"},{__newindex = mymetatable})\nprint(mytable.key1)\nmytable.newkey = \"新值2\"\nprint(mytable.newkey,mymetatable.newkey)\nmytable.key1 = \"新值1\"\nprint(mytable.key1,mymetatable.key1)\n--以下实例执行输出结构为：\n\n--value1\n--nil    新值2\n--新值1    nil\n```\n\n\n## 四、LUA GC\nLua是一门自动内存管理的语言，它使用的是经典的标记和清扫算法。\n\n### 4.1 标记和清除模式\n在标记阶段，从根集对象开始标记，把整个对象层级都标记完，这些被标记到的对象称为可到达的对象。\n在清扫阶段，遍历上面提到的对象链表，如果对象被标记过则擦除标记并跳过，如果对象没被标记，说明它不可到达，那就把它释放掉。\n\n> Lua 5.0之前，垃圾回收是一个stop the world的过程，即在执行GC的时候要一次性完成，它的好处是代码相对简单，5.0的GC代码不过几百行，如果你想了解GC算法本身，看一下5.0的lgc.h|c是非常好的。\n这种stop the world的GC在轻量的应用中不是什么问题，如果遇到程序非常大，对象特别多的情况，效率就很成问题了。因此在5.1之后，Lua进化成一个步进的GC，原理还是标记和清扫，但是把一个GC周期分成很多步，一次只执行一步。这对GC的效率是一个很大的提升，代价就是GC代码变得很复杂，Lua 5.3已经有一千多行。\n从代码上看，除了GC分步，还有upvalues，弱表，终结对象(有__gc元方法的对象)的处理，这些都加大了垃圾回收的复杂度。\n\n\n#### 三色标记\n一个GC对象分成三种颜色(三种状态):\n\n白色：表示对象未被标记，在GC周期开始之前对象为白色，如果到清扫阶段还是白色，那就说明该对象不可到达，要被清除掉。\n灰色：表示对象本身已标记，但它引用的对象未被标记，比如一个表已被标记，它的键值对象还未标记。这表示对象标记的一个中间状态。\n黑色：表示对象和它引用的对象都已被标记，在清扫阶段黑色对象为可到达对象。\n\nmarked就是对象的标记状态，它的位含义如下：\n\n第0位：第1种白\n第1位：第2种白\n第2位：黑\n第3位：标记为终结对象\n灰色为0, 1, 2位都清0的情况。\n\n我们注意到白色有两个状态，这是为了解决分步GC的中间新建对象的问题。比如在标记阶段和清扫阶段的中间，有一个新建的对象，它默认为白色；清扫的时候会因为它是白色而把它给释放掉。引入两种白色之后这样处理：\n\n>g->currentwhite表示当前白，它是两种白色中的任意一种，我们假定为白1，在清扫阶段之前，所有白对象都是白1。\n>在标记阶段结束的时候，g->currentwhite切换为白2，现在之前那些白对象和g->currentwhite就是不同白了(因为它们是白1)。\n>在标记结束之后，清扫开始之前，新建一个对象，默认标记当g->currentwhite，也就是白2。\n>>在清扫的时候，只会清扫和g->currentwhite不同的白，即白1。这样那些新建的对象就不会在清扫阶段被释放。而在清扫结束之后，这些新建的对象也会变成白2。等待下一个周期。\n要被终结对象就是那些有__gc元方法的对象。\n\n\n#### 对象链表\nglobal_State有好多和GC相关的字段，其中有一些重要链表。所有GC对象总是在下面的一个链表中：\n\nallgc 所有未被标记为终结的对象\nfinobj 所有被标记为终结的对象\ntobefnz 所有准备终结的对象(准备调用__gc的对象)\nfixedgc 不会被回收的对象\n\n> gfasttm(g,mt, TM_GC)函数: 如果给对象设置一个元表，且元表有__gc元方法，那么它会从allgc取出，加入到finobj去，并设置对象的FINALIZEDBIT标记位(就是上面说的第3个marked位)。 \n\n在标记阶段，finobj中的白对象会移到tobefnz链表去，然后标记这些对象，这样当前周期不会释放这些对象；清扫完之后会进入GCScallfin阶段，在这里调用tobefnz对象的gc方法，同时把对象移回allgc链表；如果gc中使对象重新变成可到达，则对象复活过来；否则下个周期这个对象就会被正常清除。\n\nfixedgc 是那些不会被回收的对象，在新建完对象后，必须马上调用luaC_fix把对象从allgc移到fixedgc去。GC的过程不会对fixedgc进行清扫。\n\n对于灰对象还有好几个链表：\n\ngray 普通的灰对象链表\ngrayagain 在GCSatomic阶段(是标记阶段的一个子阶段)中重新访问的灰对象，这些灰对象包括：\n进行写屏蔽的黑对象\n在传播阶段的弱表\n所有线程对象\n\nweak 待清理的弱值表\nallweak 待清理的弱键值表\nephemeron 弱键表\n可以看出这些灰对象链表是由分步和弱表引入的附加数据结构，这也是GC中较为复杂的部分。\n\n#### 写屏障\n从前文的描述知道，Lua的GC不断的遍历灰对象并把它们变黑，在遍历的过程中又有新的灰对象产生，一直重复这个过程到没有灰对象为止。此时黑对象就是可到达的对象，剩下的白对象就是不可到达的对象，要被清扫掉的。\n\n在标记阶段中有一个重要的不变条件是：黑对象不能指向白对象。比如我们有一个普通的表是黑色的，那这个表必然已经被遍历过了，所以它里面的键值一定不是白色的。\n\n但这个假设只是在一次性标记这个前提下成立。如果是增量式的，每次只标记一部分，那在标记的中间有一些修改，可能会打破这个不变式。比如t被标记为黑色，后面有一个赋值t.x = {}使得t指向了白色对象。","slug":"Lua源码研究","published":1,"date":"2020-12-23T03:45:06.499Z","updated":"2020-12-23T03:45:06.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckj0vjkdu00024rf04aarymuv","content":"<h2 id=\"一、版本更替\"><a href=\"#一、版本更替\" class=\"headerlink\" title=\"一、版本更替\"></a>一、版本更替</h2><p>Lua 5.4 : Lua 5.4 was released on 29 Jun 2020     The current release is Lua 5.4.2, released on 03 Dec 2020.</p>\n<blockquote>\n<p>Main changes<br>new generational mode for garbage collection           垃圾收集的新分代模式<br>to-be-closed variables           可close的变量<br>const variables                  常量变量<br>userdata can have multiple user values Userdata                    可以有多个用户值<br>new implementation for math.random                          Math.random 的新实现<br>warning system               报警系统<br>debug information about function arguments and returns     有关函数参数和返回值的调试信息<br>new semantics for the integer ‘for’ loop                 整数‘ for’循环的新语义<br>optional ‘init’ argument to ‘string.gmatch’           可选的“ init”参数设置为“ string.gmatch”<br>new functions ‘lua_resetthread’ and ‘coroutine.close’        新函数‘ lua _ resetthread’和‘ coroutine.close’<br>string-to-number coercions moved to the string library       字符串到数字的强制转移到字符串库<br>allocation function allowed to fail when shrinking a memory block          缩小内存块时允许失败的分配函数<br>new format ‘%p’ in ‘string.format’                      新格式“% p”中的“ string.format”<br>utf8 library accepts codepoints up to 2^31                          Utf8库接受最多2 ^ 31的代码点</p>\n</blockquote>\n<p>Lua 5.3 : Lua 5.3 was released on 12 Jan 2015    The current release is Lua 5.3.6, released on 25 Sep 2020</p>\n<blockquote>\n<p>There will probably be no further releases of Lua 5.3.<br>integers (64-bit by default)  整数(默认为64位)  Lua5.2中所有数字都是浮点数<br>official support for 32-bit numbers  32位数字的官方支持<br>bitwise operators    按位运算符<br>basic utf-8 support 基本 utf-8支持<br>functions for packing and unpacking values   包装和拆包 数值的函数<br>垃圾收集器的分代模式被删除了</p>\n</blockquote>\n<p>Lua 5.2 : was released on 16 Dec 2011.  The last release was Lua 5.2.4, released on 07 Mar 2015. There will be no further releases of Lua 5.2.</p>\n<blockquote>\n<p>Main changes:<br>yieldable pcall and metamethods<br>new lexical scheme for globals:  全局变量的新词法模式<br>ephemeron tables :<br>new library for bitwise operations<br>light C functions<br>emergency garbage collector<br>goto statement<br>finalizers for tables<br>module函数已被弃用。使用常规的Lua代码设置一个模块很容易。不再期望模块设置全局变量。<br>setfenv和getfenv函数被删除，因为环境概念的更改。<br>math.log10函数已被弃用。可以使用math.log并向第2个参数传入10来代替。<br>loadstring函数已被弃用。使用load代替，它现在可以接受字符串参数且等同于loadstring。<br>table.maxn函数已被弃用。如果你确实需要请在Lua中自己实现。<br>os.execute函数现在如果命令成功终止则返回true，否则返回nil和一个错误消息。<br>unpack函数被移到table库中，因此要改成这样调用 table.unpack。<br>模式中的字符类%z已被弃用，因为现在模式可以包含\\0作为正常字符。<br>表package.loaders重命名为package.searchers。<br>Lua不再有字节码验证。所以，所有加载代码的函数(load和loadfile)在加载不信任的二进制数据时都可能有潜在的不安全。(实际上，由于验证算法的缺陷，这些函数一直都是不安全的)。如有疑惑，请将这些函数的mode参数限制为只加载文本的块。<br>官方发布包中的标准路径可能会在不同版本间修改。</p>\n</blockquote>\n<p>Lua jit:<br>LuaJIT 是按照 5.1 的语法设计的，并且在可以预期的将来也永远不会适配 5.2，LuaJIT 作者声称会增加 5.2 所增加的那些功能，但永远不会适配 5.2 的语法，换句话说，他的发展思路是语法与兼容性不变，仅仅在 5.1 的语法基础之上增加后续 Lua 版本的新特性，LuaJIT 在 API/ABI 方面都只兼容 Lua 5.1.4。</p>\n<h2 id=\"二、LUA-5-4新特性\"><a href=\"#二、LUA-5-4新特性\" class=\"headerlink\" title=\"二、LUA 5.4新特性\"></a>二、LUA 5.4新特性</h2><p>参考： <a href=\"https://zhuanlan.zhihu.com/p/283055561\">https://zhuanlan.zhihu.com/p/283055561</a></p>\n<p>Lua 5.4语法上最大的变化是增加了const和TBC变量，前者完全由编译器支持，后者则由专门的TBC指令支持。Lua 5.4对整数for循环语义进行了调整，控制变量溢出会导致循环结束。算术和按位运算在Lua 5.3里会自动将字符串转换为浮点数，在Lua 5.4里，这一自动转换不再由语言直接支持，改为由string标准库的元方法支持（仅支持算术运算，且转换时会保留整数类型）。Lua 5.4不再使用<strong>lt模拟</strong>le元方法（但可通过配置兼容Lua 5.3）。此外，Lua 5.4还增加了新的分代GC模式，重新实现了math.random()函数，等等。</p>\n<h3 id=\"1-const语法\"><a href=\"#1-const语法\" class=\"headerlink\" title=\"1. const语法\"></a>1. const语法</h3><pre><code class=\"lua\">local a &lt;const&gt; = 4\nlocal b = a + 7\nprint(b)</code></pre>\n<p>编译器会把a消除掉，直接给b赋11。这种优化是有限的，对于基本类型和字符串，能够有效减少寄存器的访问，但对于table貌似益处不大。代码文件如果需要一些数值常量，可以写成const变量，比如：</p>\n<pre><code class=\"lua\">local MAX_LEN &lt;const&gt; = 20\nfunction check_name(name)\n    return #name &lt;= MAX_LEN\nend</code></pre>\n<p>在check_name中就没有upvalue的访问，而是直接转换成和20的比较。</p>\n<h3 id=\"2-close语法\"><a href=\"#2-close语法\" class=\"headerlink\" title=\"2. close语法\"></a>2. close语法</h3><p>close变量(To-be-closed Variables)需要和close元方法结合使用，在变量超出作用域时，会调用变量的close元方法，这听起来是不是有点像C++的RAII用法。下面是一个例子：</p>\n<pre><code class=\"lua\">local function newlock()\n    local lock = {\n        acquire = function()\n            print(&quot;acquire lock&quot;)\n        end,\n        release = function()\n            print(&quot;release lock&quot;)\n        end,\n    }\n    return lock\nend\n\nlocal function lockguard(lock)\n    local wrap = {\n        lock = lock\n    }\n    lock.acquire()\n    return setmetatable(wrap, {__close = function(t, err)\n        t.lock.release()\n    end})\nend\n\nlocal lock = newlock()\ndo\n    for i = 1, 3 do\n        local l &lt;close&gt; = lockguard(lock)\n        print(i)\n        error(&quot;err&quot;)\n    end\nend</code></pre>\n<p>定义local l /<close/>后，无论是否有错误，release都能得到调用；从这个例子也可以看出，close变量一般用于需要及时释放资源的情况；否则Lua的GC可以应付大多数情况。</p>\n<h3 id=\"3-userdata\"><a href=\"#3-userdata\" class=\"headerlink\" title=\"3.userdata\"></a>3.userdata</h3><p>userdata现在可以关联多个user值，C的API也有相应的修改，如果我们新建的userdata没有关联值，则尽量使用lua_newuserdatauv，这样更高效，lua_newuserdata仅仅为了兼容，且默认会关联1个值。</p>\n<h3 id=\"4-math-random\"><a href=\"#4-math-random\" class=\"headerlink\" title=\"4. math.random\"></a>4. math.random</h3><p>math.random使用了新的实现，会从某个随机种子开始，简单说即程序启动后第1次调用math.random会得到不同值；以前版本都从相同值开始。</p>\n<h3 id=\"5-协程库新API\"><a href=\"#5-协程库新API\" class=\"headerlink\" title=\"5.协程库新API\"></a>5.协程库新API</h3><p>协程库提供了新的APIcoroutine.close和lua_resetthread，coroutine.close只能在挂起或死亡状态下调用，挂起状态下会使用协程进入死亡状态，并且关闭所有的close变量。</p>\n<h3 id=\"6-整数for循环\"><a href=\"#6-整数for循环\" class=\"headerlink\" title=\"6.整数for循环\"></a>6.整数for循环</h3><p>循环达到最近的整数就会停止</p>\n<p>如果在Lua 5.3里执行这段代码，那么会进入死循环。但是在Lua 5.4里，只打印4个整数就结束循环了：</p>\n<pre><code class=\"lua\">$ lua-5.4.1/lua -\nfor i = math.maxinteger - 10, math.maxinteger, 3 do\n  print(i)\nend\n^D\n9223372036854775797\n9223372036854775800\n9223372036854775803\n9223372036854775806</code></pre>\n<h3 id=\"7-str-to-num语言特性变更\"><a href=\"#7-str-to-num语言特性变更\" class=\"headerlink\" title=\"7.str-to-num语言特性变更\"></a>7.str-to-num语言特性变更</h3><p>变化一： 在Lua 5.3里，str-to-num类型转换是由语言（和虚拟机）直接支持的。在Lua 5.4里，改为由string标准库通过元方法支持。</p>\n<p>以下代码在5.3中只输出一个index元方法，5.4中却输出很多</p>\n<pre><code class=\"lua\">local s = &quot;foo&quot;\nlocal mt = getmetatable(s)\nprint(mt)\nfor k,v in pairs(mt) do\n  print(k,v)\nend</code></pre>\n<pre><code class=\"lua\">--5.4输出\ntable: 0133A450\n__idiv  function: 0033AA40\n__index table: 0133A590\n__pow   function: 0033A960\n__div   function: 0033A9D0\n__mul   function: 0033A880\n__sub   function: 0033A810\n__unm   function: 0033AAB0\n__add   function: 0033A7A0\n__mod   function: 0033A8F0</code></pre>\n<p>变化二：在一的元方法列表中并未找到按位运算的元方法，因此会导致自动按位运算不支持<br>变化三：str-to-num会尽量为整数类型返回</p>\n<h3 id=\"8-le元方法\"><a href=\"#8-le元方法\" class=\"headerlink\" title=\"8. le元方法\"></a>8. le元方法</h3><p>Lua 5.3认为a &lt;= b和not (b &lt; a)等价，因此如果元表没有提供<strong>le元方法，那么将尝试用</strong>lt元方法进行模拟。Lua 5.4不再认同这个假设，因此必要时必须显示提供__le元方法。下面来看一个例子：</p>\n<pre><code class=\"lua\">local mt = {\n  __lt = function(a, b)\n    print(&quot;__lt&quot;, a, b)\n    return #a &lt; #b\n  end\n}\nlocal a = {1, 2, 3}\nlocal b = {1, 2, 3, 4}\nsetmetatable(a, mt)\nsetmetatable(b, mt)\nprint(a &lt; b)\nprint(a &lt;= b)</code></pre>\n<p>Lua 5.4源代码提供了一个LUA_COMPAT_LT_LE宏，用来控制__le的行为是否和Lua 5.3保持一致，所以上面这个例子的具体执行结果取决于lua被编译时给定的配置。这个宏在Lua 5.3的构建文件（Makefile）里默认是被打开的。</p>\n<h3 id=\"9-警告系统\"><a href=\"#9-警告系统\" class=\"headerlink\" title=\"9.警告系统\"></a>9.警告系统</h3><p>Lua 5.4增加了warn()标准库函数，用于发布警告，用法为：warn (msg1, ···)。相应的，lua命令增加了一个-W选项。只有该选项开启，警告才会被打印到控制台。下面是一个简单的例子：</p>\n<pre><code class=\"lua\">warn(&quot;foo&quot;, &quot;bar&quot;)\n^D\nLua warning: foobar</code></pre>\n<h3 id=\"10-string库\"><a href=\"#10-string库\" class=\"headerlink\" title=\"10.string库\"></a>10.string库</h3><h4 id=\"gmatch-函数\"><a href=\"#gmatch-函数\" class=\"headerlink\" title=\"gmatch()函数\"></a>gmatch()函数</h4><p>增加了可选的init参数，用法如下所示：</p>\n<pre><code class=\"lua\">string.gmatch (s, pattern)          -- Lua 5.3\nstring.gmatch (s, pattern [, init]) -- Lua 5.4\n\ns = &quot;hello world from Lua&quot;\nfor w in string.gmatch(s, &quot;%a+&quot;, 3) do\n  print(w)\nend</code></pre>\n<p>在Lua 5.4里执行，结果如下所示（注意第一行的llo）：<br>llo<br>world<br>from<br>Lua</p>\n<h4 id=\"format-函数\"><a href=\"#format-函数\" class=\"headerlink\" title=\"format()函数\"></a>format()函数</h4><p>增加了%p格式，可以打印指针，下面是一个例子：</p>\n<pre><code class=\"lua\">local t = {1, 2, 3}\nprint(t, &quot;,&quot;, string.format(&#39;%p&#39;, t))</code></pre>\n<p>在Lua 5.4里执行，打印出的结果看起来是下面这样：</p>\n<pre><code class=\"lua\">table: 0x7fde1cd04a30   ,   0x7fde1cd04a30</code></pre>\n<h3 id=\"11-垃圾回收\"><a href=\"#11-垃圾回收\" class=\"headerlink\" title=\"11.垃圾回收\"></a>11.垃圾回收</h3><p>Lua 5.4给垃圾收集器（GC）增加了分代模式，可以通过collectgarbage()函数在老的增量模式和新模式之间切换（以及调整控制GC的参数）：</p>\n<pre><code class=\"lua\">-- Change the collector mode to generational.\ncollectgarbage(&quot;generational&quot;, minor_mul, major_mul)\n-- Change the collector mode to incremental.\ncollectgarbage(&quot;incremental&quot;, pause, step_mul, step_size)\n--同时，原先的两个选项setpause和setstepmul已经被废弃：\n\ncollectgarbage(&quot;setpause&quot;, pause)      -- deprecated\ncollectgarbage(&quot;setstepmul&quot;, step_mul) -- deprecated</code></pre>\n<h2 id=\"三、相关知识点复习\"><a href=\"#三、相关知识点复习\" class=\"headerlink\" title=\"三、相关知识点复习\"></a>三、相关知识点复习</h2><h3 id=\"元表与元方法\"><a href=\"#元表与元方法\" class=\"headerlink\" title=\"元表与元方法\"></a>元表与元方法</h3><ol>\n<li>index元方法<br>这是metatable最常用的键</li>\n</ol>\n<p>当你通过键来访问table的时候，如果这个键没有值，那么Lua就会寻找该table的metatable(假定有metatable)中的__index键。如果index 包含一个表格，Lua会在表格中查找对应的键。</p>\n<p>如果index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。</p>\n<blockquote>\n<p>!!! 取值的时候，查看是否存在，如果有值则显示值 ，没有则调用index元方法，找元方法中的值 </p>\n</blockquote>\n<pre><code class=\"lua\">mytable = setmetatable({key1 = &quot;value1&quot;},\n    {__index = function(mytable,key)\n    if key == &quot;key2&quot; then \n        return &quot;metatablevalue&quot;\n    else \n        return nil\n    end \nend \n})\nprint(mytable.key1,mytable.key2)\n\n--实际输出结果为：\n--value1 metatablevalue</code></pre>\n<ol start=\"2\">\n<li>newindex元方法</li>\n</ol>\n<blockquote>\n<p>赋值的时候，如果有值 ，则取值，没有值，则会触发newindex元方法，如果元方法是一个table，则会用此table替代原table</p>\n</blockquote>\n<pre><code class=\"lua\">mymetatable = {}\nmytable = setmetatable({key1 = &quot;value1&quot;},{__newindex = mymetatable})\nprint(mytable.key1)\nmytable.newkey = &quot;新值2&quot;\nprint(mytable.newkey,mymetatable.newkey)\nmytable.key1 = &quot;新值1&quot;\nprint(mytable.key1,mymetatable.key1)\n--以下实例执行输出结构为：\n\n--value1\n--nil    新值2\n--新值1    nil</code></pre>\n<h2 id=\"四、LUA-GC\"><a href=\"#四、LUA-GC\" class=\"headerlink\" title=\"四、LUA GC\"></a>四、LUA GC</h2><p>Lua是一门自动内存管理的语言，它使用的是经典的标记和清扫算法。</p>\n<h3 id=\"4-1-标记和清除模式\"><a href=\"#4-1-标记和清除模式\" class=\"headerlink\" title=\"4.1 标记和清除模式\"></a>4.1 标记和清除模式</h3><p>在标记阶段，从根集对象开始标记，把整个对象层级都标记完，这些被标记到的对象称为可到达的对象。<br>在清扫阶段，遍历上面提到的对象链表，如果对象被标记过则擦除标记并跳过，如果对象没被标记，说明它不可到达，那就把它释放掉。</p>\n<blockquote>\n<p>Lua 5.0之前，垃圾回收是一个stop the world的过程，即在执行GC的时候要一次性完成，它的好处是代码相对简单，5.0的GC代码不过几百行，如果你想了解GC算法本身，看一下5.0的lgc.h|c是非常好的。<br>这种stop the world的GC在轻量的应用中不是什么问题，如果遇到程序非常大，对象特别多的情况，效率就很成问题了。因此在5.1之后，Lua进化成一个步进的GC，原理还是标记和清扫，但是把一个GC周期分成很多步，一次只执行一步。这对GC的效率是一个很大的提升，代价就是GC代码变得很复杂，Lua 5.3已经有一千多行。<br>从代码上看，除了GC分步，还有upvalues，弱表，终结对象(有__gc元方法的对象)的处理，这些都加大了垃圾回收的复杂度。</p>\n</blockquote>\n<h4 id=\"三色标记\"><a href=\"#三色标记\" class=\"headerlink\" title=\"三色标记\"></a>三色标记</h4><p>一个GC对象分成三种颜色(三种状态):</p>\n<p>白色：表示对象未被标记，在GC周期开始之前对象为白色，如果到清扫阶段还是白色，那就说明该对象不可到达，要被清除掉。<br>灰色：表示对象本身已标记，但它引用的对象未被标记，比如一个表已被标记，它的键值对象还未标记。这表示对象标记的一个中间状态。<br>黑色：表示对象和它引用的对象都已被标记，在清扫阶段黑色对象为可到达对象。</p>\n<p>marked就是对象的标记状态，它的位含义如下：</p>\n<p>第0位：第1种白<br>第1位：第2种白<br>第2位：黑<br>第3位：标记为终结对象<br>灰色为0, 1, 2位都清0的情况。</p>\n<p>我们注意到白色有两个状态，这是为了解决分步GC的中间新建对象的问题。比如在标记阶段和清扫阶段的中间，有一个新建的对象，它默认为白色；清扫的时候会因为它是白色而把它给释放掉。引入两种白色之后这样处理：</p>\n<blockquote>\n<p>g-&gt;currentwhite表示当前白，它是两种白色中的任意一种，我们假定为白1，在清扫阶段之前，所有白对象都是白1。<br>在标记阶段结束的时候，g-&gt;currentwhite切换为白2，现在之前那些白对象和g-&gt;currentwhite就是不同白了(因为它们是白1)。<br>在标记结束之后，清扫开始之前，新建一个对象，默认标记当g-&gt;currentwhite，也就是白2。</p>\n<blockquote>\n<p>在清扫的时候，只会清扫和g-&gt;currentwhite不同的白，即白1。这样那些新建的对象就不会在清扫阶段被释放。而在清扫结束之后，这些新建的对象也会变成白2。等待下一个周期。<br>要被终结对象就是那些有__gc元方法的对象。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"对象链表\"><a href=\"#对象链表\" class=\"headerlink\" title=\"对象链表\"></a>对象链表</h4><p>global_State有好多和GC相关的字段，其中有一些重要链表。所有GC对象总是在下面的一个链表中：</p>\n<p>allgc 所有未被标记为终结的对象<br>finobj 所有被标记为终结的对象<br>tobefnz 所有准备终结的对象(准备调用__gc的对象)<br>fixedgc 不会被回收的对象</p>\n<blockquote>\n<p>gfasttm(g,mt, TM_GC)函数: 如果给对象设置一个元表，且元表有__gc元方法，那么它会从allgc取出，加入到finobj去，并设置对象的FINALIZEDBIT标记位(就是上面说的第3个marked位)。 </p>\n</blockquote>\n<p>在标记阶段，finobj中的白对象会移到tobefnz链表去，然后标记这些对象，这样当前周期不会释放这些对象；清扫完之后会进入GCScallfin阶段，在这里调用tobefnz对象的gc方法，同时把对象移回allgc链表；如果gc中使对象重新变成可到达，则对象复活过来；否则下个周期这个对象就会被正常清除。</p>\n<p>fixedgc 是那些不会被回收的对象，在新建完对象后，必须马上调用luaC_fix把对象从allgc移到fixedgc去。GC的过程不会对fixedgc进行清扫。</p>\n<p>对于灰对象还有好几个链表：</p>\n<p>gray 普通的灰对象链表<br>grayagain 在GCSatomic阶段(是标记阶段的一个子阶段)中重新访问的灰对象，这些灰对象包括：<br>进行写屏蔽的黑对象<br>在传播阶段的弱表<br>所有线程对象</p>\n<p>weak 待清理的弱值表<br>allweak 待清理的弱键值表<br>ephemeron 弱键表<br>可以看出这些灰对象链表是由分步和弱表引入的附加数据结构，这也是GC中较为复杂的部分。</p>\n<h4 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h4><p>从前文的描述知道，Lua的GC不断的遍历灰对象并把它们变黑，在遍历的过程中又有新的灰对象产生，一直重复这个过程到没有灰对象为止。此时黑对象就是可到达的对象，剩下的白对象就是不可到达的对象，要被清扫掉的。</p>\n<p>在标记阶段中有一个重要的不变条件是：黑对象不能指向白对象。比如我们有一个普通的表是黑色的，那这个表必然已经被遍历过了，所以它里面的键值一定不是白色的。</p>\n<p>但这个假设只是在一次性标记这个前提下成立。如果是增量式的，每次只标记一部分，那在标记的中间有一些修改，可能会打破这个不变式。比如t被标记为黑色，后面有一个赋值t.x = {}使得t指向了白色对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、版本更替\"><a href=\"#一、版本更替\" class=\"headerlink\" title=\"一、版本更替\"></a>一、版本更替</h2><p>Lua 5.4 : Lua 5.4 was released on 29 Jun 2020     The current release is Lua 5.4.2, released on 03 Dec 2020.</p>\n<blockquote>\n<p>Main changes<br>new generational mode for garbage collection           垃圾收集的新分代模式<br>to-be-closed variables           可close的变量<br>const variables                  常量变量<br>userdata can have multiple user values Userdata                    可以有多个用户值<br>new implementation for math.random                          Math.random 的新实现<br>warning system               报警系统<br>debug information about function arguments and returns     有关函数参数和返回值的调试信息<br>new semantics for the integer ‘for’ loop                 整数‘ for’循环的新语义<br>optional ‘init’ argument to ‘string.gmatch’           可选的“ init”参数设置为“ string.gmatch”<br>new functions ‘lua_resetthread’ and ‘coroutine.close’        新函数‘ lua _ resetthread’和‘ coroutine.close’<br>string-to-number coercions moved to the string library       字符串到数字的强制转移到字符串库<br>allocation function allowed to fail when shrinking a memory block          缩小内存块时允许失败的分配函数<br>new format ‘%p’ in ‘string.format’                      新格式“% p”中的“ string.format”<br>utf8 library accepts codepoints up to 2^31                          Utf8库接受最多2 ^ 31的代码点</p>\n</blockquote>\n<p>Lua 5.3 : Lua 5.3 was released on 12 Jan 2015    The current release is Lua 5.3.6, released on 25 Sep 2020</p>\n<blockquote>\n<p>There will probably be no further releases of Lua 5.3.<br>integers (64-bit by default)  整数(默认为64位)  Lua5.2中所有数字都是浮点数<br>official support for 32-bit numbers  32位数字的官方支持<br>bitwise operators    按位运算符<br>basic utf-8 support 基本 utf-8支持<br>functions for packing and unpacking values   包装和拆包 数值的函数<br>垃圾收集器的分代模式被删除了</p>\n</blockquote>\n<p>Lua 5.2 : was released on 16 Dec 2011.  The last release was Lua 5.2.4, released on 07 Mar 2015. There will be no further releases of Lua 5.2.</p>\n<blockquote>\n<p>Main changes:<br>yieldable pcall and metamethods<br>new lexical scheme for globals:  全局变量的新词法模式<br>ephemeron tables :<br>new library for bitwise operations<br>light C functions<br>emergency garbage collector<br>goto statement<br>finalizers for tables<br>module函数已被弃用。使用常规的Lua代码设置一个模块很容易。不再期望模块设置全局变量。<br>setfenv和getfenv函数被删除，因为环境概念的更改。<br>math.log10函数已被弃用。可以使用math.log并向第2个参数传入10来代替。<br>loadstring函数已被弃用。使用load代替，它现在可以接受字符串参数且等同于loadstring。<br>table.maxn函数已被弃用。如果你确实需要请在Lua中自己实现。<br>os.execute函数现在如果命令成功终止则返回true，否则返回nil和一个错误消息。<br>unpack函数被移到table库中，因此要改成这样调用 table.unpack。<br>模式中的字符类%z已被弃用，因为现在模式可以包含\\0作为正常字符。<br>表package.loaders重命名为package.searchers。<br>Lua不再有字节码验证。所以，所有加载代码的函数(load和loadfile)在加载不信任的二进制数据时都可能有潜在的不安全。(实际上，由于验证算法的缺陷，这些函数一直都是不安全的)。如有疑惑，请将这些函数的mode参数限制为只加载文本的块。<br>官方发布包中的标准路径可能会在不同版本间修改。</p>\n</blockquote>\n<p>Lua jit:<br>LuaJIT 是按照 5.1 的语法设计的，并且在可以预期的将来也永远不会适配 5.2，LuaJIT 作者声称会增加 5.2 所增加的那些功能，但永远不会适配 5.2 的语法，换句话说，他的发展思路是语法与兼容性不变，仅仅在 5.1 的语法基础之上增加后续 Lua 版本的新特性，LuaJIT 在 API/ABI 方面都只兼容 Lua 5.1.4。</p>\n<h2 id=\"二、LUA-5-4新特性\"><a href=\"#二、LUA-5-4新特性\" class=\"headerlink\" title=\"二、LUA 5.4新特性\"></a>二、LUA 5.4新特性</h2><p>参考： <a href=\"https://zhuanlan.zhihu.com/p/283055561\">https://zhuanlan.zhihu.com/p/283055561</a></p>\n<p>Lua 5.4语法上最大的变化是增加了const和TBC变量，前者完全由编译器支持，后者则由专门的TBC指令支持。Lua 5.4对整数for循环语义进行了调整，控制变量溢出会导致循环结束。算术和按位运算在Lua 5.3里会自动将字符串转换为浮点数，在Lua 5.4里，这一自动转换不再由语言直接支持，改为由string标准库的元方法支持（仅支持算术运算，且转换时会保留整数类型）。Lua 5.4不再使用<strong>lt模拟</strong>le元方法（但可通过配置兼容Lua 5.3）。此外，Lua 5.4还增加了新的分代GC模式，重新实现了math.random()函数，等等。</p>\n<h3 id=\"1-const语法\"><a href=\"#1-const语法\" class=\"headerlink\" title=\"1. const语法\"></a>1. const语法</h3><pre><code class=\"lua\">local a &lt;const&gt; = 4\nlocal b = a + 7\nprint(b)</code></pre>\n<p>编译器会把a消除掉，直接给b赋11。这种优化是有限的，对于基本类型和字符串，能够有效减少寄存器的访问，但对于table貌似益处不大。代码文件如果需要一些数值常量，可以写成const变量，比如：</p>\n<pre><code class=\"lua\">local MAX_LEN &lt;const&gt; = 20\nfunction check_name(name)\n    return #name &lt;= MAX_LEN\nend</code></pre>\n<p>在check_name中就没有upvalue的访问，而是直接转换成和20的比较。</p>\n<h3 id=\"2-close语法\"><a href=\"#2-close语法\" class=\"headerlink\" title=\"2. close语法\"></a>2. close语法</h3><p>close变量(To-be-closed Variables)需要和close元方法结合使用，在变量超出作用域时，会调用变量的close元方法，这听起来是不是有点像C++的RAII用法。下面是一个例子：</p>\n<pre><code class=\"lua\">local function newlock()\n    local lock = {\n        acquire = function()\n            print(&quot;acquire lock&quot;)\n        end,\n        release = function()\n            print(&quot;release lock&quot;)\n        end,\n    }\n    return lock\nend\n\nlocal function lockguard(lock)\n    local wrap = {\n        lock = lock\n    }\n    lock.acquire()\n    return setmetatable(wrap, {__close = function(t, err)\n        t.lock.release()\n    end})\nend\n\nlocal lock = newlock()\ndo\n    for i = 1, 3 do\n        local l &lt;close&gt; = lockguard(lock)\n        print(i)\n        error(&quot;err&quot;)\n    end\nend</code></pre>\n<p>定义local l /<close/>后，无论是否有错误，release都能得到调用；从这个例子也可以看出，close变量一般用于需要及时释放资源的情况；否则Lua的GC可以应付大多数情况。</p>\n<h3 id=\"3-userdata\"><a href=\"#3-userdata\" class=\"headerlink\" title=\"3.userdata\"></a>3.userdata</h3><p>userdata现在可以关联多个user值，C的API也有相应的修改，如果我们新建的userdata没有关联值，则尽量使用lua_newuserdatauv，这样更高效，lua_newuserdata仅仅为了兼容，且默认会关联1个值。</p>\n<h3 id=\"4-math-random\"><a href=\"#4-math-random\" class=\"headerlink\" title=\"4. math.random\"></a>4. math.random</h3><p>math.random使用了新的实现，会从某个随机种子开始，简单说即程序启动后第1次调用math.random会得到不同值；以前版本都从相同值开始。</p>\n<h3 id=\"5-协程库新API\"><a href=\"#5-协程库新API\" class=\"headerlink\" title=\"5.协程库新API\"></a>5.协程库新API</h3><p>协程库提供了新的APIcoroutine.close和lua_resetthread，coroutine.close只能在挂起或死亡状态下调用，挂起状态下会使用协程进入死亡状态，并且关闭所有的close变量。</p>\n<h3 id=\"6-整数for循环\"><a href=\"#6-整数for循环\" class=\"headerlink\" title=\"6.整数for循环\"></a>6.整数for循环</h3><p>循环达到最近的整数就会停止</p>\n<p>如果在Lua 5.3里执行这段代码，那么会进入死循环。但是在Lua 5.4里，只打印4个整数就结束循环了：</p>\n<pre><code class=\"lua\">$ lua-5.4.1/lua -\nfor i = math.maxinteger - 10, math.maxinteger, 3 do\n  print(i)\nend\n^D\n9223372036854775797\n9223372036854775800\n9223372036854775803\n9223372036854775806</code></pre>\n<h3 id=\"7-str-to-num语言特性变更\"><a href=\"#7-str-to-num语言特性变更\" class=\"headerlink\" title=\"7.str-to-num语言特性变更\"></a>7.str-to-num语言特性变更</h3><p>变化一： 在Lua 5.3里，str-to-num类型转换是由语言（和虚拟机）直接支持的。在Lua 5.4里，改为由string标准库通过元方法支持。</p>\n<p>以下代码在5.3中只输出一个index元方法，5.4中却输出很多</p>\n<pre><code class=\"lua\">local s = &quot;foo&quot;\nlocal mt = getmetatable(s)\nprint(mt)\nfor k,v in pairs(mt) do\n  print(k,v)\nend</code></pre>\n<pre><code class=\"lua\">--5.4输出\ntable: 0133A450\n__idiv  function: 0033AA40\n__index table: 0133A590\n__pow   function: 0033A960\n__div   function: 0033A9D0\n__mul   function: 0033A880\n__sub   function: 0033A810\n__unm   function: 0033AAB0\n__add   function: 0033A7A0\n__mod   function: 0033A8F0</code></pre>\n<p>变化二：在一的元方法列表中并未找到按位运算的元方法，因此会导致自动按位运算不支持<br>变化三：str-to-num会尽量为整数类型返回</p>\n<h3 id=\"8-le元方法\"><a href=\"#8-le元方法\" class=\"headerlink\" title=\"8. le元方法\"></a>8. le元方法</h3><p>Lua 5.3认为a &lt;= b和not (b &lt; a)等价，因此如果元表没有提供<strong>le元方法，那么将尝试用</strong>lt元方法进行模拟。Lua 5.4不再认同这个假设，因此必要时必须显示提供__le元方法。下面来看一个例子：</p>\n<pre><code class=\"lua\">local mt = {\n  __lt = function(a, b)\n    print(&quot;__lt&quot;, a, b)\n    return #a &lt; #b\n  end\n}\nlocal a = {1, 2, 3}\nlocal b = {1, 2, 3, 4}\nsetmetatable(a, mt)\nsetmetatable(b, mt)\nprint(a &lt; b)\nprint(a &lt;= b)</code></pre>\n<p>Lua 5.4源代码提供了一个LUA_COMPAT_LT_LE宏，用来控制__le的行为是否和Lua 5.3保持一致，所以上面这个例子的具体执行结果取决于lua被编译时给定的配置。这个宏在Lua 5.3的构建文件（Makefile）里默认是被打开的。</p>\n<h3 id=\"9-警告系统\"><a href=\"#9-警告系统\" class=\"headerlink\" title=\"9.警告系统\"></a>9.警告系统</h3><p>Lua 5.4增加了warn()标准库函数，用于发布警告，用法为：warn (msg1, ···)。相应的，lua命令增加了一个-W选项。只有该选项开启，警告才会被打印到控制台。下面是一个简单的例子：</p>\n<pre><code class=\"lua\">warn(&quot;foo&quot;, &quot;bar&quot;)\n^D\nLua warning: foobar</code></pre>\n<h3 id=\"10-string库\"><a href=\"#10-string库\" class=\"headerlink\" title=\"10.string库\"></a>10.string库</h3><h4 id=\"gmatch-函数\"><a href=\"#gmatch-函数\" class=\"headerlink\" title=\"gmatch()函数\"></a>gmatch()函数</h4><p>增加了可选的init参数，用法如下所示：</p>\n<pre><code class=\"lua\">string.gmatch (s, pattern)          -- Lua 5.3\nstring.gmatch (s, pattern [, init]) -- Lua 5.4\n\ns = &quot;hello world from Lua&quot;\nfor w in string.gmatch(s, &quot;%a+&quot;, 3) do\n  print(w)\nend</code></pre>\n<p>在Lua 5.4里执行，结果如下所示（注意第一行的llo）：<br>llo<br>world<br>from<br>Lua</p>\n<h4 id=\"format-函数\"><a href=\"#format-函数\" class=\"headerlink\" title=\"format()函数\"></a>format()函数</h4><p>增加了%p格式，可以打印指针，下面是一个例子：</p>\n<pre><code class=\"lua\">local t = {1, 2, 3}\nprint(t, &quot;,&quot;, string.format(&#39;%p&#39;, t))</code></pre>\n<p>在Lua 5.4里执行，打印出的结果看起来是下面这样：</p>\n<pre><code class=\"lua\">table: 0x7fde1cd04a30   ,   0x7fde1cd04a30</code></pre>\n<h3 id=\"11-垃圾回收\"><a href=\"#11-垃圾回收\" class=\"headerlink\" title=\"11.垃圾回收\"></a>11.垃圾回收</h3><p>Lua 5.4给垃圾收集器（GC）增加了分代模式，可以通过collectgarbage()函数在老的增量模式和新模式之间切换（以及调整控制GC的参数）：</p>\n<pre><code class=\"lua\">-- Change the collector mode to generational.\ncollectgarbage(&quot;generational&quot;, minor_mul, major_mul)\n-- Change the collector mode to incremental.\ncollectgarbage(&quot;incremental&quot;, pause, step_mul, step_size)\n--同时，原先的两个选项setpause和setstepmul已经被废弃：\n\ncollectgarbage(&quot;setpause&quot;, pause)      -- deprecated\ncollectgarbage(&quot;setstepmul&quot;, step_mul) -- deprecated</code></pre>\n<h2 id=\"三、相关知识点复习\"><a href=\"#三、相关知识点复习\" class=\"headerlink\" title=\"三、相关知识点复习\"></a>三、相关知识点复习</h2><h3 id=\"元表与元方法\"><a href=\"#元表与元方法\" class=\"headerlink\" title=\"元表与元方法\"></a>元表与元方法</h3><ol>\n<li>index元方法<br>这是metatable最常用的键</li>\n</ol>\n<p>当你通过键来访问table的时候，如果这个键没有值，那么Lua就会寻找该table的metatable(假定有metatable)中的__index键。如果index 包含一个表格，Lua会在表格中查找对应的键。</p>\n<p>如果index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。</p>\n<blockquote>\n<p>!!! 取值的时候，查看是否存在，如果有值则显示值 ，没有则调用index元方法，找元方法中的值 </p>\n</blockquote>\n<pre><code class=\"lua\">mytable = setmetatable({key1 = &quot;value1&quot;},\n    {__index = function(mytable,key)\n    if key == &quot;key2&quot; then \n        return &quot;metatablevalue&quot;\n    else \n        return nil\n    end \nend \n})\nprint(mytable.key1,mytable.key2)\n\n--实际输出结果为：\n--value1 metatablevalue</code></pre>\n<ol start=\"2\">\n<li>newindex元方法</li>\n</ol>\n<blockquote>\n<p>赋值的时候，如果有值 ，则取值，没有值，则会触发newindex元方法，如果元方法是一个table，则会用此table替代原table</p>\n</blockquote>\n<pre><code class=\"lua\">mymetatable = {}\nmytable = setmetatable({key1 = &quot;value1&quot;},{__newindex = mymetatable})\nprint(mytable.key1)\nmytable.newkey = &quot;新值2&quot;\nprint(mytable.newkey,mymetatable.newkey)\nmytable.key1 = &quot;新值1&quot;\nprint(mytable.key1,mymetatable.key1)\n--以下实例执行输出结构为：\n\n--value1\n--nil    新值2\n--新值1    nil</code></pre>\n<h2 id=\"四、LUA-GC\"><a href=\"#四、LUA-GC\" class=\"headerlink\" title=\"四、LUA GC\"></a>四、LUA GC</h2><p>Lua是一门自动内存管理的语言，它使用的是经典的标记和清扫算法。</p>\n<h3 id=\"4-1-标记和清除模式\"><a href=\"#4-1-标记和清除模式\" class=\"headerlink\" title=\"4.1 标记和清除模式\"></a>4.1 标记和清除模式</h3><p>在标记阶段，从根集对象开始标记，把整个对象层级都标记完，这些被标记到的对象称为可到达的对象。<br>在清扫阶段，遍历上面提到的对象链表，如果对象被标记过则擦除标记并跳过，如果对象没被标记，说明它不可到达，那就把它释放掉。</p>\n<blockquote>\n<p>Lua 5.0之前，垃圾回收是一个stop the world的过程，即在执行GC的时候要一次性完成，它的好处是代码相对简单，5.0的GC代码不过几百行，如果你想了解GC算法本身，看一下5.0的lgc.h|c是非常好的。<br>这种stop the world的GC在轻量的应用中不是什么问题，如果遇到程序非常大，对象特别多的情况，效率就很成问题了。因此在5.1之后，Lua进化成一个步进的GC，原理还是标记和清扫，但是把一个GC周期分成很多步，一次只执行一步。这对GC的效率是一个很大的提升，代价就是GC代码变得很复杂，Lua 5.3已经有一千多行。<br>从代码上看，除了GC分步，还有upvalues，弱表，终结对象(有__gc元方法的对象)的处理，这些都加大了垃圾回收的复杂度。</p>\n</blockquote>\n<h4 id=\"三色标记\"><a href=\"#三色标记\" class=\"headerlink\" title=\"三色标记\"></a>三色标记</h4><p>一个GC对象分成三种颜色(三种状态):</p>\n<p>白色：表示对象未被标记，在GC周期开始之前对象为白色，如果到清扫阶段还是白色，那就说明该对象不可到达，要被清除掉。<br>灰色：表示对象本身已标记，但它引用的对象未被标记，比如一个表已被标记，它的键值对象还未标记。这表示对象标记的一个中间状态。<br>黑色：表示对象和它引用的对象都已被标记，在清扫阶段黑色对象为可到达对象。</p>\n<p>marked就是对象的标记状态，它的位含义如下：</p>\n<p>第0位：第1种白<br>第1位：第2种白<br>第2位：黑<br>第3位：标记为终结对象<br>灰色为0, 1, 2位都清0的情况。</p>\n<p>我们注意到白色有两个状态，这是为了解决分步GC的中间新建对象的问题。比如在标记阶段和清扫阶段的中间，有一个新建的对象，它默认为白色；清扫的时候会因为它是白色而把它给释放掉。引入两种白色之后这样处理：</p>\n<blockquote>\n<p>g-&gt;currentwhite表示当前白，它是两种白色中的任意一种，我们假定为白1，在清扫阶段之前，所有白对象都是白1。<br>在标记阶段结束的时候，g-&gt;currentwhite切换为白2，现在之前那些白对象和g-&gt;currentwhite就是不同白了(因为它们是白1)。<br>在标记结束之后，清扫开始之前，新建一个对象，默认标记当g-&gt;currentwhite，也就是白2。</p>\n<blockquote>\n<p>在清扫的时候，只会清扫和g-&gt;currentwhite不同的白，即白1。这样那些新建的对象就不会在清扫阶段被释放。而在清扫结束之后，这些新建的对象也会变成白2。等待下一个周期。<br>要被终结对象就是那些有__gc元方法的对象。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"对象链表\"><a href=\"#对象链表\" class=\"headerlink\" title=\"对象链表\"></a>对象链表</h4><p>global_State有好多和GC相关的字段，其中有一些重要链表。所有GC对象总是在下面的一个链表中：</p>\n<p>allgc 所有未被标记为终结的对象<br>finobj 所有被标记为终结的对象<br>tobefnz 所有准备终结的对象(准备调用__gc的对象)<br>fixedgc 不会被回收的对象</p>\n<blockquote>\n<p>gfasttm(g,mt, TM_GC)函数: 如果给对象设置一个元表，且元表有__gc元方法，那么它会从allgc取出，加入到finobj去，并设置对象的FINALIZEDBIT标记位(就是上面说的第3个marked位)。 </p>\n</blockquote>\n<p>在标记阶段，finobj中的白对象会移到tobefnz链表去，然后标记这些对象，这样当前周期不会释放这些对象；清扫完之后会进入GCScallfin阶段，在这里调用tobefnz对象的gc方法，同时把对象移回allgc链表；如果gc中使对象重新变成可到达，则对象复活过来；否则下个周期这个对象就会被正常清除。</p>\n<p>fixedgc 是那些不会被回收的对象，在新建完对象后，必须马上调用luaC_fix把对象从allgc移到fixedgc去。GC的过程不会对fixedgc进行清扫。</p>\n<p>对于灰对象还有好几个链表：</p>\n<p>gray 普通的灰对象链表<br>grayagain 在GCSatomic阶段(是标记阶段的一个子阶段)中重新访问的灰对象，这些灰对象包括：<br>进行写屏蔽的黑对象<br>在传播阶段的弱表<br>所有线程对象</p>\n<p>weak 待清理的弱值表<br>allweak 待清理的弱键值表<br>ephemeron 弱键表<br>可以看出这些灰对象链表是由分步和弱表引入的附加数据结构，这也是GC中较为复杂的部分。</p>\n<h4 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h4><p>从前文的描述知道，Lua的GC不断的遍历灰对象并把它们变黑，在遍历的过程中又有新的灰对象产生，一直重复这个过程到没有灰对象为止。此时黑对象就是可到达的对象，剩下的白对象就是不可到达的对象，要被清扫掉的。</p>\n<p>在标记阶段中有一个重要的不变条件是：黑对象不能指向白对象。比如我们有一个普通的表是黑色的，那这个表必然已经被遍历过了，所以它里面的键值一定不是白色的。</p>\n<p>但这个假设只是在一次性标记这个前提下成立。如果是增量式的，每次只标记一部分，那在标记的中间有一些修改，可能会打破这个不变式。比如t被标记为黑色，后面有一个赋值t.x = {}使得t指向了白色对象。</p>\n"},{"title":"Lua源码编译流程","_content":"\n## 一、配置环境\n\n示例： 新建lua文件夹，放置到环境变量的Path中\n\n\n## 二、下载lua源码\nhttps://www.lua.org/ftp/\n\n1.下载tar文件后\n2.解压：使用powershell的 tar zxf .\\lua5.3.4.tar.gz文件\n3.拷贝src文件到【一】的文件夹中，注：不需要makefile文件\n\n## 三、创建VS项目工程\n\n1.使用Visual C++ 的空项目为模板\n2.Source Files中添加现有项：添加所有【二】的文件夹的h和c文件\n\n## 四、库形式编译\n\n1.移除项目中的luac.c文件， lua.c文件\n2.改变编译环境为x64， Release模式\n3.设置项目属性的 配置类型： 动态库（dll）\n4.C/C++ -> 预处理器 -> 预处理定义：添加： LUA_BUILD_AS_DLL\n5.生成解决方案！\n\n得到 .lib 和.dll文件\n\n## 五、编译生成compiler\n\n1.删除 LUA_BUILD_AS_DLL 的定义\n2.设置项目属性的 配置类型：exe\n3.添加回luac.c文件， 编译得到luac.exe文件（compiler）\n \n ## 六、编译生成interpreter\n \n1.清空source Files中的文件\n2.仅添加lua.c文件\n3.配置：在C/C++ 中的Additional Include Directories中添加 【二】的源码文件夹\n4.配置： Linker中的Input, Additional Dependencies: 添加lua.lib\n5.配置： Linker中的General, Additional Library Dependencies: 添加lib文件所在地\n6.生成解决方案，得到lua.exe（~=18KB）\n\n## 七、源码学习\n\n1.移入所有代码，源文件和头文件到 VS c++项目\n2.新建main.cpp文件，复制 lua.c的main函数 一些结构\n3.注释掉.lua.c luac.c的main函数代码\n4.添加.lua文件到资源目录，执行测试","source":"_posts/Lua源码编译流程.md","raw":"---\ntitle: Lua源码编译流程\ncategories:\n- Unity\n---\n\n## 一、配置环境\n\n示例： 新建lua文件夹，放置到环境变量的Path中\n\n\n## 二、下载lua源码\nhttps://www.lua.org/ftp/\n\n1.下载tar文件后\n2.解压：使用powershell的 tar zxf .\\lua5.3.4.tar.gz文件\n3.拷贝src文件到【一】的文件夹中，注：不需要makefile文件\n\n## 三、创建VS项目工程\n\n1.使用Visual C++ 的空项目为模板\n2.Source Files中添加现有项：添加所有【二】的文件夹的h和c文件\n\n## 四、库形式编译\n\n1.移除项目中的luac.c文件， lua.c文件\n2.改变编译环境为x64， Release模式\n3.设置项目属性的 配置类型： 动态库（dll）\n4.C/C++ -> 预处理器 -> 预处理定义：添加： LUA_BUILD_AS_DLL\n5.生成解决方案！\n\n得到 .lib 和.dll文件\n\n## 五、编译生成compiler\n\n1.删除 LUA_BUILD_AS_DLL 的定义\n2.设置项目属性的 配置类型：exe\n3.添加回luac.c文件， 编译得到luac.exe文件（compiler）\n \n ## 六、编译生成interpreter\n \n1.清空source Files中的文件\n2.仅添加lua.c文件\n3.配置：在C/C++ 中的Additional Include Directories中添加 【二】的源码文件夹\n4.配置： Linker中的Input, Additional Dependencies: 添加lua.lib\n5.配置： Linker中的General, Additional Library Dependencies: 添加lib文件所在地\n6.生成解决方案，得到lua.exe（~=18KB）\n\n## 七、源码学习\n\n1.移入所有代码，源文件和头文件到 VS c++项目\n2.新建main.cpp文件，复制 lua.c的main函数 一些结构\n3.注释掉.lua.c luac.c的main函数代码\n4.添加.lua文件到资源目录，执行测试","slug":"Lua源码编译流程","published":1,"date":"2020-12-23T03:45:06.499Z","updated":"2020-12-23T03:45:06.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckj0vjkdw00034rf0dtvty90b","content":"<h2 id=\"一、配置环境\"><a href=\"#一、配置环境\" class=\"headerlink\" title=\"一、配置环境\"></a>一、配置环境</h2><p>示例： 新建lua文件夹，放置到环境变量的Path中</p>\n<h2 id=\"二、下载lua源码\"><a href=\"#二、下载lua源码\" class=\"headerlink\" title=\"二、下载lua源码\"></a>二、下载lua源码</h2><p><a href=\"https://www.lua.org/ftp/\">https://www.lua.org/ftp/</a></p>\n<p>1.下载tar文件后<br>2.解压：使用powershell的 tar zxf .\\lua5.3.4.tar.gz文件<br>3.拷贝src文件到【一】的文件夹中，注：不需要makefile文件</p>\n<h2 id=\"三、创建VS项目工程\"><a href=\"#三、创建VS项目工程\" class=\"headerlink\" title=\"三、创建VS项目工程\"></a>三、创建VS项目工程</h2><p>1.使用Visual C++ 的空项目为模板<br>2.Source Files中添加现有项：添加所有【二】的文件夹的h和c文件</p>\n<h2 id=\"四、库形式编译\"><a href=\"#四、库形式编译\" class=\"headerlink\" title=\"四、库形式编译\"></a>四、库形式编译</h2><p>1.移除项目中的luac.c文件， lua.c文件<br>2.改变编译环境为x64， Release模式<br>3.设置项目属性的 配置类型： 动态库（dll）<br>4.C/C++ -&gt; 预处理器 -&gt; 预处理定义：添加： LUA_BUILD_AS_DLL<br>5.生成解决方案！</p>\n<p>得到 .lib 和.dll文件</p>\n<h2 id=\"五、编译生成compiler\"><a href=\"#五、编译生成compiler\" class=\"headerlink\" title=\"五、编译生成compiler\"></a>五、编译生成compiler</h2><p>1.删除 LUA_BUILD_AS_DLL 的定义<br>2.设置项目属性的 配置类型：exe<br>3.添加回luac.c文件， 编译得到luac.exe文件（compiler）</p>\n<h2 id=\"六、编译生成interpreter\"><a href=\"#六、编译生成interpreter\" class=\"headerlink\" title=\"六、编译生成interpreter\"></a>六、编译生成interpreter</h2><p>1.清空source Files中的文件<br>2.仅添加lua.c文件<br>3.配置：在C/C++ 中的Additional Include Directories中添加 【二】的源码文件夹<br>4.配置： Linker中的Input, Additional Dependencies: 添加lua.lib<br>5.配置： Linker中的General, Additional Library Dependencies: 添加lib文件所在地<br>6.生成解决方案，得到lua.exe（~=18KB）</p>\n<h2 id=\"七、源码学习\"><a href=\"#七、源码学习\" class=\"headerlink\" title=\"七、源码学习\"></a>七、源码学习</h2><p>1.移入所有代码，源文件和头文件到 VS c++项目<br>2.新建main.cpp文件，复制 lua.c的main函数 一些结构<br>3.注释掉.lua.c luac.c的main函数代码<br>4.添加.lua文件到资源目录，执行测试</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、配置环境\"><a href=\"#一、配置环境\" class=\"headerlink\" title=\"一、配置环境\"></a>一、配置环境</h2><p>示例： 新建lua文件夹，放置到环境变量的Path中</p>\n<h2 id=\"二、下载lua源码\"><a href=\"#二、下载lua源码\" class=\"headerlink\" title=\"二、下载lua源码\"></a>二、下载lua源码</h2><p><a href=\"https://www.lua.org/ftp/\">https://www.lua.org/ftp/</a></p>\n<p>1.下载tar文件后<br>2.解压：使用powershell的 tar zxf .\\lua5.3.4.tar.gz文件<br>3.拷贝src文件到【一】的文件夹中，注：不需要makefile文件</p>\n<h2 id=\"三、创建VS项目工程\"><a href=\"#三、创建VS项目工程\" class=\"headerlink\" title=\"三、创建VS项目工程\"></a>三、创建VS项目工程</h2><p>1.使用Visual C++ 的空项目为模板<br>2.Source Files中添加现有项：添加所有【二】的文件夹的h和c文件</p>\n<h2 id=\"四、库形式编译\"><a href=\"#四、库形式编译\" class=\"headerlink\" title=\"四、库形式编译\"></a>四、库形式编译</h2><p>1.移除项目中的luac.c文件， lua.c文件<br>2.改变编译环境为x64， Release模式<br>3.设置项目属性的 配置类型： 动态库（dll）<br>4.C/C++ -&gt; 预处理器 -&gt; 预处理定义：添加： LUA_BUILD_AS_DLL<br>5.生成解决方案！</p>\n<p>得到 .lib 和.dll文件</p>\n<h2 id=\"五、编译生成compiler\"><a href=\"#五、编译生成compiler\" class=\"headerlink\" title=\"五、编译生成compiler\"></a>五、编译生成compiler</h2><p>1.删除 LUA_BUILD_AS_DLL 的定义<br>2.设置项目属性的 配置类型：exe<br>3.添加回luac.c文件， 编译得到luac.exe文件（compiler）</p>\n<h2 id=\"六、编译生成interpreter\"><a href=\"#六、编译生成interpreter\" class=\"headerlink\" title=\"六、编译生成interpreter\"></a>六、编译生成interpreter</h2><p>1.清空source Files中的文件<br>2.仅添加lua.c文件<br>3.配置：在C/C++ 中的Additional Include Directories中添加 【二】的源码文件夹<br>4.配置： Linker中的Input, Additional Dependencies: 添加lua.lib<br>5.配置： Linker中的General, Additional Library Dependencies: 添加lib文件所在地<br>6.生成解决方案，得到lua.exe（~=18KB）</p>\n<h2 id=\"七、源码学习\"><a href=\"#七、源码学习\" class=\"headerlink\" title=\"七、源码学习\"></a>七、源码学习</h2><p>1.移入所有代码，源文件和头文件到 VS c++项目<br>2.新建main.cpp文件，复制 lua.c的main函数 一些结构<br>3.注释掉.lua.c luac.c的main函数代码<br>4.添加.lua文件到资源目录，执行测试</p>\n"},{"title":"CSHARP的Dictionary","_content":"\n参考： https://www.cnblogs.com/InCerry/p/10325290.html\n\n## 一、前言\n\nDictionary最大的优点就是它查找元素的时间复杂度接近O(1)，实际项目中常被用来做一些数据的本地缓存，提升整体效率。\n\n那么是什么样的设计能使得Dictionary类能实现O(1)的时间复杂度呢？\n\n## 二、理论知识\n\n### 1.HASH算法\n对于Dictionary的实现原理，其中有两个关键的算法，一个是Hash算法，一个是用于应对Hash碰撞冲突解决算法。\n\nHash算法是一种数字摘要算法，它能将不定长度的二进制数据集给映射到一个较短的二进制长度数据集，常见的MD5算法就是一种Hash算法，通过MD5算法可对任何数据生成数字摘要。而实现了Hash算法的函数我们叫她Hash函数。Hash函数有以下几点特征。\n\n* 相同的数据进行Hash运算，得到的结果一定相同。HashFunc(key1) == HashFunc(key1)\n* 不同的数据进行Hash运算，其结果也可能会相同，(Hash会产生碰撞)。key1 != key2 => HashFunc(key1) == HashFunc(key2).\n* Hash运算时不可逆的，不能由key获取原始的数据。key1 => hashCode但是hashCode =\\=> key1。\n\n常见的构造Hash函数的算法有以下几种。\n1. 直接寻址法：取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，当中a和b为常数（这样的散列函数叫做自身函数）\n2. 数字分析法：分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。\n3. 平方取中法：取keyword平方后的中间几位作为散列地址。\n4. 折叠法：将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。\n5. 随机数法：选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。\n6. 除留余数法：取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，容易产生碰撞.\n\n\n### 2、Hash桶算法\n说到Hash算法大家就会想到Hash表，一个Key通过Hash函数运算后可快速的得到hashCode，通过hashCode的映射可直接Get到Value，但是hashCode一般取值都是非常大的，经常是2^32以上，不可能对每个hashCode都指定一个映射。\n\n因为这样的一个问题，所以人们就将生成的HashCode以分段的形式来映射，把每一段称之为一个Bucket（桶），一般常见的Hash桶就是直接对结果取余。\n\n假设将生成的hashCode可能取值有2^32个，然后将其切分成一段一段，使用8个桶来映射，那么就可以通过bucketIndex = HashFunc(key1) % 8这样一个算法来确定这个hashCode映射到具体的哪个桶中。\n\n大家可以看出来，通过hash桶这种形式来进行映射，所以会加剧hash的冲突。\n\n### 3、解决冲突算法\n对于一个hash算法，不可避免的会产生冲突，那么产生冲突以后如何处理，是一个很关键的地方，目前常见的冲突解决算法有拉链法(Dictionary实现采用的)、开放定址法、再Hash法、公共溢出分区法，本文只介绍拉链法与再Hash法，对于其它算法感兴趣的同学可参考文章最后的参考文献。\n\n1. 拉链法：这种方法的思路是将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。\n\n2. 再Hash法：顾名思义就是将key使用其它的Hash函数再次Hash，直到找到不冲突的位置为止。\n\n\n![拉链法解决冲突](/img/1608693331816.png)\n\n## 三、Dictionary实现\n\n1. Entry结构体\n首先我们引入Entry这样一个结构体，它的定义如下代码所示。这是Dictionary种存放数据的最小单位，调用Add(Key,Value)方法添加的元素都会被封装在这样的一个结构体中。\n\n``` csharp\nprivate struct Entry {\n    public int hashCode;    // 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1\n    public int next;        // 下一个元素的下标索引，如果没有下一个就为-1\n    public TKey key;        // 存放元素的键\n    public TValue value;    // 存放元素的值\n}\n```\n\n2. 其它关键私有变量\n除了Entry结构体外，还有几个关键的私有变量，其定义和解释如下代码所示。\n\n``` csharp\nprivate int[] buckets;\t\t// Hash桶\nprivate Entry[] entries;\t// Entry数组，存放元素\nprivate int count;\t\t\t// 当前entries的index位置\nprivate int version;\t\t// 当前版本，防止迭代过程中集合被更改\nprivate int freeList;\t\t// 被删除Entry在entries中的下标index，这个位置是空闲的\nprivate int freeCount;\t\t// 有多少个被删除的Entry，有多少个空闲的位置\nprivate IEqualityComparer<TKey> comparer;\t// 比较器\nprivate KeyCollection keys;\t\t// 存放Key的集合\nprivate ValueCollection values;\t\t// 存放Value的集合\n```\n\n上面代码中，需要注意的是buckets、entries这两个数组，这是实现Dictionary的关键。\n\n\n3. Dictionary - Add操作\n\n![初始状态](/img/1608693746908.png)\n![添加一个元素后](/img/1608693760326.png)\n![出现冲突hash](/img/1608693801943.png)\n![解决后](/img/1608693812822.png)\n\n\n4. Dictionary - Find操作\n\n``` csharp\n// 寻找Entry元素的位置\nprivate int FindEntry(TKey key) {\n    if( key == null) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets != null) {\n        int hashCode = comparer.GetHashCode(key) & 0x7FFFFFFF; // 获取HashCode，忽略符号位\n        // int i = buckets[hashCode % buckets.Length] 找到对应桶，然后获取entry在entries中位置\n        // i >= 0; i = entries[i].next 遍历单链表\n        for (int i = buckets[hashCode % buckets.Length]; i >= 0; i = entries[i].next) {\n            // 找到就返回了\n            if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key)) return i;\n        }\n    }\n    return -1;\n}\n...\ninternal TValue GetValueOrDefault(TKey key) {\n    int i = FindEntry(key);\n    // 大于等于0代表找到了元素位置，直接返回value\n    // 否则返回该类型的默认值\n    if (i >= 0) {\n        return entries[i].value;\n    }\n    return default(TValue);\n}\n```\n\n5. Dictionary - Remove\n\n``` csharp\npublic bool Remove(TKey key) {\n    if(key == null) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets != null) {\n        // 1. 通过key获取hashCode\n        int hashCode = comparer.GetHashCode(key) & 0x7FFFFFFF;\n        // 2. 取余获取bucket位置\n        int bucket = hashCode % buckets.Length;\n        // last用于确定是否当前bucket的单链表中最后一个元素\n        int last = -1;\n        // 3. 遍历bucket对应的单链表\n        for (int i = buckets[bucket]; i >= 0; last = i, i = entries[i].next) {\n            if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key)) {\n                // 4. 找到元素后，如果last< 0，代表当前是bucket中最后一个元素，那么直接让bucket内下标赋值为 entries[i].next即可\n                if (last < 0) {\n                    buckets[bucket] = entries[i].next;\n                }\n                else {\n                    // 4.1 last不小于0，代表当前元素处于bucket单链表中间位置，需要将该元素的头结点和尾节点相连起来,防止链表中断\n                    entries[last].next = entries[i].next;\n                }\n                // 5. 将Entry结构体内数据初始化\n                entries[i].hashCode = -1;\n                // 5.1 建立freeList单链表\n                entries[i].next = freeList;\n                entries[i].key = default(TKey);\n                entries[i].value = default(TValue);\n                // *6. 关键的代码，freeList等于当前的entry位置，下一次Add元素会优先Add到该位置\n                freeList = i;\n                freeCount++;\n                // 7. 版本号+1\n                version++;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n6.Dictionary Resize\n\n* 第一种情况自然就是数组已经满了，没有办法继续存放新的元素。\n  \n* 第二种，Dictionary中发生的碰撞次数太多，会严重影响性能，也会触发扩容操作。\n目前.Net Framwork 4.7中设置的碰撞次数阈值为100.\n\n``` csharp\npublic const int HashCollisionThreshold = 100;\n```\n\n``` csharp\nprivate void Resize(int newSize, bool forceNewHashCodes) {\n    Contract.Assert(newSize >= entries.Length);\n    // 1. 申请新的Buckets和entries\n    int[] newBuckets = new int[newSize];\n    for (int i = 0; i < newBuckets.Length; i++) newBuckets[i] = -1;\n    Entry[] newEntries = new Entry[newSize];\n    // 2. 将entries内元素拷贝到新的entries总\n    Array.Copy(entries, 0, newEntries, 0, count);\n    // 3. 如果是Hash碰撞扩容，使用新HashCode函数重新计算Hash值\n    if(forceNewHashCodes) {\n        for (int i = 0; i < count; i++) {\n            if(newEntries[i].hashCode != -1) {\n                newEntries[i].hashCode = (comparer.GetHashCode(newEntries[i].key) & 0x7FFFFFFF);\n            }\n        }\n    }\n    // 4. 确定新的bucket位置\n    // 5. 重建Hahs单链表\n    for (int i = 0; i < count; i++) {\n        if (newEntries[i].hashCode >= 0) {\n            int bucket = newEntries[i].hashCode % newSize;\n            newEntries[i].next = newBuckets[bucket];\n            newBuckets[bucket] = i;\n        }\n    }\n    buckets = newBuckets;\n    entries = newEntries;\n}\n```\n\n7. Dictionary - 再谈Add操作\n在我们之前的Add操作步骤中，提到了这样一段话，这里提到会有一种其它的情况，那就是有元素被删除的情况。\n\n避开一种其它情况不谈，接下来它会将hashCode、key、value等信息存入entries[count]中，因为count位置是空闲的；继续count++指向下一个空闲位置。上图中第一个位置，index=0就是空闲的，所以就存放在entries[0]的位置。\n因为count是通过自增的方式来指向entries[]下一个空闲的entry，如果有元素被删除了，那么在count之前的位置就会出现一个空闲的entry；如果不处理，会有很多空间被浪费。\n\n这就是为什么Remove操作会记录freeList、freeCount，就是为了将删除的空间利用起来。实际上Add操作会优先使用freeList的空闲entry位置，摘录代码如下。\n\n``` csharp\nprivate void Insert(TKey key, TValue value, bool add){\n    \n    if( key == null ) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets == null) Initialize(0);\n    // 通过key获取hashCode\n    int hashCode = comparer.GetHashCode(key) & 0x7FFFFFFF;\n    // 计算出目标bucket下标\n    int targetBucket = hashCode % buckets.Length;\n\t// 碰撞次数\n    int collisionCount = 0;\n    for (int i = buckets[targetBucket]; i >= 0; i = entries[i].next) {\n        if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key)) {\n            // 如果是增加操作，遍历到了相同的元素，那么抛出异常\n            if (add) {      \n\t\t\t\tThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            // 如果不是增加操作，那可能是索引赋值操作 dictionary[\"foo\"] = \"foo\"\n            // 那么赋值后版本++，退出\n            entries[i].value = value;\n            version++;\n            return;\n        }\n        // 每遍历一个元素，都是一次碰撞\n        collisionCount++;\n    }\n    int index;\n    // 如果有被删除的元素，那么将元素放到被删除元素的空闲位置\n    if (freeCount > 0) {\n        index = freeList;\n        freeList = entries[index].next;\n        freeCount--;\n    }\n    else {\n        // 如果当前entries已满，那么触发扩容\n        if (count == entries.Length)\n        {\n            Resize();\n            targetBucket = hashCode % buckets.Length;\n        }\n        index = count;\n        count++;\n    }\n\n    // 给entry赋值\n    entries[index].hashCode = hashCode;\n    entries[index].next = buckets[targetBucket];\n    entries[index].key = key;\n    entries[index].value = value;\n    buckets[targetBucket] = index;\n    // 版本号++\n    version++;\n\n    // 如果碰撞次数大于设置的最大碰撞次数，那么触发Hash碰撞扩容\n    if(collisionCount > HashHelpers.HashCollisionThreshold && HashHelpers.IsWellKnownEqualityComparer(comparer)) \n    {\n        comparer = (IEqualityComparer<TKey>) HashHelpers.GetRandomizedEqualityComparer(comparer);\n        Resize(entries.Length, true);\n    }\n}\n```\n\n8. Collection版本控制\n![示例](/img/1608694671258.png)\n\n![代码](/img/1608694646427.png)","source":"_posts/CSHARP的Dictionary.md","raw":"---\ntitle: CSHARP的Dictionary\ncategories:\n- Unity\n---\n\n参考： https://www.cnblogs.com/InCerry/p/10325290.html\n\n## 一、前言\n\nDictionary最大的优点就是它查找元素的时间复杂度接近O(1)，实际项目中常被用来做一些数据的本地缓存，提升整体效率。\n\n那么是什么样的设计能使得Dictionary类能实现O(1)的时间复杂度呢？\n\n## 二、理论知识\n\n### 1.HASH算法\n对于Dictionary的实现原理，其中有两个关键的算法，一个是Hash算法，一个是用于应对Hash碰撞冲突解决算法。\n\nHash算法是一种数字摘要算法，它能将不定长度的二进制数据集给映射到一个较短的二进制长度数据集，常见的MD5算法就是一种Hash算法，通过MD5算法可对任何数据生成数字摘要。而实现了Hash算法的函数我们叫她Hash函数。Hash函数有以下几点特征。\n\n* 相同的数据进行Hash运算，得到的结果一定相同。HashFunc(key1) == HashFunc(key1)\n* 不同的数据进行Hash运算，其结果也可能会相同，(Hash会产生碰撞)。key1 != key2 => HashFunc(key1) == HashFunc(key2).\n* Hash运算时不可逆的，不能由key获取原始的数据。key1 => hashCode但是hashCode =\\=> key1。\n\n常见的构造Hash函数的算法有以下几种。\n1. 直接寻址法：取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，当中a和b为常数（这样的散列函数叫做自身函数）\n2. 数字分析法：分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。\n3. 平方取中法：取keyword平方后的中间几位作为散列地址。\n4. 折叠法：将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。\n5. 随机数法：选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。\n6. 除留余数法：取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，容易产生碰撞.\n\n\n### 2、Hash桶算法\n说到Hash算法大家就会想到Hash表，一个Key通过Hash函数运算后可快速的得到hashCode，通过hashCode的映射可直接Get到Value，但是hashCode一般取值都是非常大的，经常是2^32以上，不可能对每个hashCode都指定一个映射。\n\n因为这样的一个问题，所以人们就将生成的HashCode以分段的形式来映射，把每一段称之为一个Bucket（桶），一般常见的Hash桶就是直接对结果取余。\n\n假设将生成的hashCode可能取值有2^32个，然后将其切分成一段一段，使用8个桶来映射，那么就可以通过bucketIndex = HashFunc(key1) % 8这样一个算法来确定这个hashCode映射到具体的哪个桶中。\n\n大家可以看出来，通过hash桶这种形式来进行映射，所以会加剧hash的冲突。\n\n### 3、解决冲突算法\n对于一个hash算法，不可避免的会产生冲突，那么产生冲突以后如何处理，是一个很关键的地方，目前常见的冲突解决算法有拉链法(Dictionary实现采用的)、开放定址法、再Hash法、公共溢出分区法，本文只介绍拉链法与再Hash法，对于其它算法感兴趣的同学可参考文章最后的参考文献。\n\n1. 拉链法：这种方法的思路是将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。\n\n2. 再Hash法：顾名思义就是将key使用其它的Hash函数再次Hash，直到找到不冲突的位置为止。\n\n\n![拉链法解决冲突](/img/1608693331816.png)\n\n## 三、Dictionary实现\n\n1. Entry结构体\n首先我们引入Entry这样一个结构体，它的定义如下代码所示。这是Dictionary种存放数据的最小单位，调用Add(Key,Value)方法添加的元素都会被封装在这样的一个结构体中。\n\n``` csharp\nprivate struct Entry {\n    public int hashCode;    // 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1\n    public int next;        // 下一个元素的下标索引，如果没有下一个就为-1\n    public TKey key;        // 存放元素的键\n    public TValue value;    // 存放元素的值\n}\n```\n\n2. 其它关键私有变量\n除了Entry结构体外，还有几个关键的私有变量，其定义和解释如下代码所示。\n\n``` csharp\nprivate int[] buckets;\t\t// Hash桶\nprivate Entry[] entries;\t// Entry数组，存放元素\nprivate int count;\t\t\t// 当前entries的index位置\nprivate int version;\t\t// 当前版本，防止迭代过程中集合被更改\nprivate int freeList;\t\t// 被删除Entry在entries中的下标index，这个位置是空闲的\nprivate int freeCount;\t\t// 有多少个被删除的Entry，有多少个空闲的位置\nprivate IEqualityComparer<TKey> comparer;\t// 比较器\nprivate KeyCollection keys;\t\t// 存放Key的集合\nprivate ValueCollection values;\t\t// 存放Value的集合\n```\n\n上面代码中，需要注意的是buckets、entries这两个数组，这是实现Dictionary的关键。\n\n\n3. Dictionary - Add操作\n\n![初始状态](/img/1608693746908.png)\n![添加一个元素后](/img/1608693760326.png)\n![出现冲突hash](/img/1608693801943.png)\n![解决后](/img/1608693812822.png)\n\n\n4. Dictionary - Find操作\n\n``` csharp\n// 寻找Entry元素的位置\nprivate int FindEntry(TKey key) {\n    if( key == null) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets != null) {\n        int hashCode = comparer.GetHashCode(key) & 0x7FFFFFFF; // 获取HashCode，忽略符号位\n        // int i = buckets[hashCode % buckets.Length] 找到对应桶，然后获取entry在entries中位置\n        // i >= 0; i = entries[i].next 遍历单链表\n        for (int i = buckets[hashCode % buckets.Length]; i >= 0; i = entries[i].next) {\n            // 找到就返回了\n            if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key)) return i;\n        }\n    }\n    return -1;\n}\n...\ninternal TValue GetValueOrDefault(TKey key) {\n    int i = FindEntry(key);\n    // 大于等于0代表找到了元素位置，直接返回value\n    // 否则返回该类型的默认值\n    if (i >= 0) {\n        return entries[i].value;\n    }\n    return default(TValue);\n}\n```\n\n5. Dictionary - Remove\n\n``` csharp\npublic bool Remove(TKey key) {\n    if(key == null) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets != null) {\n        // 1. 通过key获取hashCode\n        int hashCode = comparer.GetHashCode(key) & 0x7FFFFFFF;\n        // 2. 取余获取bucket位置\n        int bucket = hashCode % buckets.Length;\n        // last用于确定是否当前bucket的单链表中最后一个元素\n        int last = -1;\n        // 3. 遍历bucket对应的单链表\n        for (int i = buckets[bucket]; i >= 0; last = i, i = entries[i].next) {\n            if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key)) {\n                // 4. 找到元素后，如果last< 0，代表当前是bucket中最后一个元素，那么直接让bucket内下标赋值为 entries[i].next即可\n                if (last < 0) {\n                    buckets[bucket] = entries[i].next;\n                }\n                else {\n                    // 4.1 last不小于0，代表当前元素处于bucket单链表中间位置，需要将该元素的头结点和尾节点相连起来,防止链表中断\n                    entries[last].next = entries[i].next;\n                }\n                // 5. 将Entry结构体内数据初始化\n                entries[i].hashCode = -1;\n                // 5.1 建立freeList单链表\n                entries[i].next = freeList;\n                entries[i].key = default(TKey);\n                entries[i].value = default(TValue);\n                // *6. 关键的代码，freeList等于当前的entry位置，下一次Add元素会优先Add到该位置\n                freeList = i;\n                freeCount++;\n                // 7. 版本号+1\n                version++;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n6.Dictionary Resize\n\n* 第一种情况自然就是数组已经满了，没有办法继续存放新的元素。\n  \n* 第二种，Dictionary中发生的碰撞次数太多，会严重影响性能，也会触发扩容操作。\n目前.Net Framwork 4.7中设置的碰撞次数阈值为100.\n\n``` csharp\npublic const int HashCollisionThreshold = 100;\n```\n\n``` csharp\nprivate void Resize(int newSize, bool forceNewHashCodes) {\n    Contract.Assert(newSize >= entries.Length);\n    // 1. 申请新的Buckets和entries\n    int[] newBuckets = new int[newSize];\n    for (int i = 0; i < newBuckets.Length; i++) newBuckets[i] = -1;\n    Entry[] newEntries = new Entry[newSize];\n    // 2. 将entries内元素拷贝到新的entries总\n    Array.Copy(entries, 0, newEntries, 0, count);\n    // 3. 如果是Hash碰撞扩容，使用新HashCode函数重新计算Hash值\n    if(forceNewHashCodes) {\n        for (int i = 0; i < count; i++) {\n            if(newEntries[i].hashCode != -1) {\n                newEntries[i].hashCode = (comparer.GetHashCode(newEntries[i].key) & 0x7FFFFFFF);\n            }\n        }\n    }\n    // 4. 确定新的bucket位置\n    // 5. 重建Hahs单链表\n    for (int i = 0; i < count; i++) {\n        if (newEntries[i].hashCode >= 0) {\n            int bucket = newEntries[i].hashCode % newSize;\n            newEntries[i].next = newBuckets[bucket];\n            newBuckets[bucket] = i;\n        }\n    }\n    buckets = newBuckets;\n    entries = newEntries;\n}\n```\n\n7. Dictionary - 再谈Add操作\n在我们之前的Add操作步骤中，提到了这样一段话，这里提到会有一种其它的情况，那就是有元素被删除的情况。\n\n避开一种其它情况不谈，接下来它会将hashCode、key、value等信息存入entries[count]中，因为count位置是空闲的；继续count++指向下一个空闲位置。上图中第一个位置，index=0就是空闲的，所以就存放在entries[0]的位置。\n因为count是通过自增的方式来指向entries[]下一个空闲的entry，如果有元素被删除了，那么在count之前的位置就会出现一个空闲的entry；如果不处理，会有很多空间被浪费。\n\n这就是为什么Remove操作会记录freeList、freeCount，就是为了将删除的空间利用起来。实际上Add操作会优先使用freeList的空闲entry位置，摘录代码如下。\n\n``` csharp\nprivate void Insert(TKey key, TValue value, bool add){\n    \n    if( key == null ) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets == null) Initialize(0);\n    // 通过key获取hashCode\n    int hashCode = comparer.GetHashCode(key) & 0x7FFFFFFF;\n    // 计算出目标bucket下标\n    int targetBucket = hashCode % buckets.Length;\n\t// 碰撞次数\n    int collisionCount = 0;\n    for (int i = buckets[targetBucket]; i >= 0; i = entries[i].next) {\n        if (entries[i].hashCode == hashCode && comparer.Equals(entries[i].key, key)) {\n            // 如果是增加操作，遍历到了相同的元素，那么抛出异常\n            if (add) {      \n\t\t\t\tThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            // 如果不是增加操作，那可能是索引赋值操作 dictionary[\"foo\"] = \"foo\"\n            // 那么赋值后版本++，退出\n            entries[i].value = value;\n            version++;\n            return;\n        }\n        // 每遍历一个元素，都是一次碰撞\n        collisionCount++;\n    }\n    int index;\n    // 如果有被删除的元素，那么将元素放到被删除元素的空闲位置\n    if (freeCount > 0) {\n        index = freeList;\n        freeList = entries[index].next;\n        freeCount--;\n    }\n    else {\n        // 如果当前entries已满，那么触发扩容\n        if (count == entries.Length)\n        {\n            Resize();\n            targetBucket = hashCode % buckets.Length;\n        }\n        index = count;\n        count++;\n    }\n\n    // 给entry赋值\n    entries[index].hashCode = hashCode;\n    entries[index].next = buckets[targetBucket];\n    entries[index].key = key;\n    entries[index].value = value;\n    buckets[targetBucket] = index;\n    // 版本号++\n    version++;\n\n    // 如果碰撞次数大于设置的最大碰撞次数，那么触发Hash碰撞扩容\n    if(collisionCount > HashHelpers.HashCollisionThreshold && HashHelpers.IsWellKnownEqualityComparer(comparer)) \n    {\n        comparer = (IEqualityComparer<TKey>) HashHelpers.GetRandomizedEqualityComparer(comparer);\n        Resize(entries.Length, true);\n    }\n}\n```\n\n8. Collection版本控制\n![示例](/img/1608694671258.png)\n\n![代码](/img/1608694646427.png)","slug":"CSHARP的Dictionary","published":1,"date":"2020-12-23T06:46:38.548Z","updated":"2020-12-23T06:46:38.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckj120uda0000jjf0tfssysbl","content":"<p>参考： <a href=\"https://www.cnblogs.com/InCerry/p/10325290.html\">https://www.cnblogs.com/InCerry/p/10325290.html</a></p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>Dictionary最大的优点就是它查找元素的时间复杂度接近O(1)，实际项目中常被用来做一些数据的本地缓存，提升整体效率。</p>\n<p>那么是什么样的设计能使得Dictionary类能实现O(1)的时间复杂度呢？</p>\n<h2 id=\"二、理论知识\"><a href=\"#二、理论知识\" class=\"headerlink\" title=\"二、理论知识\"></a>二、理论知识</h2><h3 id=\"1-HASH算法\"><a href=\"#1-HASH算法\" class=\"headerlink\" title=\"1.HASH算法\"></a>1.HASH算法</h3><p>对于Dictionary的实现原理，其中有两个关键的算法，一个是Hash算法，一个是用于应对Hash碰撞冲突解决算法。</p>\n<p>Hash算法是一种数字摘要算法，它能将不定长度的二进制数据集给映射到一个较短的二进制长度数据集，常见的MD5算法就是一种Hash算法，通过MD5算法可对任何数据生成数字摘要。而实现了Hash算法的函数我们叫她Hash函数。Hash函数有以下几点特征。</p>\n<ul>\n<li>相同的数据进行Hash运算，得到的结果一定相同。HashFunc(key1) == HashFunc(key1)</li>\n<li>不同的数据进行Hash运算，其结果也可能会相同，(Hash会产生碰撞)。key1 != key2 =&gt; HashFunc(key1) == HashFunc(key2).</li>\n<li>Hash运算时不可逆的，不能由key获取原始的数据。key1 =&gt; hashCode但是hashCode ==&gt; key1。</li>\n</ul>\n<p>常见的构造Hash函数的算法有以下几种。</p>\n<ol>\n<li>直接寻址法：取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，当中a和b为常数（这样的散列函数叫做自身函数）</li>\n<li>数字分析法：分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</li>\n<li>平方取中法：取keyword平方后的中间几位作为散列地址。</li>\n<li>折叠法：将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。</li>\n<li>随机数法：选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。</li>\n<li>除留余数法：取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&lt;=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，容易产生碰撞.</li>\n</ol>\n<h3 id=\"2、Hash桶算法\"><a href=\"#2、Hash桶算法\" class=\"headerlink\" title=\"2、Hash桶算法\"></a>2、Hash桶算法</h3><p>说到Hash算法大家就会想到Hash表，一个Key通过Hash函数运算后可快速的得到hashCode，通过hashCode的映射可直接Get到Value，但是hashCode一般取值都是非常大的，经常是2^32以上，不可能对每个hashCode都指定一个映射。</p>\n<p>因为这样的一个问题，所以人们就将生成的HashCode以分段的形式来映射，把每一段称之为一个Bucket（桶），一般常见的Hash桶就是直接对结果取余。</p>\n<p>假设将生成的hashCode可能取值有2^32个，然后将其切分成一段一段，使用8个桶来映射，那么就可以通过bucketIndex = HashFunc(key1) % 8这样一个算法来确定这个hashCode映射到具体的哪个桶中。</p>\n<p>大家可以看出来，通过hash桶这种形式来进行映射，所以会加剧hash的冲突。</p>\n<h3 id=\"3、解决冲突算法\"><a href=\"#3、解决冲突算法\" class=\"headerlink\" title=\"3、解决冲突算法\"></a>3、解决冲突算法</h3><p>对于一个hash算法，不可避免的会产生冲突，那么产生冲突以后如何处理，是一个很关键的地方，目前常见的冲突解决算法有拉链法(Dictionary实现采用的)、开放定址法、再Hash法、公共溢出分区法，本文只介绍拉链法与再Hash法，对于其它算法感兴趣的同学可参考文章最后的参考文献。</p>\n<ol>\n<li><p>拉链法：这种方法的思路是将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。</p>\n</li>\n<li><p>再Hash法：顾名思义就是将key使用其它的Hash函数再次Hash，直到找到不冲突的位置为止。</p>\n</li>\n</ol>\n<p><img src=\"/img/1608693331816.png\" alt=\"拉链法解决冲突\"></p>\n<h2 id=\"三、Dictionary实现\"><a href=\"#三、Dictionary实现\" class=\"headerlink\" title=\"三、Dictionary实现\"></a>三、Dictionary实现</h2><ol>\n<li>Entry结构体<br>首先我们引入Entry这样一个结构体，它的定义如下代码所示。这是Dictionary种存放数据的最小单位，调用Add(Key,Value)方法添加的元素都会被封装在这样的一个结构体中。</li>\n</ol>\n<pre><code class=\"csharp\">private struct Entry {\n    public int hashCode;    // 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1\n    public int next;        // 下一个元素的下标索引，如果没有下一个就为-1\n    public TKey key;        // 存放元素的键\n    public TValue value;    // 存放元素的值\n}</code></pre>\n<ol start=\"2\">\n<li>其它关键私有变量<br>除了Entry结构体外，还有几个关键的私有变量，其定义和解释如下代码所示。</li>\n</ol>\n<pre><code class=\"csharp\">private int[] buckets;        // Hash桶\nprivate Entry[] entries;    // Entry数组，存放元素\nprivate int count;            // 当前entries的index位置\nprivate int version;        // 当前版本，防止迭代过程中集合被更改\nprivate int freeList;        // 被删除Entry在entries中的下标index，这个位置是空闲的\nprivate int freeCount;        // 有多少个被删除的Entry，有多少个空闲的位置\nprivate IEqualityComparer&lt;TKey&gt; comparer;    // 比较器\nprivate KeyCollection keys;        // 存放Key的集合\nprivate ValueCollection values;        // 存放Value的集合</code></pre>\n<p>上面代码中，需要注意的是buckets、entries这两个数组，这是实现Dictionary的关键。</p>\n<ol start=\"3\">\n<li>Dictionary - Add操作</li>\n</ol>\n<p><img src=\"/img/1608693746908.png\" alt=\"初始状态\"><br><img src=\"/img/1608693760326.png\" alt=\"添加一个元素后\"><br><img src=\"/img/1608693801943.png\" alt=\"出现冲突hash\"><br><img src=\"/img/1608693812822.png\" alt=\"解决后\"></p>\n<ol start=\"4\">\n<li>Dictionary - Find操作</li>\n</ol>\n<pre><code class=\"csharp\">// 寻找Entry元素的位置\nprivate int FindEntry(TKey key) {\n    if( key == null) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets != null) {\n        int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF; // 获取HashCode，忽略符号位\n        // int i = buckets[hashCode % buckets.Length] 找到对应桶，然后获取entry在entries中位置\n        // i &gt;= 0; i = entries[i].next 遍历单链表\n        for (int i = buckets[hashCode % buckets.Length]; i &gt;= 0; i = entries[i].next) {\n            // 找到就返回了\n            if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) return i;\n        }\n    }\n    return -1;\n}\n...\ninternal TValue GetValueOrDefault(TKey key) {\n    int i = FindEntry(key);\n    // 大于等于0代表找到了元素位置，直接返回value\n    // 否则返回该类型的默认值\n    if (i &gt;= 0) {\n        return entries[i].value;\n    }\n    return default(TValue);\n}</code></pre>\n<ol start=\"5\">\n<li>Dictionary - Remove</li>\n</ol>\n<pre><code class=\"csharp\">public bool Remove(TKey key) {\n    if(key == null) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets != null) {\n        // 1. 通过key获取hashCode\n        int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF;\n        // 2. 取余获取bucket位置\n        int bucket = hashCode % buckets.Length;\n        // last用于确定是否当前bucket的单链表中最后一个元素\n        int last = -1;\n        // 3. 遍历bucket对应的单链表\n        for (int i = buckets[bucket]; i &gt;= 0; last = i, i = entries[i].next) {\n            if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) {\n                // 4. 找到元素后，如果last&lt; 0，代表当前是bucket中最后一个元素，那么直接让bucket内下标赋值为 entries[i].next即可\n                if (last &lt; 0) {\n                    buckets[bucket] = entries[i].next;\n                }\n                else {\n                    // 4.1 last不小于0，代表当前元素处于bucket单链表中间位置，需要将该元素的头结点和尾节点相连起来,防止链表中断\n                    entries[last].next = entries[i].next;\n                }\n                // 5. 将Entry结构体内数据初始化\n                entries[i].hashCode = -1;\n                // 5.1 建立freeList单链表\n                entries[i].next = freeList;\n                entries[i].key = default(TKey);\n                entries[i].value = default(TValue);\n                // *6. 关键的代码，freeList等于当前的entry位置，下一次Add元素会优先Add到该位置\n                freeList = i;\n                freeCount++;\n                // 7. 版本号+1\n                version++;\n                return true;\n            }\n        }\n    }\n    return false;\n}</code></pre>\n<p>6.Dictionary Resize</p>\n<ul>\n<li><p>第一种情况自然就是数组已经满了，没有办法继续存放新的元素。</p>\n</li>\n<li><p>第二种，Dictionary中发生的碰撞次数太多，会严重影响性能，也会触发扩容操作。<br>目前.Net Framwork 4.7中设置的碰撞次数阈值为100.</p>\n</li>\n</ul>\n<pre><code class=\"csharp\">public const int HashCollisionThreshold = 100;</code></pre>\n<pre><code class=\"csharp\">private void Resize(int newSize, bool forceNewHashCodes) {\n    Contract.Assert(newSize &gt;= entries.Length);\n    // 1. 申请新的Buckets和entries\n    int[] newBuckets = new int[newSize];\n    for (int i = 0; i &lt; newBuckets.Length; i++) newBuckets[i] = -1;\n    Entry[] newEntries = new Entry[newSize];\n    // 2. 将entries内元素拷贝到新的entries总\n    Array.Copy(entries, 0, newEntries, 0, count);\n    // 3. 如果是Hash碰撞扩容，使用新HashCode函数重新计算Hash值\n    if(forceNewHashCodes) {\n        for (int i = 0; i &lt; count; i++) {\n            if(newEntries[i].hashCode != -1) {\n                newEntries[i].hashCode = (comparer.GetHashCode(newEntries[i].key) &amp; 0x7FFFFFFF);\n            }\n        }\n    }\n    // 4. 确定新的bucket位置\n    // 5. 重建Hahs单链表\n    for (int i = 0; i &lt; count; i++) {\n        if (newEntries[i].hashCode &gt;= 0) {\n            int bucket = newEntries[i].hashCode % newSize;\n            newEntries[i].next = newBuckets[bucket];\n            newBuckets[bucket] = i;\n        }\n    }\n    buckets = newBuckets;\n    entries = newEntries;\n}</code></pre>\n<ol start=\"7\">\n<li>Dictionary - 再谈Add操作<br>在我们之前的Add操作步骤中，提到了这样一段话，这里提到会有一种其它的情况，那就是有元素被删除的情况。</li>\n</ol>\n<p>避开一种其它情况不谈，接下来它会将hashCode、key、value等信息存入entries[count]中，因为count位置是空闲的；继续count++指向下一个空闲位置。上图中第一个位置，index=0就是空闲的，所以就存放在entries[0]的位置。<br>因为count是通过自增的方式来指向entries[]下一个空闲的entry，如果有元素被删除了，那么在count之前的位置就会出现一个空闲的entry；如果不处理，会有很多空间被浪费。</p>\n<p>这就是为什么Remove操作会记录freeList、freeCount，就是为了将删除的空间利用起来。实际上Add操作会优先使用freeList的空闲entry位置，摘录代码如下。</p>\n<pre><code class=\"csharp\">private void Insert(TKey key, TValue value, bool add){\n\n    if( key == null ) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets == null) Initialize(0);\n    // 通过key获取hashCode\n    int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF;\n    // 计算出目标bucket下标\n    int targetBucket = hashCode % buckets.Length;\n    // 碰撞次数\n    int collisionCount = 0;\n    for (int i = buckets[targetBucket]; i &gt;= 0; i = entries[i].next) {\n        if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) {\n            // 如果是增加操作，遍历到了相同的元素，那么抛出异常\n            if (add) {      \n                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            // 如果不是增加操作，那可能是索引赋值操作 dictionary[&quot;foo&quot;] = &quot;foo&quot;\n            // 那么赋值后版本++，退出\n            entries[i].value = value;\n            version++;\n            return;\n        }\n        // 每遍历一个元素，都是一次碰撞\n        collisionCount++;\n    }\n    int index;\n    // 如果有被删除的元素，那么将元素放到被删除元素的空闲位置\n    if (freeCount &gt; 0) {\n        index = freeList;\n        freeList = entries[index].next;\n        freeCount--;\n    }\n    else {\n        // 如果当前entries已满，那么触发扩容\n        if (count == entries.Length)\n        {\n            Resize();\n            targetBucket = hashCode % buckets.Length;\n        }\n        index = count;\n        count++;\n    }\n\n    // 给entry赋值\n    entries[index].hashCode = hashCode;\n    entries[index].next = buckets[targetBucket];\n    entries[index].key = key;\n    entries[index].value = value;\n    buckets[targetBucket] = index;\n    // 版本号++\n    version++;\n\n    // 如果碰撞次数大于设置的最大碰撞次数，那么触发Hash碰撞扩容\n    if(collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; HashHelpers.IsWellKnownEqualityComparer(comparer)) \n    {\n        comparer = (IEqualityComparer&lt;TKey&gt;) HashHelpers.GetRandomizedEqualityComparer(comparer);\n        Resize(entries.Length, true);\n    }\n}</code></pre>\n<ol start=\"8\">\n<li>Collection版本控制<br><img src=\"/img/1608694671258.png\" alt=\"示例\"></li>\n</ol>\n<p><img src=\"/img/1608694646427.png\" alt=\"代码\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考： <a href=\"https://www.cnblogs.com/InCerry/p/10325290.html\">https://www.cnblogs.com/InCerry/p/10325290.html</a></p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>Dictionary最大的优点就是它查找元素的时间复杂度接近O(1)，实际项目中常被用来做一些数据的本地缓存，提升整体效率。</p>\n<p>那么是什么样的设计能使得Dictionary类能实现O(1)的时间复杂度呢？</p>\n<h2 id=\"二、理论知识\"><a href=\"#二、理论知识\" class=\"headerlink\" title=\"二、理论知识\"></a>二、理论知识</h2><h3 id=\"1-HASH算法\"><a href=\"#1-HASH算法\" class=\"headerlink\" title=\"1.HASH算法\"></a>1.HASH算法</h3><p>对于Dictionary的实现原理，其中有两个关键的算法，一个是Hash算法，一个是用于应对Hash碰撞冲突解决算法。</p>\n<p>Hash算法是一种数字摘要算法，它能将不定长度的二进制数据集给映射到一个较短的二进制长度数据集，常见的MD5算法就是一种Hash算法，通过MD5算法可对任何数据生成数字摘要。而实现了Hash算法的函数我们叫她Hash函数。Hash函数有以下几点特征。</p>\n<ul>\n<li>相同的数据进行Hash运算，得到的结果一定相同。HashFunc(key1) == HashFunc(key1)</li>\n<li>不同的数据进行Hash运算，其结果也可能会相同，(Hash会产生碰撞)。key1 != key2 =&gt; HashFunc(key1) == HashFunc(key2).</li>\n<li>Hash运算时不可逆的，不能由key获取原始的数据。key1 =&gt; hashCode但是hashCode ==&gt; key1。</li>\n</ul>\n<p>常见的构造Hash函数的算法有以下几种。</p>\n<ol>\n<li>直接寻址法：取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，当中a和b为常数（这样的散列函数叫做自身函数）</li>\n<li>数字分析法：分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</li>\n<li>平方取中法：取keyword平方后的中间几位作为散列地址。</li>\n<li>折叠法：将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。</li>\n<li>随机数法：选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。</li>\n<li>除留余数法：取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&lt;=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，容易产生碰撞.</li>\n</ol>\n<h3 id=\"2、Hash桶算法\"><a href=\"#2、Hash桶算法\" class=\"headerlink\" title=\"2、Hash桶算法\"></a>2、Hash桶算法</h3><p>说到Hash算法大家就会想到Hash表，一个Key通过Hash函数运算后可快速的得到hashCode，通过hashCode的映射可直接Get到Value，但是hashCode一般取值都是非常大的，经常是2^32以上，不可能对每个hashCode都指定一个映射。</p>\n<p>因为这样的一个问题，所以人们就将生成的HashCode以分段的形式来映射，把每一段称之为一个Bucket（桶），一般常见的Hash桶就是直接对结果取余。</p>\n<p>假设将生成的hashCode可能取值有2^32个，然后将其切分成一段一段，使用8个桶来映射，那么就可以通过bucketIndex = HashFunc(key1) % 8这样一个算法来确定这个hashCode映射到具体的哪个桶中。</p>\n<p>大家可以看出来，通过hash桶这种形式来进行映射，所以会加剧hash的冲突。</p>\n<h3 id=\"3、解决冲突算法\"><a href=\"#3、解决冲突算法\" class=\"headerlink\" title=\"3、解决冲突算法\"></a>3、解决冲突算法</h3><p>对于一个hash算法，不可避免的会产生冲突，那么产生冲突以后如何处理，是一个很关键的地方，目前常见的冲突解决算法有拉链法(Dictionary实现采用的)、开放定址法、再Hash法、公共溢出分区法，本文只介绍拉链法与再Hash法，对于其它算法感兴趣的同学可参考文章最后的参考文献。</p>\n<ol>\n<li><p>拉链法：这种方法的思路是将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。</p>\n</li>\n<li><p>再Hash法：顾名思义就是将key使用其它的Hash函数再次Hash，直到找到不冲突的位置为止。</p>\n</li>\n</ol>\n<p><img src=\"/img/1608693331816.png\" alt=\"拉链法解决冲突\"></p>\n<h2 id=\"三、Dictionary实现\"><a href=\"#三、Dictionary实现\" class=\"headerlink\" title=\"三、Dictionary实现\"></a>三、Dictionary实现</h2><ol>\n<li>Entry结构体<br>首先我们引入Entry这样一个结构体，它的定义如下代码所示。这是Dictionary种存放数据的最小单位，调用Add(Key,Value)方法添加的元素都会被封装在这样的一个结构体中。</li>\n</ol>\n<pre><code class=\"csharp\">private struct Entry {\n    public int hashCode;    // 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1\n    public int next;        // 下一个元素的下标索引，如果没有下一个就为-1\n    public TKey key;        // 存放元素的键\n    public TValue value;    // 存放元素的值\n}</code></pre>\n<ol start=\"2\">\n<li>其它关键私有变量<br>除了Entry结构体外，还有几个关键的私有变量，其定义和解释如下代码所示。</li>\n</ol>\n<pre><code class=\"csharp\">private int[] buckets;        // Hash桶\nprivate Entry[] entries;    // Entry数组，存放元素\nprivate int count;            // 当前entries的index位置\nprivate int version;        // 当前版本，防止迭代过程中集合被更改\nprivate int freeList;        // 被删除Entry在entries中的下标index，这个位置是空闲的\nprivate int freeCount;        // 有多少个被删除的Entry，有多少个空闲的位置\nprivate IEqualityComparer&lt;TKey&gt; comparer;    // 比较器\nprivate KeyCollection keys;        // 存放Key的集合\nprivate ValueCollection values;        // 存放Value的集合</code></pre>\n<p>上面代码中，需要注意的是buckets、entries这两个数组，这是实现Dictionary的关键。</p>\n<ol start=\"3\">\n<li>Dictionary - Add操作</li>\n</ol>\n<p><img src=\"/img/1608693746908.png\" alt=\"初始状态\"><br><img src=\"/img/1608693760326.png\" alt=\"添加一个元素后\"><br><img src=\"/img/1608693801943.png\" alt=\"出现冲突hash\"><br><img src=\"/img/1608693812822.png\" alt=\"解决后\"></p>\n<ol start=\"4\">\n<li>Dictionary - Find操作</li>\n</ol>\n<pre><code class=\"csharp\">// 寻找Entry元素的位置\nprivate int FindEntry(TKey key) {\n    if( key == null) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets != null) {\n        int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF; // 获取HashCode，忽略符号位\n        // int i = buckets[hashCode % buckets.Length] 找到对应桶，然后获取entry在entries中位置\n        // i &gt;= 0; i = entries[i].next 遍历单链表\n        for (int i = buckets[hashCode % buckets.Length]; i &gt;= 0; i = entries[i].next) {\n            // 找到就返回了\n            if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) return i;\n        }\n    }\n    return -1;\n}\n...\ninternal TValue GetValueOrDefault(TKey key) {\n    int i = FindEntry(key);\n    // 大于等于0代表找到了元素位置，直接返回value\n    // 否则返回该类型的默认值\n    if (i &gt;= 0) {\n        return entries[i].value;\n    }\n    return default(TValue);\n}</code></pre>\n<ol start=\"5\">\n<li>Dictionary - Remove</li>\n</ol>\n<pre><code class=\"csharp\">public bool Remove(TKey key) {\n    if(key == null) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets != null) {\n        // 1. 通过key获取hashCode\n        int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF;\n        // 2. 取余获取bucket位置\n        int bucket = hashCode % buckets.Length;\n        // last用于确定是否当前bucket的单链表中最后一个元素\n        int last = -1;\n        // 3. 遍历bucket对应的单链表\n        for (int i = buckets[bucket]; i &gt;= 0; last = i, i = entries[i].next) {\n            if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) {\n                // 4. 找到元素后，如果last&lt; 0，代表当前是bucket中最后一个元素，那么直接让bucket内下标赋值为 entries[i].next即可\n                if (last &lt; 0) {\n                    buckets[bucket] = entries[i].next;\n                }\n                else {\n                    // 4.1 last不小于0，代表当前元素处于bucket单链表中间位置，需要将该元素的头结点和尾节点相连起来,防止链表中断\n                    entries[last].next = entries[i].next;\n                }\n                // 5. 将Entry结构体内数据初始化\n                entries[i].hashCode = -1;\n                // 5.1 建立freeList单链表\n                entries[i].next = freeList;\n                entries[i].key = default(TKey);\n                entries[i].value = default(TValue);\n                // *6. 关键的代码，freeList等于当前的entry位置，下一次Add元素会优先Add到该位置\n                freeList = i;\n                freeCount++;\n                // 7. 版本号+1\n                version++;\n                return true;\n            }\n        }\n    }\n    return false;\n}</code></pre>\n<p>6.Dictionary Resize</p>\n<ul>\n<li><p>第一种情况自然就是数组已经满了，没有办法继续存放新的元素。</p>\n</li>\n<li><p>第二种，Dictionary中发生的碰撞次数太多，会严重影响性能，也会触发扩容操作。<br>目前.Net Framwork 4.7中设置的碰撞次数阈值为100.</p>\n</li>\n</ul>\n<pre><code class=\"csharp\">public const int HashCollisionThreshold = 100;</code></pre>\n<pre><code class=\"csharp\">private void Resize(int newSize, bool forceNewHashCodes) {\n    Contract.Assert(newSize &gt;= entries.Length);\n    // 1. 申请新的Buckets和entries\n    int[] newBuckets = new int[newSize];\n    for (int i = 0; i &lt; newBuckets.Length; i++) newBuckets[i] = -1;\n    Entry[] newEntries = new Entry[newSize];\n    // 2. 将entries内元素拷贝到新的entries总\n    Array.Copy(entries, 0, newEntries, 0, count);\n    // 3. 如果是Hash碰撞扩容，使用新HashCode函数重新计算Hash值\n    if(forceNewHashCodes) {\n        for (int i = 0; i &lt; count; i++) {\n            if(newEntries[i].hashCode != -1) {\n                newEntries[i].hashCode = (comparer.GetHashCode(newEntries[i].key) &amp; 0x7FFFFFFF);\n            }\n        }\n    }\n    // 4. 确定新的bucket位置\n    // 5. 重建Hahs单链表\n    for (int i = 0; i &lt; count; i++) {\n        if (newEntries[i].hashCode &gt;= 0) {\n            int bucket = newEntries[i].hashCode % newSize;\n            newEntries[i].next = newBuckets[bucket];\n            newBuckets[bucket] = i;\n        }\n    }\n    buckets = newBuckets;\n    entries = newEntries;\n}</code></pre>\n<ol start=\"7\">\n<li>Dictionary - 再谈Add操作<br>在我们之前的Add操作步骤中，提到了这样一段话，这里提到会有一种其它的情况，那就是有元素被删除的情况。</li>\n</ol>\n<p>避开一种其它情况不谈，接下来它会将hashCode、key、value等信息存入entries[count]中，因为count位置是空闲的；继续count++指向下一个空闲位置。上图中第一个位置，index=0就是空闲的，所以就存放在entries[0]的位置。<br>因为count是通过自增的方式来指向entries[]下一个空闲的entry，如果有元素被删除了，那么在count之前的位置就会出现一个空闲的entry；如果不处理，会有很多空间被浪费。</p>\n<p>这就是为什么Remove操作会记录freeList、freeCount，就是为了将删除的空间利用起来。实际上Add操作会优先使用freeList的空闲entry位置，摘录代码如下。</p>\n<pre><code class=\"csharp\">private void Insert(TKey key, TValue value, bool add){\n\n    if( key == null ) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);\n    }\n\n    if (buckets == null) Initialize(0);\n    // 通过key获取hashCode\n    int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF;\n    // 计算出目标bucket下标\n    int targetBucket = hashCode % buckets.Length;\n    // 碰撞次数\n    int collisionCount = 0;\n    for (int i = buckets[targetBucket]; i &gt;= 0; i = entries[i].next) {\n        if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) {\n            // 如果是增加操作，遍历到了相同的元素，那么抛出异常\n            if (add) {      \n                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);\n            }\n            // 如果不是增加操作，那可能是索引赋值操作 dictionary[&quot;foo&quot;] = &quot;foo&quot;\n            // 那么赋值后版本++，退出\n            entries[i].value = value;\n            version++;\n            return;\n        }\n        // 每遍历一个元素，都是一次碰撞\n        collisionCount++;\n    }\n    int index;\n    // 如果有被删除的元素，那么将元素放到被删除元素的空闲位置\n    if (freeCount &gt; 0) {\n        index = freeList;\n        freeList = entries[index].next;\n        freeCount--;\n    }\n    else {\n        // 如果当前entries已满，那么触发扩容\n        if (count == entries.Length)\n        {\n            Resize();\n            targetBucket = hashCode % buckets.Length;\n        }\n        index = count;\n        count++;\n    }\n\n    // 给entry赋值\n    entries[index].hashCode = hashCode;\n    entries[index].next = buckets[targetBucket];\n    entries[index].key = key;\n    entries[index].value = value;\n    buckets[targetBucket] = index;\n    // 版本号++\n    version++;\n\n    // 如果碰撞次数大于设置的最大碰撞次数，那么触发Hash碰撞扩容\n    if(collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; HashHelpers.IsWellKnownEqualityComparer(comparer)) \n    {\n        comparer = (IEqualityComparer&lt;TKey&gt;) HashHelpers.GetRandomizedEqualityComparer(comparer);\n        Resize(entries.Length, true);\n    }\n}</code></pre>\n<ol start=\"8\">\n<li>Collection版本控制<br><img src=\"/img/1608694671258.png\" alt=\"示例\"></li>\n</ol>\n<p><img src=\"/img/1608694646427.png\" alt=\"代码\"></p>\n"},{"title":"CSHARP的GC","_content":"\n## 一、GC概述\n早在1958年，由鼎鼎大名的图林奖得主John McCarthy所实现的Lisp语言就已经提供了GC的功能，这是GC的第一次出现。Lisp的程序员认为内存管理太重要了，所以不能由程序员自己来管理。但后来的日子里Lisp却没有成气候，采用内存手动管理的语言占据了上风，以C为代表。出于同样的理由，不同的人却又不同的看法，C程序员认为内存管理太重要了，所以不能由系统来管理，并且讥笑Lisp程序慢如乌龟的运行速度。的确，在那个对每一个Byte都要精心计算的年代GC的速度和对系统资源的大量占用使很多人的无法接受。而后，1984年由Dave Ungar开发的Small talk语言第一次采用了Generational garbage collection的技术（这个技术在下文中会谈到），但是Small talk也没有得到十分广泛的应用。\n\n直到20世纪90年代中期GC才以主角的身份登上了历史的舞台，这不得不归功于Java的进步，今日的GC已非吴下阿蒙。Java采用VM（Virtual Machine）机制，由VM来管理程序的运行当然也包括对GC管理。90年代末期.net出现了，.net采用了和Java类似的方法由CLR(Common Language Runtime)来管理。这两大阵营的出现将人们引入了以虚拟平台为基础的开发时代，GC也在这个时候越来越得到大众的关注。\n\n为什么要使用GC呢？也可以说是为什么要使用内存自动管理？有下面的几个原因：\n1、提高了软件开发的抽象度；\n2、程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题；\n3、可以使模块的接口更加的清晰，减小模块间的偶合；\n4、大大减少了内存人为管理不当所带来的Bug；\n5、使内存管理更加高效。\n总的说来就是GC可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。\n\n比较常见的算法有Reference Counting，Mark Sweep，Copy Collection等等。目前主流的虚拟系统.net CLR，Java VM和Rotor都是采用的Mark Sweep算法。\n\n## 二、更好的方式回收非托管内存\n\n### 1. 析构函数\n析构函数的类型需要两次GC才能被完全回收。这些类型会被放到一个专门的队列里，第一次GC执行析构函数回收非托管内存，第二次ＧＣ再回收他们自身。\n采用析构函数来回收可以称为被动回收，因为你不知道它什么时候被回收。但由于它需要两次GC才能被完全回收，因此就会有一些性能影响。\n\n### 2.IDisposable接口 + using\n所以最好使用主动回收的方式，类型实现IDisposable接口后，非托管内存回收的逻辑就放在Dispose函数里。\nusing（Type A=new Type()）{A的具体使用逻辑}\nA只能再using块里使用，使用完之后就立马调用A的Dispose函数，然后回收A。\n\n## 三、Mark-Compact 标记压缩算法\n\n简单把.NET的GC算法看作Mark-Compact算法\n    阶段1: Mark-Sweep 标记清除阶段\n    先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的\n    阶段2: Compact 压缩阶段\n    对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理\n\t\n* !! 主要处理步骤：将线程挂起=>确定roots=>创建reachable objectsgraph=>对象回收=>heap压缩=>指针修复\n\n\n* roots: heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的graph，roots是CLR在heap之外可以找到的各种入口点。GC搜索roots的地方包括全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针（还有finalizationqueue）等。主要可以归为2种类型：已经初始化了的静态变量、线程仍在使用的对象（stack+CPU register）\n* Reachable objects: 指根据对象引用关系，从roots出发可以到达的对象。例如当前执行函数的局部变量对象A是一个rootobject，他的成员变量引用了对象B，则B是一个reachable object。从roots出发可以创建reachable objectsgraph，剩余对象即为unreachable，可以被回收\n* 指针修复：因为compact过程移动了heap对象，对象地址发生变化，需要修复所有引用指针，包括stack、CPUregister中的指针以及heap中其他对象的引用指针\n\n> Debug和release执行模式之间稍有区别，release模式下后续代码没有引用的对象是unreachable的，而debug模式下需要等到当前函数执行完毕，这些对象才会成为unreachable，目的是为了调试时跟踪局部对象的内容\n\n> Pinnedobjects指分配之后不能移动位置的对象，例如传递给非托管代码的对象（或者使用了fixed关键字），GC在指针修复时无法修改非托管代码中的引用指针，因此将这些对象移动将发生异常。pinnedobjects会导致heap出现碎片，但大部分情况来说传给非托管代码的对象应当在GC时能够被回收掉\n\n\n## 四、Generational 分代算法\n\n将对象按照生命周期分成新的、老的，根据统计分布规律所反映的结果，可以对新、老区域采用不同的回收策略和算法，加强对新区域的回收处理力度，争取在较短时间间隔、较小的内存区域内，以较低成本将执行路径上大量新近抛弃不再使用的局部对象及时回收掉\n\n\n* 分代算法的假设前提条件：\n1、大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长\n2、对部分内存进行回收比基于全部内存的回收操作要快\n3、新创建的对象之间关联程度通常较强。heap分配的对象是连续的，关联度较强有利于提高CPU cache的命中率\n\n\nHeap分为3个代龄区域，相应的GC有3种方式: # Gen 0 collections, # Gen 1 collections, #Gen 2 collections。如果**Gen 0 heap内存达到阀值**，则触发0代GC，0代GC后Gen 0中幸存的对象进入Gen1。如果**Gen 1的内存达到阀值**，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。==2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收 #F44336==\n   Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为fullGC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时fullGC可能需要花费几秒时间。大致上来讲.NET应用运行期间2代、1代和0代GC的频率应当大致为1:10:100。\n\n\n## 五、Finalization Queue和Freachable Queue\n这两个队列和.net对象所提供的Finalize方法有关。这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了new操作符在Managed Heap上分配空间时，GC会对其进行分析，如果该对象含有Finalize方法则在Finalization Queue中添加一个指向该对象的指针。在GC被启动以后，经过Mark阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被Finalization Queue中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到Freachable Queue中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？==因为这个对象的Finalize方法还没有被执行，所以不能让它死去 #F44336==。\n\nFreachable Queue平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的Finalize方法执行，之后将这个指针从队列中剔除，这是对象就可以安静的死去了。\n\n.net framework的System.GC类提供了控制Finalize的两个方法，ReRegisterForFinalize和SuppressFinalize。前者是请求系统完成对象的Finalize方法，后者是请求系统不要完成对象的Finalize方法。\n\n* ReRegisterForFinalize方法其实就是将指向对象的指针重新添加到Finalization Queue中。这就出现了一个很有趣的现象，因为在Finalization Queue中的对象可以复生，如果在对象的Finalize方法中调用ReRegisterForFinalize方法，这样就形成了一个在堆上永远不会死去的对象，像凤凰涅槃一样每次死的时候都可以复生。\n\n\n![流程](/img/1608690535258.png)\n\n>非托管资源：\nApplicationContext,Brush,Component,ComponentDesigner,Container,Context,Cursor,FileStream,Font,Icon,Image,Matrix,Object,OdbcDataReader,OleDBDataReader,Pen,Regex,Socket,StreamWriter,Timer,Tooltip ,文件句柄,GDI资源,数据库连接等等资源。可能在使用的时候很多都没有注意到！\n\n \n\n### .NET的GC机制有这样两个问题：\n首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。\n第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。\n\n\n### 使用SuppressFinalize函数\n\n在使用~析构函数的同时又使用了IDisposable接口的时候，Dispose函数在执行完后应该调用 GC.SuppressFinalize以阻止 GC调用Finalize方法，因为Finalize方法的调用会牺牲部分性能。\n\n### 强制GC回收\n\nGC.Collect(Int32, GCCollectionMode) \t\n强制对零代到指定代进行即时垃圾回收。强制回收的模式\n\n\n\nGC注意事项：\n\n1、只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理\n\n2、循环引用，网状结构等的实现会变得简单。GC的标志也压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。\n\n3、GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。\n\n4、GC在一个独立的线程中运行来删除不再被引用的内存\n\n5、GC每次运行时会压缩托管堆\n\n6、你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。\n\n7、对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数\n\n8、Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer.而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。\n\n9、.NET GC使用\"代\"(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。==成员变量和全局变量很快变成第1代对象并最终成为第2代对象。 #F44336==\n\n10、GC对不同代的对象执行不同的检查策略以优化性能。==每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象 #F44336==。重新思考Finalization的代价：需要Finalization的对象可能比不需要Finalization在内存中停留额外9个GC周期。如果此时它还没有被Finalize,就变成第2代对象，从而在内存中停留更长时间。","source":"_posts/CSHARP的GC.md","raw":"---\ntitle: CSHARP的GC\ncategories:\n- Unity\n---\n\n## 一、GC概述\n早在1958年，由鼎鼎大名的图林奖得主John McCarthy所实现的Lisp语言就已经提供了GC的功能，这是GC的第一次出现。Lisp的程序员认为内存管理太重要了，所以不能由程序员自己来管理。但后来的日子里Lisp却没有成气候，采用内存手动管理的语言占据了上风，以C为代表。出于同样的理由，不同的人却又不同的看法，C程序员认为内存管理太重要了，所以不能由系统来管理，并且讥笑Lisp程序慢如乌龟的运行速度。的确，在那个对每一个Byte都要精心计算的年代GC的速度和对系统资源的大量占用使很多人的无法接受。而后，1984年由Dave Ungar开发的Small talk语言第一次采用了Generational garbage collection的技术（这个技术在下文中会谈到），但是Small talk也没有得到十分广泛的应用。\n\n直到20世纪90年代中期GC才以主角的身份登上了历史的舞台，这不得不归功于Java的进步，今日的GC已非吴下阿蒙。Java采用VM（Virtual Machine）机制，由VM来管理程序的运行当然也包括对GC管理。90年代末期.net出现了，.net采用了和Java类似的方法由CLR(Common Language Runtime)来管理。这两大阵营的出现将人们引入了以虚拟平台为基础的开发时代，GC也在这个时候越来越得到大众的关注。\n\n为什么要使用GC呢？也可以说是为什么要使用内存自动管理？有下面的几个原因：\n1、提高了软件开发的抽象度；\n2、程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题；\n3、可以使模块的接口更加的清晰，减小模块间的偶合；\n4、大大减少了内存人为管理不当所带来的Bug；\n5、使内存管理更加高效。\n总的说来就是GC可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。\n\n比较常见的算法有Reference Counting，Mark Sweep，Copy Collection等等。目前主流的虚拟系统.net CLR，Java VM和Rotor都是采用的Mark Sweep算法。\n\n## 二、更好的方式回收非托管内存\n\n### 1. 析构函数\n析构函数的类型需要两次GC才能被完全回收。这些类型会被放到一个专门的队列里，第一次GC执行析构函数回收非托管内存，第二次ＧＣ再回收他们自身。\n采用析构函数来回收可以称为被动回收，因为你不知道它什么时候被回收。但由于它需要两次GC才能被完全回收，因此就会有一些性能影响。\n\n### 2.IDisposable接口 + using\n所以最好使用主动回收的方式，类型实现IDisposable接口后，非托管内存回收的逻辑就放在Dispose函数里。\nusing（Type A=new Type()）{A的具体使用逻辑}\nA只能再using块里使用，使用完之后就立马调用A的Dispose函数，然后回收A。\n\n## 三、Mark-Compact 标记压缩算法\n\n简单把.NET的GC算法看作Mark-Compact算法\n    阶段1: Mark-Sweep 标记清除阶段\n    先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的\n    阶段2: Compact 压缩阶段\n    对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理\n\t\n* !! 主要处理步骤：将线程挂起=>确定roots=>创建reachable objectsgraph=>对象回收=>heap压缩=>指针修复\n\n\n* roots: heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的graph，roots是CLR在heap之外可以找到的各种入口点。GC搜索roots的地方包括全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针（还有finalizationqueue）等。主要可以归为2种类型：已经初始化了的静态变量、线程仍在使用的对象（stack+CPU register）\n* Reachable objects: 指根据对象引用关系，从roots出发可以到达的对象。例如当前执行函数的局部变量对象A是一个rootobject，他的成员变量引用了对象B，则B是一个reachable object。从roots出发可以创建reachable objectsgraph，剩余对象即为unreachable，可以被回收\n* 指针修复：因为compact过程移动了heap对象，对象地址发生变化，需要修复所有引用指针，包括stack、CPUregister中的指针以及heap中其他对象的引用指针\n\n> Debug和release执行模式之间稍有区别，release模式下后续代码没有引用的对象是unreachable的，而debug模式下需要等到当前函数执行完毕，这些对象才会成为unreachable，目的是为了调试时跟踪局部对象的内容\n\n> Pinnedobjects指分配之后不能移动位置的对象，例如传递给非托管代码的对象（或者使用了fixed关键字），GC在指针修复时无法修改非托管代码中的引用指针，因此将这些对象移动将发生异常。pinnedobjects会导致heap出现碎片，但大部分情况来说传给非托管代码的对象应当在GC时能够被回收掉\n\n\n## 四、Generational 分代算法\n\n将对象按照生命周期分成新的、老的，根据统计分布规律所反映的结果，可以对新、老区域采用不同的回收策略和算法，加强对新区域的回收处理力度，争取在较短时间间隔、较小的内存区域内，以较低成本将执行路径上大量新近抛弃不再使用的局部对象及时回收掉\n\n\n* 分代算法的假设前提条件：\n1、大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长\n2、对部分内存进行回收比基于全部内存的回收操作要快\n3、新创建的对象之间关联程度通常较强。heap分配的对象是连续的，关联度较强有利于提高CPU cache的命中率\n\n\nHeap分为3个代龄区域，相应的GC有3种方式: # Gen 0 collections, # Gen 1 collections, #Gen 2 collections。如果**Gen 0 heap内存达到阀值**，则触发0代GC，0代GC后Gen 0中幸存的对象进入Gen1。如果**Gen 1的内存达到阀值**，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。==2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收 #F44336==\n   Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为fullGC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时fullGC可能需要花费几秒时间。大致上来讲.NET应用运行期间2代、1代和0代GC的频率应当大致为1:10:100。\n\n\n## 五、Finalization Queue和Freachable Queue\n这两个队列和.net对象所提供的Finalize方法有关。这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了new操作符在Managed Heap上分配空间时，GC会对其进行分析，如果该对象含有Finalize方法则在Finalization Queue中添加一个指向该对象的指针。在GC被启动以后，经过Mark阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被Finalization Queue中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到Freachable Queue中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？==因为这个对象的Finalize方法还没有被执行，所以不能让它死去 #F44336==。\n\nFreachable Queue平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的Finalize方法执行，之后将这个指针从队列中剔除，这是对象就可以安静的死去了。\n\n.net framework的System.GC类提供了控制Finalize的两个方法，ReRegisterForFinalize和SuppressFinalize。前者是请求系统完成对象的Finalize方法，后者是请求系统不要完成对象的Finalize方法。\n\n* ReRegisterForFinalize方法其实就是将指向对象的指针重新添加到Finalization Queue中。这就出现了一个很有趣的现象，因为在Finalization Queue中的对象可以复生，如果在对象的Finalize方法中调用ReRegisterForFinalize方法，这样就形成了一个在堆上永远不会死去的对象，像凤凰涅槃一样每次死的时候都可以复生。\n\n\n![流程](/img/1608690535258.png)\n\n>非托管资源：\nApplicationContext,Brush,Component,ComponentDesigner,Container,Context,Cursor,FileStream,Font,Icon,Image,Matrix,Object,OdbcDataReader,OleDBDataReader,Pen,Regex,Socket,StreamWriter,Timer,Tooltip ,文件句柄,GDI资源,数据库连接等等资源。可能在使用的时候很多都没有注意到！\n\n \n\n### .NET的GC机制有这样两个问题：\n首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。\n第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。\n\n\n### 使用SuppressFinalize函数\n\n在使用~析构函数的同时又使用了IDisposable接口的时候，Dispose函数在执行完后应该调用 GC.SuppressFinalize以阻止 GC调用Finalize方法，因为Finalize方法的调用会牺牲部分性能。\n\n### 强制GC回收\n\nGC.Collect(Int32, GCCollectionMode) \t\n强制对零代到指定代进行即时垃圾回收。强制回收的模式\n\n\n\nGC注意事项：\n\n1、只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理\n\n2、循环引用，网状结构等的实现会变得简单。GC的标志也压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。\n\n3、GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。\n\n4、GC在一个独立的线程中运行来删除不再被引用的内存\n\n5、GC每次运行时会压缩托管堆\n\n6、你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。\n\n7、对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数\n\n8、Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer.而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。\n\n9、.NET GC使用\"代\"(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。==成员变量和全局变量很快变成第1代对象并最终成为第2代对象。 #F44336==\n\n10、GC对不同代的对象执行不同的检查策略以优化性能。==每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象 #F44336==。重新思考Finalization的代价：需要Finalization的对象可能比不需要Finalization在内存中停留额外9个GC周期。如果此时它还没有被Finalize,就变成第2代对象，从而在内存中停留更长时间。","slug":"CSHARP的GC","published":1,"date":"2020-12-23T06:46:38.549Z","updated":"2020-12-23T06:46:38.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckj120udr0001jjf0mc5e86d7","content":"<h2 id=\"一、GC概述\"><a href=\"#一、GC概述\" class=\"headerlink\" title=\"一、GC概述\"></a>一、GC概述</h2><p>早在1958年，由鼎鼎大名的图林奖得主John McCarthy所实现的Lisp语言就已经提供了GC的功能，这是GC的第一次出现。Lisp的程序员认为内存管理太重要了，所以不能由程序员自己来管理。但后来的日子里Lisp却没有成气候，采用内存手动管理的语言占据了上风，以C为代表。出于同样的理由，不同的人却又不同的看法，C程序员认为内存管理太重要了，所以不能由系统来管理，并且讥笑Lisp程序慢如乌龟的运行速度。的确，在那个对每一个Byte都要精心计算的年代GC的速度和对系统资源的大量占用使很多人的无法接受。而后，1984年由Dave Ungar开发的Small talk语言第一次采用了Generational garbage collection的技术（这个技术在下文中会谈到），但是Small talk也没有得到十分广泛的应用。</p>\n<p>直到20世纪90年代中期GC才以主角的身份登上了历史的舞台，这不得不归功于Java的进步，今日的GC已非吴下阿蒙。Java采用VM（Virtual Machine）机制，由VM来管理程序的运行当然也包括对GC管理。90年代末期.net出现了，.net采用了和Java类似的方法由CLR(Common Language Runtime)来管理。这两大阵营的出现将人们引入了以虚拟平台为基础的开发时代，GC也在这个时候越来越得到大众的关注。</p>\n<p>为什么要使用GC呢？也可以说是为什么要使用内存自动管理？有下面的几个原因：<br>1、提高了软件开发的抽象度；<br>2、程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题；<br>3、可以使模块的接口更加的清晰，减小模块间的偶合；<br>4、大大减少了内存人为管理不当所带来的Bug；<br>5、使内存管理更加高效。<br>总的说来就是GC可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。</p>\n<p>比较常见的算法有Reference Counting，Mark Sweep，Copy Collection等等。目前主流的虚拟系统.net CLR，Java VM和Rotor都是采用的Mark Sweep算法。</p>\n<h2 id=\"二、更好的方式回收非托管内存\"><a href=\"#二、更好的方式回收非托管内存\" class=\"headerlink\" title=\"二、更好的方式回收非托管内存\"></a>二、更好的方式回收非托管内存</h2><h3 id=\"1-析构函数\"><a href=\"#1-析构函数\" class=\"headerlink\" title=\"1. 析构函数\"></a>1. 析构函数</h3><p>析构函数的类型需要两次GC才能被完全回收。这些类型会被放到一个专门的队列里，第一次GC执行析构函数回收非托管内存，第二次ＧＣ再回收他们自身。<br>采用析构函数来回收可以称为被动回收，因为你不知道它什么时候被回收。但由于它需要两次GC才能被完全回收，因此就会有一些性能影响。</p>\n<h3 id=\"2-IDisposable接口-using\"><a href=\"#2-IDisposable接口-using\" class=\"headerlink\" title=\"2.IDisposable接口 + using\"></a>2.IDisposable接口 + using</h3><p>所以最好使用主动回收的方式，类型实现IDisposable接口后，非托管内存回收的逻辑就放在Dispose函数里。<br>using（Type A=new Type()）{A的具体使用逻辑}<br>A只能再using块里使用，使用完之后就立马调用A的Dispose函数，然后回收A。</p>\n<h2 id=\"三、Mark-Compact-标记压缩算法\"><a href=\"#三、Mark-Compact-标记压缩算法\" class=\"headerlink\" title=\"三、Mark-Compact 标记压缩算法\"></a>三、Mark-Compact 标记压缩算法</h2><p>简单把.NET的GC算法看作Mark-Compact算法<br>    阶段1: Mark-Sweep 标记清除阶段<br>    先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的<br>    阶段2: Compact 压缩阶段<br>    对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理</p>\n<ul>\n<li>!! 主要处理步骤：将线程挂起=&gt;确定roots=&gt;创建reachable objectsgraph=&gt;对象回收=&gt;heap压缩=&gt;指针修复</li>\n</ul>\n<ul>\n<li>roots: heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的graph，roots是CLR在heap之外可以找到的各种入口点。GC搜索roots的地方包括全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针（还有finalizationqueue）等。主要可以归为2种类型：已经初始化了的静态变量、线程仍在使用的对象（stack+CPU register）</li>\n<li>Reachable objects: 指根据对象引用关系，从roots出发可以到达的对象。例如当前执行函数的局部变量对象A是一个rootobject，他的成员变量引用了对象B，则B是一个reachable object。从roots出发可以创建reachable objectsgraph，剩余对象即为unreachable，可以被回收</li>\n<li>指针修复：因为compact过程移动了heap对象，对象地址发生变化，需要修复所有引用指针，包括stack、CPUregister中的指针以及heap中其他对象的引用指针</li>\n</ul>\n<blockquote>\n<p>Debug和release执行模式之间稍有区别，release模式下后续代码没有引用的对象是unreachable的，而debug模式下需要等到当前函数执行完毕，这些对象才会成为unreachable，目的是为了调试时跟踪局部对象的内容</p>\n</blockquote>\n<blockquote>\n<p>Pinnedobjects指分配之后不能移动位置的对象，例如传递给非托管代码的对象（或者使用了fixed关键字），GC在指针修复时无法修改非托管代码中的引用指针，因此将这些对象移动将发生异常。pinnedobjects会导致heap出现碎片，但大部分情况来说传给非托管代码的对象应当在GC时能够被回收掉</p>\n</blockquote>\n<h2 id=\"四、Generational-分代算法\"><a href=\"#四、Generational-分代算法\" class=\"headerlink\" title=\"四、Generational 分代算法\"></a>四、Generational 分代算法</h2><p>将对象按照生命周期分成新的、老的，根据统计分布规律所反映的结果，可以对新、老区域采用不同的回收策略和算法，加强对新区域的回收处理力度，争取在较短时间间隔、较小的内存区域内，以较低成本将执行路径上大量新近抛弃不再使用的局部对象及时回收掉</p>\n<ul>\n<li>分代算法的假设前提条件：<br>1、大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长<br>2、对部分内存进行回收比基于全部内存的回收操作要快<br>3、新创建的对象之间关联程度通常较强。heap分配的对象是连续的，关联度较强有利于提高CPU cache的命中率</li>\n</ul>\n<p>Heap分为3个代龄区域，相应的GC有3种方式: # Gen 0 collections, # Gen 1 collections, #Gen 2 collections。如果<strong>Gen 0 heap内存达到阀值</strong>，则触发0代GC，0代GC后Gen 0中幸存的对象进入Gen1。如果<strong>Gen 1的内存达到阀值</strong>，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。==2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收 #F44336==<br>   Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为fullGC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时fullGC可能需要花费几秒时间。大致上来讲.NET应用运行期间2代、1代和0代GC的频率应当大致为1:10:100。</p>\n<h2 id=\"五、Finalization-Queue和Freachable-Queue\"><a href=\"#五、Finalization-Queue和Freachable-Queue\" class=\"headerlink\" title=\"五、Finalization Queue和Freachable Queue\"></a>五、Finalization Queue和Freachable Queue</h2><p>这两个队列和.net对象所提供的Finalize方法有关。这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了new操作符在Managed Heap上分配空间时，GC会对其进行分析，如果该对象含有Finalize方法则在Finalization Queue中添加一个指向该对象的指针。在GC被启动以后，经过Mark阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被Finalization Queue中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到Freachable Queue中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？==因为这个对象的Finalize方法还没有被执行，所以不能让它死去 #F44336==。</p>\n<p>Freachable Queue平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的Finalize方法执行，之后将这个指针从队列中剔除，这是对象就可以安静的死去了。</p>\n<p>.net framework的System.GC类提供了控制Finalize的两个方法，ReRegisterForFinalize和SuppressFinalize。前者是请求系统完成对象的Finalize方法，后者是请求系统不要完成对象的Finalize方法。</p>\n<ul>\n<li>ReRegisterForFinalize方法其实就是将指向对象的指针重新添加到Finalization Queue中。这就出现了一个很有趣的现象，因为在Finalization Queue中的对象可以复生，如果在对象的Finalize方法中调用ReRegisterForFinalize方法，这样就形成了一个在堆上永远不会死去的对象，像凤凰涅槃一样每次死的时候都可以复生。</li>\n</ul>\n<p><img src=\"/img/1608690535258.png\" alt=\"流程\"></p>\n<blockquote>\n<p>非托管资源：<br>ApplicationContext,Brush,Component,ComponentDesigner,Container,Context,Cursor,FileStream,Font,Icon,Image,Matrix,Object,OdbcDataReader,OleDBDataReader,Pen,Regex,Socket,StreamWriter,Timer,Tooltip ,文件句柄,GDI资源,数据库连接等等资源。可能在使用的时候很多都没有注意到！</p>\n</blockquote>\n<h3 id=\"NET的GC机制有这样两个问题：\"><a href=\"#NET的GC机制有这样两个问题：\" class=\"headerlink\" title=\".NET的GC机制有这样两个问题：\"></a>.NET的GC机制有这样两个问题：</h3><p>首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。<br>第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。</p>\n<h3 id=\"使用SuppressFinalize函数\"><a href=\"#使用SuppressFinalize函数\" class=\"headerlink\" title=\"使用SuppressFinalize函数\"></a>使用SuppressFinalize函数</h3><p>在使用~析构函数的同时又使用了IDisposable接口的时候，Dispose函数在执行完后应该调用 GC.SuppressFinalize以阻止 GC调用Finalize方法，因为Finalize方法的调用会牺牲部分性能。</p>\n<h3 id=\"强制GC回收\"><a href=\"#强制GC回收\" class=\"headerlink\" title=\"强制GC回收\"></a>强制GC回收</h3><p>GC.Collect(Int32, GCCollectionMode)<br>强制对零代到指定代进行即时垃圾回收。强制回收的模式</p>\n<p>GC注意事项：</p>\n<p>1、只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理</p>\n<p>2、循环引用，网状结构等的实现会变得简单。GC的标志也压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。</p>\n<p>3、GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。</p>\n<p>4、GC在一个独立的线程中运行来删除不再被引用的内存</p>\n<p>5、GC每次运行时会压缩托管堆</p>\n<p>6、你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。</p>\n<p>7、对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数</p>\n<p>8、Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer.而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。</p>\n<p>9、.NET GC使用”代”(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。==成员变量和全局变量很快变成第1代对象并最终成为第2代对象。 #F44336==</p>\n<p>10、GC对不同代的对象执行不同的检查策略以优化性能。==每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象 #F44336==。重新思考Finalization的代价：需要Finalization的对象可能比不需要Finalization在内存中停留额外9个GC周期。如果此时它还没有被Finalize,就变成第2代对象，从而在内存中停留更长时间。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、GC概述\"><a href=\"#一、GC概述\" class=\"headerlink\" title=\"一、GC概述\"></a>一、GC概述</h2><p>早在1958年，由鼎鼎大名的图林奖得主John McCarthy所实现的Lisp语言就已经提供了GC的功能，这是GC的第一次出现。Lisp的程序员认为内存管理太重要了，所以不能由程序员自己来管理。但后来的日子里Lisp却没有成气候，采用内存手动管理的语言占据了上风，以C为代表。出于同样的理由，不同的人却又不同的看法，C程序员认为内存管理太重要了，所以不能由系统来管理，并且讥笑Lisp程序慢如乌龟的运行速度。的确，在那个对每一个Byte都要精心计算的年代GC的速度和对系统资源的大量占用使很多人的无法接受。而后，1984年由Dave Ungar开发的Small talk语言第一次采用了Generational garbage collection的技术（这个技术在下文中会谈到），但是Small talk也没有得到十分广泛的应用。</p>\n<p>直到20世纪90年代中期GC才以主角的身份登上了历史的舞台，这不得不归功于Java的进步，今日的GC已非吴下阿蒙。Java采用VM（Virtual Machine）机制，由VM来管理程序的运行当然也包括对GC管理。90年代末期.net出现了，.net采用了和Java类似的方法由CLR(Common Language Runtime)来管理。这两大阵营的出现将人们引入了以虚拟平台为基础的开发时代，GC也在这个时候越来越得到大众的关注。</p>\n<p>为什么要使用GC呢？也可以说是为什么要使用内存自动管理？有下面的几个原因：<br>1、提高了软件开发的抽象度；<br>2、程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题；<br>3、可以使模块的接口更加的清晰，减小模块间的偶合；<br>4、大大减少了内存人为管理不当所带来的Bug；<br>5、使内存管理更加高效。<br>总的说来就是GC可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。</p>\n<p>比较常见的算法有Reference Counting，Mark Sweep，Copy Collection等等。目前主流的虚拟系统.net CLR，Java VM和Rotor都是采用的Mark Sweep算法。</p>\n<h2 id=\"二、更好的方式回收非托管内存\"><a href=\"#二、更好的方式回收非托管内存\" class=\"headerlink\" title=\"二、更好的方式回收非托管内存\"></a>二、更好的方式回收非托管内存</h2><h3 id=\"1-析构函数\"><a href=\"#1-析构函数\" class=\"headerlink\" title=\"1. 析构函数\"></a>1. 析构函数</h3><p>析构函数的类型需要两次GC才能被完全回收。这些类型会被放到一个专门的队列里，第一次GC执行析构函数回收非托管内存，第二次ＧＣ再回收他们自身。<br>采用析构函数来回收可以称为被动回收，因为你不知道它什么时候被回收。但由于它需要两次GC才能被完全回收，因此就会有一些性能影响。</p>\n<h3 id=\"2-IDisposable接口-using\"><a href=\"#2-IDisposable接口-using\" class=\"headerlink\" title=\"2.IDisposable接口 + using\"></a>2.IDisposable接口 + using</h3><p>所以最好使用主动回收的方式，类型实现IDisposable接口后，非托管内存回收的逻辑就放在Dispose函数里。<br>using（Type A=new Type()）{A的具体使用逻辑}<br>A只能再using块里使用，使用完之后就立马调用A的Dispose函数，然后回收A。</p>\n<h2 id=\"三、Mark-Compact-标记压缩算法\"><a href=\"#三、Mark-Compact-标记压缩算法\" class=\"headerlink\" title=\"三、Mark-Compact 标记压缩算法\"></a>三、Mark-Compact 标记压缩算法</h2><p>简单把.NET的GC算法看作Mark-Compact算法<br>    阶段1: Mark-Sweep 标记清除阶段<br>    先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的<br>    阶段2: Compact 压缩阶段<br>    对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理</p>\n<ul>\n<li>!! 主要处理步骤：将线程挂起=&gt;确定roots=&gt;创建reachable objectsgraph=&gt;对象回收=&gt;heap压缩=&gt;指针修复</li>\n</ul>\n<ul>\n<li>roots: heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的graph，roots是CLR在heap之外可以找到的各种入口点。GC搜索roots的地方包括全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针（还有finalizationqueue）等。主要可以归为2种类型：已经初始化了的静态变量、线程仍在使用的对象（stack+CPU register）</li>\n<li>Reachable objects: 指根据对象引用关系，从roots出发可以到达的对象。例如当前执行函数的局部变量对象A是一个rootobject，他的成员变量引用了对象B，则B是一个reachable object。从roots出发可以创建reachable objectsgraph，剩余对象即为unreachable，可以被回收</li>\n<li>指针修复：因为compact过程移动了heap对象，对象地址发生变化，需要修复所有引用指针，包括stack、CPUregister中的指针以及heap中其他对象的引用指针</li>\n</ul>\n<blockquote>\n<p>Debug和release执行模式之间稍有区别，release模式下后续代码没有引用的对象是unreachable的，而debug模式下需要等到当前函数执行完毕，这些对象才会成为unreachable，目的是为了调试时跟踪局部对象的内容</p>\n</blockquote>\n<blockquote>\n<p>Pinnedobjects指分配之后不能移动位置的对象，例如传递给非托管代码的对象（或者使用了fixed关键字），GC在指针修复时无法修改非托管代码中的引用指针，因此将这些对象移动将发生异常。pinnedobjects会导致heap出现碎片，但大部分情况来说传给非托管代码的对象应当在GC时能够被回收掉</p>\n</blockquote>\n<h2 id=\"四、Generational-分代算法\"><a href=\"#四、Generational-分代算法\" class=\"headerlink\" title=\"四、Generational 分代算法\"></a>四、Generational 分代算法</h2><p>将对象按照生命周期分成新的、老的，根据统计分布规律所反映的结果，可以对新、老区域采用不同的回收策略和算法，加强对新区域的回收处理力度，争取在较短时间间隔、较小的内存区域内，以较低成本将执行路径上大量新近抛弃不再使用的局部对象及时回收掉</p>\n<ul>\n<li>分代算法的假设前提条件：<br>1、大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长<br>2、对部分内存进行回收比基于全部内存的回收操作要快<br>3、新创建的对象之间关联程度通常较强。heap分配的对象是连续的，关联度较强有利于提高CPU cache的命中率</li>\n</ul>\n<p>Heap分为3个代龄区域，相应的GC有3种方式: # Gen 0 collections, # Gen 1 collections, #Gen 2 collections。如果<strong>Gen 0 heap内存达到阀值</strong>，则触发0代GC，0代GC后Gen 0中幸存的对象进入Gen1。如果<strong>Gen 1的内存达到阀值</strong>，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。==2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收 #F44336==<br>   Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为fullGC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时fullGC可能需要花费几秒时间。大致上来讲.NET应用运行期间2代、1代和0代GC的频率应当大致为1:10:100。</p>\n<h2 id=\"五、Finalization-Queue和Freachable-Queue\"><a href=\"#五、Finalization-Queue和Freachable-Queue\" class=\"headerlink\" title=\"五、Finalization Queue和Freachable Queue\"></a>五、Finalization Queue和Freachable Queue</h2><p>这两个队列和.net对象所提供的Finalize方法有关。这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了new操作符在Managed Heap上分配空间时，GC会对其进行分析，如果该对象含有Finalize方法则在Finalization Queue中添加一个指向该对象的指针。在GC被启动以后，经过Mark阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被Finalization Queue中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到Freachable Queue中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？==因为这个对象的Finalize方法还没有被执行，所以不能让它死去 #F44336==。</p>\n<p>Freachable Queue平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的Finalize方法执行，之后将这个指针从队列中剔除，这是对象就可以安静的死去了。</p>\n<p>.net framework的System.GC类提供了控制Finalize的两个方法，ReRegisterForFinalize和SuppressFinalize。前者是请求系统完成对象的Finalize方法，后者是请求系统不要完成对象的Finalize方法。</p>\n<ul>\n<li>ReRegisterForFinalize方法其实就是将指向对象的指针重新添加到Finalization Queue中。这就出现了一个很有趣的现象，因为在Finalization Queue中的对象可以复生，如果在对象的Finalize方法中调用ReRegisterForFinalize方法，这样就形成了一个在堆上永远不会死去的对象，像凤凰涅槃一样每次死的时候都可以复生。</li>\n</ul>\n<p><img src=\"/img/1608690535258.png\" alt=\"流程\"></p>\n<blockquote>\n<p>非托管资源：<br>ApplicationContext,Brush,Component,ComponentDesigner,Container,Context,Cursor,FileStream,Font,Icon,Image,Matrix,Object,OdbcDataReader,OleDBDataReader,Pen,Regex,Socket,StreamWriter,Timer,Tooltip ,文件句柄,GDI资源,数据库连接等等资源。可能在使用的时候很多都没有注意到！</p>\n</blockquote>\n<h3 id=\"NET的GC机制有这样两个问题：\"><a href=\"#NET的GC机制有这样两个问题：\" class=\"headerlink\" title=\".NET的GC机制有这样两个问题：\"></a>.NET的GC机制有这样两个问题：</h3><p>首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。<br>第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。</p>\n<h3 id=\"使用SuppressFinalize函数\"><a href=\"#使用SuppressFinalize函数\" class=\"headerlink\" title=\"使用SuppressFinalize函数\"></a>使用SuppressFinalize函数</h3><p>在使用~析构函数的同时又使用了IDisposable接口的时候，Dispose函数在执行完后应该调用 GC.SuppressFinalize以阻止 GC调用Finalize方法，因为Finalize方法的调用会牺牲部分性能。</p>\n<h3 id=\"强制GC回收\"><a href=\"#强制GC回收\" class=\"headerlink\" title=\"强制GC回收\"></a>强制GC回收</h3><p>GC.Collect(Int32, GCCollectionMode)<br>强制对零代到指定代进行即时垃圾回收。强制回收的模式</p>\n<p>GC注意事项：</p>\n<p>1、只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理</p>\n<p>2、循环引用，网状结构等的实现会变得简单。GC的标志也压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。</p>\n<p>3、GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。</p>\n<p>4、GC在一个独立的线程中运行来删除不再被引用的内存</p>\n<p>5、GC每次运行时会压缩托管堆</p>\n<p>6、你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。</p>\n<p>7、对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数</p>\n<p>8、Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer.而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。</p>\n<p>9、.NET GC使用”代”(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。==成员变量和全局变量很快变成第1代对象并最终成为第2代对象。 #F44336==</p>\n<p>10、GC对不同代的对象执行不同的检查策略以优化性能。==每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象 #F44336==。重新思考Finalization的代价：需要Finalization的对象可能比不需要Finalization在内存中停留额外9个GC周期。如果此时它还没有被Finalize,就变成第2代对象，从而在内存中停留更长时间。</p>\n"},{"title":"CSHARP的编译器","_content":"\n## C#、.NET Framework、CLR的关系\n\n1. .NET框架是一个独立发布的软件包，其包含了CLR、类库以及相关的语言编辑器等工具。C#代码经过编译之后在CLR环境中运行。\n2. C#是一种面向对象编程语言，是为开发.NET框架上的程序而设计的。\n（1）C#是由C和C++衍生出来的，所以其可调用由 C/C++ 编写的本机原生函数，同时不损失C/C++原有的强大的功能。\n（2）C#所开发的程序源代码并不是编译成能够直接在操作系统上执行的二进制本地代码。它是被编译成为中间代码，然后通过.NET框架的虚拟机（即CLR）来执行。所以如果计算机上没有安装.Net框架，那么程序将不能够被执行。在执行的过程中，.Net框架会将中间代码翻译成为二进制机器码，从而使它得到正确的运行。最终翻译的二进制代码将被存储在一个缓冲区中。所以一旦程序使用了相同的代码，那么将会调用缓冲区中的版本。这样如果一个.Net程序第二次被运行，那么这种翻译不需要进行第二次，速度会明显加快。\n\n3. .NET框架有三部分组成\n（1）CLR\n\n（2）编程工具：涵盖了编码和调试需要的一切:包含：VisualStudio集成开发环境、.NET兼容的编译器（例如：C#、VB、JScript和托管的C++）、调试器、服务器端改进（比如ASP.NET）\n\n（3）BCL（Base Class Library，基类库）：是.NET框架使用的一个大的类库，而且也可以在你的程序中使用。包括以下一些类。\n    a.通用基础类：这些类提供了一组极为强大的工具，可以应用带广泛的编程任务中，比如字符串操作、安全和加密。\n    b.集合类：这些类实现了列表、字典、散列表以及位数组。\n    c.线程和同步类：这些类用于创建多线程程序。\n    d.XML类，这些类用于创建、读取以及操作XML文档。\n\t\n4. CLR: \n GC： 自动垃圾回收机制：\n \t\ta.GC自动从内存中删除程序不再访问的对象\n \t\tb.GC是程序员不再操心许多以前必须执行的任务，比如释放内存和检查内存泄漏。这可不是小特性，因为检查内存泄漏可能非常困难而且耗时。\n \n \n ![CLR示意图](/img/1605751344921.png)\n \n 5. 编译流程\n\n（1）编译成CIL：.NET语言的编译器接受源代码文件，并生成名为程序集的输出文件。程序集可以是可执行文件或DLL（如下图所示）\n \t\ta.程序集里的代码并不是本机代码，而是一种名称为CIL（Common Intermediate Language，公共中间语言）的中间代码。\n\t\tb.程序集包含的信息中，包含下列项目：程序的CIL、程序中使用的类型的元数据、对其他程序集引用的元数据\n\n![编译流程](/img/1605751484739.png)\n\n（2）编译成本机代码并执行：程序的CIL直到它被调用运行时才会被编译成本机代码。在运行时，CLR执行下面的步骤（如下图）\n        a.检查程序集的安全特性\n        b.在内存中分配空间\n        c.把程序集中的可执行代码发送给实时（Just-in-Time）编译器，把其中的一部分编译成本机代码。  \n> 程序集中的可执行代码在需要的时候由实时编译器编译，然后它就被缓存以备在后来的程序中执行，使用这个方法意味着不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次。\n        一旦CIL被编译成本机代码，CLR就在它运行时管理它，执行像释放无主内存、检查数组边界、检查参数类型和管理异常之类的任务。这里产生了两个重要的术语：\n       托管代码：为.NET框架编写的代码称为托管代码，需要CLR。\n       非托管代码：不在CLR控制之下运行的代码，比如Win32C/C++ DLL，成为非托管代码。\n\n![CLR编译流程](/img/1605751556990.png)\n\n（3）编译和执行综述：无论原始源文件的语言是什么，懂遵循同样的编译和执行过程。\n![整个编译流程](/img/1605751595361.png)\n","source":"_posts/CSHARP的编译器.md","raw":"---\ntitle: CSHARP的编译器\ncategories:\n- Unity\n---\n\n## C#、.NET Framework、CLR的关系\n\n1. .NET框架是一个独立发布的软件包，其包含了CLR、类库以及相关的语言编辑器等工具。C#代码经过编译之后在CLR环境中运行。\n2. C#是一种面向对象编程语言，是为开发.NET框架上的程序而设计的。\n（1）C#是由C和C++衍生出来的，所以其可调用由 C/C++ 编写的本机原生函数，同时不损失C/C++原有的强大的功能。\n（2）C#所开发的程序源代码并不是编译成能够直接在操作系统上执行的二进制本地代码。它是被编译成为中间代码，然后通过.NET框架的虚拟机（即CLR）来执行。所以如果计算机上没有安装.Net框架，那么程序将不能够被执行。在执行的过程中，.Net框架会将中间代码翻译成为二进制机器码，从而使它得到正确的运行。最终翻译的二进制代码将被存储在一个缓冲区中。所以一旦程序使用了相同的代码，那么将会调用缓冲区中的版本。这样如果一个.Net程序第二次被运行，那么这种翻译不需要进行第二次，速度会明显加快。\n\n3. .NET框架有三部分组成\n（1）CLR\n\n（2）编程工具：涵盖了编码和调试需要的一切:包含：VisualStudio集成开发环境、.NET兼容的编译器（例如：C#、VB、JScript和托管的C++）、调试器、服务器端改进（比如ASP.NET）\n\n（3）BCL（Base Class Library，基类库）：是.NET框架使用的一个大的类库，而且也可以在你的程序中使用。包括以下一些类。\n    a.通用基础类：这些类提供了一组极为强大的工具，可以应用带广泛的编程任务中，比如字符串操作、安全和加密。\n    b.集合类：这些类实现了列表、字典、散列表以及位数组。\n    c.线程和同步类：这些类用于创建多线程程序。\n    d.XML类，这些类用于创建、读取以及操作XML文档。\n\t\n4. CLR: \n GC： 自动垃圾回收机制：\n \t\ta.GC自动从内存中删除程序不再访问的对象\n \t\tb.GC是程序员不再操心许多以前必须执行的任务，比如释放内存和检查内存泄漏。这可不是小特性，因为检查内存泄漏可能非常困难而且耗时。\n \n \n ![CLR示意图](/img/1605751344921.png)\n \n 5. 编译流程\n\n（1）编译成CIL：.NET语言的编译器接受源代码文件，并生成名为程序集的输出文件。程序集可以是可执行文件或DLL（如下图所示）\n \t\ta.程序集里的代码并不是本机代码，而是一种名称为CIL（Common Intermediate Language，公共中间语言）的中间代码。\n\t\tb.程序集包含的信息中，包含下列项目：程序的CIL、程序中使用的类型的元数据、对其他程序集引用的元数据\n\n![编译流程](/img/1605751484739.png)\n\n（2）编译成本机代码并执行：程序的CIL直到它被调用运行时才会被编译成本机代码。在运行时，CLR执行下面的步骤（如下图）\n        a.检查程序集的安全特性\n        b.在内存中分配空间\n        c.把程序集中的可执行代码发送给实时（Just-in-Time）编译器，把其中的一部分编译成本机代码。  \n> 程序集中的可执行代码在需要的时候由实时编译器编译，然后它就被缓存以备在后来的程序中执行，使用这个方法意味着不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次。\n        一旦CIL被编译成本机代码，CLR就在它运行时管理它，执行像释放无主内存、检查数组边界、检查参数类型和管理异常之类的任务。这里产生了两个重要的术语：\n       托管代码：为.NET框架编写的代码称为托管代码，需要CLR。\n       非托管代码：不在CLR控制之下运行的代码，比如Win32C/C++ DLL，成为非托管代码。\n\n![CLR编译流程](/img/1605751556990.png)\n\n（3）编译和执行综述：无论原始源文件的语言是什么，懂遵循同样的编译和执行过程。\n![整个编译流程](/img/1605751595361.png)\n","slug":"CSHARP的编译器","published":1,"date":"2020-12-23T06:46:38.549Z","updated":"2020-12-23T06:46:38.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckj120udx0002jjf0nhlsce3b","content":"<h2 id=\"C-、-NET-Framework、CLR的关系\"><a href=\"#C-、-NET-Framework、CLR的关系\" class=\"headerlink\" title=\"C#、.NET Framework、CLR的关系\"></a>C#、.NET Framework、CLR的关系</h2><ol>\n<li><p>.NET框架是一个独立发布的软件包，其包含了CLR、类库以及相关的语言编辑器等工具。C#代码经过编译之后在CLR环境中运行。</p>\n</li>\n<li><p>C#是一种面向对象编程语言，是为开发.NET框架上的程序而设计的。<br>（1）C#是由C和C++衍生出来的，所以其可调用由 C/C++ 编写的本机原生函数，同时不损失C/C++原有的强大的功能。<br>（2）C#所开发的程序源代码并不是编译成能够直接在操作系统上执行的二进制本地代码。它是被编译成为中间代码，然后通过.NET框架的虚拟机（即CLR）来执行。所以如果计算机上没有安装.Net框架，那么程序将不能够被执行。在执行的过程中，.Net框架会将中间代码翻译成为二进制机器码，从而使它得到正确的运行。最终翻译的二进制代码将被存储在一个缓冲区中。所以一旦程序使用了相同的代码，那么将会调用缓冲区中的版本。这样如果一个.Net程序第二次被运行，那么这种翻译不需要进行第二次，速度会明显加快。</p>\n</li>\n<li><p>.NET框架有三部分组成<br>（1）CLR</p>\n</li>\n</ol>\n<p>（2）编程工具：涵盖了编码和调试需要的一切:包含：VisualStudio集成开发环境、.NET兼容的编译器（例如：C#、VB、JScript和托管的C++）、调试器、服务器端改进（比如ASP.NET）</p>\n<p>（3）BCL（Base Class Library，基类库）：是.NET框架使用的一个大的类库，而且也可以在你的程序中使用。包括以下一些类。<br>    a.通用基础类：这些类提供了一组极为强大的工具，可以应用带广泛的编程任务中，比如字符串操作、安全和加密。<br>    b.集合类：这些类实现了列表、字典、散列表以及位数组。<br>    c.线程和同步类：这些类用于创建多线程程序。<br>    d.XML类，这些类用于创建、读取以及操作XML文档。</p>\n<ol start=\"4\">\n<li>CLR:<br>GC： 自动垃圾回收机制：<pre><code>  a.GC自动从内存中删除程序不再访问的对象\n  b.GC是程序员不再操心许多以前必须执行的任务，比如释放内存和检查内存泄漏。这可不是小特性，因为检查内存泄漏可能非常困难而且耗时。</code></pre></li>\n</ol>\n<p> <img src=\"/img/1605751344921.png\" alt=\"CLR示意图\"></p>\n<ol start=\"5\">\n<li>编译流程</li>\n</ol>\n<p>（1）编译成CIL：.NET语言的编译器接受源代码文件，并生成名为程序集的输出文件。程序集可以是可执行文件或DLL（如下图所示）<br>         a.程序集里的代码并不是本机代码，而是一种名称为CIL（Common Intermediate Language，公共中间语言）的中间代码。<br>        b.程序集包含的信息中，包含下列项目：程序的CIL、程序中使用的类型的元数据、对其他程序集引用的元数据</p>\n<p><img src=\"/img/1605751484739.png\" alt=\"编译流程\"></p>\n<p>（2）编译成本机代码并执行：程序的CIL直到它被调用运行时才会被编译成本机代码。在运行时，CLR执行下面的步骤（如下图）<br>        a.检查程序集的安全特性<br>        b.在内存中分配空间<br>        c.把程序集中的可执行代码发送给实时（Just-in-Time）编译器，把其中的一部分编译成本机代码。  </p>\n<blockquote>\n<p>程序集中的可执行代码在需要的时候由实时编译器编译，然后它就被缓存以备在后来的程序中执行，使用这个方法意味着不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次。<br>        一旦CIL被编译成本机代码，CLR就在它运行时管理它，执行像释放无主内存、检查数组边界、检查参数类型和管理异常之类的任务。这里产生了两个重要的术语：<br>       托管代码：为.NET框架编写的代码称为托管代码，需要CLR。<br>       非托管代码：不在CLR控制之下运行的代码，比如Win32C/C++ DLL，成为非托管代码。</p>\n</blockquote>\n<p><img src=\"/img/1605751556990.png\" alt=\"CLR编译流程\"></p>\n<p>（3）编译和执行综述：无论原始源文件的语言是什么，懂遵循同样的编译和执行过程。<br><img src=\"/img/1605751595361.png\" alt=\"整个编译流程\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-、-NET-Framework、CLR的关系\"><a href=\"#C-、-NET-Framework、CLR的关系\" class=\"headerlink\" title=\"C#、.NET Framework、CLR的关系\"></a>C#、.NET Framework、CLR的关系</h2><ol>\n<li><p>.NET框架是一个独立发布的软件包，其包含了CLR、类库以及相关的语言编辑器等工具。C#代码经过编译之后在CLR环境中运行。</p>\n</li>\n<li><p>C#是一种面向对象编程语言，是为开发.NET框架上的程序而设计的。<br>（1）C#是由C和C++衍生出来的，所以其可调用由 C/C++ 编写的本机原生函数，同时不损失C/C++原有的强大的功能。<br>（2）C#所开发的程序源代码并不是编译成能够直接在操作系统上执行的二进制本地代码。它是被编译成为中间代码，然后通过.NET框架的虚拟机（即CLR）来执行。所以如果计算机上没有安装.Net框架，那么程序将不能够被执行。在执行的过程中，.Net框架会将中间代码翻译成为二进制机器码，从而使它得到正确的运行。最终翻译的二进制代码将被存储在一个缓冲区中。所以一旦程序使用了相同的代码，那么将会调用缓冲区中的版本。这样如果一个.Net程序第二次被运行，那么这种翻译不需要进行第二次，速度会明显加快。</p>\n</li>\n<li><p>.NET框架有三部分组成<br>（1）CLR</p>\n</li>\n</ol>\n<p>（2）编程工具：涵盖了编码和调试需要的一切:包含：VisualStudio集成开发环境、.NET兼容的编译器（例如：C#、VB、JScript和托管的C++）、调试器、服务器端改进（比如ASP.NET）</p>\n<p>（3）BCL（Base Class Library，基类库）：是.NET框架使用的一个大的类库，而且也可以在你的程序中使用。包括以下一些类。<br>    a.通用基础类：这些类提供了一组极为强大的工具，可以应用带广泛的编程任务中，比如字符串操作、安全和加密。<br>    b.集合类：这些类实现了列表、字典、散列表以及位数组。<br>    c.线程和同步类：这些类用于创建多线程程序。<br>    d.XML类，这些类用于创建、读取以及操作XML文档。</p>\n<ol start=\"4\">\n<li>CLR:<br>GC： 自动垃圾回收机制：<pre><code>  a.GC自动从内存中删除程序不再访问的对象\n  b.GC是程序员不再操心许多以前必须执行的任务，比如释放内存和检查内存泄漏。这可不是小特性，因为检查内存泄漏可能非常困难而且耗时。</code></pre></li>\n</ol>\n<p> <img src=\"/img/1605751344921.png\" alt=\"CLR示意图\"></p>\n<ol start=\"5\">\n<li>编译流程</li>\n</ol>\n<p>（1）编译成CIL：.NET语言的编译器接受源代码文件，并生成名为程序集的输出文件。程序集可以是可执行文件或DLL（如下图所示）<br>         a.程序集里的代码并不是本机代码，而是一种名称为CIL（Common Intermediate Language，公共中间语言）的中间代码。<br>        b.程序集包含的信息中，包含下列项目：程序的CIL、程序中使用的类型的元数据、对其他程序集引用的元数据</p>\n<p><img src=\"/img/1605751484739.png\" alt=\"编译流程\"></p>\n<p>（2）编译成本机代码并执行：程序的CIL直到它被调用运行时才会被编译成本机代码。在运行时，CLR执行下面的步骤（如下图）<br>        a.检查程序集的安全特性<br>        b.在内存中分配空间<br>        c.把程序集中的可执行代码发送给实时（Just-in-Time）编译器，把其中的一部分编译成本机代码。  </p>\n<blockquote>\n<p>程序集中的可执行代码在需要的时候由实时编译器编译，然后它就被缓存以备在后来的程序中执行，使用这个方法意味着不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次。<br>        一旦CIL被编译成本机代码，CLR就在它运行时管理它，执行像释放无主内存、检查数组边界、检查参数类型和管理异常之类的任务。这里产生了两个重要的术语：<br>       托管代码：为.NET框架编写的代码称为托管代码，需要CLR。<br>       非托管代码：不在CLR控制之下运行的代码，比如Win32C/C++ DLL，成为非托管代码。</p>\n</blockquote>\n<p><img src=\"/img/1605751556990.png\" alt=\"CLR编译流程\"></p>\n<p>（3）编译和执行综述：无论原始源文件的语言是什么，懂遵循同样的编译和执行过程。<br><img src=\"/img/1605751595361.png\" alt=\"整个编译流程\"></p>\n"},{"title":"CSHARP的内置引用类型","_content":"\n## 对象类型\nobject 类型是 System.Object 在 .NET 中的别名。 ==在 C# 的统一类型系统中，所有类型（预定义类型、用户定义类型、引用类型和值类型）都是直接或间接从 System.Object 继承的。 可以将任何类型的值赋给 object 类型的变量。 #F44336== 可以使用文本 null 将任何 object 变量赋值给其默认值。 将值类型的变量转换为对象的过程称为 装箱 。 将 object 类型的变量转换为值类型的过程称为取消装箱 。\n\n## 字符串类型\n\nstring 类型表示零个或多个 Unicode 字符的序列。 string 是 System.String 在 .NET 中的别名。\nstring 为引用类型.\n\n> The C# String type is internally a 'UTF-16' byte string.\n\n![核心结构](/img/1608707782744.png)\n\n### Intern pool:常量池，==调用String.Intern()将返回常量池里的相同的字符串引用！ #F44336==\n\n``` csharp\nvar x = new string(new[] { 'f', 'o', 'o' });\nvar y = new string(new[] { 'f', 'o', 'o' });\nvar z = \"foo\";\nvar u = \"foo\";\nvar v = String.Intern(x);\n \n// different reference: x != y != z\nConsole.WriteLine(Object.ReferenceEquals(x, y)); // false\nConsole.WriteLine(Object.ReferenceEquals(x, z)); // false\n \n// same reference: z == u == v\nConsole.WriteLine(Object.ReferenceEquals(z, u)); // true\nConsole.WriteLine(Object.ReferenceEquals(z, v)); // true\n \n// same value\nConsole.WriteLine(x == y && x == z && x == u && x == v); // true\n```\n\n### concat与+连接\n\nC # 编译器执行专门的处理，String 的‘ + ’连接转换为 String.Concat。\n\n\n``` csharp\n//“‘ x: ” + x + “ y: ” + y + “ z: ” + z’\nstring.Concat(new string[]{\"x:\", x.ToString(), \"y:\", y.ToString(), \"z:\", z.ToString() } );//与上面等价\n```\n\n> 使用 c # 编译器优化“ + ”级联可能会在当前级联和过去级联之间获得不同的结果。例如，Visual Studio 2019的 c # 编译器的(int x) + (String y) + (int z)结果将是‘ String。Concat (x.ToString () ，y，z.ToString ())’。然而，Visual Studio 2017的 c # 编译器将是‘ String’。Concat ((object) x，y，(object) z)’ ，如果连接非字符串参数，将使用对象重载。因此，会发生结构装箱。如果使用 Unity，你必须注意，结果将根据与 Unity 捆绑的 c # 编译器的版本而有所不同。\n\n### StringBuilder and SpanFormatter\n\n‘ StringBuilder’是一个有‘ char []’作为临时缓冲区的类。Append 用于写入缓冲区，ToString 生成最终的字符串。\n\n``` csharp\n// .NET Standard 2.0\npublic StringBuilder Append(int value)\n{\n    return Append(value.ToString(CultureInfo.CurrentCulture));\n}\n \n// .NET Standard 2.1\npublic StringBuilder Append(int value)\n{\n    return AppendSpanFormattable(value);\n}\n \nprivate StringBuilder AppendSpanFormattable<T>(T value)\n    where T : ISpanFormattable\n{\n    if (value.TryFormat(RemainingCurrentChunk,\n        out int charsWritten, format: default, provider: null))\n    {\n        m_ChunkLength += charsWritten;\n        return this;\n    }\n    return Append(value.ToString());\n}\n```\n\n### String.Format\n\n由于接收参数为object,因此有拆装箱操作\n\n\n如图： “ x: ” + x + “ y: ” + y + “ z: ” + z’的简单字符串连接的性能度量。\n![各string方式性能对比](/img/1608709965913.png)\n\n## 委托类型\n\n``` csharp\npublic delegate void MessageDelegate(string message);\npublic delegate int AnotherDelegate(MyType m, long num);\n```\n\n## 动态类型\n\ndynamic 类型表示变量的使用和对其成员的引用绕过编译时类型检查。 \n\n==编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时评估操作。 在此过程中，dynamic 类型的变量会编译为 object 类型的变量。 因此，dynamic 类型只在编译时存在，在运行时则不存在。 #F44336==","source":"_posts/CSHARP的内置引用类型.md","raw":"---\ntitle: CSHARP的内置引用类型\ncategories:\n- Unity\n---\n\n## 对象类型\nobject 类型是 System.Object 在 .NET 中的别名。 ==在 C# 的统一类型系统中，所有类型（预定义类型、用户定义类型、引用类型和值类型）都是直接或间接从 System.Object 继承的。 可以将任何类型的值赋给 object 类型的变量。 #F44336== 可以使用文本 null 将任何 object 变量赋值给其默认值。 将值类型的变量转换为对象的过程称为 装箱 。 将 object 类型的变量转换为值类型的过程称为取消装箱 。\n\n## 字符串类型\n\nstring 类型表示零个或多个 Unicode 字符的序列。 string 是 System.String 在 .NET 中的别名。\nstring 为引用类型.\n\n> The C# String type is internally a 'UTF-16' byte string.\n\n![核心结构](/img/1608707782744.png)\n\n### Intern pool:常量池，==调用String.Intern()将返回常量池里的相同的字符串引用！ #F44336==\n\n``` csharp\nvar x = new string(new[] { 'f', 'o', 'o' });\nvar y = new string(new[] { 'f', 'o', 'o' });\nvar z = \"foo\";\nvar u = \"foo\";\nvar v = String.Intern(x);\n \n// different reference: x != y != z\nConsole.WriteLine(Object.ReferenceEquals(x, y)); // false\nConsole.WriteLine(Object.ReferenceEquals(x, z)); // false\n \n// same reference: z == u == v\nConsole.WriteLine(Object.ReferenceEquals(z, u)); // true\nConsole.WriteLine(Object.ReferenceEquals(z, v)); // true\n \n// same value\nConsole.WriteLine(x == y && x == z && x == u && x == v); // true\n```\n\n### concat与+连接\n\nC # 编译器执行专门的处理，String 的‘ + ’连接转换为 String.Concat。\n\n\n``` csharp\n//“‘ x: ” + x + “ y: ” + y + “ z: ” + z’\nstring.Concat(new string[]{\"x:\", x.ToString(), \"y:\", y.ToString(), \"z:\", z.ToString() } );//与上面等价\n```\n\n> 使用 c # 编译器优化“ + ”级联可能会在当前级联和过去级联之间获得不同的结果。例如，Visual Studio 2019的 c # 编译器的(int x) + (String y) + (int z)结果将是‘ String。Concat (x.ToString () ，y，z.ToString ())’。然而，Visual Studio 2017的 c # 编译器将是‘ String’。Concat ((object) x，y，(object) z)’ ，如果连接非字符串参数，将使用对象重载。因此，会发生结构装箱。如果使用 Unity，你必须注意，结果将根据与 Unity 捆绑的 c # 编译器的版本而有所不同。\n\n### StringBuilder and SpanFormatter\n\n‘ StringBuilder’是一个有‘ char []’作为临时缓冲区的类。Append 用于写入缓冲区，ToString 生成最终的字符串。\n\n``` csharp\n// .NET Standard 2.0\npublic StringBuilder Append(int value)\n{\n    return Append(value.ToString(CultureInfo.CurrentCulture));\n}\n \n// .NET Standard 2.1\npublic StringBuilder Append(int value)\n{\n    return AppendSpanFormattable(value);\n}\n \nprivate StringBuilder AppendSpanFormattable<T>(T value)\n    where T : ISpanFormattable\n{\n    if (value.TryFormat(RemainingCurrentChunk,\n        out int charsWritten, format: default, provider: null))\n    {\n        m_ChunkLength += charsWritten;\n        return this;\n    }\n    return Append(value.ToString());\n}\n```\n\n### String.Format\n\n由于接收参数为object,因此有拆装箱操作\n\n\n如图： “ x: ” + x + “ y: ” + y + “ z: ” + z’的简单字符串连接的性能度量。\n![各string方式性能对比](/img/1608709965913.png)\n\n## 委托类型\n\n``` csharp\npublic delegate void MessageDelegate(string message);\npublic delegate int AnotherDelegate(MyType m, long num);\n```\n\n## 动态类型\n\ndynamic 类型表示变量的使用和对其成员的引用绕过编译时类型检查。 \n\n==编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时评估操作。 在此过程中，dynamic 类型的变量会编译为 object 类型的变量。 因此，dynamic 类型只在编译时存在，在运行时则不存在。 #F44336==","slug":"CSHARP的内置引用类型","published":1,"date":"2020-12-26T09:16:48.221Z","updated":"2020-12-26T09:16:48.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckj5hqcjy00003ff0obhjdk18","content":"<h2 id=\"对象类型\"><a href=\"#对象类型\" class=\"headerlink\" title=\"对象类型\"></a>对象类型</h2><p>object 类型是 System.Object 在 .NET 中的别名。 ==在 C# 的统一类型系统中，所有类型（预定义类型、用户定义类型、引用类型和值类型）都是直接或间接从 System.Object 继承的。 可以将任何类型的值赋给 object 类型的变量。 #F44336== 可以使用文本 null 将任何 object 变量赋值给其默认值。 将值类型的变量转换为对象的过程称为 装箱 。 将 object 类型的变量转换为值类型的过程称为取消装箱 。</p>\n<h2 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h2><p>string 类型表示零个或多个 Unicode 字符的序列。 string 是 System.String 在 .NET 中的别名。<br>string 为引用类型.</p>\n<blockquote>\n<p>The C# String type is internally a ‘UTF-16’ byte string.</p>\n</blockquote>\n<p><img src=\"/img/1608707782744.png\" alt=\"核心结构\"></p>\n<h3 id=\"Intern-pool-常量池，-调用String-Intern-将返回常量池里的相同的字符串引用！-F44336\"><a href=\"#Intern-pool-常量池，-调用String-Intern-将返回常量池里的相同的字符串引用！-F44336\" class=\"headerlink\" title=\"Intern pool:常量池，==调用String.Intern()将返回常量池里的相同的字符串引用！ #F44336==\"></a>Intern pool:常量池，==调用String.Intern()将返回常量池里的相同的字符串引用！ #F44336==</h3><pre><code class=\"csharp\">var x = new string(new[] { &#39;f&#39;, &#39;o&#39;, &#39;o&#39; });\nvar y = new string(new[] { &#39;f&#39;, &#39;o&#39;, &#39;o&#39; });\nvar z = &quot;foo&quot;;\nvar u = &quot;foo&quot;;\nvar v = String.Intern(x);\n\n// different reference: x != y != z\nConsole.WriteLine(Object.ReferenceEquals(x, y)); // false\nConsole.WriteLine(Object.ReferenceEquals(x, z)); // false\n\n// same reference: z == u == v\nConsole.WriteLine(Object.ReferenceEquals(z, u)); // true\nConsole.WriteLine(Object.ReferenceEquals(z, v)); // true\n\n// same value\nConsole.WriteLine(x == y &amp;&amp; x == z &amp;&amp; x == u &amp;&amp; x == v); // true</code></pre>\n<h3 id=\"concat与-连接\"><a href=\"#concat与-连接\" class=\"headerlink\" title=\"concat与+连接\"></a>concat与+连接</h3><p>C # 编译器执行专门的处理，String 的‘ + ’连接转换为 String.Concat。</p>\n<pre><code class=\"csharp\">//“‘ x: ” + x + “ y: ” + y + “ z: ” + z’\nstring.Concat(new string[]{&quot;x:&quot;, x.ToString(), &quot;y:&quot;, y.ToString(), &quot;z:&quot;, z.ToString() } );//与上面等价</code></pre>\n<blockquote>\n<p>使用 c # 编译器优化“ + ”级联可能会在当前级联和过去级联之间获得不同的结果。例如，Visual Studio 2019的 c # 编译器的(int x) + (String y) + (int z)结果将是‘ String。Concat (x.ToString () ，y，z.ToString ())’。然而，Visual Studio 2017的 c # 编译器将是‘ String’。Concat ((object) x，y，(object) z)’ ，如果连接非字符串参数，将使用对象重载。因此，会发生结构装箱。如果使用 Unity，你必须注意，结果将根据与 Unity 捆绑的 c # 编译器的版本而有所不同。</p>\n</blockquote>\n<h3 id=\"StringBuilder-and-SpanFormatter\"><a href=\"#StringBuilder-and-SpanFormatter\" class=\"headerlink\" title=\"StringBuilder and SpanFormatter\"></a>StringBuilder and SpanFormatter</h3><p>‘ StringBuilder’是一个有‘ char []’作为临时缓冲区的类。Append 用于写入缓冲区，ToString 生成最终的字符串。</p>\n<pre><code class=\"csharp\">// .NET Standard 2.0\npublic StringBuilder Append(int value)\n{\n    return Append(value.ToString(CultureInfo.CurrentCulture));\n}\n\n// .NET Standard 2.1\npublic StringBuilder Append(int value)\n{\n    return AppendSpanFormattable(value);\n}\n\nprivate StringBuilder AppendSpanFormattable&lt;T&gt;(T value)\n    where T : ISpanFormattable\n{\n    if (value.TryFormat(RemainingCurrentChunk,\n        out int charsWritten, format: default, provider: null))\n    {\n        m_ChunkLength += charsWritten;\n        return this;\n    }\n    return Append(value.ToString());\n}</code></pre>\n<h3 id=\"String-Format\"><a href=\"#String-Format\" class=\"headerlink\" title=\"String.Format\"></a>String.Format</h3><p>由于接收参数为object,因此有拆装箱操作</p>\n<p>如图： “ x: ” + x + “ y: ” + y + “ z: ” + z’的简单字符串连接的性能度量。<br><img src=\"/img/1608709965913.png\" alt=\"各string方式性能对比\"></p>\n<h2 id=\"委托类型\"><a href=\"#委托类型\" class=\"headerlink\" title=\"委托类型\"></a>委托类型</h2><pre><code class=\"csharp\">public delegate void MessageDelegate(string message);\npublic delegate int AnotherDelegate(MyType m, long num);</code></pre>\n<h2 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h2><p>dynamic 类型表示变量的使用和对其成员的引用绕过编译时类型检查。 </p>\n<p>==编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时评估操作。 在此过程中，dynamic 类型的变量会编译为 object 类型的变量。 因此，dynamic 类型只在编译时存在，在运行时则不存在。 #F44336==</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"对象类型\"><a href=\"#对象类型\" class=\"headerlink\" title=\"对象类型\"></a>对象类型</h2><p>object 类型是 System.Object 在 .NET 中的别名。 ==在 C# 的统一类型系统中，所有类型（预定义类型、用户定义类型、引用类型和值类型）都是直接或间接从 System.Object 继承的。 可以将任何类型的值赋给 object 类型的变量。 #F44336== 可以使用文本 null 将任何 object 变量赋值给其默认值。 将值类型的变量转换为对象的过程称为 装箱 。 将 object 类型的变量转换为值类型的过程称为取消装箱 。</p>\n<h2 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h2><p>string 类型表示零个或多个 Unicode 字符的序列。 string 是 System.String 在 .NET 中的别名。<br>string 为引用类型.</p>\n<blockquote>\n<p>The C# String type is internally a ‘UTF-16’ byte string.</p>\n</blockquote>\n<p><img src=\"/img/1608707782744.png\" alt=\"核心结构\"></p>\n<h3 id=\"Intern-pool-常量池，-调用String-Intern-将返回常量池里的相同的字符串引用！-F44336\"><a href=\"#Intern-pool-常量池，-调用String-Intern-将返回常量池里的相同的字符串引用！-F44336\" class=\"headerlink\" title=\"Intern pool:常量池，==调用String.Intern()将返回常量池里的相同的字符串引用！ #F44336==\"></a>Intern pool:常量池，==调用String.Intern()将返回常量池里的相同的字符串引用！ #F44336==</h3><pre><code class=\"csharp\">var x = new string(new[] { &#39;f&#39;, &#39;o&#39;, &#39;o&#39; });\nvar y = new string(new[] { &#39;f&#39;, &#39;o&#39;, &#39;o&#39; });\nvar z = &quot;foo&quot;;\nvar u = &quot;foo&quot;;\nvar v = String.Intern(x);\n\n// different reference: x != y != z\nConsole.WriteLine(Object.ReferenceEquals(x, y)); // false\nConsole.WriteLine(Object.ReferenceEquals(x, z)); // false\n\n// same reference: z == u == v\nConsole.WriteLine(Object.ReferenceEquals(z, u)); // true\nConsole.WriteLine(Object.ReferenceEquals(z, v)); // true\n\n// same value\nConsole.WriteLine(x == y &amp;&amp; x == z &amp;&amp; x == u &amp;&amp; x == v); // true</code></pre>\n<h3 id=\"concat与-连接\"><a href=\"#concat与-连接\" class=\"headerlink\" title=\"concat与+连接\"></a>concat与+连接</h3><p>C # 编译器执行专门的处理，String 的‘ + ’连接转换为 String.Concat。</p>\n<pre><code class=\"csharp\">//“‘ x: ” + x + “ y: ” + y + “ z: ” + z’\nstring.Concat(new string[]{&quot;x:&quot;, x.ToString(), &quot;y:&quot;, y.ToString(), &quot;z:&quot;, z.ToString() } );//与上面等价</code></pre>\n<blockquote>\n<p>使用 c # 编译器优化“ + ”级联可能会在当前级联和过去级联之间获得不同的结果。例如，Visual Studio 2019的 c # 编译器的(int x) + (String y) + (int z)结果将是‘ String。Concat (x.ToString () ，y，z.ToString ())’。然而，Visual Studio 2017的 c # 编译器将是‘ String’。Concat ((object) x，y，(object) z)’ ，如果连接非字符串参数，将使用对象重载。因此，会发生结构装箱。如果使用 Unity，你必须注意，结果将根据与 Unity 捆绑的 c # 编译器的版本而有所不同。</p>\n</blockquote>\n<h3 id=\"StringBuilder-and-SpanFormatter\"><a href=\"#StringBuilder-and-SpanFormatter\" class=\"headerlink\" title=\"StringBuilder and SpanFormatter\"></a>StringBuilder and SpanFormatter</h3><p>‘ StringBuilder’是一个有‘ char []’作为临时缓冲区的类。Append 用于写入缓冲区，ToString 生成最终的字符串。</p>\n<pre><code class=\"csharp\">// .NET Standard 2.0\npublic StringBuilder Append(int value)\n{\n    return Append(value.ToString(CultureInfo.CurrentCulture));\n}\n\n// .NET Standard 2.1\npublic StringBuilder Append(int value)\n{\n    return AppendSpanFormattable(value);\n}\n\nprivate StringBuilder AppendSpanFormattable&lt;T&gt;(T value)\n    where T : ISpanFormattable\n{\n    if (value.TryFormat(RemainingCurrentChunk,\n        out int charsWritten, format: default, provider: null))\n    {\n        m_ChunkLength += charsWritten;\n        return this;\n    }\n    return Append(value.ToString());\n}</code></pre>\n<h3 id=\"String-Format\"><a href=\"#String-Format\" class=\"headerlink\" title=\"String.Format\"></a>String.Format</h3><p>由于接收参数为object,因此有拆装箱操作</p>\n<p>如图： “ x: ” + x + “ y: ” + y + “ z: ” + z’的简单字符串连接的性能度量。<br><img src=\"/img/1608709965913.png\" alt=\"各string方式性能对比\"></p>\n<h2 id=\"委托类型\"><a href=\"#委托类型\" class=\"headerlink\" title=\"委托类型\"></a>委托类型</h2><pre><code class=\"csharp\">public delegate void MessageDelegate(string message);\npublic delegate int AnotherDelegate(MyType m, long num);</code></pre>\n<h2 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h2><p>dynamic 类型表示变量的使用和对其成员的引用绕过编译时类型检查。 </p>\n<p>==编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时评估操作。 在此过程中，dynamic 类型的变量会编译为 object 类型的变量。 因此，dynamic 类型只在编译时存在，在运行时则不存在。 #F44336==</p>\n"},{"title":"LUA与CSHARP交互","_content":"\n## 相互调用\n原理：  C#与Lua进行交互主要通过虚拟栈实现\n\n## C# Call Lua:\n* 内存： 由C#先将数据放入栈中，由lua去栈中获取数据，然后返回数据对应的值到栈顶，再由栈顶返回至C#。\n* 代码： C#生成Bridge文件，Bridge调dll文件（dll是用C写的库），先调用lua中dll文件，由dll文件执行lua代码\nC#->Bridge->dll->Lua  OR   C#->dll->Lua\n\n## Lua Call C#:\n* 内存： 先生成C#源文件所对应的Wrap文件或者编写C#源文件所对应的c模块，然后将源文件内容通过Wrap文件或者C模块注册到Lua解释器中，然后由Lua去调用这个模块的函数。\n* 代码：先生成Wrap文件（中间文件/适配文件），wrap文件把字段方法，注册到lua虚拟机中（解释器luajit），然后lua通过wrap就可以调C#了\n或者在config文件中添加相应类型也可以\n\n## unity下的lua框架\n\n为了使基于unity开发的应用在移动平台能够热更新，我们嵌入了Lua虚拟机，将需要热更新的逻辑用lua实现。c#通过P/Invoke和lua交互（lua由ANSI C实现）。在这个过程中，由于数据的交换需要使用==lua提供的虚拟栈 #F44336==，不够简单高效，为了解决这个问题，我们引入了\\*lua框架（xlua、slua、ulua）来达到类似RPC式的函数调用、类原生对象式的对象访问以及高效的对象传递。\n\n### XLUA\n可以把xlua的push API归为两类：一类是针对某种特定类型的push，暂且叫做LowLevelAPI；还有一类是基于LowLevelAPI封装的更上层的HighLevelAPI。\n\n* 门面模式\n使用HighLevelAPI时你只要简单的传入你想push的对象，HighLevelAPI会帮你找到最适合的LowLevelAPI调用，因为就算同一种类型的push方法，也可能有用户自定义的优化版本。而对于LowLevelAPI最终是需要调用xlua.dll中提供的C API来协调完成最终的工作。\n\n#### LowLevelAPI\n\n``` csharp\n//using RealStatePtr = System.IntPtr;\n//using LuaCSFunction = XLua.LuaDLL.lua_CSFunction;\n//typedef int (*lua_CFunction) (lua_State *L);\n\n//ObjectTranslator.cs\nvoid pushPrimitive(RealStatePtr L, object o)\npublic void Push(RealStatePtr L, object o)\npublic void PushObject(RealStatePtr L, object o, int type_id)\npublic void Push(RealStatePtr L, LuaCSFunction o)\ninternal void PushFixCSFunction(RealStatePtr L, LuaCSFunction func)\npublic void Push(RealStatePtr L, LuaBase o)\npublic void PushDecimal(RealStatePtr L, decimal val)\n```\n\n* 传递基元类型\n \n \n基元类型为 Boolean、Byte、SByte、Int16、UInt16、Int32、UInt32、Int64、UInt64、UIntPtr、Char、Double、Single和IntPtr （对应的void*）。\n``` csharp\nvoid pushPrimitive(RealStatePtr L, object o)\n```\n\nXLUA中：\n\n``` csharp\n//push一个int\nLUA_API void xlua_pushinteger (lua_State *L, int n)\n//push一个double\n#define LUA_NUMBER\tdouble\ntypedef LUA_NUMBER lua_Number;\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n)\n//push一个IntPtr\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p)\n```\n\n对于long，xlua定制：\n\n``` cpp\n//i64lib.c\n//在lua中表示c#中的long\ntypedef struct {\n\tint fake_id;\n\tint8_t type;\n    union {\n\t\tint64_t i64;\n\t\tuint64_t u64;\n\t} data;\n} Integer64;\n```\n\n* 传递 object\n\n``` csharp\npublic void Push(RealStatePtr L, object o)\npublic void PushObject(RealStatePtr L, object o, int type_id)\n```\n\n\n不管object是什么类型，最终的push都是使用:\n``` c\nLUA_API void xlua_pushcsobj(lua_State *L, int key, int meta_ref, int need_cache, int cache_ref) {\n\tint* pointer = (int*)lua_newuserdata(L, sizeof(int));\n\t*pointer = key;\n\t\n\tif (need_cache) cacheud(L, key, cache_ref);\n\n    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);\n\n\tlua_setmetatable(L, -2);\n}\n```\n\n为什么我们传给lua的对象是一个int类型（这里的key）？其实我们这里的key是我们要传递的c#对象的一个索引，我们可以通过这个索引找到这个c#对象。\n\n当传递一个c#对象的时候，我们创建一个userdate，并把这个索引值赋给这个userdata。然后，lua在全局注册表中，有一张专门的表用来存放c#各种类型所对应的元表，而**meta_ref**就是当前这个对象所对应类型的元表的索引id，我们通过他找到对应的元表，就可以通过setmetatable来绑定操作这个对象的方法。最终lua就可以愉快的使用这个对象。\n\n>每种类型所对应的元表，是我们在push一种类型的对象之前，提前注册进来的，后面详述。\n\n\n但是对于引用类型的对象，其生命周期是有可能超出当前的调用栈的（比如lua用一个变量引用了这个对象） 。这时，我们就不仅要能够通过这个key找到c#原始对象，还要通过这个key能够找到对应的lua代理对象。因此，对于引用类型，我们在lua中同样也要建立一套索引机制，这就是need_cache和cache_ref的作用：\n``` c\nstatic void cacheud(lua_State *L, int key, int cache_ref) {\n\tlua_rawgeti(L, LUA_REGISTRYINDEX, cache_ref);\n\tlua_pushvalue(L, -2);\n\tlua_rawseti(L, -2, key);\n\tlua_pop(L, 1);\n}\n```\n\n* 缓存\n\n再回过头来看看c#中的索引和缓存机制：\n\n在调用xlua_pushcsobj之前,所有object都会被放入一个对象的缓存池中ObjectTranslator.objects。而我们得到的key就是这个对象在缓存池中的下标。\n\n\n* gc\n\n对于引用类型，它的生命周期管理会略微复杂。**mono和lua虚拟机有各自的gc系统**，并且相互无法感知。当lua和c#同时引用一个对象时，我们需要能够保证对象生命周期的正确，不能一边还在引用，另一边却把它释放掉了。\n\n这个过程是由lua的gc驱动的。我们**把对象push到lua时，会缓存在c#的对象池中，所以是不会被mono的gc所释放掉，这样就保证了lua能够安全的持有c#对象。同时我们也会把这个对象的代理缓存到lua中，而lua中对象的缓存表是一个弱表，也就是说，当没有其他的lua引用这个对象时，lua的gc会把这个对象从lua的缓存中回收**，而对象被gc回收的过程会触发这个对象的的__gc元方法。\n\n而这个__gc元方法就会通知到c#这端，来告诉我们lua不再使用这个对象，我们可以把它从对象缓存池中移除。当没有其他c#对其的引用时，mono的gc就会正常的回收这个对象。\n\n``` csharp\n//StaticLuaCallback.cs\n//__gc元方法：\npublic static int LuaGC(RealStatePtr L)\n{\n    try\n    {\n        int udata = LuaAPI.xlua_tocsobj_safe(L, 1);\n        if (udata != -1)\n        {\n            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);\n            if ( translator != null )\n            {\n                translator.collectObject(udata);\n            }\n        }\n        return 0;\n    }\n    catch (Exception e)\n    {\n        return LuaAPI.luaL_error(L, \"c# exception in LuaGC:\" + e);\n    }\n}\n\n//从缓存池中删除\ninternal void collectObject(int obj_index_to_collect)\n{\n\tobject o;\n\t\n\tif (objects.TryGetValue(obj_index_to_collect, out o))\n\t{\n\t\tobjects.Remove(obj_index_to_collect);\n        \n        if (o != null)\n        {\n            int obj_index;\n            //lua gc是先把weak table移除后再调用__gc，这期间同一个对象可能再次push到lua，关联到新的index\n            bool is_enum = o.GetType().IsEnum();\n            if ((is_enum ? enumMap.TryGetValue(o, out obj_index) : reverseMap.TryGetValue(o, out obj_index))\n                && obj_index == obj_index_to_collect)\n            {\n                if (is_enum)\n                {\n                    enumMap.Remove(o);\n                }\n                else\n                {\n                    reverseMap.Remove(o);\n                }\n            }\n        }\n\t}\n}\n```\n\n* 元表\n\n对于业务来说，我们只是单纯的把对象的索引传递过去，是远远不够的，我们还需要提供直接使用和操作对象的方法。前面我们提到，在我们把一个对象push到lua之前，我们会把对象类型所对应的元表提前注册到lua之中。这样在我们真正push一个对象时，就会用这个元表来设置操作这个对象的方法。\n\n首先第一个问题就是，如何表示c#对象的类型？回过头来看看我们的Push函数，其中最重要的就是getTypeId：\n\n首先会尝试从c#的类型缓存typeIdMap中检查是否已经注册过这种类型，如果没有的话，我们就需要为其生成一个type_id。\n\n**再从lua的类型缓存中用类型名来检索是否已经注册过这种类型，如果没有的话，意味着我们还没有为这种类型在lua中注册一个元表，继而通过TryDelayWrapLoader来生成这个类型的元表**。\n\n``` csharp\n//\npublic void Push(RealStatePtr L, object o)\n{\n\t//...\n\tType type = o.GetType();\n\tbool is_first;\n\tint type_id = getTypeId(L, type, out is_first);\n\t//...\n}\n\n//这里再次吐槽getTypeId函数的设计和实现，为了保持清楚，我只保留能大体说明逻辑的的代码\ninternal int getTypeId(RealStatePtr L, Type type, out bool is_first, LOGLEVEL log_level = LOGLEVEL.WARN)\n{\n\t//尝试获取c#中检索\n\tif (typeIdMap.TryGetValue(type, out type_id)){return;}\n\t//尝试从lua中检索\n\tLuaAPI.luaL_getmetatable(L,type.FullName);\n\tif (LuaAPI.lua_isnil(L, -1)) \n\t{\n\t    LuaAPI.lua_pop(L, 1);\n\t    //获取类型的元表\n\t    if (TryDelayWrapLoader(L,  type))\n\t    {\n\t        LuaAPI.luaL_getmetatable(L, type.FullName);\n\t    }\n\t    else\n\t    {\n\t        throw new Exception(\"Fatal: can not load metatable of type:\" + type);\n\t    }\n\t}\n\t//生成新的type_id\n\ttype_id = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);\n\t//注册到lua\n    LuaAPI.lua_pushnumber(L, type_id);\n    LuaAPI.xlua_rawseti(L, -2, 1);\n    LuaAPI.lua_pop(L, 1);\n    \n    if (type.IsValueType())\n    {\n    \ttypeMap.Add(type_id, type);\n    }\n\n    typeIdMap.Add(type, type_id);\n}\n```\n\n* 传递c#函数\n \n\nxlua通过lua_pushstdcallcfunction来push一个LuaCSFunction，其调用的时xlua.dll提供的xlua_push_csharp_function。\n``` csharp\n //LUADLL.cs\npublic static void lua_pushstdcallcfunction(IntPtr L, lua_CSFunction function, int n = 0)//[-0, +1, m]\n{\n\tIntPtr fn = Marshal.GetFunctionPointerForDelegate(function);\n\txlua_push_csharp_function(L, fn, n);\n}\n```\n\n最终提供给用户的是这两个接口：\n\n``` csharp\ninternal void PushFixCSFunction(RealStatePtr L, LuaCSFunction func)\npublic void Push(RealStatePtr L, LuaCSFunction o)\n```\n\n这两个函数都做了一件事情，就是在LuaCSFunction函数push到lua之前，用另一个LuaCSFunction来包装了一层，用来做异常捕获。\n\n> 和gc一样，mono和lua有自己的异常\n\n两种索引方式的不同，使用在了不同的场景。\n\nPushFixCSFunction()大量被用在我们静态生成的元表构造器中，做为默认需要支持的类型的元表，注册进lua，并永久存在。而Push()被大量使用在反射生成的元表之中，在使用完之后，可能就会被释放。\n\n最后还有一个小细节，Push()中对IsStaticPInvokeCSFunction的函数没有加包装，因为这种类型的函数是我们静态生成的，在生成时，我们已经加入了异常捕获的代码，不需要再被捕获了。\n\n>可以看到，一个函数在被调用之前，进行了多次的包装，每次包装都附带了一些额外的功能，但又对原函数没有侵入。（函数式编程，面向切片编程）\n\n* 其他push\n\n``` csharp\n//push一个lua在c#中的代理对象\npublic void Push(RealStatePtr L, LuaBase o)\n```\n\nLuaBase是c#对lua中特有的类型的封装。比如说LuaTable对应table、LuaFunction对应luafunction（此处不是luacfunction）。C#可以通过对应的类型去创建、操作一个lua原生对象。\n\n所以，LuaBase只是一个lua对象在c#中的代理，我们push一个LuaBase其实是找到真正的lua对象，并push。\n\n``` csharp\n//重载push一个decimal，避免gc\nvoid PushDecimal(RealStatePtr L, decimal val)\n```\n\n\n#### HighLevelAPI\n\n对于HighLevelAPI，里面不包含具体的push实现，而是通过获取对象的类型，来选择性的调用类型所对应的具体push函数。\n\n可以看作类似是编译器的函数重载功能\n\n``` csharp\npublic void PushAny(RealStatePtr L, object o)\npublic void PushByType<T>(RealStatePtr L,  T v)\n```\n\n* 顾名思义，PushAny()可以用来push所有的类型，可以被用在我们提前没法知道对象类型的地方。最典型的例子就是在反射生成元表时，我们动态的获取对象，通过PushAny()把类型未知的对象push到lua。\n\n* PushByType()是对PushAny()的封装，唯一的不同就是做了一个优化：\n对于基元类型，不再调用pushPrimitive() （会有装箱/拆箱）,而是通过查表的方式直接获取针对各个基元类型的直接push的方式。","source":"_posts/LUA与CSHARP交互.md","raw":"---\ntitle: LUA与CSHARP交互\ncategories:\n- Unity\n---\n\n## 相互调用\n原理：  C#与Lua进行交互主要通过虚拟栈实现\n\n## C# Call Lua:\n* 内存： 由C#先将数据放入栈中，由lua去栈中获取数据，然后返回数据对应的值到栈顶，再由栈顶返回至C#。\n* 代码： C#生成Bridge文件，Bridge调dll文件（dll是用C写的库），先调用lua中dll文件，由dll文件执行lua代码\nC#->Bridge->dll->Lua  OR   C#->dll->Lua\n\n## Lua Call C#:\n* 内存： 先生成C#源文件所对应的Wrap文件或者编写C#源文件所对应的c模块，然后将源文件内容通过Wrap文件或者C模块注册到Lua解释器中，然后由Lua去调用这个模块的函数。\n* 代码：先生成Wrap文件（中间文件/适配文件），wrap文件把字段方法，注册到lua虚拟机中（解释器luajit），然后lua通过wrap就可以调C#了\n或者在config文件中添加相应类型也可以\n\n## unity下的lua框架\n\n为了使基于unity开发的应用在移动平台能够热更新，我们嵌入了Lua虚拟机，将需要热更新的逻辑用lua实现。c#通过P/Invoke和lua交互（lua由ANSI C实现）。在这个过程中，由于数据的交换需要使用==lua提供的虚拟栈 #F44336==，不够简单高效，为了解决这个问题，我们引入了\\*lua框架（xlua、slua、ulua）来达到类似RPC式的函数调用、类原生对象式的对象访问以及高效的对象传递。\n\n### XLUA\n可以把xlua的push API归为两类：一类是针对某种特定类型的push，暂且叫做LowLevelAPI；还有一类是基于LowLevelAPI封装的更上层的HighLevelAPI。\n\n* 门面模式\n使用HighLevelAPI时你只要简单的传入你想push的对象，HighLevelAPI会帮你找到最适合的LowLevelAPI调用，因为就算同一种类型的push方法，也可能有用户自定义的优化版本。而对于LowLevelAPI最终是需要调用xlua.dll中提供的C API来协调完成最终的工作。\n\n#### LowLevelAPI\n\n``` csharp\n//using RealStatePtr = System.IntPtr;\n//using LuaCSFunction = XLua.LuaDLL.lua_CSFunction;\n//typedef int (*lua_CFunction) (lua_State *L);\n\n//ObjectTranslator.cs\nvoid pushPrimitive(RealStatePtr L, object o)\npublic void Push(RealStatePtr L, object o)\npublic void PushObject(RealStatePtr L, object o, int type_id)\npublic void Push(RealStatePtr L, LuaCSFunction o)\ninternal void PushFixCSFunction(RealStatePtr L, LuaCSFunction func)\npublic void Push(RealStatePtr L, LuaBase o)\npublic void PushDecimal(RealStatePtr L, decimal val)\n```\n\n* 传递基元类型\n \n \n基元类型为 Boolean、Byte、SByte、Int16、UInt16、Int32、UInt32、Int64、UInt64、UIntPtr、Char、Double、Single和IntPtr （对应的void*）。\n``` csharp\nvoid pushPrimitive(RealStatePtr L, object o)\n```\n\nXLUA中：\n\n``` csharp\n//push一个int\nLUA_API void xlua_pushinteger (lua_State *L, int n)\n//push一个double\n#define LUA_NUMBER\tdouble\ntypedef LUA_NUMBER lua_Number;\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n)\n//push一个IntPtr\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p)\n```\n\n对于long，xlua定制：\n\n``` cpp\n//i64lib.c\n//在lua中表示c#中的long\ntypedef struct {\n\tint fake_id;\n\tint8_t type;\n    union {\n\t\tint64_t i64;\n\t\tuint64_t u64;\n\t} data;\n} Integer64;\n```\n\n* 传递 object\n\n``` csharp\npublic void Push(RealStatePtr L, object o)\npublic void PushObject(RealStatePtr L, object o, int type_id)\n```\n\n\n不管object是什么类型，最终的push都是使用:\n``` c\nLUA_API void xlua_pushcsobj(lua_State *L, int key, int meta_ref, int need_cache, int cache_ref) {\n\tint* pointer = (int*)lua_newuserdata(L, sizeof(int));\n\t*pointer = key;\n\t\n\tif (need_cache) cacheud(L, key, cache_ref);\n\n    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);\n\n\tlua_setmetatable(L, -2);\n}\n```\n\n为什么我们传给lua的对象是一个int类型（这里的key）？其实我们这里的key是我们要传递的c#对象的一个索引，我们可以通过这个索引找到这个c#对象。\n\n当传递一个c#对象的时候，我们创建一个userdate，并把这个索引值赋给这个userdata。然后，lua在全局注册表中，有一张专门的表用来存放c#各种类型所对应的元表，而**meta_ref**就是当前这个对象所对应类型的元表的索引id，我们通过他找到对应的元表，就可以通过setmetatable来绑定操作这个对象的方法。最终lua就可以愉快的使用这个对象。\n\n>每种类型所对应的元表，是我们在push一种类型的对象之前，提前注册进来的，后面详述。\n\n\n但是对于引用类型的对象，其生命周期是有可能超出当前的调用栈的（比如lua用一个变量引用了这个对象） 。这时，我们就不仅要能够通过这个key找到c#原始对象，还要通过这个key能够找到对应的lua代理对象。因此，对于引用类型，我们在lua中同样也要建立一套索引机制，这就是need_cache和cache_ref的作用：\n``` c\nstatic void cacheud(lua_State *L, int key, int cache_ref) {\n\tlua_rawgeti(L, LUA_REGISTRYINDEX, cache_ref);\n\tlua_pushvalue(L, -2);\n\tlua_rawseti(L, -2, key);\n\tlua_pop(L, 1);\n}\n```\n\n* 缓存\n\n再回过头来看看c#中的索引和缓存机制：\n\n在调用xlua_pushcsobj之前,所有object都会被放入一个对象的缓存池中ObjectTranslator.objects。而我们得到的key就是这个对象在缓存池中的下标。\n\n\n* gc\n\n对于引用类型，它的生命周期管理会略微复杂。**mono和lua虚拟机有各自的gc系统**，并且相互无法感知。当lua和c#同时引用一个对象时，我们需要能够保证对象生命周期的正确，不能一边还在引用，另一边却把它释放掉了。\n\n这个过程是由lua的gc驱动的。我们**把对象push到lua时，会缓存在c#的对象池中，所以是不会被mono的gc所释放掉，这样就保证了lua能够安全的持有c#对象。同时我们也会把这个对象的代理缓存到lua中，而lua中对象的缓存表是一个弱表，也就是说，当没有其他的lua引用这个对象时，lua的gc会把这个对象从lua的缓存中回收**，而对象被gc回收的过程会触发这个对象的的__gc元方法。\n\n而这个__gc元方法就会通知到c#这端，来告诉我们lua不再使用这个对象，我们可以把它从对象缓存池中移除。当没有其他c#对其的引用时，mono的gc就会正常的回收这个对象。\n\n``` csharp\n//StaticLuaCallback.cs\n//__gc元方法：\npublic static int LuaGC(RealStatePtr L)\n{\n    try\n    {\n        int udata = LuaAPI.xlua_tocsobj_safe(L, 1);\n        if (udata != -1)\n        {\n            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);\n            if ( translator != null )\n            {\n                translator.collectObject(udata);\n            }\n        }\n        return 0;\n    }\n    catch (Exception e)\n    {\n        return LuaAPI.luaL_error(L, \"c# exception in LuaGC:\" + e);\n    }\n}\n\n//从缓存池中删除\ninternal void collectObject(int obj_index_to_collect)\n{\n\tobject o;\n\t\n\tif (objects.TryGetValue(obj_index_to_collect, out o))\n\t{\n\t\tobjects.Remove(obj_index_to_collect);\n        \n        if (o != null)\n        {\n            int obj_index;\n            //lua gc是先把weak table移除后再调用__gc，这期间同一个对象可能再次push到lua，关联到新的index\n            bool is_enum = o.GetType().IsEnum();\n            if ((is_enum ? enumMap.TryGetValue(o, out obj_index) : reverseMap.TryGetValue(o, out obj_index))\n                && obj_index == obj_index_to_collect)\n            {\n                if (is_enum)\n                {\n                    enumMap.Remove(o);\n                }\n                else\n                {\n                    reverseMap.Remove(o);\n                }\n            }\n        }\n\t}\n}\n```\n\n* 元表\n\n对于业务来说，我们只是单纯的把对象的索引传递过去，是远远不够的，我们还需要提供直接使用和操作对象的方法。前面我们提到，在我们把一个对象push到lua之前，我们会把对象类型所对应的元表提前注册到lua之中。这样在我们真正push一个对象时，就会用这个元表来设置操作这个对象的方法。\n\n首先第一个问题就是，如何表示c#对象的类型？回过头来看看我们的Push函数，其中最重要的就是getTypeId：\n\n首先会尝试从c#的类型缓存typeIdMap中检查是否已经注册过这种类型，如果没有的话，我们就需要为其生成一个type_id。\n\n**再从lua的类型缓存中用类型名来检索是否已经注册过这种类型，如果没有的话，意味着我们还没有为这种类型在lua中注册一个元表，继而通过TryDelayWrapLoader来生成这个类型的元表**。\n\n``` csharp\n//\npublic void Push(RealStatePtr L, object o)\n{\n\t//...\n\tType type = o.GetType();\n\tbool is_first;\n\tint type_id = getTypeId(L, type, out is_first);\n\t//...\n}\n\n//这里再次吐槽getTypeId函数的设计和实现，为了保持清楚，我只保留能大体说明逻辑的的代码\ninternal int getTypeId(RealStatePtr L, Type type, out bool is_first, LOGLEVEL log_level = LOGLEVEL.WARN)\n{\n\t//尝试获取c#中检索\n\tif (typeIdMap.TryGetValue(type, out type_id)){return;}\n\t//尝试从lua中检索\n\tLuaAPI.luaL_getmetatable(L,type.FullName);\n\tif (LuaAPI.lua_isnil(L, -1)) \n\t{\n\t    LuaAPI.lua_pop(L, 1);\n\t    //获取类型的元表\n\t    if (TryDelayWrapLoader(L,  type))\n\t    {\n\t        LuaAPI.luaL_getmetatable(L, type.FullName);\n\t    }\n\t    else\n\t    {\n\t        throw new Exception(\"Fatal: can not load metatable of type:\" + type);\n\t    }\n\t}\n\t//生成新的type_id\n\ttype_id = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);\n\t//注册到lua\n    LuaAPI.lua_pushnumber(L, type_id);\n    LuaAPI.xlua_rawseti(L, -2, 1);\n    LuaAPI.lua_pop(L, 1);\n    \n    if (type.IsValueType())\n    {\n    \ttypeMap.Add(type_id, type);\n    }\n\n    typeIdMap.Add(type, type_id);\n}\n```\n\n* 传递c#函数\n \n\nxlua通过lua_pushstdcallcfunction来push一个LuaCSFunction，其调用的时xlua.dll提供的xlua_push_csharp_function。\n``` csharp\n //LUADLL.cs\npublic static void lua_pushstdcallcfunction(IntPtr L, lua_CSFunction function, int n = 0)//[-0, +1, m]\n{\n\tIntPtr fn = Marshal.GetFunctionPointerForDelegate(function);\n\txlua_push_csharp_function(L, fn, n);\n}\n```\n\n最终提供给用户的是这两个接口：\n\n``` csharp\ninternal void PushFixCSFunction(RealStatePtr L, LuaCSFunction func)\npublic void Push(RealStatePtr L, LuaCSFunction o)\n```\n\n这两个函数都做了一件事情，就是在LuaCSFunction函数push到lua之前，用另一个LuaCSFunction来包装了一层，用来做异常捕获。\n\n> 和gc一样，mono和lua有自己的异常\n\n两种索引方式的不同，使用在了不同的场景。\n\nPushFixCSFunction()大量被用在我们静态生成的元表构造器中，做为默认需要支持的类型的元表，注册进lua，并永久存在。而Push()被大量使用在反射生成的元表之中，在使用完之后，可能就会被释放。\n\n最后还有一个小细节，Push()中对IsStaticPInvokeCSFunction的函数没有加包装，因为这种类型的函数是我们静态生成的，在生成时，我们已经加入了异常捕获的代码，不需要再被捕获了。\n\n>可以看到，一个函数在被调用之前，进行了多次的包装，每次包装都附带了一些额外的功能，但又对原函数没有侵入。（函数式编程，面向切片编程）\n\n* 其他push\n\n``` csharp\n//push一个lua在c#中的代理对象\npublic void Push(RealStatePtr L, LuaBase o)\n```\n\nLuaBase是c#对lua中特有的类型的封装。比如说LuaTable对应table、LuaFunction对应luafunction（此处不是luacfunction）。C#可以通过对应的类型去创建、操作一个lua原生对象。\n\n所以，LuaBase只是一个lua对象在c#中的代理，我们push一个LuaBase其实是找到真正的lua对象，并push。\n\n``` csharp\n//重载push一个decimal，避免gc\nvoid PushDecimal(RealStatePtr L, decimal val)\n```\n\n\n#### HighLevelAPI\n\n对于HighLevelAPI，里面不包含具体的push实现，而是通过获取对象的类型，来选择性的调用类型所对应的具体push函数。\n\n可以看作类似是编译器的函数重载功能\n\n``` csharp\npublic void PushAny(RealStatePtr L, object o)\npublic void PushByType<T>(RealStatePtr L,  T v)\n```\n\n* 顾名思义，PushAny()可以用来push所有的类型，可以被用在我们提前没法知道对象类型的地方。最典型的例子就是在反射生成元表时，我们动态的获取对象，通过PushAny()把类型未知的对象push到lua。\n\n* PushByType()是对PushAny()的封装，唯一的不同就是做了一个优化：\n对于基元类型，不再调用pushPrimitive() （会有装箱/拆箱）,而是通过查表的方式直接获取针对各个基元类型的直接push的方式。","slug":"LUA与CSHARP交互","published":1,"date":"2020-12-26T09:16:48.221Z","updated":"2020-12-26T09:16:48.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckj5hqckr00013ff0rf8r8t9j","content":"<h2 id=\"相互调用\"><a href=\"#相互调用\" class=\"headerlink\" title=\"相互调用\"></a>相互调用</h2><p>原理：  C#与Lua进行交互主要通过虚拟栈实现</p>\n<h2 id=\"C-Call-Lua\"><a href=\"#C-Call-Lua\" class=\"headerlink\" title=\"C# Call Lua:\"></a>C# Call Lua:</h2><ul>\n<li>内存： 由C#先将数据放入栈中，由lua去栈中获取数据，然后返回数据对应的值到栈顶，再由栈顶返回至C#。</li>\n<li>代码： C#生成Bridge文件，Bridge调dll文件（dll是用C写的库），先调用lua中dll文件，由dll文件执行lua代码<br>C#-&gt;Bridge-&gt;dll-&gt;Lua  OR   C#-&gt;dll-&gt;Lua</li>\n</ul>\n<h2 id=\"Lua-Call-C\"><a href=\"#Lua-Call-C\" class=\"headerlink\" title=\"Lua Call C#:\"></a>Lua Call C#:</h2><ul>\n<li>内存： 先生成C#源文件所对应的Wrap文件或者编写C#源文件所对应的c模块，然后将源文件内容通过Wrap文件或者C模块注册到Lua解释器中，然后由Lua去调用这个模块的函数。</li>\n<li>代码：先生成Wrap文件（中间文件/适配文件），wrap文件把字段方法，注册到lua虚拟机中（解释器luajit），然后lua通过wrap就可以调C#了<br>或者在config文件中添加相应类型也可以</li>\n</ul>\n<h2 id=\"unity下的lua框架\"><a href=\"#unity下的lua框架\" class=\"headerlink\" title=\"unity下的lua框架\"></a>unity下的lua框架</h2><p>为了使基于unity开发的应用在移动平台能够热更新，我们嵌入了Lua虚拟机，将需要热更新的逻辑用lua实现。c#通过P/Invoke和lua交互（lua由ANSI C实现）。在这个过程中，由于数据的交换需要使用==lua提供的虚拟栈 #F44336==，不够简单高效，为了解决这个问题，我们引入了*lua框架（xlua、slua、ulua）来达到类似RPC式的函数调用、类原生对象式的对象访问以及高效的对象传递。</p>\n<h3 id=\"XLUA\"><a href=\"#XLUA\" class=\"headerlink\" title=\"XLUA\"></a>XLUA</h3><p>可以把xlua的push API归为两类：一类是针对某种特定类型的push，暂且叫做LowLevelAPI；还有一类是基于LowLevelAPI封装的更上层的HighLevelAPI。</p>\n<ul>\n<li>门面模式<br>使用HighLevelAPI时你只要简单的传入你想push的对象，HighLevelAPI会帮你找到最适合的LowLevelAPI调用，因为就算同一种类型的push方法，也可能有用户自定义的优化版本。而对于LowLevelAPI最终是需要调用xlua.dll中提供的C API来协调完成最终的工作。</li>\n</ul>\n<h4 id=\"LowLevelAPI\"><a href=\"#LowLevelAPI\" class=\"headerlink\" title=\"LowLevelAPI\"></a>LowLevelAPI</h4><pre><code class=\"csharp\">//using RealStatePtr = System.IntPtr;\n//using LuaCSFunction = XLua.LuaDLL.lua_CSFunction;\n//typedef int (*lua_CFunction) (lua_State *L);\n\n//ObjectTranslator.cs\nvoid pushPrimitive(RealStatePtr L, object o)\npublic void Push(RealStatePtr L, object o)\npublic void PushObject(RealStatePtr L, object o, int type_id)\npublic void Push(RealStatePtr L, LuaCSFunction o)\ninternal void PushFixCSFunction(RealStatePtr L, LuaCSFunction func)\npublic void Push(RealStatePtr L, LuaBase o)\npublic void PushDecimal(RealStatePtr L, decimal val)</code></pre>\n<ul>\n<li>传递基元类型</li>\n</ul>\n<p>基元类型为 Boolean、Byte、SByte、Int16、UInt16、Int32、UInt32、Int64、UInt64、UIntPtr、Char、Double、Single和IntPtr （对应的void*）。</p>\n<pre><code class=\"csharp\">void pushPrimitive(RealStatePtr L, object o)</code></pre>\n<p>XLUA中：</p>\n<pre><code class=\"csharp\">//push一个int\nLUA_API void xlua_pushinteger (lua_State *L, int n)\n//push一个double\n#define LUA_NUMBER    double\ntypedef LUA_NUMBER lua_Number;\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n)\n//push一个IntPtr\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p)</code></pre>\n<p>对于long，xlua定制：</p>\n<pre><code class=\"cpp\">//i64lib.c\n//在lua中表示c#中的long\ntypedef struct {\n    int fake_id;\n    int8_t type;\n    union {\n        int64_t i64;\n        uint64_t u64;\n    } data;\n} Integer64;</code></pre>\n<ul>\n<li>传递 object</li>\n</ul>\n<pre><code class=\"csharp\">public void Push(RealStatePtr L, object o)\npublic void PushObject(RealStatePtr L, object o, int type_id)</code></pre>\n<p>不管object是什么类型，最终的push都是使用:</p>\n<pre><code class=\"c\">LUA_API void xlua_pushcsobj(lua_State *L, int key, int meta_ref, int need_cache, int cache_ref) {\n    int* pointer = (int*)lua_newuserdata(L, sizeof(int));\n    *pointer = key;\n\n    if (need_cache) cacheud(L, key, cache_ref);\n\n    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);\n\n    lua_setmetatable(L, -2);\n}</code></pre>\n<p>为什么我们传给lua的对象是一个int类型（这里的key）？其实我们这里的key是我们要传递的c#对象的一个索引，我们可以通过这个索引找到这个c#对象。</p>\n<p>当传递一个c#对象的时候，我们创建一个userdate，并把这个索引值赋给这个userdata。然后，lua在全局注册表中，有一张专门的表用来存放c#各种类型所对应的元表，而<strong>meta_ref</strong>就是当前这个对象所对应类型的元表的索引id，我们通过他找到对应的元表，就可以通过setmetatable来绑定操作这个对象的方法。最终lua就可以愉快的使用这个对象。</p>\n<blockquote>\n<p>每种类型所对应的元表，是我们在push一种类型的对象之前，提前注册进来的，后面详述。</p>\n</blockquote>\n<p>但是对于引用类型的对象，其生命周期是有可能超出当前的调用栈的（比如lua用一个变量引用了这个对象） 。这时，我们就不仅要能够通过这个key找到c#原始对象，还要通过这个key能够找到对应的lua代理对象。因此，对于引用类型，我们在lua中同样也要建立一套索引机制，这就是need_cache和cache_ref的作用：</p>\n<pre><code class=\"c\">static void cacheud(lua_State *L, int key, int cache_ref) {\n    lua_rawgeti(L, LUA_REGISTRYINDEX, cache_ref);\n    lua_pushvalue(L, -2);\n    lua_rawseti(L, -2, key);\n    lua_pop(L, 1);\n}</code></pre>\n<ul>\n<li>缓存</li>\n</ul>\n<p>再回过头来看看c#中的索引和缓存机制：</p>\n<p>在调用xlua_pushcsobj之前,所有object都会被放入一个对象的缓存池中ObjectTranslator.objects。而我们得到的key就是这个对象在缓存池中的下标。</p>\n<ul>\n<li>gc</li>\n</ul>\n<p>对于引用类型，它的生命周期管理会略微复杂。<strong>mono和lua虚拟机有各自的gc系统</strong>，并且相互无法感知。当lua和c#同时引用一个对象时，我们需要能够保证对象生命周期的正确，不能一边还在引用，另一边却把它释放掉了。</p>\n<p>这个过程是由lua的gc驱动的。我们<strong>把对象push到lua时，会缓存在c#的对象池中，所以是不会被mono的gc所释放掉，这样就保证了lua能够安全的持有c#对象。同时我们也会把这个对象的代理缓存到lua中，而lua中对象的缓存表是一个弱表，也就是说，当没有其他的lua引用这个对象时，lua的gc会把这个对象从lua的缓存中回收</strong>，而对象被gc回收的过程会触发这个对象的的__gc元方法。</p>\n<p>而这个__gc元方法就会通知到c#这端，来告诉我们lua不再使用这个对象，我们可以把它从对象缓存池中移除。当没有其他c#对其的引用时，mono的gc就会正常的回收这个对象。</p>\n<pre><code class=\"csharp\">//StaticLuaCallback.cs\n//__gc元方法：\npublic static int LuaGC(RealStatePtr L)\n{\n    try\n    {\n        int udata = LuaAPI.xlua_tocsobj_safe(L, 1);\n        if (udata != -1)\n        {\n            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);\n            if ( translator != null )\n            {\n                translator.collectObject(udata);\n            }\n        }\n        return 0;\n    }\n    catch (Exception e)\n    {\n        return LuaAPI.luaL_error(L, &quot;c# exception in LuaGC:&quot; + e);\n    }\n}\n\n//从缓存池中删除\ninternal void collectObject(int obj_index_to_collect)\n{\n    object o;\n\n    if (objects.TryGetValue(obj_index_to_collect, out o))\n    {\n        objects.Remove(obj_index_to_collect);\n\n        if (o != null)\n        {\n            int obj_index;\n            //lua gc是先把weak table移除后再调用__gc，这期间同一个对象可能再次push到lua，关联到新的index\n            bool is_enum = o.GetType().IsEnum();\n            if ((is_enum ? enumMap.TryGetValue(o, out obj_index) : reverseMap.TryGetValue(o, out obj_index))\n                &amp;&amp; obj_index == obj_index_to_collect)\n            {\n                if (is_enum)\n                {\n                    enumMap.Remove(o);\n                }\n                else\n                {\n                    reverseMap.Remove(o);\n                }\n            }\n        }\n    }\n}</code></pre>\n<ul>\n<li>元表</li>\n</ul>\n<p>对于业务来说，我们只是单纯的把对象的索引传递过去，是远远不够的，我们还需要提供直接使用和操作对象的方法。前面我们提到，在我们把一个对象push到lua之前，我们会把对象类型所对应的元表提前注册到lua之中。这样在我们真正push一个对象时，就会用这个元表来设置操作这个对象的方法。</p>\n<p>首先第一个问题就是，如何表示c#对象的类型？回过头来看看我们的Push函数，其中最重要的就是getTypeId：</p>\n<p>首先会尝试从c#的类型缓存typeIdMap中检查是否已经注册过这种类型，如果没有的话，我们就需要为其生成一个type_id。</p>\n<p><strong>再从lua的类型缓存中用类型名来检索是否已经注册过这种类型，如果没有的话，意味着我们还没有为这种类型在lua中注册一个元表，继而通过TryDelayWrapLoader来生成这个类型的元表</strong>。</p>\n<pre><code class=\"csharp\">//\npublic void Push(RealStatePtr L, object o)\n{\n    //...\n    Type type = o.GetType();\n    bool is_first;\n    int type_id = getTypeId(L, type, out is_first);\n    //...\n}\n\n//这里再次吐槽getTypeId函数的设计和实现，为了保持清楚，我只保留能大体说明逻辑的的代码\ninternal int getTypeId(RealStatePtr L, Type type, out bool is_first, LOGLEVEL log_level = LOGLEVEL.WARN)\n{\n    //尝试获取c#中检索\n    if (typeIdMap.TryGetValue(type, out type_id)){return;}\n    //尝试从lua中检索\n    LuaAPI.luaL_getmetatable(L,type.FullName);\n    if (LuaAPI.lua_isnil(L, -1)) \n    {\n        LuaAPI.lua_pop(L, 1);\n        //获取类型的元表\n        if (TryDelayWrapLoader(L,  type))\n        {\n            LuaAPI.luaL_getmetatable(L, type.FullName);\n        }\n        else\n        {\n            throw new Exception(&quot;Fatal: can not load metatable of type:&quot; + type);\n        }\n    }\n    //生成新的type_id\n    type_id = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);\n    //注册到lua\n    LuaAPI.lua_pushnumber(L, type_id);\n    LuaAPI.xlua_rawseti(L, -2, 1);\n    LuaAPI.lua_pop(L, 1);\n\n    if (type.IsValueType())\n    {\n        typeMap.Add(type_id, type);\n    }\n\n    typeIdMap.Add(type, type_id);\n}</code></pre>\n<ul>\n<li>传递c#函数</li>\n</ul>\n<p>xlua通过lua_pushstdcallcfunction来push一个LuaCSFunction，其调用的时xlua.dll提供的xlua_push_csharp_function。</p>\n<pre><code class=\"csharp\"> //LUADLL.cs\npublic static void lua_pushstdcallcfunction(IntPtr L, lua_CSFunction function, int n = 0)//[-0, +1, m]\n{\n    IntPtr fn = Marshal.GetFunctionPointerForDelegate(function);\n    xlua_push_csharp_function(L, fn, n);\n}</code></pre>\n<p>最终提供给用户的是这两个接口：</p>\n<pre><code class=\"csharp\">internal void PushFixCSFunction(RealStatePtr L, LuaCSFunction func)\npublic void Push(RealStatePtr L, LuaCSFunction o)</code></pre>\n<p>这两个函数都做了一件事情，就是在LuaCSFunction函数push到lua之前，用另一个LuaCSFunction来包装了一层，用来做异常捕获。</p>\n<blockquote>\n<p>和gc一样，mono和lua有自己的异常</p>\n</blockquote>\n<p>两种索引方式的不同，使用在了不同的场景。</p>\n<p>PushFixCSFunction()大量被用在我们静态生成的元表构造器中，做为默认需要支持的类型的元表，注册进lua，并永久存在。而Push()被大量使用在反射生成的元表之中，在使用完之后，可能就会被释放。</p>\n<p>最后还有一个小细节，Push()中对IsStaticPInvokeCSFunction的函数没有加包装，因为这种类型的函数是我们静态生成的，在生成时，我们已经加入了异常捕获的代码，不需要再被捕获了。</p>\n<blockquote>\n<p>可以看到，一个函数在被调用之前，进行了多次的包装，每次包装都附带了一些额外的功能，但又对原函数没有侵入。（函数式编程，面向切片编程）</p>\n</blockquote>\n<ul>\n<li>其他push</li>\n</ul>\n<pre><code class=\"csharp\">//push一个lua在c#中的代理对象\npublic void Push(RealStatePtr L, LuaBase o)</code></pre>\n<p>LuaBase是c#对lua中特有的类型的封装。比如说LuaTable对应table、LuaFunction对应luafunction（此处不是luacfunction）。C#可以通过对应的类型去创建、操作一个lua原生对象。</p>\n<p>所以，LuaBase只是一个lua对象在c#中的代理，我们push一个LuaBase其实是找到真正的lua对象，并push。</p>\n<pre><code class=\"csharp\">//重载push一个decimal，避免gc\nvoid PushDecimal(RealStatePtr L, decimal val)</code></pre>\n<h4 id=\"HighLevelAPI\"><a href=\"#HighLevelAPI\" class=\"headerlink\" title=\"HighLevelAPI\"></a>HighLevelAPI</h4><p>对于HighLevelAPI，里面不包含具体的push实现，而是通过获取对象的类型，来选择性的调用类型所对应的具体push函数。</p>\n<p>可以看作类似是编译器的函数重载功能</p>\n<pre><code class=\"csharp\">public void PushAny(RealStatePtr L, object o)\npublic void PushByType&lt;T&gt;(RealStatePtr L,  T v)</code></pre>\n<ul>\n<li><p>顾名思义，PushAny()可以用来push所有的类型，可以被用在我们提前没法知道对象类型的地方。最典型的例子就是在反射生成元表时，我们动态的获取对象，通过PushAny()把类型未知的对象push到lua。</p>\n</li>\n<li><p>PushByType()是对PushAny()的封装，唯一的不同就是做了一个优化：<br>对于基元类型，不再调用pushPrimitive() （会有装箱/拆箱）,而是通过查表的方式直接获取针对各个基元类型的直接push的方式。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"相互调用\"><a href=\"#相互调用\" class=\"headerlink\" title=\"相互调用\"></a>相互调用</h2><p>原理：  C#与Lua进行交互主要通过虚拟栈实现</p>\n<h2 id=\"C-Call-Lua\"><a href=\"#C-Call-Lua\" class=\"headerlink\" title=\"C# Call Lua:\"></a>C# Call Lua:</h2><ul>\n<li>内存： 由C#先将数据放入栈中，由lua去栈中获取数据，然后返回数据对应的值到栈顶，再由栈顶返回至C#。</li>\n<li>代码： C#生成Bridge文件，Bridge调dll文件（dll是用C写的库），先调用lua中dll文件，由dll文件执行lua代码<br>C#-&gt;Bridge-&gt;dll-&gt;Lua  OR   C#-&gt;dll-&gt;Lua</li>\n</ul>\n<h2 id=\"Lua-Call-C\"><a href=\"#Lua-Call-C\" class=\"headerlink\" title=\"Lua Call C#:\"></a>Lua Call C#:</h2><ul>\n<li>内存： 先生成C#源文件所对应的Wrap文件或者编写C#源文件所对应的c模块，然后将源文件内容通过Wrap文件或者C模块注册到Lua解释器中，然后由Lua去调用这个模块的函数。</li>\n<li>代码：先生成Wrap文件（中间文件/适配文件），wrap文件把字段方法，注册到lua虚拟机中（解释器luajit），然后lua通过wrap就可以调C#了<br>或者在config文件中添加相应类型也可以</li>\n</ul>\n<h2 id=\"unity下的lua框架\"><a href=\"#unity下的lua框架\" class=\"headerlink\" title=\"unity下的lua框架\"></a>unity下的lua框架</h2><p>为了使基于unity开发的应用在移动平台能够热更新，我们嵌入了Lua虚拟机，将需要热更新的逻辑用lua实现。c#通过P/Invoke和lua交互（lua由ANSI C实现）。在这个过程中，由于数据的交换需要使用==lua提供的虚拟栈 #F44336==，不够简单高效，为了解决这个问题，我们引入了*lua框架（xlua、slua、ulua）来达到类似RPC式的函数调用、类原生对象式的对象访问以及高效的对象传递。</p>\n<h3 id=\"XLUA\"><a href=\"#XLUA\" class=\"headerlink\" title=\"XLUA\"></a>XLUA</h3><p>可以把xlua的push API归为两类：一类是针对某种特定类型的push，暂且叫做LowLevelAPI；还有一类是基于LowLevelAPI封装的更上层的HighLevelAPI。</p>\n<ul>\n<li>门面模式<br>使用HighLevelAPI时你只要简单的传入你想push的对象，HighLevelAPI会帮你找到最适合的LowLevelAPI调用，因为就算同一种类型的push方法，也可能有用户自定义的优化版本。而对于LowLevelAPI最终是需要调用xlua.dll中提供的C API来协调完成最终的工作。</li>\n</ul>\n<h4 id=\"LowLevelAPI\"><a href=\"#LowLevelAPI\" class=\"headerlink\" title=\"LowLevelAPI\"></a>LowLevelAPI</h4><pre><code class=\"csharp\">//using RealStatePtr = System.IntPtr;\n//using LuaCSFunction = XLua.LuaDLL.lua_CSFunction;\n//typedef int (*lua_CFunction) (lua_State *L);\n\n//ObjectTranslator.cs\nvoid pushPrimitive(RealStatePtr L, object o)\npublic void Push(RealStatePtr L, object o)\npublic void PushObject(RealStatePtr L, object o, int type_id)\npublic void Push(RealStatePtr L, LuaCSFunction o)\ninternal void PushFixCSFunction(RealStatePtr L, LuaCSFunction func)\npublic void Push(RealStatePtr L, LuaBase o)\npublic void PushDecimal(RealStatePtr L, decimal val)</code></pre>\n<ul>\n<li>传递基元类型</li>\n</ul>\n<p>基元类型为 Boolean、Byte、SByte、Int16、UInt16、Int32、UInt32、Int64、UInt64、UIntPtr、Char、Double、Single和IntPtr （对应的void*）。</p>\n<pre><code class=\"csharp\">void pushPrimitive(RealStatePtr L, object o)</code></pre>\n<p>XLUA中：</p>\n<pre><code class=\"csharp\">//push一个int\nLUA_API void xlua_pushinteger (lua_State *L, int n)\n//push一个double\n#define LUA_NUMBER    double\ntypedef LUA_NUMBER lua_Number;\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n)\n//push一个IntPtr\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p)</code></pre>\n<p>对于long，xlua定制：</p>\n<pre><code class=\"cpp\">//i64lib.c\n//在lua中表示c#中的long\ntypedef struct {\n    int fake_id;\n    int8_t type;\n    union {\n        int64_t i64;\n        uint64_t u64;\n    } data;\n} Integer64;</code></pre>\n<ul>\n<li>传递 object</li>\n</ul>\n<pre><code class=\"csharp\">public void Push(RealStatePtr L, object o)\npublic void PushObject(RealStatePtr L, object o, int type_id)</code></pre>\n<p>不管object是什么类型，最终的push都是使用:</p>\n<pre><code class=\"c\">LUA_API void xlua_pushcsobj(lua_State *L, int key, int meta_ref, int need_cache, int cache_ref) {\n    int* pointer = (int*)lua_newuserdata(L, sizeof(int));\n    *pointer = key;\n\n    if (need_cache) cacheud(L, key, cache_ref);\n\n    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);\n\n    lua_setmetatable(L, -2);\n}</code></pre>\n<p>为什么我们传给lua的对象是一个int类型（这里的key）？其实我们这里的key是我们要传递的c#对象的一个索引，我们可以通过这个索引找到这个c#对象。</p>\n<p>当传递一个c#对象的时候，我们创建一个userdate，并把这个索引值赋给这个userdata。然后，lua在全局注册表中，有一张专门的表用来存放c#各种类型所对应的元表，而<strong>meta_ref</strong>就是当前这个对象所对应类型的元表的索引id，我们通过他找到对应的元表，就可以通过setmetatable来绑定操作这个对象的方法。最终lua就可以愉快的使用这个对象。</p>\n<blockquote>\n<p>每种类型所对应的元表，是我们在push一种类型的对象之前，提前注册进来的，后面详述。</p>\n</blockquote>\n<p>但是对于引用类型的对象，其生命周期是有可能超出当前的调用栈的（比如lua用一个变量引用了这个对象） 。这时，我们就不仅要能够通过这个key找到c#原始对象，还要通过这个key能够找到对应的lua代理对象。因此，对于引用类型，我们在lua中同样也要建立一套索引机制，这就是need_cache和cache_ref的作用：</p>\n<pre><code class=\"c\">static void cacheud(lua_State *L, int key, int cache_ref) {\n    lua_rawgeti(L, LUA_REGISTRYINDEX, cache_ref);\n    lua_pushvalue(L, -2);\n    lua_rawseti(L, -2, key);\n    lua_pop(L, 1);\n}</code></pre>\n<ul>\n<li>缓存</li>\n</ul>\n<p>再回过头来看看c#中的索引和缓存机制：</p>\n<p>在调用xlua_pushcsobj之前,所有object都会被放入一个对象的缓存池中ObjectTranslator.objects。而我们得到的key就是这个对象在缓存池中的下标。</p>\n<ul>\n<li>gc</li>\n</ul>\n<p>对于引用类型，它的生命周期管理会略微复杂。<strong>mono和lua虚拟机有各自的gc系统</strong>，并且相互无法感知。当lua和c#同时引用一个对象时，我们需要能够保证对象生命周期的正确，不能一边还在引用，另一边却把它释放掉了。</p>\n<p>这个过程是由lua的gc驱动的。我们<strong>把对象push到lua时，会缓存在c#的对象池中，所以是不会被mono的gc所释放掉，这样就保证了lua能够安全的持有c#对象。同时我们也会把这个对象的代理缓存到lua中，而lua中对象的缓存表是一个弱表，也就是说，当没有其他的lua引用这个对象时，lua的gc会把这个对象从lua的缓存中回收</strong>，而对象被gc回收的过程会触发这个对象的的__gc元方法。</p>\n<p>而这个__gc元方法就会通知到c#这端，来告诉我们lua不再使用这个对象，我们可以把它从对象缓存池中移除。当没有其他c#对其的引用时，mono的gc就会正常的回收这个对象。</p>\n<pre><code class=\"csharp\">//StaticLuaCallback.cs\n//__gc元方法：\npublic static int LuaGC(RealStatePtr L)\n{\n    try\n    {\n        int udata = LuaAPI.xlua_tocsobj_safe(L, 1);\n        if (udata != -1)\n        {\n            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);\n            if ( translator != null )\n            {\n                translator.collectObject(udata);\n            }\n        }\n        return 0;\n    }\n    catch (Exception e)\n    {\n        return LuaAPI.luaL_error(L, &quot;c# exception in LuaGC:&quot; + e);\n    }\n}\n\n//从缓存池中删除\ninternal void collectObject(int obj_index_to_collect)\n{\n    object o;\n\n    if (objects.TryGetValue(obj_index_to_collect, out o))\n    {\n        objects.Remove(obj_index_to_collect);\n\n        if (o != null)\n        {\n            int obj_index;\n            //lua gc是先把weak table移除后再调用__gc，这期间同一个对象可能再次push到lua，关联到新的index\n            bool is_enum = o.GetType().IsEnum();\n            if ((is_enum ? enumMap.TryGetValue(o, out obj_index) : reverseMap.TryGetValue(o, out obj_index))\n                &amp;&amp; obj_index == obj_index_to_collect)\n            {\n                if (is_enum)\n                {\n                    enumMap.Remove(o);\n                }\n                else\n                {\n                    reverseMap.Remove(o);\n                }\n            }\n        }\n    }\n}</code></pre>\n<ul>\n<li>元表</li>\n</ul>\n<p>对于业务来说，我们只是单纯的把对象的索引传递过去，是远远不够的，我们还需要提供直接使用和操作对象的方法。前面我们提到，在我们把一个对象push到lua之前，我们会把对象类型所对应的元表提前注册到lua之中。这样在我们真正push一个对象时，就会用这个元表来设置操作这个对象的方法。</p>\n<p>首先第一个问题就是，如何表示c#对象的类型？回过头来看看我们的Push函数，其中最重要的就是getTypeId：</p>\n<p>首先会尝试从c#的类型缓存typeIdMap中检查是否已经注册过这种类型，如果没有的话，我们就需要为其生成一个type_id。</p>\n<p><strong>再从lua的类型缓存中用类型名来检索是否已经注册过这种类型，如果没有的话，意味着我们还没有为这种类型在lua中注册一个元表，继而通过TryDelayWrapLoader来生成这个类型的元表</strong>。</p>\n<pre><code class=\"csharp\">//\npublic void Push(RealStatePtr L, object o)\n{\n    //...\n    Type type = o.GetType();\n    bool is_first;\n    int type_id = getTypeId(L, type, out is_first);\n    //...\n}\n\n//这里再次吐槽getTypeId函数的设计和实现，为了保持清楚，我只保留能大体说明逻辑的的代码\ninternal int getTypeId(RealStatePtr L, Type type, out bool is_first, LOGLEVEL log_level = LOGLEVEL.WARN)\n{\n    //尝试获取c#中检索\n    if (typeIdMap.TryGetValue(type, out type_id)){return;}\n    //尝试从lua中检索\n    LuaAPI.luaL_getmetatable(L,type.FullName);\n    if (LuaAPI.lua_isnil(L, -1)) \n    {\n        LuaAPI.lua_pop(L, 1);\n        //获取类型的元表\n        if (TryDelayWrapLoader(L,  type))\n        {\n            LuaAPI.luaL_getmetatable(L, type.FullName);\n        }\n        else\n        {\n            throw new Exception(&quot;Fatal: can not load metatable of type:&quot; + type);\n        }\n    }\n    //生成新的type_id\n    type_id = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);\n    //注册到lua\n    LuaAPI.lua_pushnumber(L, type_id);\n    LuaAPI.xlua_rawseti(L, -2, 1);\n    LuaAPI.lua_pop(L, 1);\n\n    if (type.IsValueType())\n    {\n        typeMap.Add(type_id, type);\n    }\n\n    typeIdMap.Add(type, type_id);\n}</code></pre>\n<ul>\n<li>传递c#函数</li>\n</ul>\n<p>xlua通过lua_pushstdcallcfunction来push一个LuaCSFunction，其调用的时xlua.dll提供的xlua_push_csharp_function。</p>\n<pre><code class=\"csharp\"> //LUADLL.cs\npublic static void lua_pushstdcallcfunction(IntPtr L, lua_CSFunction function, int n = 0)//[-0, +1, m]\n{\n    IntPtr fn = Marshal.GetFunctionPointerForDelegate(function);\n    xlua_push_csharp_function(L, fn, n);\n}</code></pre>\n<p>最终提供给用户的是这两个接口：</p>\n<pre><code class=\"csharp\">internal void PushFixCSFunction(RealStatePtr L, LuaCSFunction func)\npublic void Push(RealStatePtr L, LuaCSFunction o)</code></pre>\n<p>这两个函数都做了一件事情，就是在LuaCSFunction函数push到lua之前，用另一个LuaCSFunction来包装了一层，用来做异常捕获。</p>\n<blockquote>\n<p>和gc一样，mono和lua有自己的异常</p>\n</blockquote>\n<p>两种索引方式的不同，使用在了不同的场景。</p>\n<p>PushFixCSFunction()大量被用在我们静态生成的元表构造器中，做为默认需要支持的类型的元表，注册进lua，并永久存在。而Push()被大量使用在反射生成的元表之中，在使用完之后，可能就会被释放。</p>\n<p>最后还有一个小细节，Push()中对IsStaticPInvokeCSFunction的函数没有加包装，因为这种类型的函数是我们静态生成的，在生成时，我们已经加入了异常捕获的代码，不需要再被捕获了。</p>\n<blockquote>\n<p>可以看到，一个函数在被调用之前，进行了多次的包装，每次包装都附带了一些额外的功能，但又对原函数没有侵入。（函数式编程，面向切片编程）</p>\n</blockquote>\n<ul>\n<li>其他push</li>\n</ul>\n<pre><code class=\"csharp\">//push一个lua在c#中的代理对象\npublic void Push(RealStatePtr L, LuaBase o)</code></pre>\n<p>LuaBase是c#对lua中特有的类型的封装。比如说LuaTable对应table、LuaFunction对应luafunction（此处不是luacfunction）。C#可以通过对应的类型去创建、操作一个lua原生对象。</p>\n<p>所以，LuaBase只是一个lua对象在c#中的代理，我们push一个LuaBase其实是找到真正的lua对象，并push。</p>\n<pre><code class=\"csharp\">//重载push一个decimal，避免gc\nvoid PushDecimal(RealStatePtr L, decimal val)</code></pre>\n<h4 id=\"HighLevelAPI\"><a href=\"#HighLevelAPI\" class=\"headerlink\" title=\"HighLevelAPI\"></a>HighLevelAPI</h4><p>对于HighLevelAPI，里面不包含具体的push实现，而是通过获取对象的类型，来选择性的调用类型所对应的具体push函数。</p>\n<p>可以看作类似是编译器的函数重载功能</p>\n<pre><code class=\"csharp\">public void PushAny(RealStatePtr L, object o)\npublic void PushByType&lt;T&gt;(RealStatePtr L,  T v)</code></pre>\n<ul>\n<li><p>顾名思义，PushAny()可以用来push所有的类型，可以被用在我们提前没法知道对象类型的地方。最典型的例子就是在反射生成元表时，我们动态的获取对象，通过PushAny()把类型未知的对象push到lua。</p>\n</li>\n<li><p>PushByType()是对PushAny()的封装，唯一的不同就是做了一个优化：<br>对于基元类型，不再调用pushPrimitive() （会有装箱/拆箱）,而是通过查表的方式直接获取针对各个基元类型的直接push的方式。</p>\n</li>\n</ul>\n"},{"title":"贝塞尔曲线","_content":"转自： https://www.zhihu.com/question/29565629\n\n贝塞尔曲线的历史:贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝济埃（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计,贝塞尔曲线最初由保尔·德·卡斯特里奥于1959年运用德卡斯特里奥算法开发，以稳定数值的方法求出贝塞尔曲线.\nhttps://www.jasondavies.com/animated-bezier/\n\n\n ![一阶曲线](/img/1608803433152.png)\n \n ![二阶曲线](/img/1608803453009.png)\n \n ![二阶曲线方程](/img/1608803474166.png)\n \n ![三阶曲线方程](/img/1608804894728.png)\n \n 如果仔细观察这些曲线，你会立即注意到：\n* 控制点不总是在曲线上这是非常正常的，稍后我们将看到曲线是如何构建的。\n* 曲线的阶次等于控制点的数量减一。 对于两个点我们能得到一条线性曲线（直线），三个点 — 一条二阶曲线，四个点 — 一条三阶曲线。\n* 曲线总是在控制点的凸包内部：\n\n实现：\n\n``` csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BezierTest : MonoBehaviour\n{\n    public struct SplineData\n    {\n        public Vector3 P0;\n        public Vector3 P1; \n    }\n    public GameObject SampleObj;\n    private List<GameObject> allObjs = new List<GameObject>();\n    private List<Vector3> allPoss = new List<Vector3>();\n\n    public LineRenderer lineRender;\n\n    private int curPoints = 0;\n    public int PointCount = 3;\n\n    public int LinePointCount = 20;\n\n    public bool Gen = false;\n\n    private int temp;\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        if (PointCount != curPoints)\n        {\n            CreatePointObj();\n            curPoints = PointCount;\n            Gen = true;\n        }\n\n        if (CheckChangePos())\n            Gen = true;\n        \n        if (!Gen)\n            return;\n        \n        SetLineRender();\n        Gen = false;\n    }\n\n    void CreatePointObj()\n    {\n        foreach (var obj in allObjs)\n        {\n            Destroy(obj);\n        }\n        \n        allObjs.Clear();\n\n        for (int i = 0; i < PointCount; i++)\n        {\n            GameObject go = GameObject.Instantiate(SampleObj);\n            go.transform.position = new Vector3(i,i,i);\n            go.transform.localScale = new Vector3(0.2f,0.2f,0.2f);\n            allObjs.Add(go);\n        }\n        \n        allPoss.Clear();\n        foreach (var go in allObjs)\n        {\n            allPoss.Add(go.transform.position);\n        }\n    }\n\n    public bool CheckChangePos()\n    {\n        bool isChanged = false;\n        for (int i = 0; i < allObjs.Count; i++)\n        {\n            if (isChange(allObjs[i].transform.position, allPoss[i]))\n            {\n                temp = i;\n                allPoss[i] = allObjs[i].transform.position;\n                isChanged = true;\n            }\n        }\n\n        return isChanged;\n    }\n\n    public bool isChange(Vector3 p1, Vector3 p2)\n    {\n        float absX = Mathf.Abs(p1.x - p2.x);\n        float absY = Mathf.Abs(p1.y - p2.y);\n        float absZ = Mathf.Abs(p1.z - p2.z);\n\n        if (absX > 0.1f || absY > 0.1f || absZ > 0.1f)\n            return true;\n\n        return false;\n    }\n    \n\n\n    public void SetLineRender()\n    {\n        \n        \n        List<Vector3> allVectors = new List<Vector3>();\n\n        if (LinePointCount > 0)\n        {\n            float step = 1.0f / LinePointCount;\n            for (int i = 0; i < LinePointCount+1; i++)\n            {\n                \n                Vector3 bezierPos = GetAllPos(i* step, ConvertVectorToSplines(allPoss));\n                allVectors.Add(bezierPos);\n            }\n        }\n\n        lineRender.useWorldSpace = true;\n        lineRender.positionCount = LinePointCount+1;\n        lineRender.SetPositions(allVectors.ToArray());\n    }\n \n    public Vector3 GetAllPos(float t, List<SplineData> allData)\n    {\n        if (allData.Count == 1)\n        {\n            return GetBezierPos(t, allData[0].P0, allData[0].P1);\n        }\n        else\n        {\n            List<Vector3> nVector3s = new List<Vector3>();\n            foreach (var spline in allData)\n            {\n                nVector3s.Add(GetBezierPos(t, spline.P0, spline.P1));\n            }\n\n            List<SplineData> genSplines = ConvertVectorToSplines(nVector3s);\n            return GetAllPos(t, genSplines);\n        }\n    }\n    \n    \n\n    public List<SplineData> ConvertVectorToSplines(List<Vector3> allVs)\n    {\n        List<SplineData> result  = new List<SplineData>();\n        for (int i = 0; i < allVs.Count; i++)\n        {\n            int next = i + 1;\n            if (next >= allVs.Count)\n            {\n                break;\n            }\n            result.Add(new SplineData(){\n                P0 = allVs[i],\n                P1 = allVs[next]\n            });\n        }\n\n        return result;\n    }\n    \n    public Vector3 GetBezierPos(float t, Vector3 p0, Vector3 p1)\n    {\n        return (1 - t) * p0 + t * p1;\n    }\n    \n    public Vector3 GetBezierPos(float t, Vector3 p0, Vector3 p1, Vector3 p2)\n    {\n        return Mathf.Pow(1 - t, 2) * p0 + 2 * t * (1 - t) * p1 + Mathf.Pow(t, 2) * p2;\n    }\n}\n```\n\n","source":"_posts/贝塞尔曲线.md","raw":"---\ntitle: 贝塞尔曲线\ncategories:\n- Unity\n---\n转自： https://www.zhihu.com/question/29565629\n\n贝塞尔曲线的历史:贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝济埃（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计,贝塞尔曲线最初由保尔·德·卡斯特里奥于1959年运用德卡斯特里奥算法开发，以稳定数值的方法求出贝塞尔曲线.\nhttps://www.jasondavies.com/animated-bezier/\n\n\n ![一阶曲线](/img/1608803433152.png)\n \n ![二阶曲线](/img/1608803453009.png)\n \n ![二阶曲线方程](/img/1608803474166.png)\n \n ![三阶曲线方程](/img/1608804894728.png)\n \n 如果仔细观察这些曲线，你会立即注意到：\n* 控制点不总是在曲线上这是非常正常的，稍后我们将看到曲线是如何构建的。\n* 曲线的阶次等于控制点的数量减一。 对于两个点我们能得到一条线性曲线（直线），三个点 — 一条二阶曲线，四个点 — 一条三阶曲线。\n* 曲线总是在控制点的凸包内部：\n\n实现：\n\n``` csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BezierTest : MonoBehaviour\n{\n    public struct SplineData\n    {\n        public Vector3 P0;\n        public Vector3 P1; \n    }\n    public GameObject SampleObj;\n    private List<GameObject> allObjs = new List<GameObject>();\n    private List<Vector3> allPoss = new List<Vector3>();\n\n    public LineRenderer lineRender;\n\n    private int curPoints = 0;\n    public int PointCount = 3;\n\n    public int LinePointCount = 20;\n\n    public bool Gen = false;\n\n    private int temp;\n    // Start is called before the first frame update\n    void Start()\n    {\n        \n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        if (PointCount != curPoints)\n        {\n            CreatePointObj();\n            curPoints = PointCount;\n            Gen = true;\n        }\n\n        if (CheckChangePos())\n            Gen = true;\n        \n        if (!Gen)\n            return;\n        \n        SetLineRender();\n        Gen = false;\n    }\n\n    void CreatePointObj()\n    {\n        foreach (var obj in allObjs)\n        {\n            Destroy(obj);\n        }\n        \n        allObjs.Clear();\n\n        for (int i = 0; i < PointCount; i++)\n        {\n            GameObject go = GameObject.Instantiate(SampleObj);\n            go.transform.position = new Vector3(i,i,i);\n            go.transform.localScale = new Vector3(0.2f,0.2f,0.2f);\n            allObjs.Add(go);\n        }\n        \n        allPoss.Clear();\n        foreach (var go in allObjs)\n        {\n            allPoss.Add(go.transform.position);\n        }\n    }\n\n    public bool CheckChangePos()\n    {\n        bool isChanged = false;\n        for (int i = 0; i < allObjs.Count; i++)\n        {\n            if (isChange(allObjs[i].transform.position, allPoss[i]))\n            {\n                temp = i;\n                allPoss[i] = allObjs[i].transform.position;\n                isChanged = true;\n            }\n        }\n\n        return isChanged;\n    }\n\n    public bool isChange(Vector3 p1, Vector3 p2)\n    {\n        float absX = Mathf.Abs(p1.x - p2.x);\n        float absY = Mathf.Abs(p1.y - p2.y);\n        float absZ = Mathf.Abs(p1.z - p2.z);\n\n        if (absX > 0.1f || absY > 0.1f || absZ > 0.1f)\n            return true;\n\n        return false;\n    }\n    \n\n\n    public void SetLineRender()\n    {\n        \n        \n        List<Vector3> allVectors = new List<Vector3>();\n\n        if (LinePointCount > 0)\n        {\n            float step = 1.0f / LinePointCount;\n            for (int i = 0; i < LinePointCount+1; i++)\n            {\n                \n                Vector3 bezierPos = GetAllPos(i* step, ConvertVectorToSplines(allPoss));\n                allVectors.Add(bezierPos);\n            }\n        }\n\n        lineRender.useWorldSpace = true;\n        lineRender.positionCount = LinePointCount+1;\n        lineRender.SetPositions(allVectors.ToArray());\n    }\n \n    public Vector3 GetAllPos(float t, List<SplineData> allData)\n    {\n        if (allData.Count == 1)\n        {\n            return GetBezierPos(t, allData[0].P0, allData[0].P1);\n        }\n        else\n        {\n            List<Vector3> nVector3s = new List<Vector3>();\n            foreach (var spline in allData)\n            {\n                nVector3s.Add(GetBezierPos(t, spline.P0, spline.P1));\n            }\n\n            List<SplineData> genSplines = ConvertVectorToSplines(nVector3s);\n            return GetAllPos(t, genSplines);\n        }\n    }\n    \n    \n\n    public List<SplineData> ConvertVectorToSplines(List<Vector3> allVs)\n    {\n        List<SplineData> result  = new List<SplineData>();\n        for (int i = 0; i < allVs.Count; i++)\n        {\n            int next = i + 1;\n            if (next >= allVs.Count)\n            {\n                break;\n            }\n            result.Add(new SplineData(){\n                P0 = allVs[i],\n                P1 = allVs[next]\n            });\n        }\n\n        return result;\n    }\n    \n    public Vector3 GetBezierPos(float t, Vector3 p0, Vector3 p1)\n    {\n        return (1 - t) * p0 + t * p1;\n    }\n    \n    public Vector3 GetBezierPos(float t, Vector3 p0, Vector3 p1, Vector3 p2)\n    {\n        return Mathf.Pow(1 - t, 2) * p0 + 2 * t * (1 - t) * p1 + Mathf.Pow(t, 2) * p2;\n    }\n}\n```\n\n","slug":"贝塞尔曲线","published":1,"date":"2020-12-26T09:16:48.222Z","updated":"2020-12-26T09:16:48.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckj5hqckw00023ff0fn80ushs","content":"<p>转自： <a href=\"https://www.zhihu.com/question/29565629\">https://www.zhihu.com/question/29565629</a></p>\n<p>贝塞尔曲线的历史:贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝济埃（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计,贝塞尔曲线最初由保尔·德·卡斯特里奥于1959年运用德卡斯特里奥算法开发，以稳定数值的方法求出贝塞尔曲线.<br><a href=\"https://www.jasondavies.com/animated-bezier/\">https://www.jasondavies.com/animated-bezier/</a></p>\n<p> <img src=\"/img/1608803433152.png\" alt=\"一阶曲线\"></p>\n<p> <img src=\"/img/1608803453009.png\" alt=\"二阶曲线\"></p>\n<p> <img src=\"/img/1608803474166.png\" alt=\"二阶曲线方程\"></p>\n<p> <img src=\"/img/1608804894728.png\" alt=\"三阶曲线方程\"></p>\n<p> 如果仔细观察这些曲线，你会立即注意到：</p>\n<ul>\n<li>控制点不总是在曲线上这是非常正常的，稍后我们将看到曲线是如何构建的。</li>\n<li>曲线的阶次等于控制点的数量减一。 对于两个点我们能得到一条线性曲线（直线），三个点 — 一条二阶曲线，四个点 — 一条三阶曲线。</li>\n<li>曲线总是在控制点的凸包内部：</li>\n</ul>\n<p>实现：</p>\n<pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BezierTest : MonoBehaviour\n{\n    public struct SplineData\n    {\n        public Vector3 P0;\n        public Vector3 P1; \n    }\n    public GameObject SampleObj;\n    private List&lt;GameObject&gt; allObjs = new List&lt;GameObject&gt;();\n    private List&lt;Vector3&gt; allPoss = new List&lt;Vector3&gt;();\n\n    public LineRenderer lineRender;\n\n    private int curPoints = 0;\n    public int PointCount = 3;\n\n    public int LinePointCount = 20;\n\n    public bool Gen = false;\n\n    private int temp;\n    // Start is called before the first frame update\n    void Start()\n    {\n\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        if (PointCount != curPoints)\n        {\n            CreatePointObj();\n            curPoints = PointCount;\n            Gen = true;\n        }\n\n        if (CheckChangePos())\n            Gen = true;\n\n        if (!Gen)\n            return;\n\n        SetLineRender();\n        Gen = false;\n    }\n\n    void CreatePointObj()\n    {\n        foreach (var obj in allObjs)\n        {\n            Destroy(obj);\n        }\n\n        allObjs.Clear();\n\n        for (int i = 0; i &lt; PointCount; i++)\n        {\n            GameObject go = GameObject.Instantiate(SampleObj);\n            go.transform.position = new Vector3(i,i,i);\n            go.transform.localScale = new Vector3(0.2f,0.2f,0.2f);\n            allObjs.Add(go);\n        }\n\n        allPoss.Clear();\n        foreach (var go in allObjs)\n        {\n            allPoss.Add(go.transform.position);\n        }\n    }\n\n    public bool CheckChangePos()\n    {\n        bool isChanged = false;\n        for (int i = 0; i &lt; allObjs.Count; i++)\n        {\n            if (isChange(allObjs[i].transform.position, allPoss[i]))\n            {\n                temp = i;\n                allPoss[i] = allObjs[i].transform.position;\n                isChanged = true;\n            }\n        }\n\n        return isChanged;\n    }\n\n    public bool isChange(Vector3 p1, Vector3 p2)\n    {\n        float absX = Mathf.Abs(p1.x - p2.x);\n        float absY = Mathf.Abs(p1.y - p2.y);\n        float absZ = Mathf.Abs(p1.z - p2.z);\n\n        if (absX &gt; 0.1f || absY &gt; 0.1f || absZ &gt; 0.1f)\n            return true;\n\n        return false;\n    }\n\n\n\n    public void SetLineRender()\n    {\n\n\n        List&lt;Vector3&gt; allVectors = new List&lt;Vector3&gt;();\n\n        if (LinePointCount &gt; 0)\n        {\n            float step = 1.0f / LinePointCount;\n            for (int i = 0; i &lt; LinePointCount+1; i++)\n            {\n\n                Vector3 bezierPos = GetAllPos(i* step, ConvertVectorToSplines(allPoss));\n                allVectors.Add(bezierPos);\n            }\n        }\n\n        lineRender.useWorldSpace = true;\n        lineRender.positionCount = LinePointCount+1;\n        lineRender.SetPositions(allVectors.ToArray());\n    }\n\n    public Vector3 GetAllPos(float t, List&lt;SplineData&gt; allData)\n    {\n        if (allData.Count == 1)\n        {\n            return GetBezierPos(t, allData[0].P0, allData[0].P1);\n        }\n        else\n        {\n            List&lt;Vector3&gt; nVector3s = new List&lt;Vector3&gt;();\n            foreach (var spline in allData)\n            {\n                nVector3s.Add(GetBezierPos(t, spline.P0, spline.P1));\n            }\n\n            List&lt;SplineData&gt; genSplines = ConvertVectorToSplines(nVector3s);\n            return GetAllPos(t, genSplines);\n        }\n    }\n\n\n\n    public List&lt;SplineData&gt; ConvertVectorToSplines(List&lt;Vector3&gt; allVs)\n    {\n        List&lt;SplineData&gt; result  = new List&lt;SplineData&gt;();\n        for (int i = 0; i &lt; allVs.Count; i++)\n        {\n            int next = i + 1;\n            if (next &gt;= allVs.Count)\n            {\n                break;\n            }\n            result.Add(new SplineData(){\n                P0 = allVs[i],\n                P1 = allVs[next]\n            });\n        }\n\n        return result;\n    }\n\n    public Vector3 GetBezierPos(float t, Vector3 p0, Vector3 p1)\n    {\n        return (1 - t) * p0 + t * p1;\n    }\n\n    public Vector3 GetBezierPos(float t, Vector3 p0, Vector3 p1, Vector3 p2)\n    {\n        return Mathf.Pow(1 - t, 2) * p0 + 2 * t * (1 - t) * p1 + Mathf.Pow(t, 2) * p2;\n    }\n}</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>转自： <a href=\"https://www.zhihu.com/question/29565629\">https://www.zhihu.com/question/29565629</a></p>\n<p>贝塞尔曲线的历史:贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝济埃（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计,贝塞尔曲线最初由保尔·德·卡斯特里奥于1959年运用德卡斯特里奥算法开发，以稳定数值的方法求出贝塞尔曲线.<br><a href=\"https://www.jasondavies.com/animated-bezier/\">https://www.jasondavies.com/animated-bezier/</a></p>\n<p> <img src=\"/img/1608803433152.png\" alt=\"一阶曲线\"></p>\n<p> <img src=\"/img/1608803453009.png\" alt=\"二阶曲线\"></p>\n<p> <img src=\"/img/1608803474166.png\" alt=\"二阶曲线方程\"></p>\n<p> <img src=\"/img/1608804894728.png\" alt=\"三阶曲线方程\"></p>\n<p> 如果仔细观察这些曲线，你会立即注意到：</p>\n<ul>\n<li>控制点不总是在曲线上这是非常正常的，稍后我们将看到曲线是如何构建的。</li>\n<li>曲线的阶次等于控制点的数量减一。 对于两个点我们能得到一条线性曲线（直线），三个点 — 一条二阶曲线，四个点 — 一条三阶曲线。</li>\n<li>曲线总是在控制点的凸包内部：</li>\n</ul>\n<p>实现：</p>\n<pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BezierTest : MonoBehaviour\n{\n    public struct SplineData\n    {\n        public Vector3 P0;\n        public Vector3 P1; \n    }\n    public GameObject SampleObj;\n    private List&lt;GameObject&gt; allObjs = new List&lt;GameObject&gt;();\n    private List&lt;Vector3&gt; allPoss = new List&lt;Vector3&gt;();\n\n    public LineRenderer lineRender;\n\n    private int curPoints = 0;\n    public int PointCount = 3;\n\n    public int LinePointCount = 20;\n\n    public bool Gen = false;\n\n    private int temp;\n    // Start is called before the first frame update\n    void Start()\n    {\n\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        if (PointCount != curPoints)\n        {\n            CreatePointObj();\n            curPoints = PointCount;\n            Gen = true;\n        }\n\n        if (CheckChangePos())\n            Gen = true;\n\n        if (!Gen)\n            return;\n\n        SetLineRender();\n        Gen = false;\n    }\n\n    void CreatePointObj()\n    {\n        foreach (var obj in allObjs)\n        {\n            Destroy(obj);\n        }\n\n        allObjs.Clear();\n\n        for (int i = 0; i &lt; PointCount; i++)\n        {\n            GameObject go = GameObject.Instantiate(SampleObj);\n            go.transform.position = new Vector3(i,i,i);\n            go.transform.localScale = new Vector3(0.2f,0.2f,0.2f);\n            allObjs.Add(go);\n        }\n\n        allPoss.Clear();\n        foreach (var go in allObjs)\n        {\n            allPoss.Add(go.transform.position);\n        }\n    }\n\n    public bool CheckChangePos()\n    {\n        bool isChanged = false;\n        for (int i = 0; i &lt; allObjs.Count; i++)\n        {\n            if (isChange(allObjs[i].transform.position, allPoss[i]))\n            {\n                temp = i;\n                allPoss[i] = allObjs[i].transform.position;\n                isChanged = true;\n            }\n        }\n\n        return isChanged;\n    }\n\n    public bool isChange(Vector3 p1, Vector3 p2)\n    {\n        float absX = Mathf.Abs(p1.x - p2.x);\n        float absY = Mathf.Abs(p1.y - p2.y);\n        float absZ = Mathf.Abs(p1.z - p2.z);\n\n        if (absX &gt; 0.1f || absY &gt; 0.1f || absZ &gt; 0.1f)\n            return true;\n\n        return false;\n    }\n\n\n\n    public void SetLineRender()\n    {\n\n\n        List&lt;Vector3&gt; allVectors = new List&lt;Vector3&gt;();\n\n        if (LinePointCount &gt; 0)\n        {\n            float step = 1.0f / LinePointCount;\n            for (int i = 0; i &lt; LinePointCount+1; i++)\n            {\n\n                Vector3 bezierPos = GetAllPos(i* step, ConvertVectorToSplines(allPoss));\n                allVectors.Add(bezierPos);\n            }\n        }\n\n        lineRender.useWorldSpace = true;\n        lineRender.positionCount = LinePointCount+1;\n        lineRender.SetPositions(allVectors.ToArray());\n    }\n\n    public Vector3 GetAllPos(float t, List&lt;SplineData&gt; allData)\n    {\n        if (allData.Count == 1)\n        {\n            return GetBezierPos(t, allData[0].P0, allData[0].P1);\n        }\n        else\n        {\n            List&lt;Vector3&gt; nVector3s = new List&lt;Vector3&gt;();\n            foreach (var spline in allData)\n            {\n                nVector3s.Add(GetBezierPos(t, spline.P0, spline.P1));\n            }\n\n            List&lt;SplineData&gt; genSplines = ConvertVectorToSplines(nVector3s);\n            return GetAllPos(t, genSplines);\n        }\n    }\n\n\n\n    public List&lt;SplineData&gt; ConvertVectorToSplines(List&lt;Vector3&gt; allVs)\n    {\n        List&lt;SplineData&gt; result  = new List&lt;SplineData&gt;();\n        for (int i = 0; i &lt; allVs.Count; i++)\n        {\n            int next = i + 1;\n            if (next &gt;= allVs.Count)\n            {\n                break;\n            }\n            result.Add(new SplineData(){\n                P0 = allVs[i],\n                P1 = allVs[next]\n            });\n        }\n\n        return result;\n    }\n\n    public Vector3 GetBezierPos(float t, Vector3 p0, Vector3 p1)\n    {\n        return (1 - t) * p0 + t * p1;\n    }\n\n    public Vector3 GetBezierPos(float t, Vector3 p0, Vector3 p1, Vector3 p2)\n    {\n        return Mathf.Pow(1 - t, 2) * p0 + 2 * t * (1 - t) * p1 + Mathf.Pow(t, 2) * p2;\n    }\n}</code></pre>\n"},{"title":"Python知识汇总1","_content":"\n# 总概\n\n## 1.Old-style, New-style class\n\n\n```python\nOld-style classes\n\nclass Person():\n    _names_cache = {}\n    def __init__(self,name):\n        self.name = name\n    def __new__(cls,name):\n        return cls._names_cache.setdefault(name,object.__new__(cls,name))\n\nahmed1 = Person(\"Ahmed\")\nahmed2 = Person(\"Ahmed\")\nprint ahmed1 is ahmed2\nprint ahmed1\nprint ahmed2\n\n\n# >>> False\n# <__main__.Person instance at 0xb74acf8c>\n# <__main__.Person instance at 0xb74ac6cc>\n# >>>\n\nNew-style classes\n\nclass Person(object):\n    _names_cache = {}\n    def __init__(self,name):\n        self.name = name\n    def __new__(cls,name):\n        return cls._names_cache.setdefault(name,object.__new__(cls,name))\n\nahmed1 = Person(\"Ahmed\")\nahmed2 = Person(\"Ahmed\")\nprint ahmed2 is ahmed1\nprint ahmed1\nprint ahmed2\n\n# >>> True\n# <__main__.Person object at 0xb74ac66c>\n# <__main__.Person object at 0xb74ac66c>\n# >>>\n```\n\n\n## 2.字符串拼接的性能对比\n\n\n```python\nimport random\n\nL = 400000\n\ns1 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns2 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns3 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns4 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns5 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\n\nimport timeit\nm = 2000\nprint timeit.Timer('s=\"\".join((s1,s2,s3,s4,s5))', 'from __main__ import s1,s2,s3,s4,s5').timeit(m)  # 性能最佳\nprint timeit.Timer('s=string.join((s1,s2,s3,s4,s5))', 'from __main__ import s1,s2,s3,s4,s5; import string').timeit(m) # 性能较好\nprint timeit.Timer('s=s1; s+=s2; s+=s3; s+=s4; s+=s5', 'from __main__ import s1,s2,s3,s4,s5').timeit(m) # 较差\nprint timeit.Timer('s=s1+s2+s3+s4+s5', 'from __main__ import s1,s2,s3,s4,s5').timeit(m)# 较差\nprint timeit.Timer('s=\"%s%s%s%s%s\"%(s1,s2,s3,s4,s5)', 'from __main__ import s1,s2,s3,s4,s5').timeit(m)# 较差\n\n```\n\n## 3.对象类型\n* 一切都是对象, int,float等基础类型都是对象。但除了关键字！\n\n```python\nisinstance(type(A), object)\nisinstance(type(type(A)), object)\nisinstance(type, object)\nisinstance(staticmethod, object)\n```\n\n>> import, class, def, pass, return 等不是对象\n>> python3.x 以后print是对象，python2.x则不是对象\n\n## 4.迭代器\n自定义迭代器实现：\n* __init__函数 \n* next 函数 \n\n迭代器的使用，如图非标注的函数返回不是迭代器，则会产生一定的性能问题\n![迭代器的使用](/img/2021/1.png)\n\n简单实例\n![简单实例](/img/2021/2.png)\n\n\n* 方法一：自定义迭代器\n```\nclass FooIterator(object):\n    def __init__(self, foo):\n        self._list = foo\n        self._cur = 0\n\n    def next(self):\n        if self._cur < len(self._list):\n            res = self._list[self._cur]\n            self._cur += 1\n            return res\n        else:\n            return StopIteration\n\nclass Foo(object):\n    def __init__(self):\n        self._list = [1,2,3,4,5]\n\n    def __iter__(self):\n        return FooIterator(self)\n\n    def __len__(self):\n        return len(self._list)\n\n    def __getitem__(self, item):\n        return self._list[item]\n\na = Foo()\nfor a1 in a:\n    for b1 in a:\n        if a1 is StopIteration:\n            break\n        if b1 is StopIteration:\n            break\n        print (a1,b1)\n```\n\n* 方法二：使用对象自带的迭代器\n\n```python\nclass Foo(object):\n    def __init__(self):\n        self._list = [1,2,3,4,5]\n\n    def __iter__(self):\n        return iter(self._list)\n\n    def __len__(self):\n        return len(self._list)\n\n    def __getitem__(self, item):\n        return self._list[item]\n```\n\n* 方法三：yield 形式\n运行时调用时会生成generator对象。\n![image](/img/2021/3.png)\n输出  1，2，3\n\n> 问题：\n```python\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\n```\n> foo()在没有引用时会被销毁，在下一行初始化时内存会命中同一块地址空间，虽然地址相同，但实际是一个全新的对象。\n\n* 方法四：Closure闭包\n函数内套函数\n报错4.1：counter:\n![image](/img/2021/1.png)\niter(callable, stop_value)\n第一个参数：必须为可调用对象\n第二个参数：当迭代器返回值与stop_value相同时将抛出StopIterator\n\n## 5. Name-space vs Object-space\n\n![image](/img/2021/5.png)\n![image](/img/2021/6.png)\n\n* C++中输出是不影响的，但python中是会影响到\n\n```python\nclass CSV(object):\n    def __init__(self):\n        self._list = [91, 92, 93]\n\n    def push(self, item):\n        self._list = item\n\n    def show(self):\n        print self._list\n\n\nif __name__ == '__main__':\n    mylist = [1, 2, 3]\n    obj = CSV()\n    obj.push(mylist)\n    obj.show()\n    # >> [1, 2, 3]\n    \n    mylist[1] = 99\n    obj.show()\n    # >> [1, 99, 3]\n```\n\n\n![image](/img/2021/7.png)\n\n* 搜索顺序：\nlocal -> parent local -> ... -> global -> built-in\n全局的namespace: __buildin__\n\n>报错4.1：counter的解释：\n\n>*写的操作将打断往外的搜索顺序\n代码 counter += 1 建立了一个空引用的映射，但不是正确的映射，不再往外搜索，但此counter并未赋值。\n\n>*解决方案：使用counter[0]替代counter\n\n\n## 6. Reflection 反射\nC++原生不支持，JAVA,PYTHON,C#都是支持的\n\npython:\n* dir: 返回所有可用.访问的所有名字\n* __dict__：返回所有的name space空间\n\n实例1：\n```python\nclass A(object):\n    def fox(self):\n        print \"fox\"\n\ndef dog(self):\n    print 'dog'\n\ndef cat(self):\n    print 'cat'\n\nif __name__ == '__main__':\n    a1 = A()\n    a2 = A()\n    a1.fox()\n    a2.fox()\n\n    A.fox = dog\n    a1.fox()\n    a2.fox()\n\n    A.fox = cat\n    a1.fox()\n    a2.fox()\n\n```\n输出：\nfox\nfox\n\ndog\ndog\n\ncat\ncat\n\n实例2：\n\n```python\na1 = A()\na2 = A()\na1.fox()\na2.fox()\n\nimport new\na2.fox = new.instancemethod(cat, a2, A)\na2.fox()\na1.fox()\n```\n\n输出：\nfox\nfox\ncat\nfox\n\n实例3：\n\n```python\nprint dir(a1)\nprint dir(a2)\nprint '-' * 30\nprint a1.__dict__\nprint a2.__dict__\n```\n\n输出：\n\n```\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'fox']\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'fox']\n------------------------------\n{}\n{'fox': <bound method A.cat of <__main__.A object at 0x000000000330FDC8>>}\n```\n\n实例4：\n\n```python\nprint '-' * 30\nprint a1.__dict__\nprint a2.__dict__\nA.fox = duck\na1.fox()\na2.fox()\nprint '-' * 30\nprint a1.__dict__\nprint a2.__dict__\n```\n\n输出：\n\n```\n------------------------------\n{}\n{'fox': <bound method A.cat of <__main__.A object at 0x00000000037CFE88>>}\nduck\ncat\n------------------------------\n{}\n{'fox': <bound method A.cat of <__main__.A object at 0x00000000037CFE88>>}\n```\n\n解释：a2的由于局部空间还是cat\n\n实例5：\n\n```python\ndel a2.__dict__[\"fox\"]\na1.fox()\na2.fox()\nprint '-' * 30\nprint a1.__dict__\nprint a2.__dict__\n```\n\n结果：\n```\nduck\nduck\n------------------------------\n{}\n{}\n```\n\n\n## 7.对象生命周期\n引用计数，计数为0清空\n创建时为0， 有引用+1，解引用-1\n\nGC回收机制\n\n## 8.mutable vs immutable\n![image](/img/2021/8.png)\n不可变对象，比如 str，赋值时将重新生成对象。\n实例：\n\n```python\ndef foo(v, items = [], added= True):\n    if added:\n        items.append(v)\n    print items\n\nfoo(1)\nfoo(2)\nfoo(3, added=False)\n```\n\n输出：\n[1]\n[1,2]\n[1,2]\n解释：Python的默认值是保存在函数中的，因为每次调用的默认值时将取同一个表！同时由于[]是可变对象，因此结果是会被存进去的。\n\n> 注：不要将可变对象做为默认参数值\n\n修改：使用None这种非可变对象做为默认参数 \n```python\ndef foo(v, items = None, added= True):\n    if added:\n        if items is None: \n            items = []\n        items.append(v)\n    print items\n\nfoo(1)\nfoo(2)\nfoo(3, added=False)\n```\n\n## 9.== 与 is\n\n![image](/img/2021/9.png)\n![image](/img/2021/10.png)\n![image](/img/2021/11.png)\n![image](/img/2021/12.png)\n![image](/img/2021/13.png)\n![image](/img/2021/14.png)\n![image](/img/2021/15.png)\n\n> 注：\n> == 值相同\n> is 对象引用相同  a is b ---->  id(a) == id(b)\n> 小对象池，对于某个范围内的str, int这些类型，将从池子直接拿，返回的是相同的对象\n如：int范围，-128 ~ 约200\n> None的实例永远只有一个。返回的一个实例。 扩展C时，如果返回为None，需要手动为其加一个引用实例\n> Bool只有两个实例，True,False\n\n## 10.import语义\n执行期的内容\n![image](/img/2021/16.png)\n\nLoad the module:\n* 1.首先检测是否有，没有则打开m相关的载体，\n* 2.创建模块对象，放至到sys.modules\n* 3.**在module的namespace中顺序执行所有语句**\n\n> module层级不建议写大消耗代码 \n> 不要将import全部写在module头。将导致启动时非常耗时。\n\n\n![image](/img/2021/17.png)\n![image](/img/2021/18.png)\n* 使用from import时，会建立一个新的映射。因此不建议使用from import变量，可以使用函数。==**一定要小心使用**==\n* 不建议使用 from m import * 导致严重污染到当前命名空间\n\n![image](/img/2021/19.png) \n![image](/img/2021/20.png)\n*重复的写操作，import时，也会有写操作，编译期(py->pyc)建立命名空间，多次import就会已经math了\n\n# 总结\n![image](/img/2021/21.png)","source":"_posts/Python知识汇总1.md","raw":"---\ntitle: Python知识汇总1\ncategories:\n- Python\ntags: \n- Python\n- Note\n---\n\n# 总概\n\n## 1.Old-style, New-style class\n\n\n```python\nOld-style classes\n\nclass Person():\n    _names_cache = {}\n    def __init__(self,name):\n        self.name = name\n    def __new__(cls,name):\n        return cls._names_cache.setdefault(name,object.__new__(cls,name))\n\nahmed1 = Person(\"Ahmed\")\nahmed2 = Person(\"Ahmed\")\nprint ahmed1 is ahmed2\nprint ahmed1\nprint ahmed2\n\n\n# >>> False\n# <__main__.Person instance at 0xb74acf8c>\n# <__main__.Person instance at 0xb74ac6cc>\n# >>>\n\nNew-style classes\n\nclass Person(object):\n    _names_cache = {}\n    def __init__(self,name):\n        self.name = name\n    def __new__(cls,name):\n        return cls._names_cache.setdefault(name,object.__new__(cls,name))\n\nahmed1 = Person(\"Ahmed\")\nahmed2 = Person(\"Ahmed\")\nprint ahmed2 is ahmed1\nprint ahmed1\nprint ahmed2\n\n# >>> True\n# <__main__.Person object at 0xb74ac66c>\n# <__main__.Person object at 0xb74ac66c>\n# >>>\n```\n\n\n## 2.字符串拼接的性能对比\n\n\n```python\nimport random\n\nL = 400000\n\ns1 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns2 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns3 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns4 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns5 = ''.join([chr(random.randint(45, 90)) for i in xrange(L)])\n\nimport timeit\nm = 2000\nprint timeit.Timer('s=\"\".join((s1,s2,s3,s4,s5))', 'from __main__ import s1,s2,s3,s4,s5').timeit(m)  # 性能最佳\nprint timeit.Timer('s=string.join((s1,s2,s3,s4,s5))', 'from __main__ import s1,s2,s3,s4,s5; import string').timeit(m) # 性能较好\nprint timeit.Timer('s=s1; s+=s2; s+=s3; s+=s4; s+=s5', 'from __main__ import s1,s2,s3,s4,s5').timeit(m) # 较差\nprint timeit.Timer('s=s1+s2+s3+s4+s5', 'from __main__ import s1,s2,s3,s4,s5').timeit(m)# 较差\nprint timeit.Timer('s=\"%s%s%s%s%s\"%(s1,s2,s3,s4,s5)', 'from __main__ import s1,s2,s3,s4,s5').timeit(m)# 较差\n\n```\n\n## 3.对象类型\n* 一切都是对象, int,float等基础类型都是对象。但除了关键字！\n\n```python\nisinstance(type(A), object)\nisinstance(type(type(A)), object)\nisinstance(type, object)\nisinstance(staticmethod, object)\n```\n\n>> import, class, def, pass, return 等不是对象\n>> python3.x 以后print是对象，python2.x则不是对象\n\n## 4.迭代器\n自定义迭代器实现：\n* __init__函数 \n* next 函数 \n\n迭代器的使用，如图非标注的函数返回不是迭代器，则会产生一定的性能问题\n![迭代器的使用](/img/2021/1.png)\n\n简单实例\n![简单实例](/img/2021/2.png)\n\n\n* 方法一：自定义迭代器\n```\nclass FooIterator(object):\n    def __init__(self, foo):\n        self._list = foo\n        self._cur = 0\n\n    def next(self):\n        if self._cur < len(self._list):\n            res = self._list[self._cur]\n            self._cur += 1\n            return res\n        else:\n            return StopIteration\n\nclass Foo(object):\n    def __init__(self):\n        self._list = [1,2,3,4,5]\n\n    def __iter__(self):\n        return FooIterator(self)\n\n    def __len__(self):\n        return len(self._list)\n\n    def __getitem__(self, item):\n        return self._list[item]\n\na = Foo()\nfor a1 in a:\n    for b1 in a:\n        if a1 is StopIteration:\n            break\n        if b1 is StopIteration:\n            break\n        print (a1,b1)\n```\n\n* 方法二：使用对象自带的迭代器\n\n```python\nclass Foo(object):\n    def __init__(self):\n        self._list = [1,2,3,4,5]\n\n    def __iter__(self):\n        return iter(self._list)\n\n    def __len__(self):\n        return len(self._list)\n\n    def __getitem__(self, item):\n        return self._list[item]\n```\n\n* 方法三：yield 形式\n运行时调用时会生成generator对象。\n![image](/img/2021/3.png)\n输出  1，2，3\n\n> 问题：\n```python\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\n```\n> foo()在没有引用时会被销毁，在下一行初始化时内存会命中同一块地址空间，虽然地址相同，但实际是一个全新的对象。\n\n* 方法四：Closure闭包\n函数内套函数\n报错4.1：counter:\n![image](/img/2021/1.png)\niter(callable, stop_value)\n第一个参数：必须为可调用对象\n第二个参数：当迭代器返回值与stop_value相同时将抛出StopIterator\n\n## 5. Name-space vs Object-space\n\n![image](/img/2021/5.png)\n![image](/img/2021/6.png)\n\n* C++中输出是不影响的，但python中是会影响到\n\n```python\nclass CSV(object):\n    def __init__(self):\n        self._list = [91, 92, 93]\n\n    def push(self, item):\n        self._list = item\n\n    def show(self):\n        print self._list\n\n\nif __name__ == '__main__':\n    mylist = [1, 2, 3]\n    obj = CSV()\n    obj.push(mylist)\n    obj.show()\n    # >> [1, 2, 3]\n    \n    mylist[1] = 99\n    obj.show()\n    # >> [1, 99, 3]\n```\n\n\n![image](/img/2021/7.png)\n\n* 搜索顺序：\nlocal -> parent local -> ... -> global -> built-in\n全局的namespace: __buildin__\n\n>报错4.1：counter的解释：\n\n>*写的操作将打断往外的搜索顺序\n代码 counter += 1 建立了一个空引用的映射，但不是正确的映射，不再往外搜索，但此counter并未赋值。\n\n>*解决方案：使用counter[0]替代counter\n\n\n## 6. Reflection 反射\nC++原生不支持，JAVA,PYTHON,C#都是支持的\n\npython:\n* dir: 返回所有可用.访问的所有名字\n* __dict__：返回所有的name space空间\n\n实例1：\n```python\nclass A(object):\n    def fox(self):\n        print \"fox\"\n\ndef dog(self):\n    print 'dog'\n\ndef cat(self):\n    print 'cat'\n\nif __name__ == '__main__':\n    a1 = A()\n    a2 = A()\n    a1.fox()\n    a2.fox()\n\n    A.fox = dog\n    a1.fox()\n    a2.fox()\n\n    A.fox = cat\n    a1.fox()\n    a2.fox()\n\n```\n输出：\nfox\nfox\n\ndog\ndog\n\ncat\ncat\n\n实例2：\n\n```python\na1 = A()\na2 = A()\na1.fox()\na2.fox()\n\nimport new\na2.fox = new.instancemethod(cat, a2, A)\na2.fox()\na1.fox()\n```\n\n输出：\nfox\nfox\ncat\nfox\n\n实例3：\n\n```python\nprint dir(a1)\nprint dir(a2)\nprint '-' * 30\nprint a1.__dict__\nprint a2.__dict__\n```\n\n输出：\n\n```\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'fox']\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'fox']\n------------------------------\n{}\n{'fox': <bound method A.cat of <__main__.A object at 0x000000000330FDC8>>}\n```\n\n实例4：\n\n```python\nprint '-' * 30\nprint a1.__dict__\nprint a2.__dict__\nA.fox = duck\na1.fox()\na2.fox()\nprint '-' * 30\nprint a1.__dict__\nprint a2.__dict__\n```\n\n输出：\n\n```\n------------------------------\n{}\n{'fox': <bound method A.cat of <__main__.A object at 0x00000000037CFE88>>}\nduck\ncat\n------------------------------\n{}\n{'fox': <bound method A.cat of <__main__.A object at 0x00000000037CFE88>>}\n```\n\n解释：a2的由于局部空间还是cat\n\n实例5：\n\n```python\ndel a2.__dict__[\"fox\"]\na1.fox()\na2.fox()\nprint '-' * 30\nprint a1.__dict__\nprint a2.__dict__\n```\n\n结果：\n```\nduck\nduck\n------------------------------\n{}\n{}\n```\n\n\n## 7.对象生命周期\n引用计数，计数为0清空\n创建时为0， 有引用+1，解引用-1\n\nGC回收机制\n\n## 8.mutable vs immutable\n![image](/img/2021/8.png)\n不可变对象，比如 str，赋值时将重新生成对象。\n实例：\n\n```python\ndef foo(v, items = [], added= True):\n    if added:\n        items.append(v)\n    print items\n\nfoo(1)\nfoo(2)\nfoo(3, added=False)\n```\n\n输出：\n[1]\n[1,2]\n[1,2]\n解释：Python的默认值是保存在函数中的，因为每次调用的默认值时将取同一个表！同时由于[]是可变对象，因此结果是会被存进去的。\n\n> 注：不要将可变对象做为默认参数值\n\n修改：使用None这种非可变对象做为默认参数 \n```python\ndef foo(v, items = None, added= True):\n    if added:\n        if items is None: \n            items = []\n        items.append(v)\n    print items\n\nfoo(1)\nfoo(2)\nfoo(3, added=False)\n```\n\n## 9.== 与 is\n\n![image](/img/2021/9.png)\n![image](/img/2021/10.png)\n![image](/img/2021/11.png)\n![image](/img/2021/12.png)\n![image](/img/2021/13.png)\n![image](/img/2021/14.png)\n![image](/img/2021/15.png)\n\n> 注：\n> == 值相同\n> is 对象引用相同  a is b ---->  id(a) == id(b)\n> 小对象池，对于某个范围内的str, int这些类型，将从池子直接拿，返回的是相同的对象\n如：int范围，-128 ~ 约200\n> None的实例永远只有一个。返回的一个实例。 扩展C时，如果返回为None，需要手动为其加一个引用实例\n> Bool只有两个实例，True,False\n\n## 10.import语义\n执行期的内容\n![image](/img/2021/16.png)\n\nLoad the module:\n* 1.首先检测是否有，没有则打开m相关的载体，\n* 2.创建模块对象，放至到sys.modules\n* 3.**在module的namespace中顺序执行所有语句**\n\n> module层级不建议写大消耗代码 \n> 不要将import全部写在module头。将导致启动时非常耗时。\n\n\n![image](/img/2021/17.png)\n![image](/img/2021/18.png)\n* 使用from import时，会建立一个新的映射。因此不建议使用from import变量，可以使用函数。==**一定要小心使用**==\n* 不建议使用 from m import * 导致严重污染到当前命名空间\n\n![image](/img/2021/19.png) \n![image](/img/2021/20.png)\n*重复的写操作，import时，也会有写操作，编译期(py->pyc)建立命名空间，多次import就会已经math了\n\n# 总结\n![image](/img/2021/21.png)","slug":"Python知识汇总1","published":1,"date":"2021-02-26T03:56:02.088Z","updated":"2021-02-26T03:56:02.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckllsk7np0000ezf0nljrin4r","content":"<h1 id=\"总概\"><a href=\"#总概\" class=\"headerlink\" title=\"总概\"></a>总概</h1><h2 id=\"1-Old-style-New-style-class\"><a href=\"#1-Old-style-New-style-class\" class=\"headerlink\" title=\"1.Old-style, New-style class\"></a>1.Old-style, New-style class</h2><pre><code class=\"python\">Old-style classes\n\nclass Person():\n    _names_cache = {}\n    def __init__(self,name):\n        self.name = name\n    def __new__(cls,name):\n        return cls._names_cache.setdefault(name,object.__new__(cls,name))\n\nahmed1 = Person(&quot;Ahmed&quot;)\nahmed2 = Person(&quot;Ahmed&quot;)\nprint ahmed1 is ahmed2\nprint ahmed1\nprint ahmed2\n\n\n# &gt;&gt;&gt; False\n# &lt;__main__.Person instance at 0xb74acf8c&gt;\n# &lt;__main__.Person instance at 0xb74ac6cc&gt;\n# &gt;&gt;&gt;\n\nNew-style classes\n\nclass Person(object):\n    _names_cache = {}\n    def __init__(self,name):\n        self.name = name\n    def __new__(cls,name):\n        return cls._names_cache.setdefault(name,object.__new__(cls,name))\n\nahmed1 = Person(&quot;Ahmed&quot;)\nahmed2 = Person(&quot;Ahmed&quot;)\nprint ahmed2 is ahmed1\nprint ahmed1\nprint ahmed2\n\n# &gt;&gt;&gt; True\n# &lt;__main__.Person object at 0xb74ac66c&gt;\n# &lt;__main__.Person object at 0xb74ac66c&gt;\n# &gt;&gt;&gt;</code></pre>\n<h2 id=\"2-字符串拼接的性能对比\"><a href=\"#2-字符串拼接的性能对比\" class=\"headerlink\" title=\"2.字符串拼接的性能对比\"></a>2.字符串拼接的性能对比</h2><pre><code class=\"python\">import random\n\nL = 400000\n\ns1 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns2 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns3 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns4 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns5 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\n\nimport timeit\nm = 2000\nprint timeit.Timer(&#39;s=&quot;&quot;.join((s1,s2,s3,s4,s5))&#39;, &#39;from __main__ import s1,s2,s3,s4,s5&#39;).timeit(m)  # 性能最佳\nprint timeit.Timer(&#39;s=string.join((s1,s2,s3,s4,s5))&#39;, &#39;from __main__ import s1,s2,s3,s4,s5; import string&#39;).timeit(m) # 性能较好\nprint timeit.Timer(&#39;s=s1; s+=s2; s+=s3; s+=s4; s+=s5&#39;, &#39;from __main__ import s1,s2,s3,s4,s5&#39;).timeit(m) # 较差\nprint timeit.Timer(&#39;s=s1+s2+s3+s4+s5&#39;, &#39;from __main__ import s1,s2,s3,s4,s5&#39;).timeit(m)# 较差\nprint timeit.Timer(&#39;s=&quot;%s%s%s%s%s&quot;%(s1,s2,s3,s4,s5)&#39;, &#39;from __main__ import s1,s2,s3,s4,s5&#39;).timeit(m)# 较差\n</code></pre>\n<h2 id=\"3-对象类型\"><a href=\"#3-对象类型\" class=\"headerlink\" title=\"3.对象类型\"></a>3.对象类型</h2><ul>\n<li>一切都是对象, int,float等基础类型都是对象。但除了关键字！</li>\n</ul>\n<pre><code class=\"python\">isinstance(type(A), object)\nisinstance(type(type(A)), object)\nisinstance(type, object)\nisinstance(staticmethod, object)</code></pre>\n<blockquote>\n<blockquote>\n<p>import, class, def, pass, return 等不是对象<br>python3.x 以后print是对象，python2.x则不是对象</p>\n</blockquote>\n</blockquote>\n<h2 id=\"4-迭代器\"><a href=\"#4-迭代器\" class=\"headerlink\" title=\"4.迭代器\"></a>4.迭代器</h2><p>自定义迭代器实现：</p>\n<ul>\n<li><strong>init</strong>函数 </li>\n<li>next 函数 </li>\n</ul>\n<p>迭代器的使用，如图非标注的函数返回不是迭代器，则会产生一定的性能问题<br><img src=\"/img/2021/1.png\" alt=\"迭代器的使用\"></p>\n<p>简单实例<br><img src=\"/img/2021/2.png\" alt=\"简单实例\"></p>\n<ul>\n<li><p>方法一：自定义迭代器</p>\n<pre><code>class FooIterator(object):\n  def __init__(self, foo):\n      self._list = foo\n      self._cur = 0\n\n  def next(self):\n      if self._cur &lt; len(self._list):\n          res = self._list[self._cur]\n          self._cur += 1\n          return res\n      else:\n          return StopIteration\n</code></pre></li>\n</ul>\n<p>class Foo(object):<br>    def <strong>init</strong>(self):<br>        self._list = [1,2,3,4,5]</p>\n<pre><code>def __iter__(self):\n    return FooIterator(self)\n\ndef __len__(self):\n    return len(self._list)\n\ndef __getitem__(self, item):\n    return self._list[item]</code></pre><p>a = Foo()<br>for a1 in a:<br>    for b1 in a:<br>        if a1 is StopIteration:<br>            break<br>        if b1 is StopIteration:<br>            break<br>        print (a1,b1)</p>\n<pre><code>\n* 方法二：使用对象自带的迭代器\n\n```python\nclass Foo(object):\n    def __init__(self):\n        self._list = [1,2,3,4,5]\n\n    def __iter__(self):\n        return iter(self._list)\n\n    def __len__(self):\n        return len(self._list)\n\n    def __getitem__(self, item):\n        return self._list[item]</code></pre><ul>\n<li>方法三：yield 形式<br>运行时调用时会生成generator对象。<br><img src=\"/img/2021/3.png\" alt=\"image\"><br>输出  1，2，3</li>\n</ul>\n<blockquote>\n<p>问题：</p>\n</blockquote>\n<pre><code class=\"python\">print foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc</code></pre>\n<blockquote>\n<p>foo()在没有引用时会被销毁，在下一行初始化时内存会命中同一块地址空间，虽然地址相同，但实际是一个全新的对象。</p>\n</blockquote>\n<ul>\n<li>方法四：Closure闭包<br>函数内套函数<br>报错4.1：counter:<br><img src=\"/img/2021/1.png\" alt=\"image\"><br>iter(callable, stop_value)<br>第一个参数：必须为可调用对象<br>第二个参数：当迭代器返回值与stop_value相同时将抛出StopIterator</li>\n</ul>\n<h2 id=\"5-Name-space-vs-Object-space\"><a href=\"#5-Name-space-vs-Object-space\" class=\"headerlink\" title=\"5. Name-space vs Object-space\"></a>5. Name-space vs Object-space</h2><p><img src=\"/img/2021/5.png\" alt=\"image\"><br><img src=\"/img/2021/6.png\" alt=\"image\"></p>\n<ul>\n<li>C++中输出是不影响的，但python中是会影响到</li>\n</ul>\n<pre><code class=\"python\">class CSV(object):\n    def __init__(self):\n        self._list = [91, 92, 93]\n\n    def push(self, item):\n        self._list = item\n\n    def show(self):\n        print self._list\n\n\nif __name__ == &#39;__main__&#39;:\n    mylist = [1, 2, 3]\n    obj = CSV()\n    obj.push(mylist)\n    obj.show()\n    # &gt;&gt; [1, 2, 3]\n\n    mylist[1] = 99\n    obj.show()\n    # &gt;&gt; [1, 99, 3]</code></pre>\n<p><img src=\"/img/2021/7.png\" alt=\"image\"></p>\n<ul>\n<li>搜索顺序：<br>local -&gt; parent local -&gt; … -&gt; global -&gt; built-in<br>全局的namespace: <strong>buildin</strong></li>\n</ul>\n<blockquote>\n<p>报错4.1：counter的解释：</p>\n</blockquote>\n<blockquote>\n<p>*写的操作将打断往外的搜索顺序<br>代码 counter += 1 建立了一个空引用的映射，但不是正确的映射，不再往外搜索，但此counter并未赋值。</p>\n</blockquote>\n<blockquote>\n<p>*解决方案：使用counter[0]替代counter</p>\n</blockquote>\n<h2 id=\"6-Reflection-反射\"><a href=\"#6-Reflection-反射\" class=\"headerlink\" title=\"6. Reflection 反射\"></a>6. Reflection 反射</h2><p>C++原生不支持，JAVA,PYTHON,C#都是支持的</p>\n<p>python:</p>\n<ul>\n<li>dir: 返回所有可用.访问的所有名字</li>\n<li><strong>dict</strong>：返回所有的name space空间</li>\n</ul>\n<p>实例1：</p>\n<pre><code class=\"python\">class A(object):\n    def fox(self):\n        print &quot;fox&quot;\n\ndef dog(self):\n    print &#39;dog&#39;\n\ndef cat(self):\n    print &#39;cat&#39;\n\nif __name__ == &#39;__main__&#39;:\n    a1 = A()\n    a2 = A()\n    a1.fox()\n    a2.fox()\n\n    A.fox = dog\n    a1.fox()\n    a2.fox()\n\n    A.fox = cat\n    a1.fox()\n    a2.fox()\n</code></pre>\n<p>输出：<br>fox<br>fox</p>\n<p>dog<br>dog</p>\n<p>cat<br>cat</p>\n<p>实例2：</p>\n<pre><code class=\"python\">a1 = A()\na2 = A()\na1.fox()\na2.fox()\n\nimport new\na2.fox = new.instancemethod(cat, a2, A)\na2.fox()\na1.fox()</code></pre>\n<p>输出：<br>fox<br>fox<br>cat<br>fox</p>\n<p>实例3：</p>\n<pre><code class=\"python\">print dir(a1)\nprint dir(a2)\nprint &#39;-&#39; * 30\nprint a1.__dict__\nprint a2.__dict__</code></pre>\n<p>输出：</p>\n<pre><code>[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__module__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;fox&#39;]\n[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__module__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;fox&#39;]\n------------------------------\n{}\n{&#39;fox&#39;: &lt;bound method A.cat of &lt;__main__.A object at 0x000000000330FDC8&gt;&gt;}</code></pre><p>实例4：</p>\n<pre><code class=\"python\">print &#39;-&#39; * 30\nprint a1.__dict__\nprint a2.__dict__\nA.fox = duck\na1.fox()\na2.fox()\nprint &#39;-&#39; * 30\nprint a1.__dict__\nprint a2.__dict__</code></pre>\n<p>输出：</p>\n<pre><code>------------------------------\n{}\n{&#39;fox&#39;: &lt;bound method A.cat of &lt;__main__.A object at 0x00000000037CFE88&gt;&gt;}\nduck\ncat\n------------------------------\n{}\n{&#39;fox&#39;: &lt;bound method A.cat of &lt;__main__.A object at 0x00000000037CFE88&gt;&gt;}</code></pre><p>解释：a2的由于局部空间还是cat</p>\n<p>实例5：</p>\n<pre><code class=\"python\">del a2.__dict__[&quot;fox&quot;]\na1.fox()\na2.fox()\nprint &#39;-&#39; * 30\nprint a1.__dict__\nprint a2.__dict__</code></pre>\n<p>结果：</p>\n<pre><code>duck\nduck\n------------------------------\n{}\n{}</code></pre><h2 id=\"7-对象生命周期\"><a href=\"#7-对象生命周期\" class=\"headerlink\" title=\"7.对象生命周期\"></a>7.对象生命周期</h2><p>引用计数，计数为0清空<br>创建时为0， 有引用+1，解引用-1</p>\n<p>GC回收机制</p>\n<h2 id=\"8-mutable-vs-immutable\"><a href=\"#8-mutable-vs-immutable\" class=\"headerlink\" title=\"8.mutable vs immutable\"></a>8.mutable vs immutable</h2><p><img src=\"/img/2021/8.png\" alt=\"image\"><br>不可变对象，比如 str，赋值时将重新生成对象。<br>实例：</p>\n<pre><code class=\"python\">def foo(v, items = [], added= True):\n    if added:\n        items.append(v)\n    print items\n\nfoo(1)\nfoo(2)\nfoo(3, added=False)</code></pre>\n<p>输出：<br>[1]<br>[1,2]<br>[1,2]<br>解释：Python的默认值是保存在函数中的，因为每次调用的默认值时将取同一个表！同时由于[]是可变对象，因此结果是会被存进去的。</p>\n<blockquote>\n<p>注：不要将可变对象做为默认参数值</p>\n</blockquote>\n<p>修改：使用None这种非可变对象做为默认参数 </p>\n<pre><code class=\"python\">def foo(v, items = None, added= True):\n    if added:\n        if items is None: \n            items = []\n        items.append(v)\n    print items\n\nfoo(1)\nfoo(2)\nfoo(3, added=False)</code></pre>\n<h2 id=\"9-与-is\"><a href=\"#9-与-is\" class=\"headerlink\" title=\"9.== 与 is\"></a>9.== 与 is</h2><p><img src=\"/img/2021/9.png\" alt=\"image\"><br><img src=\"/img/2021/10.png\" alt=\"image\"><br><img src=\"/img/2021/11.png\" alt=\"image\"><br><img src=\"/img/2021/12.png\" alt=\"image\"><br><img src=\"/img/2021/13.png\" alt=\"image\"><br><img src=\"/img/2021/14.png\" alt=\"image\"><br><img src=\"/img/2021/15.png\" alt=\"image\"></p>\n<blockquote>\n<p>注：<br>== 值相同<br>is 对象引用相同  a is b —-&gt;  id(a) == id(b)<br>小对象池，对于某个范围内的str, int这些类型，将从池子直接拿，返回的是相同的对象<br>如：int范围，-128 ~ 约200<br>None的实例永远只有一个。返回的一个实例。 扩展C时，如果返回为None，需要手动为其加一个引用实例<br>Bool只有两个实例，True,False</p>\n</blockquote>\n<h2 id=\"10-import语义\"><a href=\"#10-import语义\" class=\"headerlink\" title=\"10.import语义\"></a>10.import语义</h2><p>执行期的内容<br><img src=\"/img/2021/16.png\" alt=\"image\"></p>\n<p>Load the module:</p>\n<ul>\n<li>1.首先检测是否有，没有则打开m相关的载体，</li>\n<li>2.创建模块对象，放至到sys.modules</li>\n<li>3.<strong>在module的namespace中顺序执行所有语句</strong></li>\n</ul>\n<blockquote>\n<p>module层级不建议写大消耗代码<br>不要将import全部写在module头。将导致启动时非常耗时。</p>\n</blockquote>\n<p><img src=\"/img/2021/17.png\" alt=\"image\"><br><img src=\"/img/2021/18.png\" alt=\"image\"></p>\n<ul>\n<li>使用from import时，会建立一个新的映射。因此不建议使用from import变量，可以使用函数。==<strong>一定要小心使用</strong>==</li>\n<li>不建议使用 from m import * 导致严重污染到当前命名空间</li>\n</ul>\n<p><img src=\"/img/2021/19.png\" alt=\"image\"><br><img src=\"/img/2021/20.png\" alt=\"image\"><br>*重复的写操作，import时，也会有写操作，编译期(py-&gt;pyc)建立命名空间，多次import就会已经math了</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><img src=\"/img/2021/21.png\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"总概\"><a href=\"#总概\" class=\"headerlink\" title=\"总概\"></a>总概</h1><h2 id=\"1-Old-style-New-style-class\"><a href=\"#1-Old-style-New-style-class\" class=\"headerlink\" title=\"1.Old-style, New-style class\"></a>1.Old-style, New-style class</h2><pre><code class=\"python\">Old-style classes\n\nclass Person():\n    _names_cache = {}\n    def __init__(self,name):\n        self.name = name\n    def __new__(cls,name):\n        return cls._names_cache.setdefault(name,object.__new__(cls,name))\n\nahmed1 = Person(&quot;Ahmed&quot;)\nahmed2 = Person(&quot;Ahmed&quot;)\nprint ahmed1 is ahmed2\nprint ahmed1\nprint ahmed2\n\n\n# &gt;&gt;&gt; False\n# &lt;__main__.Person instance at 0xb74acf8c&gt;\n# &lt;__main__.Person instance at 0xb74ac6cc&gt;\n# &gt;&gt;&gt;\n\nNew-style classes\n\nclass Person(object):\n    _names_cache = {}\n    def __init__(self,name):\n        self.name = name\n    def __new__(cls,name):\n        return cls._names_cache.setdefault(name,object.__new__(cls,name))\n\nahmed1 = Person(&quot;Ahmed&quot;)\nahmed2 = Person(&quot;Ahmed&quot;)\nprint ahmed2 is ahmed1\nprint ahmed1\nprint ahmed2\n\n# &gt;&gt;&gt; True\n# &lt;__main__.Person object at 0xb74ac66c&gt;\n# &lt;__main__.Person object at 0xb74ac66c&gt;\n# &gt;&gt;&gt;</code></pre>\n<h2 id=\"2-字符串拼接的性能对比\"><a href=\"#2-字符串拼接的性能对比\" class=\"headerlink\" title=\"2.字符串拼接的性能对比\"></a>2.字符串拼接的性能对比</h2><pre><code class=\"python\">import random\n\nL = 400000\n\ns1 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns2 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns3 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns4 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\ns5 = &#39;&#39;.join([chr(random.randint(45, 90)) for i in xrange(L)])\n\nimport timeit\nm = 2000\nprint timeit.Timer(&#39;s=&quot;&quot;.join((s1,s2,s3,s4,s5))&#39;, &#39;from __main__ import s1,s2,s3,s4,s5&#39;).timeit(m)  # 性能最佳\nprint timeit.Timer(&#39;s=string.join((s1,s2,s3,s4,s5))&#39;, &#39;from __main__ import s1,s2,s3,s4,s5; import string&#39;).timeit(m) # 性能较好\nprint timeit.Timer(&#39;s=s1; s+=s2; s+=s3; s+=s4; s+=s5&#39;, &#39;from __main__ import s1,s2,s3,s4,s5&#39;).timeit(m) # 较差\nprint timeit.Timer(&#39;s=s1+s2+s3+s4+s5&#39;, &#39;from __main__ import s1,s2,s3,s4,s5&#39;).timeit(m)# 较差\nprint timeit.Timer(&#39;s=&quot;%s%s%s%s%s&quot;%(s1,s2,s3,s4,s5)&#39;, &#39;from __main__ import s1,s2,s3,s4,s5&#39;).timeit(m)# 较差\n</code></pre>\n<h2 id=\"3-对象类型\"><a href=\"#3-对象类型\" class=\"headerlink\" title=\"3.对象类型\"></a>3.对象类型</h2><ul>\n<li>一切都是对象, int,float等基础类型都是对象。但除了关键字！</li>\n</ul>\n<pre><code class=\"python\">isinstance(type(A), object)\nisinstance(type(type(A)), object)\nisinstance(type, object)\nisinstance(staticmethod, object)</code></pre>\n<blockquote>\n<blockquote>\n<p>import, class, def, pass, return 等不是对象<br>python3.x 以后print是对象，python2.x则不是对象</p>\n</blockquote>\n</blockquote>\n<h2 id=\"4-迭代器\"><a href=\"#4-迭代器\" class=\"headerlink\" title=\"4.迭代器\"></a>4.迭代器</h2><p>自定义迭代器实现：</p>\n<ul>\n<li><strong>init</strong>函数 </li>\n<li>next 函数 </li>\n</ul>\n<p>迭代器的使用，如图非标注的函数返回不是迭代器，则会产生一定的性能问题<br><img src=\"/img/2021/1.png\" alt=\"迭代器的使用\"></p>\n<p>简单实例<br><img src=\"/img/2021/2.png\" alt=\"简单实例\"></p>\n<ul>\n<li><p>方法一：自定义迭代器</p>\n<pre><code>class FooIterator(object):\n  def __init__(self, foo):\n      self._list = foo\n      self._cur = 0\n\n  def next(self):\n      if self._cur &lt; len(self._list):\n          res = self._list[self._cur]\n          self._cur += 1\n          return res\n      else:\n          return StopIteration\n</code></pre></li>\n</ul>\n<p>class Foo(object):<br>    def <strong>init</strong>(self):<br>        self._list = [1,2,3,4,5]</p>\n<pre><code>def __iter__(self):\n    return FooIterator(self)\n\ndef __len__(self):\n    return len(self._list)\n\ndef __getitem__(self, item):\n    return self._list[item]</code></pre><p>a = Foo()<br>for a1 in a:<br>    for b1 in a:<br>        if a1 is StopIteration:<br>            break<br>        if b1 is StopIteration:<br>            break<br>        print (a1,b1)</p>\n<pre><code>\n* 方法二：使用对象自带的迭代器\n\n```python\nclass Foo(object):\n    def __init__(self):\n        self._list = [1,2,3,4,5]\n\n    def __iter__(self):\n        return iter(self._list)\n\n    def __len__(self):\n        return len(self._list)\n\n    def __getitem__(self, item):\n        return self._list[item]</code></pre><ul>\n<li>方法三：yield 形式<br>运行时调用时会生成generator对象。<br><img src=\"/img/2021/3.png\" alt=\"image\"><br>输出  1，2，3</li>\n</ul>\n<blockquote>\n<p>问题：</p>\n</blockquote>\n<pre><code class=\"python\">print foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc\nprint foo().next() # 输出 1 地址0xxxabc</code></pre>\n<blockquote>\n<p>foo()在没有引用时会被销毁，在下一行初始化时内存会命中同一块地址空间，虽然地址相同，但实际是一个全新的对象。</p>\n</blockquote>\n<ul>\n<li>方法四：Closure闭包<br>函数内套函数<br>报错4.1：counter:<br><img src=\"/img/2021/1.png\" alt=\"image\"><br>iter(callable, stop_value)<br>第一个参数：必须为可调用对象<br>第二个参数：当迭代器返回值与stop_value相同时将抛出StopIterator</li>\n</ul>\n<h2 id=\"5-Name-space-vs-Object-space\"><a href=\"#5-Name-space-vs-Object-space\" class=\"headerlink\" title=\"5. Name-space vs Object-space\"></a>5. Name-space vs Object-space</h2><p><img src=\"/img/2021/5.png\" alt=\"image\"><br><img src=\"/img/2021/6.png\" alt=\"image\"></p>\n<ul>\n<li>C++中输出是不影响的，但python中是会影响到</li>\n</ul>\n<pre><code class=\"python\">class CSV(object):\n    def __init__(self):\n        self._list = [91, 92, 93]\n\n    def push(self, item):\n        self._list = item\n\n    def show(self):\n        print self._list\n\n\nif __name__ == &#39;__main__&#39;:\n    mylist = [1, 2, 3]\n    obj = CSV()\n    obj.push(mylist)\n    obj.show()\n    # &gt;&gt; [1, 2, 3]\n\n    mylist[1] = 99\n    obj.show()\n    # &gt;&gt; [1, 99, 3]</code></pre>\n<p><img src=\"/img/2021/7.png\" alt=\"image\"></p>\n<ul>\n<li>搜索顺序：<br>local -&gt; parent local -&gt; … -&gt; global -&gt; built-in<br>全局的namespace: <strong>buildin</strong></li>\n</ul>\n<blockquote>\n<p>报错4.1：counter的解释：</p>\n</blockquote>\n<blockquote>\n<p>*写的操作将打断往外的搜索顺序<br>代码 counter += 1 建立了一个空引用的映射，但不是正确的映射，不再往外搜索，但此counter并未赋值。</p>\n</blockquote>\n<blockquote>\n<p>*解决方案：使用counter[0]替代counter</p>\n</blockquote>\n<h2 id=\"6-Reflection-反射\"><a href=\"#6-Reflection-反射\" class=\"headerlink\" title=\"6. Reflection 反射\"></a>6. Reflection 反射</h2><p>C++原生不支持，JAVA,PYTHON,C#都是支持的</p>\n<p>python:</p>\n<ul>\n<li>dir: 返回所有可用.访问的所有名字</li>\n<li><strong>dict</strong>：返回所有的name space空间</li>\n</ul>\n<p>实例1：</p>\n<pre><code class=\"python\">class A(object):\n    def fox(self):\n        print &quot;fox&quot;\n\ndef dog(self):\n    print &#39;dog&#39;\n\ndef cat(self):\n    print &#39;cat&#39;\n\nif __name__ == &#39;__main__&#39;:\n    a1 = A()\n    a2 = A()\n    a1.fox()\n    a2.fox()\n\n    A.fox = dog\n    a1.fox()\n    a2.fox()\n\n    A.fox = cat\n    a1.fox()\n    a2.fox()\n</code></pre>\n<p>输出：<br>fox<br>fox</p>\n<p>dog<br>dog</p>\n<p>cat<br>cat</p>\n<p>实例2：</p>\n<pre><code class=\"python\">a1 = A()\na2 = A()\na1.fox()\na2.fox()\n\nimport new\na2.fox = new.instancemethod(cat, a2, A)\na2.fox()\na1.fox()</code></pre>\n<p>输出：<br>fox<br>fox<br>cat<br>fox</p>\n<p>实例3：</p>\n<pre><code class=\"python\">print dir(a1)\nprint dir(a2)\nprint &#39;-&#39; * 30\nprint a1.__dict__\nprint a2.__dict__</code></pre>\n<p>输出：</p>\n<pre><code>[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__module__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;fox&#39;]\n[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__doc__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__module__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;fox&#39;]\n------------------------------\n{}\n{&#39;fox&#39;: &lt;bound method A.cat of &lt;__main__.A object at 0x000000000330FDC8&gt;&gt;}</code></pre><p>实例4：</p>\n<pre><code class=\"python\">print &#39;-&#39; * 30\nprint a1.__dict__\nprint a2.__dict__\nA.fox = duck\na1.fox()\na2.fox()\nprint &#39;-&#39; * 30\nprint a1.__dict__\nprint a2.__dict__</code></pre>\n<p>输出：</p>\n<pre><code>------------------------------\n{}\n{&#39;fox&#39;: &lt;bound method A.cat of &lt;__main__.A object at 0x00000000037CFE88&gt;&gt;}\nduck\ncat\n------------------------------\n{}\n{&#39;fox&#39;: &lt;bound method A.cat of &lt;__main__.A object at 0x00000000037CFE88&gt;&gt;}</code></pre><p>解释：a2的由于局部空间还是cat</p>\n<p>实例5：</p>\n<pre><code class=\"python\">del a2.__dict__[&quot;fox&quot;]\na1.fox()\na2.fox()\nprint &#39;-&#39; * 30\nprint a1.__dict__\nprint a2.__dict__</code></pre>\n<p>结果：</p>\n<pre><code>duck\nduck\n------------------------------\n{}\n{}</code></pre><h2 id=\"7-对象生命周期\"><a href=\"#7-对象生命周期\" class=\"headerlink\" title=\"7.对象生命周期\"></a>7.对象生命周期</h2><p>引用计数，计数为0清空<br>创建时为0， 有引用+1，解引用-1</p>\n<p>GC回收机制</p>\n<h2 id=\"8-mutable-vs-immutable\"><a href=\"#8-mutable-vs-immutable\" class=\"headerlink\" title=\"8.mutable vs immutable\"></a>8.mutable vs immutable</h2><p><img src=\"/img/2021/8.png\" alt=\"image\"><br>不可变对象，比如 str，赋值时将重新生成对象。<br>实例：</p>\n<pre><code class=\"python\">def foo(v, items = [], added= True):\n    if added:\n        items.append(v)\n    print items\n\nfoo(1)\nfoo(2)\nfoo(3, added=False)</code></pre>\n<p>输出：<br>[1]<br>[1,2]<br>[1,2]<br>解释：Python的默认值是保存在函数中的，因为每次调用的默认值时将取同一个表！同时由于[]是可变对象，因此结果是会被存进去的。</p>\n<blockquote>\n<p>注：不要将可变对象做为默认参数值</p>\n</blockquote>\n<p>修改：使用None这种非可变对象做为默认参数 </p>\n<pre><code class=\"python\">def foo(v, items = None, added= True):\n    if added:\n        if items is None: \n            items = []\n        items.append(v)\n    print items\n\nfoo(1)\nfoo(2)\nfoo(3, added=False)</code></pre>\n<h2 id=\"9-与-is\"><a href=\"#9-与-is\" class=\"headerlink\" title=\"9.== 与 is\"></a>9.== 与 is</h2><p><img src=\"/img/2021/9.png\" alt=\"image\"><br><img src=\"/img/2021/10.png\" alt=\"image\"><br><img src=\"/img/2021/11.png\" alt=\"image\"><br><img src=\"/img/2021/12.png\" alt=\"image\"><br><img src=\"/img/2021/13.png\" alt=\"image\"><br><img src=\"/img/2021/14.png\" alt=\"image\"><br><img src=\"/img/2021/15.png\" alt=\"image\"></p>\n<blockquote>\n<p>注：<br>== 值相同<br>is 对象引用相同  a is b —-&gt;  id(a) == id(b)<br>小对象池，对于某个范围内的str, int这些类型，将从池子直接拿，返回的是相同的对象<br>如：int范围，-128 ~ 约200<br>None的实例永远只有一个。返回的一个实例。 扩展C时，如果返回为None，需要手动为其加一个引用实例<br>Bool只有两个实例，True,False</p>\n</blockquote>\n<h2 id=\"10-import语义\"><a href=\"#10-import语义\" class=\"headerlink\" title=\"10.import语义\"></a>10.import语义</h2><p>执行期的内容<br><img src=\"/img/2021/16.png\" alt=\"image\"></p>\n<p>Load the module:</p>\n<ul>\n<li>1.首先检测是否有，没有则打开m相关的载体，</li>\n<li>2.创建模块对象，放至到sys.modules</li>\n<li>3.<strong>在module的namespace中顺序执行所有语句</strong></li>\n</ul>\n<blockquote>\n<p>module层级不建议写大消耗代码<br>不要将import全部写在module头。将导致启动时非常耗时。</p>\n</blockquote>\n<p><img src=\"/img/2021/17.png\" alt=\"image\"><br><img src=\"/img/2021/18.png\" alt=\"image\"></p>\n<ul>\n<li>使用from import时，会建立一个新的映射。因此不建议使用from import变量，可以使用函数。==<strong>一定要小心使用</strong>==</li>\n<li>不建议使用 from m import * 导致严重污染到当前命名空间</li>\n</ul>\n<p><img src=\"/img/2021/19.png\" alt=\"image\"><br><img src=\"/img/2021/20.png\" alt=\"image\"><br>*重复的写操作，import时，也会有写操作，编译期(py-&gt;pyc)建立命名空间，多次import就会已经math了</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><img src=\"/img/2021/21.png\" alt=\"image\"></p>\n"},{"title":"Python源码剖析-Note1","_content":"\n## 1.Python 架构\n\n* 1.1 文件组：\n\n  模块、库、自定义模块\n\n* 1.2 核心\n    \n  解析器\n\n  Scanner词法分析 -> Parser语法分析，建立AST（抽象语法树）\n  -> Compiler 生成指令集合，Python字节码（byte code） -> 由Code Evaluator（虚拟机）执行字节码\n   \n* 1.3 运行时环境\n  \n    对象/类型系统 Object/Type structures\n    内存分配器  Memory Allocator\n    运行时状态信息  Current State of Python\n\n## 2.Python的内建对象\n\n* 2.1 关于对象\n* 类型对象（整数类型，字符串类型）都是被静态初始化的\n* 对象被创建后的内存中的大小是不可变的！\n\n* 2.2 PyObject\n* 只包含一个引用计数和一个类型指针（指向具体的结构信息）\n```c\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   \\\n    _PyObject_HEAD_EXTRA                \\\n    Py_ssize_t ob_refcnt;               \\\n    struct _typeobject *ob_type;\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\ntypedef struct _object {\n    PyObject_HEAD\n} PyObject;\n```\n\n* 2.3 PyVarObject\n* 对PyObject的扩展，可以理解为一个容器，比如对于一个string的实现，需要使用一个n * char的实现方式，因此需要一个字段存储长度。因此结构如下：\n\n```c\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD               \\\n    PyObject_HEAD                       \\\n    Py_ssize_t ob_size; /* Number of items in variable part */\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\ntypedef struct {\n    PyObject_VAR_HEAD\n} PyVarObject;\n```\n\n* 2.4 创建类型对象的方式\n* 使用范型的API（AOL）\n```c\nPyObject *intObj = PyObject_New(PyObject, &PyInt_Type);\n```\n* 使用与类型相关的API（COL）\n```c\nPyObject* intObj = PyInt_FromLong(20);\n```\n\n* 2.5 对象的行为\n* PyTypeObject包含大量函数指针，指明了其不同的对象的行为实现。\n* 标准行为函数族：基础类型的函数，列表的函数族，字典用的函数族\n```c\n    PyNumberMethods *tp_as_number;  \n    PySequenceMethods *tp_as_sequence;\n    PyMappingMethods *tp_as_mapping;\n```\n\n2.6 类型的类型\n* 对于用户自定义class所对应的PyTypeObject对象通过PyType_Type创建。\n```python\nclass A(object):\n    pass\n\nA.__class__ # 输出 <type 'type'>\nint.__class__  # 输出 <type 'type'>\n```\npython中被称为metaclass\n\n> int运行时类型关系： \n> int - ob_refent + ob_type\n>    ob_type - PyInt_Type(ob_type)\n>       PyInt_Type(ob_type) -> PyType_Type\n>       PyInt_Type(tp_base) -> PyBaseObject_Type\n\n2.7 多态的实现原理\n所有的对象使用PyObject来存储，然后再对不同的对象类型执行不同的函数族，实现多态，如\n```c\n// PyTypeObject PyInt_Type = {\n//     PyVarObject_HEAD_INIT(&PyType_Type, 0)\n//     \"int\",\n//     sizeof(PyIntObject),\n//     0,\n//     (destructor)int_dealloc,                    /* tp_dealloc */\n//     (printfunc)int_print,                       /* tp_print */\n//      ....\n\nPyObject* intObj = PyInt_FromLong(20);\nintObj->ob_type->tp_print(intObj, fp, 0);\n\n```\n2.8 引用计数\n* 增加和减少一个对象的引用计数\n```c\nob_refcnt <- Py_INCREF(op), Py_DECREF(op)\n```\n\n* 类型对象是超越引用计数规则的，即永远不会析构，每个对象指向类型对象的指针不会被视为对类型对象的引用。\n> 注意：当引数为0时，会调用其对应的析构函数，但这并不意味着一定会调用free，因为这样频繁的调用会导致性能不好，所以会采取将其放到内存池的作法。\n\n2.9 对象分类：\n* Fundamental对象：类型对象         type\n* Numeric对象：数值对象         boolean, float, int\n* Sequence对象：序列集合对象     list, tuple, string\n* Mapping对象：对应C++中的map     dict\n* Internal对象：虚拟机运行时的内部使用对象       function, code, frame, module, method\n\n## 3.Python中的整数对象\n\n3.1 实现方式\n* PyIntObject用于实现整数对象，不可变对象，即创建后就不能改变其值\n> 引出问题？  非常频繁的创建和销毁Int对象将会导致性能问题\n\n* 元信息：\n```c\nPyTypeObject PyInt_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"int\",\n    sizeof(PyIntObject),\n    0,\n    (destructor)int_dealloc,                    /* tp_dealloc */\n    (printfunc)int_print,                       /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    (cmpfunc)int_compare,                       /* tp_compare */\n    (reprfunc)int_to_decimal_string,            /* tp_repr */\n    &int_as_number,                             /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    (hashfunc)int_hash,                         /* tp_hash */\n    0,                                          /* tp_call */\n    (reprfunc)int_to_decimal_string,            /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |\n        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_INT_SUBCLASS,          /* tp_flags */\n    int_doc,                                    /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    int_methods,                                /* tp_methods */\n    0,                                          /* tp_members */\n    int_getset,                                 /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    int_new,                                    /* tp_new */\n};\n```\n\n* PyNumberMethods展示所有可选的操作信息\n\n\n3.2 int_add的实现\n\n* PyInt_AS_LONG  vs PyInt_AsLong ,后者版本执行效率较慢，会有多方的检查\n\n> python中对于频繁执行的代码，都会提供函数和宏两个版本\n\n* 默认情况下，返回一个新的PyIntObject， 当越界时将转为PyLong_Type的结果返回\n```c\nstatic PyObject *\nint_add(PyIntObject *v, PyIntObject *w)\n{\n    register long a, b, x;\n    CONVERT_TO_LONG(v, a);\n    CONVERT_TO_LONG(w, b);\n    /* casts in the line below avoid undefined behaviour on overflow */\n    x = (long)((unsigned long)a + b);\n    if ((x^a) >= 0 || (x^b) >= 0)\n        return PyInt_FromLong(x);\n    return PyLong_Type.tp_as_number->nb_add((PyObject *)v, (PyObject *)w);\n\n```\n3.3 PyIntObject的创建\n\n* PyInt_FromString 与 PyInt_FromUnicode 最终都是调用PyInt_FromLong创建，适配器模式的设计模式\n```c\nPyAPI_FUNC(PyObject *) PyInt_FromString(char*, char**, int);\n#ifdef Py_USING_UNICODE\nPyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE*, Py_ssize_t, int);\n#endif\nPyAPI_FUNC(PyObject *) PyInt_FromLong(long);\nPyAPI_FUNC(PyObject *) PyInt_FromSize_t(size_t);\nPyAPI_FUNC(PyObject *) PyInt_FromSsize_t(Py_ssize_t);\n```\n\n3.4 大整数与小整数\n* 小整数： 默认是[-5，257]的范围，这些整数直接缓存在内存中，并存放其指针在small_ints的中。\n```c\n// intobject.c\n#ifndef NSMALLPOSINTS\n#define NSMALLPOSINTS           257\n#endif\n#ifndef NSMALLNEGINTS\n#define NSMALLNEGINTS           5\n#endif\n```\n\n* 大整数：提供一块内存空间，配置如下：\n```c\n#define BLOCK_SIZE      1000    /* 1K less typical malloc overhead */\n#define BHEAD_SIZE      8       /* Enough for a 64-bit pointer */\n#define N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))\n\nstruct _intblock {\n    struct _intblock *next;\n    PyIntObject objects[N_INTOBJECTS];\n};\n```\n\n计算得出N_INTOBJECTS的值为24，对于一个64位指针使用8个字节来算\n\n3.5 添加与删除\n\n```c\nPyObject *\nPyInt_FromLong(long ival)\n{\n    register PyIntObject *v;\n#if NSMALLNEGINTS + NSMALLPOSINTS > 0\n    // 使用小整数池\n    if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) {\n        v = small_ints[ival + NSMALLNEGINTS];\n        Py_INCREF(v);\n#ifdef COUNT_ALLOCS\n        if (ival >= 0)\n            quick_int_allocs++;\n        else\n            quick_neg_int_allocs++;\n#endif\n        return (PyObject *) v;\n    }\n#endif\n    // 使用通用对象池\n    if (free_list == NULL) {\n        if ((free_list = fill_free_list()) == NULL)\n            return NULL;\n    }\n    /* Inline PyObject_New */\n    v = free_list;\n    free_list = (PyIntObject *)Py_TYPE(v);\n    (void)PyObject_INIT(v, &PyInt_Type);\n    v->ob_ival = ival;\n    return (PyObject *) v;\n}\n```","source":"_posts/Python源码剖析-Note1.md","raw":"---\ntitle: Python源码剖析-Note1\ncategories:\n- Python\ntags: \n- Python\n- Note\n---\n\n## 1.Python 架构\n\n* 1.1 文件组：\n\n  模块、库、自定义模块\n\n* 1.2 核心\n    \n  解析器\n\n  Scanner词法分析 -> Parser语法分析，建立AST（抽象语法树）\n  -> Compiler 生成指令集合，Python字节码（byte code） -> 由Code Evaluator（虚拟机）执行字节码\n   \n* 1.3 运行时环境\n  \n    对象/类型系统 Object/Type structures\n    内存分配器  Memory Allocator\n    运行时状态信息  Current State of Python\n\n## 2.Python的内建对象\n\n* 2.1 关于对象\n* 类型对象（整数类型，字符串类型）都是被静态初始化的\n* 对象被创建后的内存中的大小是不可变的！\n\n* 2.2 PyObject\n* 只包含一个引用计数和一个类型指针（指向具体的结构信息）\n```c\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   \\\n    _PyObject_HEAD_EXTRA                \\\n    Py_ssize_t ob_refcnt;               \\\n    struct _typeobject *ob_type;\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\ntypedef struct _object {\n    PyObject_HEAD\n} PyObject;\n```\n\n* 2.3 PyVarObject\n* 对PyObject的扩展，可以理解为一个容器，比如对于一个string的实现，需要使用一个n * char的实现方式，因此需要一个字段存储长度。因此结构如下：\n\n```c\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD               \\\n    PyObject_HEAD                       \\\n    Py_ssize_t ob_size; /* Number of items in variable part */\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\ntypedef struct {\n    PyObject_VAR_HEAD\n} PyVarObject;\n```\n\n* 2.4 创建类型对象的方式\n* 使用范型的API（AOL）\n```c\nPyObject *intObj = PyObject_New(PyObject, &PyInt_Type);\n```\n* 使用与类型相关的API（COL）\n```c\nPyObject* intObj = PyInt_FromLong(20);\n```\n\n* 2.5 对象的行为\n* PyTypeObject包含大量函数指针，指明了其不同的对象的行为实现。\n* 标准行为函数族：基础类型的函数，列表的函数族，字典用的函数族\n```c\n    PyNumberMethods *tp_as_number;  \n    PySequenceMethods *tp_as_sequence;\n    PyMappingMethods *tp_as_mapping;\n```\n\n2.6 类型的类型\n* 对于用户自定义class所对应的PyTypeObject对象通过PyType_Type创建。\n```python\nclass A(object):\n    pass\n\nA.__class__ # 输出 <type 'type'>\nint.__class__  # 输出 <type 'type'>\n```\npython中被称为metaclass\n\n> int运行时类型关系： \n> int - ob_refent + ob_type\n>    ob_type - PyInt_Type(ob_type)\n>       PyInt_Type(ob_type) -> PyType_Type\n>       PyInt_Type(tp_base) -> PyBaseObject_Type\n\n2.7 多态的实现原理\n所有的对象使用PyObject来存储，然后再对不同的对象类型执行不同的函数族，实现多态，如\n```c\n// PyTypeObject PyInt_Type = {\n//     PyVarObject_HEAD_INIT(&PyType_Type, 0)\n//     \"int\",\n//     sizeof(PyIntObject),\n//     0,\n//     (destructor)int_dealloc,                    /* tp_dealloc */\n//     (printfunc)int_print,                       /* tp_print */\n//      ....\n\nPyObject* intObj = PyInt_FromLong(20);\nintObj->ob_type->tp_print(intObj, fp, 0);\n\n```\n2.8 引用计数\n* 增加和减少一个对象的引用计数\n```c\nob_refcnt <- Py_INCREF(op), Py_DECREF(op)\n```\n\n* 类型对象是超越引用计数规则的，即永远不会析构，每个对象指向类型对象的指针不会被视为对类型对象的引用。\n> 注意：当引数为0时，会调用其对应的析构函数，但这并不意味着一定会调用free，因为这样频繁的调用会导致性能不好，所以会采取将其放到内存池的作法。\n\n2.9 对象分类：\n* Fundamental对象：类型对象         type\n* Numeric对象：数值对象         boolean, float, int\n* Sequence对象：序列集合对象     list, tuple, string\n* Mapping对象：对应C++中的map     dict\n* Internal对象：虚拟机运行时的内部使用对象       function, code, frame, module, method\n\n## 3.Python中的整数对象\n\n3.1 实现方式\n* PyIntObject用于实现整数对象，不可变对象，即创建后就不能改变其值\n> 引出问题？  非常频繁的创建和销毁Int对象将会导致性能问题\n\n* 元信息：\n```c\nPyTypeObject PyInt_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"int\",\n    sizeof(PyIntObject),\n    0,\n    (destructor)int_dealloc,                    /* tp_dealloc */\n    (printfunc)int_print,                       /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    (cmpfunc)int_compare,                       /* tp_compare */\n    (reprfunc)int_to_decimal_string,            /* tp_repr */\n    &int_as_number,                             /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    (hashfunc)int_hash,                         /* tp_hash */\n    0,                                          /* tp_call */\n    (reprfunc)int_to_decimal_string,            /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |\n        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_INT_SUBCLASS,          /* tp_flags */\n    int_doc,                                    /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    int_methods,                                /* tp_methods */\n    0,                                          /* tp_members */\n    int_getset,                                 /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    int_new,                                    /* tp_new */\n};\n```\n\n* PyNumberMethods展示所有可选的操作信息\n\n\n3.2 int_add的实现\n\n* PyInt_AS_LONG  vs PyInt_AsLong ,后者版本执行效率较慢，会有多方的检查\n\n> python中对于频繁执行的代码，都会提供函数和宏两个版本\n\n* 默认情况下，返回一个新的PyIntObject， 当越界时将转为PyLong_Type的结果返回\n```c\nstatic PyObject *\nint_add(PyIntObject *v, PyIntObject *w)\n{\n    register long a, b, x;\n    CONVERT_TO_LONG(v, a);\n    CONVERT_TO_LONG(w, b);\n    /* casts in the line below avoid undefined behaviour on overflow */\n    x = (long)((unsigned long)a + b);\n    if ((x^a) >= 0 || (x^b) >= 0)\n        return PyInt_FromLong(x);\n    return PyLong_Type.tp_as_number->nb_add((PyObject *)v, (PyObject *)w);\n\n```\n3.3 PyIntObject的创建\n\n* PyInt_FromString 与 PyInt_FromUnicode 最终都是调用PyInt_FromLong创建，适配器模式的设计模式\n```c\nPyAPI_FUNC(PyObject *) PyInt_FromString(char*, char**, int);\n#ifdef Py_USING_UNICODE\nPyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE*, Py_ssize_t, int);\n#endif\nPyAPI_FUNC(PyObject *) PyInt_FromLong(long);\nPyAPI_FUNC(PyObject *) PyInt_FromSize_t(size_t);\nPyAPI_FUNC(PyObject *) PyInt_FromSsize_t(Py_ssize_t);\n```\n\n3.4 大整数与小整数\n* 小整数： 默认是[-5，257]的范围，这些整数直接缓存在内存中，并存放其指针在small_ints的中。\n```c\n// intobject.c\n#ifndef NSMALLPOSINTS\n#define NSMALLPOSINTS           257\n#endif\n#ifndef NSMALLNEGINTS\n#define NSMALLNEGINTS           5\n#endif\n```\n\n* 大整数：提供一块内存空间，配置如下：\n```c\n#define BLOCK_SIZE      1000    /* 1K less typical malloc overhead */\n#define BHEAD_SIZE      8       /* Enough for a 64-bit pointer */\n#define N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))\n\nstruct _intblock {\n    struct _intblock *next;\n    PyIntObject objects[N_INTOBJECTS];\n};\n```\n\n计算得出N_INTOBJECTS的值为24，对于一个64位指针使用8个字节来算\n\n3.5 添加与删除\n\n```c\nPyObject *\nPyInt_FromLong(long ival)\n{\n    register PyIntObject *v;\n#if NSMALLNEGINTS + NSMALLPOSINTS > 0\n    // 使用小整数池\n    if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) {\n        v = small_ints[ival + NSMALLNEGINTS];\n        Py_INCREF(v);\n#ifdef COUNT_ALLOCS\n        if (ival >= 0)\n            quick_int_allocs++;\n        else\n            quick_neg_int_allocs++;\n#endif\n        return (PyObject *) v;\n    }\n#endif\n    // 使用通用对象池\n    if (free_list == NULL) {\n        if ((free_list = fill_free_list()) == NULL)\n            return NULL;\n    }\n    /* Inline PyObject_New */\n    v = free_list;\n    free_list = (PyIntObject *)Py_TYPE(v);\n    (void)PyObject_INIT(v, &PyInt_Type);\n    v->ob_ival = ival;\n    return (PyObject *) v;\n}\n```","slug":"Python源码剖析-Note1","published":1,"date":"2021-06-04T03:22:22.100Z","updated":"2021-06-04T03:22:22.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckphri01c00003ef0aexnuh0d","content":"<h2 id=\"1-Python-架构\"><a href=\"#1-Python-架构\" class=\"headerlink\" title=\"1.Python 架构\"></a>1.Python 架构</h2><ul>\n<li><p>1.1 文件组：</p>\n<p>模块、库、自定义模块</p>\n</li>\n<li><p>1.2 核心</p>\n<p>解析器</p>\n<p>Scanner词法分析 -&gt; Parser语法分析，建立AST（抽象语法树）<br>-&gt; Compiler 生成指令集合，Python字节码（byte code） -&gt; 由Code Evaluator（虚拟机）执行字节码</p>\n</li>\n<li><p>1.3 运行时环境</p>\n<p>  对象/类型系统 Object/Type structures<br>  内存分配器  Memory Allocator<br>  运行时状态信息  Current State of Python</p>\n</li>\n</ul>\n<h2 id=\"2-Python的内建对象\"><a href=\"#2-Python的内建对象\" class=\"headerlink\" title=\"2.Python的内建对象\"></a>2.Python的内建对象</h2><ul>\n<li><p>2.1 关于对象</p>\n</li>\n<li><p>类型对象（整数类型，字符串类型）都是被静态初始化的</p>\n</li>\n<li><p>对象被创建后的内存中的大小是不可变的！</p>\n</li>\n<li><p>2.2 PyObject</p>\n</li>\n<li><p>只包含一个引用计数和一个类型指针（指向具体的结构信息）</p>\n<pre><code class=\"c\">/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   \\\n  _PyObject_HEAD_EXTRA                \\\n  Py_ssize_t ob_refcnt;               \\\n  struct _typeobject *ob_type;\n</code></pre>\n</li>\n</ul>\n<p>/* Nothing is actually declared to be a PyObject, but every pointer to</p>\n<ul>\n<li>a Python object can be cast to a PyObject*.  This is inheritance built</li>\n<li>by hand.  Similarly every pointer to a variable-size Python object can,</li>\n<li>in addition, be cast to PyVarObject*.</li>\n<li>/<br>typedef struct _object {<br>  PyObject_HEAD<br>} PyObject;<pre><code></code></pre></li>\n</ul>\n<ul>\n<li>2.3 PyVarObject</li>\n<li>对PyObject的扩展，可以理解为一个容器，比如对于一个string的实现，需要使用一个n * char的实现方式，因此需要一个字段存储长度。因此结构如下：</li>\n</ul>\n<pre><code class=\"c\">/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc&#39;ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD               \\\n    PyObject_HEAD                       \\\n    Py_ssize_t ob_size; /* Number of items in variable part */\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\ntypedef struct {\n    PyObject_VAR_HEAD\n} PyVarObject;</code></pre>\n<ul>\n<li><p>2.4 创建类型对象的方式</p>\n</li>\n<li><p>使用范型的API（AOL）</p>\n<pre><code class=\"c\">PyObject *intObj = PyObject_New(PyObject, &amp;PyInt_Type);</code></pre>\n</li>\n<li><p>使用与类型相关的API（COL）</p>\n<pre><code class=\"c\">PyObject* intObj = PyInt_FromLong(20);</code></pre>\n</li>\n<li><p>2.5 对象的行为</p>\n</li>\n<li><p>PyTypeObject包含大量函数指针，指明了其不同的对象的行为实现。</p>\n</li>\n<li><p>标准行为函数族：基础类型的函数，列表的函数族，字典用的函数族</p>\n<pre><code class=\"c\">  PyNumberMethods *tp_as_number;  \n  PySequenceMethods *tp_as_sequence;\n  PyMappingMethods *tp_as_mapping;</code></pre>\n</li>\n</ul>\n<p>2.6 类型的类型</p>\n<ul>\n<li>对于用户自定义class所对应的PyTypeObject对象通过PyType_Type创建。<pre><code class=\"python\">class A(object):\n  pass\n</code></pre>\n</li>\n</ul>\n<p>A.<strong>class</strong> # 输出 &lt;type ‘type’&gt;<br>int.<strong>class</strong>  # 输出 &lt;type ‘type’&gt;</p>\n<pre><code>python中被称为metaclass\n\n&gt; int运行时类型关系： \n&gt; int - ob_refent + ob_type\n&gt;    ob_type - PyInt_Type(ob_type)\n&gt;       PyInt_Type(ob_type) -&gt; PyType_Type\n&gt;       PyInt_Type(tp_base) -&gt; PyBaseObject_Type\n\n2.7 多态的实现原理\n所有的对象使用PyObject来存储，然后再对不同的对象类型执行不同的函数族，实现多态，如\n```c\n// PyTypeObject PyInt_Type = {\n//     PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)\n//     &quot;int&quot;,\n//     sizeof(PyIntObject),\n//     0,\n//     (destructor)int_dealloc,                    /* tp_dealloc */\n//     (printfunc)int_print,                       /* tp_print */\n//      ....\n\nPyObject* intObj = PyInt_FromLong(20);\nintObj-&gt;ob_type-&gt;tp_print(intObj, fp, 0);\n</code></pre><p>2.8 引用计数</p>\n<ul>\n<li><p>增加和减少一个对象的引用计数</p>\n<pre><code class=\"c\">ob_refcnt &lt;- Py_INCREF(op), Py_DECREF(op)</code></pre>\n</li>\n<li><p>类型对象是超越引用计数规则的，即永远不会析构，每个对象指向类型对象的指针不会被视为对类型对象的引用。</p>\n<blockquote>\n<p>注意：当引数为0时，会调用其对应的析构函数，但这并不意味着一定会调用free，因为这样频繁的调用会导致性能不好，所以会采取将其放到内存池的作法。</p>\n</blockquote>\n</li>\n</ul>\n<p>2.9 对象分类：</p>\n<ul>\n<li>Fundamental对象：类型对象         type</li>\n<li>Numeric对象：数值对象         boolean, float, int</li>\n<li>Sequence对象：序列集合对象     list, tuple, string</li>\n<li>Mapping对象：对应C++中的map     dict</li>\n<li>Internal对象：虚拟机运行时的内部使用对象       function, code, frame, module, method</li>\n</ul>\n<h2 id=\"3-Python中的整数对象\"><a href=\"#3-Python中的整数对象\" class=\"headerlink\" title=\"3.Python中的整数对象\"></a>3.Python中的整数对象</h2><p>3.1 实现方式</p>\n<ul>\n<li><p>PyIntObject用于实现整数对象，不可变对象，即创建后就不能改变其值</p>\n<blockquote>\n<p>引出问题？  非常频繁的创建和销毁Int对象将会导致性能问题</p>\n</blockquote>\n</li>\n<li><p>元信息：</p>\n<pre><code class=\"c\">PyTypeObject PyInt_Type = {\n  PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)\n  &quot;int&quot;,\n  sizeof(PyIntObject),\n  0,\n  (destructor)int_dealloc,                    /* tp_dealloc */\n  (printfunc)int_print,                       /* tp_print */\n  0,                                          /* tp_getattr */\n  0,                                          /* tp_setattr */\n  (cmpfunc)int_compare,                       /* tp_compare */\n  (reprfunc)int_to_decimal_string,            /* tp_repr */\n  &amp;int_as_number,                             /* tp_as_number */\n  0,                                          /* tp_as_sequence */\n  0,                                          /* tp_as_mapping */\n  (hashfunc)int_hash,                         /* tp_hash */\n  0,                                          /* tp_call */\n  (reprfunc)int_to_decimal_string,            /* tp_str */\n  PyObject_GenericGetAttr,                    /* tp_getattro */\n  0,                                          /* tp_setattro */\n  0,                                          /* tp_as_buffer */\n  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |\n      Py_TPFLAGS_BASETYPE | Py_TPFLAGS_INT_SUBCLASS,          /* tp_flags */\n  int_doc,                                    /* tp_doc */\n  0,                                          /* tp_traverse */\n  0,                                          /* tp_clear */\n  0,                                          /* tp_richcompare */\n  0,                                          /* tp_weaklistoffset */\n  0,                                          /* tp_iter */\n  0,                                          /* tp_iternext */\n  int_methods,                                /* tp_methods */\n  0,                                          /* tp_members */\n  int_getset,                                 /* tp_getset */\n  0,                                          /* tp_base */\n  0,                                          /* tp_dict */\n  0,                                          /* tp_descr_get */\n  0,                                          /* tp_descr_set */\n  0,                                          /* tp_dictoffset */\n  0,                                          /* tp_init */\n  0,                                          /* tp_alloc */\n  int_new,                                    /* tp_new */\n};</code></pre>\n</li>\n<li><p>PyNumberMethods展示所有可选的操作信息</p>\n</li>\n</ul>\n<p>3.2 int_add的实现</p>\n<ul>\n<li>PyInt_AS_LONG  vs PyInt_AsLong ,后者版本执行效率较慢，会有多方的检查</li>\n</ul>\n<blockquote>\n<p>python中对于频繁执行的代码，都会提供函数和宏两个版本</p>\n</blockquote>\n<ul>\n<li>默认情况下，返回一个新的PyIntObject， 当越界时将转为PyLong_Type的结果返回<pre><code class=\"c\">static PyObject *\nint_add(PyIntObject *v, PyIntObject *w)\n{\n  register long a, b, x;\n  CONVERT_TO_LONG(v, a);\n  CONVERT_TO_LONG(w, b);\n  /* casts in the line below avoid undefined behaviour on overflow */\n  x = (long)((unsigned long)a + b);\n  if ((x^a) &gt;= 0 || (x^b) &gt;= 0)\n      return PyInt_FromLong(x);\n  return PyLong_Type.tp_as_number-&gt;nb_add((PyObject *)v, (PyObject *)w);\n</code></pre>\n</li>\n</ul>\n<pre><code>3.3 PyIntObject的创建\n\n* PyInt_FromString 与 PyInt_FromUnicode 最终都是调用PyInt_FromLong创建，适配器模式的设计模式\n```c\nPyAPI_FUNC(PyObject *) PyInt_FromString(char*, char**, int);\n#ifdef Py_USING_UNICODE\nPyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE*, Py_ssize_t, int);\n#endif\nPyAPI_FUNC(PyObject *) PyInt_FromLong(long);\nPyAPI_FUNC(PyObject *) PyInt_FromSize_t(size_t);\nPyAPI_FUNC(PyObject *) PyInt_FromSsize_t(Py_ssize_t);</code></pre><p>3.4 大整数与小整数</p>\n<ul>\n<li><p>小整数： 默认是[-5，257]的范围，这些整数直接缓存在内存中，并存放其指针在small_ints的中。</p>\n<pre><code class=\"c\">// intobject.c\n#ifndef NSMALLPOSINTS\n#define NSMALLPOSINTS           257\n#endif\n#ifndef NSMALLNEGINTS\n#define NSMALLNEGINTS           5\n#endif</code></pre>\n</li>\n<li><p>大整数：提供一块内存空间，配置如下：</p>\n<pre><code class=\"c\">#define BLOCK_SIZE      1000    /* 1K less typical malloc overhead */\n#define BHEAD_SIZE      8       /* Enough for a 64-bit pointer */\n#define N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))\n</code></pre>\n</li>\n</ul>\n<p>struct _intblock {<br>    struct _intblock *next;<br>    PyIntObject objects[N_INTOBJECTS];<br>};</p>\n<pre><code>\n计算得出N_INTOBJECTS的值为24，对于一个64位指针使用8个字节来算\n\n3.5 添加与删除\n\n```c\nPyObject *\nPyInt_FromLong(long ival)\n{\n    register PyIntObject *v;\n#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0\n    // 使用小整数池\n    if (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) {\n        v = small_ints[ival + NSMALLNEGINTS];\n        Py_INCREF(v);\n#ifdef COUNT_ALLOCS\n        if (ival &gt;= 0)\n            quick_int_allocs++;\n        else\n            quick_neg_int_allocs++;\n#endif\n        return (PyObject *) v;\n    }\n#endif\n    // 使用通用对象池\n    if (free_list == NULL) {\n        if ((free_list = fill_free_list()) == NULL)\n            return NULL;\n    }\n    /* Inline PyObject_New */\n    v = free_list;\n    free_list = (PyIntObject *)Py_TYPE(v);\n    (void)PyObject_INIT(v, &amp;PyInt_Type);\n    v-&gt;ob_ival = ival;\n    return (PyObject *) v;\n}</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Python-架构\"><a href=\"#1-Python-架构\" class=\"headerlink\" title=\"1.Python 架构\"></a>1.Python 架构</h2><ul>\n<li><p>1.1 文件组：</p>\n<p>模块、库、自定义模块</p>\n</li>\n<li><p>1.2 核心</p>\n<p>解析器</p>\n<p>Scanner词法分析 -&gt; Parser语法分析，建立AST（抽象语法树）<br>-&gt; Compiler 生成指令集合，Python字节码（byte code） -&gt; 由Code Evaluator（虚拟机）执行字节码</p>\n</li>\n<li><p>1.3 运行时环境</p>\n<p>  对象/类型系统 Object/Type structures<br>  内存分配器  Memory Allocator<br>  运行时状态信息  Current State of Python</p>\n</li>\n</ul>\n<h2 id=\"2-Python的内建对象\"><a href=\"#2-Python的内建对象\" class=\"headerlink\" title=\"2.Python的内建对象\"></a>2.Python的内建对象</h2><ul>\n<li><p>2.1 关于对象</p>\n</li>\n<li><p>类型对象（整数类型，字符串类型）都是被静态初始化的</p>\n</li>\n<li><p>对象被创建后的内存中的大小是不可变的！</p>\n</li>\n<li><p>2.2 PyObject</p>\n</li>\n<li><p>只包含一个引用计数和一个类型指针（指向具体的结构信息）</p>\n<pre><code class=\"c\">/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   \\\n  _PyObject_HEAD_EXTRA                \\\n  Py_ssize_t ob_refcnt;               \\\n  struct _typeobject *ob_type;\n</code></pre>\n</li>\n</ul>\n<p>/* Nothing is actually declared to be a PyObject, but every pointer to</p>\n<ul>\n<li>a Python object can be cast to a PyObject*.  This is inheritance built</li>\n<li>by hand.  Similarly every pointer to a variable-size Python object can,</li>\n<li>in addition, be cast to PyVarObject*.</li>\n<li>/<br>typedef struct _object {<br>  PyObject_HEAD<br>} PyObject;<pre><code></code></pre></li>\n</ul>\n<ul>\n<li>2.3 PyVarObject</li>\n<li>对PyObject的扩展，可以理解为一个容器，比如对于一个string的实现，需要使用一个n * char的实现方式，因此需要一个字段存储长度。因此结构如下：</li>\n</ul>\n<pre><code class=\"c\">/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc&#39;ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD               \\\n    PyObject_HEAD                       \\\n    Py_ssize_t ob_size; /* Number of items in variable part */\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\ntypedef struct {\n    PyObject_VAR_HEAD\n} PyVarObject;</code></pre>\n<ul>\n<li><p>2.4 创建类型对象的方式</p>\n</li>\n<li><p>使用范型的API（AOL）</p>\n<pre><code class=\"c\">PyObject *intObj = PyObject_New(PyObject, &amp;PyInt_Type);</code></pre>\n</li>\n<li><p>使用与类型相关的API（COL）</p>\n<pre><code class=\"c\">PyObject* intObj = PyInt_FromLong(20);</code></pre>\n</li>\n<li><p>2.5 对象的行为</p>\n</li>\n<li><p>PyTypeObject包含大量函数指针，指明了其不同的对象的行为实现。</p>\n</li>\n<li><p>标准行为函数族：基础类型的函数，列表的函数族，字典用的函数族</p>\n<pre><code class=\"c\">  PyNumberMethods *tp_as_number;  \n  PySequenceMethods *tp_as_sequence;\n  PyMappingMethods *tp_as_mapping;</code></pre>\n</li>\n</ul>\n<p>2.6 类型的类型</p>\n<ul>\n<li>对于用户自定义class所对应的PyTypeObject对象通过PyType_Type创建。<pre><code class=\"python\">class A(object):\n  pass\n</code></pre>\n</li>\n</ul>\n<p>A.<strong>class</strong> # 输出 &lt;type ‘type’&gt;<br>int.<strong>class</strong>  # 输出 &lt;type ‘type’&gt;</p>\n<pre><code>python中被称为metaclass\n\n&gt; int运行时类型关系： \n&gt; int - ob_refent + ob_type\n&gt;    ob_type - PyInt_Type(ob_type)\n&gt;       PyInt_Type(ob_type) -&gt; PyType_Type\n&gt;       PyInt_Type(tp_base) -&gt; PyBaseObject_Type\n\n2.7 多态的实现原理\n所有的对象使用PyObject来存储，然后再对不同的对象类型执行不同的函数族，实现多态，如\n```c\n// PyTypeObject PyInt_Type = {\n//     PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)\n//     &quot;int&quot;,\n//     sizeof(PyIntObject),\n//     0,\n//     (destructor)int_dealloc,                    /* tp_dealloc */\n//     (printfunc)int_print,                       /* tp_print */\n//      ....\n\nPyObject* intObj = PyInt_FromLong(20);\nintObj-&gt;ob_type-&gt;tp_print(intObj, fp, 0);\n</code></pre><p>2.8 引用计数</p>\n<ul>\n<li><p>增加和减少一个对象的引用计数</p>\n<pre><code class=\"c\">ob_refcnt &lt;- Py_INCREF(op), Py_DECREF(op)</code></pre>\n</li>\n<li><p>类型对象是超越引用计数规则的，即永远不会析构，每个对象指向类型对象的指针不会被视为对类型对象的引用。</p>\n<blockquote>\n<p>注意：当引数为0时，会调用其对应的析构函数，但这并不意味着一定会调用free，因为这样频繁的调用会导致性能不好，所以会采取将其放到内存池的作法。</p>\n</blockquote>\n</li>\n</ul>\n<p>2.9 对象分类：</p>\n<ul>\n<li>Fundamental对象：类型对象         type</li>\n<li>Numeric对象：数值对象         boolean, float, int</li>\n<li>Sequence对象：序列集合对象     list, tuple, string</li>\n<li>Mapping对象：对应C++中的map     dict</li>\n<li>Internal对象：虚拟机运行时的内部使用对象       function, code, frame, module, method</li>\n</ul>\n<h2 id=\"3-Python中的整数对象\"><a href=\"#3-Python中的整数对象\" class=\"headerlink\" title=\"3.Python中的整数对象\"></a>3.Python中的整数对象</h2><p>3.1 实现方式</p>\n<ul>\n<li><p>PyIntObject用于实现整数对象，不可变对象，即创建后就不能改变其值</p>\n<blockquote>\n<p>引出问题？  非常频繁的创建和销毁Int对象将会导致性能问题</p>\n</blockquote>\n</li>\n<li><p>元信息：</p>\n<pre><code class=\"c\">PyTypeObject PyInt_Type = {\n  PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)\n  &quot;int&quot;,\n  sizeof(PyIntObject),\n  0,\n  (destructor)int_dealloc,                    /* tp_dealloc */\n  (printfunc)int_print,                       /* tp_print */\n  0,                                          /* tp_getattr */\n  0,                                          /* tp_setattr */\n  (cmpfunc)int_compare,                       /* tp_compare */\n  (reprfunc)int_to_decimal_string,            /* tp_repr */\n  &amp;int_as_number,                             /* tp_as_number */\n  0,                                          /* tp_as_sequence */\n  0,                                          /* tp_as_mapping */\n  (hashfunc)int_hash,                         /* tp_hash */\n  0,                                          /* tp_call */\n  (reprfunc)int_to_decimal_string,            /* tp_str */\n  PyObject_GenericGetAttr,                    /* tp_getattro */\n  0,                                          /* tp_setattro */\n  0,                                          /* tp_as_buffer */\n  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |\n      Py_TPFLAGS_BASETYPE | Py_TPFLAGS_INT_SUBCLASS,          /* tp_flags */\n  int_doc,                                    /* tp_doc */\n  0,                                          /* tp_traverse */\n  0,                                          /* tp_clear */\n  0,                                          /* tp_richcompare */\n  0,                                          /* tp_weaklistoffset */\n  0,                                          /* tp_iter */\n  0,                                          /* tp_iternext */\n  int_methods,                                /* tp_methods */\n  0,                                          /* tp_members */\n  int_getset,                                 /* tp_getset */\n  0,                                          /* tp_base */\n  0,                                          /* tp_dict */\n  0,                                          /* tp_descr_get */\n  0,                                          /* tp_descr_set */\n  0,                                          /* tp_dictoffset */\n  0,                                          /* tp_init */\n  0,                                          /* tp_alloc */\n  int_new,                                    /* tp_new */\n};</code></pre>\n</li>\n<li><p>PyNumberMethods展示所有可选的操作信息</p>\n</li>\n</ul>\n<p>3.2 int_add的实现</p>\n<ul>\n<li>PyInt_AS_LONG  vs PyInt_AsLong ,后者版本执行效率较慢，会有多方的检查</li>\n</ul>\n<blockquote>\n<p>python中对于频繁执行的代码，都会提供函数和宏两个版本</p>\n</blockquote>\n<ul>\n<li>默认情况下，返回一个新的PyIntObject， 当越界时将转为PyLong_Type的结果返回<pre><code class=\"c\">static PyObject *\nint_add(PyIntObject *v, PyIntObject *w)\n{\n  register long a, b, x;\n  CONVERT_TO_LONG(v, a);\n  CONVERT_TO_LONG(w, b);\n  /* casts in the line below avoid undefined behaviour on overflow */\n  x = (long)((unsigned long)a + b);\n  if ((x^a) &gt;= 0 || (x^b) &gt;= 0)\n      return PyInt_FromLong(x);\n  return PyLong_Type.tp_as_number-&gt;nb_add((PyObject *)v, (PyObject *)w);\n</code></pre>\n</li>\n</ul>\n<pre><code>3.3 PyIntObject的创建\n\n* PyInt_FromString 与 PyInt_FromUnicode 最终都是调用PyInt_FromLong创建，适配器模式的设计模式\n```c\nPyAPI_FUNC(PyObject *) PyInt_FromString(char*, char**, int);\n#ifdef Py_USING_UNICODE\nPyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE*, Py_ssize_t, int);\n#endif\nPyAPI_FUNC(PyObject *) PyInt_FromLong(long);\nPyAPI_FUNC(PyObject *) PyInt_FromSize_t(size_t);\nPyAPI_FUNC(PyObject *) PyInt_FromSsize_t(Py_ssize_t);</code></pre><p>3.4 大整数与小整数</p>\n<ul>\n<li><p>小整数： 默认是[-5，257]的范围，这些整数直接缓存在内存中，并存放其指针在small_ints的中。</p>\n<pre><code class=\"c\">// intobject.c\n#ifndef NSMALLPOSINTS\n#define NSMALLPOSINTS           257\n#endif\n#ifndef NSMALLNEGINTS\n#define NSMALLNEGINTS           5\n#endif</code></pre>\n</li>\n<li><p>大整数：提供一块内存空间，配置如下：</p>\n<pre><code class=\"c\">#define BLOCK_SIZE      1000    /* 1K less typical malloc overhead */\n#define BHEAD_SIZE      8       /* Enough for a 64-bit pointer */\n#define N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))\n</code></pre>\n</li>\n</ul>\n<p>struct _intblock {<br>    struct _intblock *next;<br>    PyIntObject objects[N_INTOBJECTS];<br>};</p>\n<pre><code>\n计算得出N_INTOBJECTS的值为24，对于一个64位指针使用8个字节来算\n\n3.5 添加与删除\n\n```c\nPyObject *\nPyInt_FromLong(long ival)\n{\n    register PyIntObject *v;\n#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0\n    // 使用小整数池\n    if (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) {\n        v = small_ints[ival + NSMALLNEGINTS];\n        Py_INCREF(v);\n#ifdef COUNT_ALLOCS\n        if (ival &gt;= 0)\n            quick_int_allocs++;\n        else\n            quick_neg_int_allocs++;\n#endif\n        return (PyObject *) v;\n    }\n#endif\n    // 使用通用对象池\n    if (free_list == NULL) {\n        if ((free_list = fill_free_list()) == NULL)\n            return NULL;\n    }\n    /* Inline PyObject_New */\n    v = free_list;\n    free_list = (PyIntObject *)Py_TYPE(v);\n    (void)PyObject_INIT(v, &amp;PyInt_Type);\n    v-&gt;ob_ival = ival;\n    return (PyObject *) v;\n}</code></pre>"},{"title":"Python源码剖析-Note2","_content":"# Python的内存\n\n## 引用计数\n\n由源码可知，Python的数据对象由PyVarObject（PyObject+size）组成，PyObject中又包含了双向链表，计数器，数据类型_typeobject对象（其中可以定制行为）\n\n```c\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    struct _object *_ob_next;           \\\n    struct _object *_ob_prev;\n\n#define PyObject_HEAD                   \\\n    _PyObject_HEAD_EXTRA                \\\n    Py_ssize_t ob_refcnt;               \\\n    struct _typeobject *ob_type;\n    \n#define PyObject_VAR_HEAD               \\\n    PyObject_HEAD                       \\\n    Py_ssize_t ob_size; /* Number of items in variable part */\n\ntypedef struct {\n    PyObject_HEAD\n    long ob_ival;\n} PyIntObject;\n\ntypedef struct {\n    PyObject_HEAD\n    double ob_fval;\n} PyFloatObject;\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 <= ob_size <= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\n    Py_ssize_t allocated;\n} PyListObject;\n\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    PyObject *ob_item[1];\n\n    /* ob_item contains space for 'ob_size' elements.\n     * Items must normally not be NULL, except during construction when\n     * the tuple is not yet visible outside the function that builds it.\n     */\n} PyTupleObject;\n\n\n/*\nTo ensure the lookup algorithm terminates, there must be at least one Unused\nslot (NULL key) in the table.\nThe value ma_fill is the number of non-NULL keys (sum of Active and Dummy);\nma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL\nvalues == the number of Active items).\nTo avoid slowing down lookups on a near-full table, we resize the table when\nit's two-thirds full.\n*/\ntypedef struct _dictobject PyDictObject;\nstruct _dictobject {\n    PyObject_HEAD\n    Py_ssize_t ma_fill;  /* # Active + # Dummy */\n    Py_ssize_t ma_used;  /* # Active */\n\n    /* The table contains ma_mask + 1 slots, and that's a power of 2.\n     * We store the mask instead of the size because the mask is more\n     * frequently needed.\n     */\n    Py_ssize_t ma_mask;\n\n    /* ma_table points to ma_smalltable for small tables, else to\n     * additional malloc'ed memory.  ma_table is never NULL!  This rule\n     * saves repeated runtime null-tests in the workhorse getitem and\n     * setitem calls.\n     */\n    PyDictEntry *ma_table;\n    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);\n    PyDictEntry ma_smalltable[PyDict_MINSIZE];\n};\n\n\n```\n\n## 标记清除\n对于list, dict, tuple 这种类型，有可能存在循环引用的情况，这时需要再做一次扫描及标记清除的处理。\n* 在Python中使用另一个新的链表来存储需要标记清除的对象。然而这种扫描的往往比较耗时，需要执行可达性分析，以找到unreachable的对象，对这些对象进行标记清除。\n* 因此为标记清除的处理需要找一个时间点来。 这就引入了分代机制\n\n\n## 分代机制\n标记清除的扫描的操作比较耗时。所以需要设置一个时间点。\n* Python中设置第一代为 700个对象， 第二代为第一代的10次，第三代为第二代的10次\n* 可使用python的gc模块，从业务层对这些值进行设置\n\n## 缓存机制\n一、int的缓存机制\n\n二、字符串的缓存机制：\n\n* intern dict ： PyDict对象，key, value就是字符串\n\n* nullstring, characters， 空串和单串，有两个属性来存储\n\n  > intern的默认识别只能在compile时，无法在runtime时识别，不过可以手动调用intern\n\n![字符串缓存机制](/img/image-20210730174828153.png)\n\n三、tuple的缓存机制\n\nPyTupleObject， 维护一个链表，用free_list存储链表头， 20个\n\n不用像int和string一整块的申请，利用链表的ob_item组起来\n\n四、list的缓存机制\n\n维护一个free_list ， 保存80个，运行时往里回放。\n\n四、源码分析\nobmalloc.c -> PyObject_Malloc\n\n1. 申请大小大于256，直接使用 PyMem_Malloc\n\n2. 小于256， 进入小块内存池\n\n* 取size， 指定大小-1 后 除以8或者16字节。(设定一个block大小)\n\n  \n\n## 总结\n\n![关于python机制的总结](/img/image-20210801173440707.png)\n","source":"_posts/Python源码剖析-Note2.md","raw":"---\ntitle: Python源码剖析-Note2\ncategories:\n- Python\ntags: \n- Python\n- Note\n---\n# Python的内存\n\n## 引用计数\n\n由源码可知，Python的数据对象由PyVarObject（PyObject+size）组成，PyObject中又包含了双向链表，计数器，数据类型_typeobject对象（其中可以定制行为）\n\n```c\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    struct _object *_ob_next;           \\\n    struct _object *_ob_prev;\n\n#define PyObject_HEAD                   \\\n    _PyObject_HEAD_EXTRA                \\\n    Py_ssize_t ob_refcnt;               \\\n    struct _typeobject *ob_type;\n    \n#define PyObject_VAR_HEAD               \\\n    PyObject_HEAD                       \\\n    Py_ssize_t ob_size; /* Number of items in variable part */\n\ntypedef struct {\n    PyObject_HEAD\n    long ob_ival;\n} PyIntObject;\n\ntypedef struct {\n    PyObject_HEAD\n    double ob_fval;\n} PyFloatObject;\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 <= ob_size <= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\n    Py_ssize_t allocated;\n} PyListObject;\n\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    PyObject *ob_item[1];\n\n    /* ob_item contains space for 'ob_size' elements.\n     * Items must normally not be NULL, except during construction when\n     * the tuple is not yet visible outside the function that builds it.\n     */\n} PyTupleObject;\n\n\n/*\nTo ensure the lookup algorithm terminates, there must be at least one Unused\nslot (NULL key) in the table.\nThe value ma_fill is the number of non-NULL keys (sum of Active and Dummy);\nma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL\nvalues == the number of Active items).\nTo avoid slowing down lookups on a near-full table, we resize the table when\nit's two-thirds full.\n*/\ntypedef struct _dictobject PyDictObject;\nstruct _dictobject {\n    PyObject_HEAD\n    Py_ssize_t ma_fill;  /* # Active + # Dummy */\n    Py_ssize_t ma_used;  /* # Active */\n\n    /* The table contains ma_mask + 1 slots, and that's a power of 2.\n     * We store the mask instead of the size because the mask is more\n     * frequently needed.\n     */\n    Py_ssize_t ma_mask;\n\n    /* ma_table points to ma_smalltable for small tables, else to\n     * additional malloc'ed memory.  ma_table is never NULL!  This rule\n     * saves repeated runtime null-tests in the workhorse getitem and\n     * setitem calls.\n     */\n    PyDictEntry *ma_table;\n    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);\n    PyDictEntry ma_smalltable[PyDict_MINSIZE];\n};\n\n\n```\n\n## 标记清除\n对于list, dict, tuple 这种类型，有可能存在循环引用的情况，这时需要再做一次扫描及标记清除的处理。\n* 在Python中使用另一个新的链表来存储需要标记清除的对象。然而这种扫描的往往比较耗时，需要执行可达性分析，以找到unreachable的对象，对这些对象进行标记清除。\n* 因此为标记清除的处理需要找一个时间点来。 这就引入了分代机制\n\n\n## 分代机制\n标记清除的扫描的操作比较耗时。所以需要设置一个时间点。\n* Python中设置第一代为 700个对象， 第二代为第一代的10次，第三代为第二代的10次\n* 可使用python的gc模块，从业务层对这些值进行设置\n\n## 缓存机制\n一、int的缓存机制\n\n二、字符串的缓存机制：\n\n* intern dict ： PyDict对象，key, value就是字符串\n\n* nullstring, characters， 空串和单串，有两个属性来存储\n\n  > intern的默认识别只能在compile时，无法在runtime时识别，不过可以手动调用intern\n\n![字符串缓存机制](/img/image-20210730174828153.png)\n\n三、tuple的缓存机制\n\nPyTupleObject， 维护一个链表，用free_list存储链表头， 20个\n\n不用像int和string一整块的申请，利用链表的ob_item组起来\n\n四、list的缓存机制\n\n维护一个free_list ， 保存80个，运行时往里回放。\n\n四、源码分析\nobmalloc.c -> PyObject_Malloc\n\n1. 申请大小大于256，直接使用 PyMem_Malloc\n\n2. 小于256， 进入小块内存池\n\n* 取size， 指定大小-1 后 除以8或者16字节。(设定一个block大小)\n\n  \n\n## 总结\n\n![关于python机制的总结](/img/image-20210801173440707.png)\n","slug":"Python源码剖析-Note2","published":1,"date":"2021-08-01T09:43:43.427Z","updated":"2021-08-01T09:43:43.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrt0nxrr0000zxf0k9h8i5lw","content":"<h1 id=\"Python的内存\"><a href=\"#Python的内存\" class=\"headerlink\" title=\"Python的内存\"></a>Python的内存</h1><h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><p>由源码可知，Python的数据对象由PyVarObject（PyObject+size）组成，PyObject中又包含了双向链表，计数器，数据类型_typeobject对象（其中可以定制行为）</p>\n<pre><code class=\"c\">/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    struct _object *_ob_next;           \\\n    struct _object *_ob_prev;\n\n#define PyObject_HEAD                   \\\n    _PyObject_HEAD_EXTRA                \\\n    Py_ssize_t ob_refcnt;               \\\n    struct _typeobject *ob_type;\n\n#define PyObject_VAR_HEAD               \\\n    PyObject_HEAD                       \\\n    Py_ssize_t ob_size; /* Number of items in variable part */\n\ntypedef struct {\n    PyObject_HEAD\n    long ob_ival;\n} PyIntObject;\n\ntypedef struct {\n    PyObject_HEAD\n    double ob_fval;\n} PyFloatObject;\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for &#39;allocated&#39; elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 &lt;= ob_size &lt;= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\n    Py_ssize_t allocated;\n} PyListObject;\n\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    PyObject *ob_item[1];\n\n    /* ob_item contains space for &#39;ob_size&#39; elements.\n     * Items must normally not be NULL, except during construction when\n     * the tuple is not yet visible outside the function that builds it.\n     */\n} PyTupleObject;\n\n\n/*\nTo ensure the lookup algorithm terminates, there must be at least one Unused\nslot (NULL key) in the table.\nThe value ma_fill is the number of non-NULL keys (sum of Active and Dummy);\nma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL\nvalues == the number of Active items).\nTo avoid slowing down lookups on a near-full table, we resize the table when\nit&#39;s two-thirds full.\n*/\ntypedef struct _dictobject PyDictObject;\nstruct _dictobject {\n    PyObject_HEAD\n    Py_ssize_t ma_fill;  /* # Active + # Dummy */\n    Py_ssize_t ma_used;  /* # Active */\n\n    /* The table contains ma_mask + 1 slots, and that&#39;s a power of 2.\n     * We store the mask instead of the size because the mask is more\n     * frequently needed.\n     */\n    Py_ssize_t ma_mask;\n\n    /* ma_table points to ma_smalltable for small tables, else to\n     * additional malloc&#39;ed memory.  ma_table is never NULL!  This rule\n     * saves repeated runtime null-tests in the workhorse getitem and\n     * setitem calls.\n     */\n    PyDictEntry *ma_table;\n    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);\n    PyDictEntry ma_smalltable[PyDict_MINSIZE];\n};\n\n</code></pre>\n<h2 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h2><p>对于list, dict, tuple 这种类型，有可能存在循环引用的情况，这时需要再做一次扫描及标记清除的处理。</p>\n<ul>\n<li>在Python中使用另一个新的链表来存储需要标记清除的对象。然而这种扫描的往往比较耗时，需要执行可达性分析，以找到unreachable的对象，对这些对象进行标记清除。</li>\n<li>因此为标记清除的处理需要找一个时间点来。 这就引入了分代机制</li>\n</ul>\n<h2 id=\"分代机制\"><a href=\"#分代机制\" class=\"headerlink\" title=\"分代机制\"></a>分代机制</h2><p>标记清除的扫描的操作比较耗时。所以需要设置一个时间点。</p>\n<ul>\n<li>Python中设置第一代为 700个对象， 第二代为第一代的10次，第三代为第二代的10次</li>\n<li>可使用python的gc模块，从业务层对这些值进行设置</li>\n</ul>\n<h2 id=\"缓存机制\"><a href=\"#缓存机制\" class=\"headerlink\" title=\"缓存机制\"></a>缓存机制</h2><p>一、int的缓存机制</p>\n<p>二、字符串的缓存机制：</p>\n<ul>\n<li><p>intern dict ： PyDict对象，key, value就是字符串</p>\n</li>\n<li><p>nullstring, characters， 空串和单串，有两个属性来存储</p>\n<blockquote>\n<p>intern的默认识别只能在compile时，无法在runtime时识别，不过可以手动调用intern</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"/img/image-20210730174828153.png\" alt=\"字符串缓存机制\"></p>\n<p>三、tuple的缓存机制</p>\n<p>PyTupleObject， 维护一个链表，用free_list存储链表头， 20个</p>\n<p>不用像int和string一整块的申请，利用链表的ob_item组起来</p>\n<p>四、list的缓存机制</p>\n<p>维护一个free_list ， 保存80个，运行时往里回放。</p>\n<p>四、源码分析<br>obmalloc.c -&gt; PyObject_Malloc</p>\n<ol>\n<li><p>申请大小大于256，直接使用 PyMem_Malloc</p>\n</li>\n<li><p>小于256， 进入小块内存池</p>\n</li>\n</ol>\n<ul>\n<li>取size， 指定大小-1 后 除以8或者16字节。(设定一个block大小)</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/img/image-20210801173440707.png\" alt=\"关于python机制的总结\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python的内存\"><a href=\"#Python的内存\" class=\"headerlink\" title=\"Python的内存\"></a>Python的内存</h1><h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><p>由源码可知，Python的数据对象由PyVarObject（PyObject+size）组成，PyObject中又包含了双向链表，计数器，数据类型_typeobject对象（其中可以定制行为）</p>\n<pre><code class=\"c\">/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    struct _object *_ob_next;           \\\n    struct _object *_ob_prev;\n\n#define PyObject_HEAD                   \\\n    _PyObject_HEAD_EXTRA                \\\n    Py_ssize_t ob_refcnt;               \\\n    struct _typeobject *ob_type;\n\n#define PyObject_VAR_HEAD               \\\n    PyObject_HEAD                       \\\n    Py_ssize_t ob_size; /* Number of items in variable part */\n\ntypedef struct {\n    PyObject_HEAD\n    long ob_ival;\n} PyIntObject;\n\ntypedef struct {\n    PyObject_HEAD\n    double ob_fval;\n} PyFloatObject;\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for &#39;allocated&#39; elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 &lt;= ob_size &lt;= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\n    Py_ssize_t allocated;\n} PyListObject;\n\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    PyObject *ob_item[1];\n\n    /* ob_item contains space for &#39;ob_size&#39; elements.\n     * Items must normally not be NULL, except during construction when\n     * the tuple is not yet visible outside the function that builds it.\n     */\n} PyTupleObject;\n\n\n/*\nTo ensure the lookup algorithm terminates, there must be at least one Unused\nslot (NULL key) in the table.\nThe value ma_fill is the number of non-NULL keys (sum of Active and Dummy);\nma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL\nvalues == the number of Active items).\nTo avoid slowing down lookups on a near-full table, we resize the table when\nit&#39;s two-thirds full.\n*/\ntypedef struct _dictobject PyDictObject;\nstruct _dictobject {\n    PyObject_HEAD\n    Py_ssize_t ma_fill;  /* # Active + # Dummy */\n    Py_ssize_t ma_used;  /* # Active */\n\n    /* The table contains ma_mask + 1 slots, and that&#39;s a power of 2.\n     * We store the mask instead of the size because the mask is more\n     * frequently needed.\n     */\n    Py_ssize_t ma_mask;\n\n    /* ma_table points to ma_smalltable for small tables, else to\n     * additional malloc&#39;ed memory.  ma_table is never NULL!  This rule\n     * saves repeated runtime null-tests in the workhorse getitem and\n     * setitem calls.\n     */\n    PyDictEntry *ma_table;\n    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);\n    PyDictEntry ma_smalltable[PyDict_MINSIZE];\n};\n\n</code></pre>\n<h2 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h2><p>对于list, dict, tuple 这种类型，有可能存在循环引用的情况，这时需要再做一次扫描及标记清除的处理。</p>\n<ul>\n<li>在Python中使用另一个新的链表来存储需要标记清除的对象。然而这种扫描的往往比较耗时，需要执行可达性分析，以找到unreachable的对象，对这些对象进行标记清除。</li>\n<li>因此为标记清除的处理需要找一个时间点来。 这就引入了分代机制</li>\n</ul>\n<h2 id=\"分代机制\"><a href=\"#分代机制\" class=\"headerlink\" title=\"分代机制\"></a>分代机制</h2><p>标记清除的扫描的操作比较耗时。所以需要设置一个时间点。</p>\n<ul>\n<li>Python中设置第一代为 700个对象， 第二代为第一代的10次，第三代为第二代的10次</li>\n<li>可使用python的gc模块，从业务层对这些值进行设置</li>\n</ul>\n<h2 id=\"缓存机制\"><a href=\"#缓存机制\" class=\"headerlink\" title=\"缓存机制\"></a>缓存机制</h2><p>一、int的缓存机制</p>\n<p>二、字符串的缓存机制：</p>\n<ul>\n<li><p>intern dict ： PyDict对象，key, value就是字符串</p>\n</li>\n<li><p>nullstring, characters， 空串和单串，有两个属性来存储</p>\n<blockquote>\n<p>intern的默认识别只能在compile时，无法在runtime时识别，不过可以手动调用intern</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"/img/image-20210730174828153.png\" alt=\"字符串缓存机制\"></p>\n<p>三、tuple的缓存机制</p>\n<p>PyTupleObject， 维护一个链表，用free_list存储链表头， 20个</p>\n<p>不用像int和string一整块的申请，利用链表的ob_item组起来</p>\n<p>四、list的缓存机制</p>\n<p>维护一个free_list ， 保存80个，运行时往里回放。</p>\n<p>四、源码分析<br>obmalloc.c -&gt; PyObject_Malloc</p>\n<ol>\n<li><p>申请大小大于256，直接使用 PyMem_Malloc</p>\n</li>\n<li><p>小于256， 进入小块内存池</p>\n</li>\n</ol>\n<ul>\n<li>取size， 指定大小-1 后 除以8或者16字节。(设定一个block大小)</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/img/image-20210801173440707.png\" alt=\"关于python机制的总结\"></p>\n"},{"title":"Python Note 5","_content":"# Python Note 5\n\n## kwargs的使用\n* 1. kwargs表示有key, value形式的参数，如：\n```python\ndef test(*args,**kwargs):\n    print \"args:\", args\n    print \"kwargs\", kwargs\n\ntest(12,2,abc={\"good\":7})\n\n# 输出：\n# args: (12, 2)\n# kwargs {'abc': {'good': 7}}\n```\n\n* 2. 使用Pop取出kwargs的值\n```python\ndef test(*args,**kwargs):\n    print \"args:\", args\n    print \"kwargs\", kwargs\n    val1 = kwargs.pop('abc', False)\n    print \"kwargs val:\", val1\n    if kwargs:\n        raise TypeError(\"Unexpectd ** kwargs, %r\" % kwargs)\n\ntest(12,2,abc={\"good\":7}, cde=5)\n\n# 输出：\n# args: (12, 2)\n# kwargs {'cde': 5, 'abc': {'good': 7}}\n# kwargs val: {'good': 7}\n# Traceback (most recent call last):\n#   File \"D:/Avery/Workspaces/pythonProject2/test.py\", line 54, in # <module>\n#     test(12,2,abc={\"good\":7}, cde=5)\n#   File \"D:/Avery/Workspaces/pythonProject2/test.py\", line 52, in test\n#     raise TypeError(\"Unexpectd ** kwargs, %r\" % kwargs)\n# TypeError: Unexpectd ** kwargs, {'cde': 5}\n```\n\n","source":"_posts/python_5.md","raw":"---\ntitle: Python Note 5\ncategories:\n- Python\ntags: \n- Python\n- Note\n---\n# Python Note 5\n\n## kwargs的使用\n* 1. kwargs表示有key, value形式的参数，如：\n```python\ndef test(*args,**kwargs):\n    print \"args:\", args\n    print \"kwargs\", kwargs\n\ntest(12,2,abc={\"good\":7})\n\n# 输出：\n# args: (12, 2)\n# kwargs {'abc': {'good': 7}}\n```\n\n* 2. 使用Pop取出kwargs的值\n```python\ndef test(*args,**kwargs):\n    print \"args:\", args\n    print \"kwargs\", kwargs\n    val1 = kwargs.pop('abc', False)\n    print \"kwargs val:\", val1\n    if kwargs:\n        raise TypeError(\"Unexpectd ** kwargs, %r\" % kwargs)\n\ntest(12,2,abc={\"good\":7}, cde=5)\n\n# 输出：\n# args: (12, 2)\n# kwargs {'cde': 5, 'abc': {'good': 7}}\n# kwargs val: {'good': 7}\n# Traceback (most recent call last):\n#   File \"D:/Avery/Workspaces/pythonProject2/test.py\", line 54, in # <module>\n#     test(12,2,abc={\"good\":7}, cde=5)\n#   File \"D:/Avery/Workspaces/pythonProject2/test.py\", line 52, in test\n#     raise TypeError(\"Unexpectd ** kwargs, %r\" % kwargs)\n# TypeError: Unexpectd ** kwargs, {'cde': 5}\n```\n\n","slug":"python_5","published":1,"date":"2022-04-09T10:23:31.861Z","updated":"2022-04-09T10:23:31.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1rpmkp00000zhf09oqtnx2o","content":"<h1 id=\"Python-Note-5\"><a href=\"#Python-Note-5\" class=\"headerlink\" title=\"Python Note 5\"></a>Python Note 5</h1><h2 id=\"kwargs的使用\"><a href=\"#kwargs的使用\" class=\"headerlink\" title=\"kwargs的使用\"></a>kwargs的使用</h2><ul>\n<li><ol>\n<li>kwargs表示有key, value形式的参数，如：<pre><code class=\"python\">def test(*args,**kwargs):\nprint &quot;args:&quot;, args\nprint &quot;kwargs&quot;, kwargs\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<p>test(12,2,abc={“good”:7})</p>\n<h1 id=\"输出：\"><a href=\"#输出：\" class=\"headerlink\" title=\"输出：\"></a>输出：</h1><h1 id=\"args-12-2\"><a href=\"#args-12-2\" class=\"headerlink\" title=\"args: (12, 2)\"></a>args: (12, 2)</h1><h1 id=\"kwargs-‘abc’-‘good’-7\"><a href=\"#kwargs-‘abc’-‘good’-7\" class=\"headerlink\" title=\"kwargs {‘abc’: {‘good’: 7}}\"></a>kwargs {‘abc’: {‘good’: 7}}</h1><pre><code>\n* 2. 使用Pop取出kwargs的值\n```python\ndef test(*args,**kwargs):\n    print &quot;args:&quot;, args\n    print &quot;kwargs&quot;, kwargs\n    val1 = kwargs.pop(&#39;abc&#39;, False)\n    print &quot;kwargs val:&quot;, val1\n    if kwargs:\n        raise TypeError(&quot;Unexpectd ** kwargs, %r&quot; % kwargs)\n\ntest(12,2,abc={&quot;good&quot;:7}, cde=5)\n\n# 输出：\n# args: (12, 2)\n# kwargs {&#39;cde&#39;: 5, &#39;abc&#39;: {&#39;good&#39;: 7}}\n# kwargs val: {&#39;good&#39;: 7}\n# Traceback (most recent call last):\n#   File &quot;D:/Avery/Workspaces/pythonProject2/test.py&quot;, line 54, in # &lt;module&gt;\n#     test(12,2,abc={&quot;good&quot;:7}, cde=5)\n#   File &quot;D:/Avery/Workspaces/pythonProject2/test.py&quot;, line 52, in test\n#     raise TypeError(&quot;Unexpectd ** kwargs, %r&quot; % kwargs)\n# TypeError: Unexpectd ** kwargs, {&#39;cde&#39;: 5}</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python-Note-5\"><a href=\"#Python-Note-5\" class=\"headerlink\" title=\"Python Note 5\"></a>Python Note 5</h1><h2 id=\"kwargs的使用\"><a href=\"#kwargs的使用\" class=\"headerlink\" title=\"kwargs的使用\"></a>kwargs的使用</h2><ul>\n<li><ol>\n<li>kwargs表示有key, value形式的参数，如：<pre><code class=\"python\">def test(*args,**kwargs):\nprint &quot;args:&quot;, args\nprint &quot;kwargs&quot;, kwargs\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<p>test(12,2,abc={“good”:7})</p>\n<h1 id=\"输出：\"><a href=\"#输出：\" class=\"headerlink\" title=\"输出：\"></a>输出：</h1><h1 id=\"args-12-2\"><a href=\"#args-12-2\" class=\"headerlink\" title=\"args: (12, 2)\"></a>args: (12, 2)</h1><h1 id=\"kwargs-‘abc’-‘good’-7\"><a href=\"#kwargs-‘abc’-‘good’-7\" class=\"headerlink\" title=\"kwargs {‘abc’: {‘good’: 7}}\"></a>kwargs {‘abc’: {‘good’: 7}}</h1><pre><code>\n* 2. 使用Pop取出kwargs的值\n```python\ndef test(*args,**kwargs):\n    print &quot;args:&quot;, args\n    print &quot;kwargs&quot;, kwargs\n    val1 = kwargs.pop(&#39;abc&#39;, False)\n    print &quot;kwargs val:&quot;, val1\n    if kwargs:\n        raise TypeError(&quot;Unexpectd ** kwargs, %r&quot; % kwargs)\n\ntest(12,2,abc={&quot;good&quot;:7}, cde=5)\n\n# 输出：\n# args: (12, 2)\n# kwargs {&#39;cde&#39;: 5, &#39;abc&#39;: {&#39;good&#39;: 7}}\n# kwargs val: {&#39;good&#39;: 7}\n# Traceback (most recent call last):\n#   File &quot;D:/Avery/Workspaces/pythonProject2/test.py&quot;, line 54, in # &lt;module&gt;\n#     test(12,2,abc={&quot;good&quot;:7}, cde=5)\n#   File &quot;D:/Avery/Workspaces/pythonProject2/test.py&quot;, line 52, in test\n#     raise TypeError(&quot;Unexpectd ** kwargs, %r&quot; % kwargs)\n# TypeError: Unexpectd ** kwargs, {&#39;cde&#39;: 5}</code></pre>"},{"title":"UE5初入","_content":"# UE5初入\n\n## 创建初始场景\n* 1. 光源\n    需要天空光照，平行光源（太阳光）\n\n* 2. 视觉效果\n    天空大气，指数雾，体积云\n\n* 3. 设置场景光（当前默认设置）\n    设置平行光源与场景天空对应\n\n## 快捷键\n使用End，可以让一个物体底部定到下个物体的表面\n使用鼠标结合WSADQE精细调整","source":"_posts/UE5初入.md","raw":"---\ntitle: UE5初入\ncategories:\n- UE\ntags: \n- UE\n- Note\n---\n# UE5初入\n\n## 创建初始场景\n* 1. 光源\n    需要天空光照，平行光源（太阳光）\n\n* 2. 视觉效果\n    天空大气，指数雾，体积云\n\n* 3. 设置场景光（当前默认设置）\n    设置平行光源与场景天空对应\n\n## 快捷键\n使用End，可以让一个物体底部定到下个物体的表面\n使用鼠标结合WSADQE精细调整","slug":"UE5初入","published":1,"date":"2022-04-09T10:40:13.145Z","updated":"2022-04-09T10:40:13.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1rq81f300002kf0p7v8ph5s","content":"<h1 id=\"UE5初入\"><a href=\"#UE5初入\" class=\"headerlink\" title=\"UE5初入\"></a>UE5初入</h1><h2 id=\"创建初始场景\"><a href=\"#创建初始场景\" class=\"headerlink\" title=\"创建初始场景\"></a>创建初始场景</h2><ul>\n<li><ol>\n<li>光源<br>需要天空光照，平行光源（太阳光）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>视觉效果<br>天空大气，指数雾，体积云</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>设置场景光（当前默认设置）<br>设置平行光源与场景天空对应</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>使用End，可以让一个物体底部定到下个物体的表面<br>使用鼠标结合WSADQE精细调整</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UE5初入\"><a href=\"#UE5初入\" class=\"headerlink\" title=\"UE5初入\"></a>UE5初入</h1><h2 id=\"创建初始场景\"><a href=\"#创建初始场景\" class=\"headerlink\" title=\"创建初始场景\"></a>创建初始场景</h2><ul>\n<li><ol>\n<li>光源<br>需要天空光照，平行光源（太阳光）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>视觉效果<br>天空大气，指数雾，体积云</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>设置场景光（当前默认设置）<br>设置平行光源与场景天空对应</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>使用End，可以让一个物体底部定到下个物体的表面<br>使用鼠标结合WSADQE精细调整</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckgssh0xp00004wf0eis6qtyk","category_id":"ckgssh0y000034wf0a6643620","_id":"ckgssh0yg000d4wf0ivojrni5"},{"post_id":"ckgssh0yb000b4wf0f4f8l9e9","category_id":"ckgssh0y000034wf0a6643620","_id":"ckgssh0yk000k4wf0kfe5aew7"},{"post_id":"ckgssh0xw00024wf0ah6k6x8b","category_id":"ckgssh0y800084wf0093rtsfa","_id":"ckgssh0ym000o4wf09kwoyxtz"},{"post_id":"ckgssh0y300054wf03r9j1wi1","category_id":"ckgssh0yh000e4wf09m2ax3g3","_id":"ckgssh0yo000r4wf0kfcn2vit"},{"post_id":"ckgssh0y600064wf0ahaa3swg","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckgssh0ys000w4wf0u36v95d4"},{"post_id":"ckgssh0yr000v4wf0x6eva7yt","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckgssh0ze00124wf0x1ry8w7r"},{"post_id":"ckgssh0y700074wf08sstmtpq","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh0zi00174wf00ym7e2az"},{"post_id":"ckgssh0ys000x4wf00cnw4n0y","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckgssh0zn001a4wf0ruyl7aw3"},{"post_id":"ckgssh0zb00104wf0pr2rgtr9","category_id":"ckgssh0y000034wf0a6643620","_id":"ckgssh0zq001f4wf0abcllx2v"},{"post_id":"ckgssh0yd000c4wf0wwyj2onu","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh0zr001i4wf0eklk0bgi"},{"post_id":"ckgssh0yh000h4wf08p5pism9","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckgssh0zu001m4wf0gr37y1ds"},{"post_id":"ckgssh0yj000j4wf0z5hyfxk8","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh102001q4wf01ciz5bg6"},{"post_id":"ckgssh0zr001h4wf0cukf7xng","category_id":"ckgssh0y800084wf0093rtsfa","_id":"ckgssh104001t4wf04uhn3sfl"},{"post_id":"ckgssh0yl000n4wf0w84mkneg","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh106001w4wf0mivds0bh"},{"post_id":"ckgssh101001o4wf0peev19vl","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh109001z4wf07t9n48t4"},{"post_id":"ckgssh103001s4wf0bafr6iq1","category_id":"ckgssh0yh000e4wf09m2ax3g3","_id":"ckgssh10b00224wf0ro6f3s4s"},{"post_id":"ckgssh0yn000q4wf0d0oidbxm","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh10d00274wf0392pfz2j"},{"post_id":"ckgssh105001u4wf0bv2x6usr","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh10i002a4wf0v4f0o2o2"},{"post_id":"ckgssh108001y4wf0f6vqxrjn","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh10l002f4wf069fuduhb"},{"post_id":"ckgssh0yp000u4wf0dp0syxvj","category_id":"ckgssh106001v4wf0lk2yiedm","_id":"ckgssh10m002i4wf09kl8w37c"},{"post_id":"ckgssh10a00214wf0i8bud1nc","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh10o002n4wf0r6spkg19"},{"post_id":"ckgssh10d00264wf0aihh4x41","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh10q002q4wf0pf0nlfcx"},{"post_id":"ckgssh0zd00114wf0x6hff7w4","category_id":"ckgssh106001v4wf0lk2yiedm","_id":"ckgssh10s002v4wf0pm0yuvzy"},{"post_id":"ckgssh10k002e4wf0nfqjqqhz","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckgssh10u002y4wf0eomoudht"},{"post_id":"ckgssh0zh00164wf0y25que0k","category_id":"ckgssh106001v4wf0lk2yiedm","_id":"ckgssh10y00334wf09l3off50"},{"post_id":"ckgssh10o002m4wf06mtgo9fu","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh11000364wf0qq7pweic"},{"post_id":"ckgssh0zi00194wf08hfpcyow","category_id":"ckgssh106001v4wf0lk2yiedm","_id":"ckgssh112003b4wf05uu4xn11"},{"post_id":"ckgssh0zp001e4wf0st5613gs","category_id":"ckgssh106001v4wf0lk2yiedm","_id":"ckgssh117003e4wf0712xp1q8"},{"post_id":"ckgssh10t002x4wf0foob2swm","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh119003j4wf0k6qnne7q"},{"post_id":"ckgssh10h00294wf05d0yt558","category_id":"ckgssh10u002z4wf0n4s5qh93","_id":"ckgssh11e003m4wf09c0perw0"},{"post_id":"ckgssh10z00354wf0ae9f5cmd","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh11i003r4wf0zag7qdyv"},{"post_id":"ckgssh10m002h4wf0apq4d50v","category_id":"ckgssh10u002z4wf0n4s5qh93","_id":"ckgssh11k003u4wf0t5r5c0fk"},{"post_id":"ckgssh113003d4wf0vsjg5owv","category_id":"ckgssh0y800084wf0093rtsfa","_id":"ckgssh11m003y4wf0wpfsuh6a"},{"post_id":"ckgssh10p002p4wf0e4lqeig5","category_id":"ckgssh118003f4wf06go56f39","_id":"ckgssh11p00424wf0qy6x7uzg"},{"post_id":"ckgssh11a003l4wf0am95udsr","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh11r00464wf02lq4ojz6"},{"post_id":"ckgssh11g003q4wf0aasnkg9o","category_id":"ckgssh10u002z4wf0n4s5qh93","_id":"ckgssh127004a4wf0io096n9b"},{"post_id":"ckgssh11j003t4wf0ldwwhiez","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh12b004e4wf0p1m1bgoj"},{"post_id":"ckgssh10v00324wf0xzpb5ud5","category_id":"ckgssh11f003o4wf0dtlbkgub","_id":"ckgssh12d004i4wf0k874uwes"},{"post_id":"ckgssh11l003w4wf0yhuj3se1","category_id":"ckgssh0y800084wf0093rtsfa","_id":"ckgssh12e004l4wf0oy1dwbfe"},{"post_id":"ckgssh11o00414wf0jwtg4uef","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckgssh12g004q4wf075x0ygt0"},{"post_id":"ckgssh111003a4wf02glht1wf","category_id":"ckgssh11f003o4wf0dtlbkgub","_id":"ckgssh12i004t4wf0f6mvq8ec"},{"post_id":"ckgssh119003i4wf083iha4rv","category_id":"ckgssh11f003o4wf0dtlbkgub","_id":"ckgssh12v004y4wf0onr3jv7s"},{"post_id":"ckgssh12c004h4wf0ua8g3p9m","category_id":"ckgssh12b004d4wf0fckbshoa","_id":"ckgssh12x00514wf0b6ckxvlh"},{"post_id":"ckgssh11p00444wf0hiaql9e5","category_id":"ckgssh12b004d4wf0fckbshoa","_id":"ckgssh12z00554wf0sp74w7a7"},{"post_id":"ckgssh12d004k4wf0wjizb137","category_id":"ckgssh12b004d4wf0fckbshoa","_id":"ckgssh13100594wf0qwqqoyz0"},{"post_id":"ckgssh12g004p4wf0mcq2d0le","category_id":"ckgssh12b004d4wf0fckbshoa","_id":"ckgssh133005d4wf0g5iu60wi"},{"post_id":"ckgssh12600494wf064cacvot","category_id":"ckgssh12b004d4wf0fckbshoa","_id":"ckgssh134005h4wf000p61bmk"},{"post_id":"ckgssh12h004s4wf0x11ebyuj","category_id":"ckgssh12b004d4wf0fckbshoa","_id":"ckgssh136005l4wf0hgpfvkay"},{"post_id":"ckgssh12u004x4wf090hbcbdm","category_id":"ckgssh12b004d4wf0fckbshoa","_id":"ckgssh13m005o4wf0rlr2sl77"},{"post_id":"ckgssh12a004c4wf0qduq4jiq","category_id":"ckgssh12b004d4wf0fckbshoa","_id":"ckgssh13n005r4wf0utjqly10"},{"post_id":"ckgssh13100584wf0fif278j8","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckgssh13r005v4wf0gnxmiisa"},{"post_id":"ckgssh132005c4wf07lz3ergp","category_id":"ckgssh12b004d4wf0fckbshoa","_id":"ckgssh13s005y4wf0scsoqk76"},{"post_id":"ckgssh12w00504wf0gojky6nz","category_id":"ckgssh12z00574wf01vzqx66x","_id":"ckgssh13v00634wf010xx1e6v"},{"post_id":"ckgssh133005f4wf0mwnnrv8h","category_id":"ckgssh10u002z4wf0n4s5qh93","_id":"ckgssh13w00664wf0vtfwlji7"},{"post_id":"ckgssh135005k4wf0l1ht2d17","category_id":"ckgssh12z00574wf01vzqx66x","_id":"ckgssh13z006b4wf0b7jvmv5n"},{"post_id":"ckgssh12y00544wf062agtdmv","category_id":"ckgssh12z00574wf01vzqx66x","_id":"ckgssh140006d4wf03xmqsbaz"},{"post_id":"ckgssh13l005n4wf0yuowu6h1","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckgssh141006g4wf0zo96wbzn"},{"post_id":"ckgssh13n005q4wf0ordlelpq","category_id":"ckgssh11f003o4wf0dtlbkgub","_id":"ckgssh141006i4wf0l9l26lnb"},{"post_id":"ckgssh13r005x4wf0fryo7tzx","category_id":"ckgssh11f003o4wf0dtlbkgub","_id":"ckgssh142006l4wf0459i8t2r"},{"post_id":"ckgssh13v00654wf07aip7ze1","category_id":"ckgssh13t00614wf07xhieukd","_id":"ckgssh142006n4wf02rhnhujy"},{"post_id":"ckgssh13o005u4wf0rbu2gfvq","category_id":"ckgssh13t00614wf07xhieukd","_id":"ckgssh14a006q4wf05bavj11v"},{"post_id":"ckgssh13y00694wf0b7tfttn9","category_id":"ckgssh12z00574wf01vzqx66x","_id":"ckgssh14b006s4wf07uz7753a"},{"post_id":"ckgssh13t00624wf08sayl1lk","category_id":"ckgssh13z006a4wf0rvc4llea","_id":"ckgssh14b006v4wf0r0hglev7"},{"post_id":"ckhng3etm0000taf0pu4kpvro","category_id":"ckgssh0y800084wf0093rtsfa","_id":"ckhng3eud0004taf066sit60b"},{"post_id":"ckhng3eu50001taf00vnayg5a","category_id":"ckgssh0y800084wf0093rtsfa","_id":"ckhng3eud0005taf0vq2zi4ay"},{"post_id":"ckitrsiij00013wf0xqg3afv0","category_id":"ckgssh0y800084wf0093rtsfa","_id":"ckitrsij000063wf0nr2wv989"},{"post_id":"ckitrsiip00033wf0kcouf43r","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckitrsij000073wf0gqg3bh4n"},{"post_id":"ckitrsijl00083wf0n5w2gw8m","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckitrsijq00093wf06px5hr8l"},{"post_id":"ckizhf0ai0000hof0gqrhxxwy","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckizhf0b70001hof0oxcye3s5"},{"post_id":"ckj0vjkdu00024rf04aarymuv","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckj0vjkdz00064rf0ey6s3gqy"},{"post_id":"ckj0vjkdw00034rf0dtvty90b","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckj0vjkdz00074rf00fuzld00"},{"post_id":"ckj120uda0000jjf0tfssysbl","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckj120ue70003jjf0yba6up4t"},{"post_id":"ckj120udr0001jjf0mc5e86d7","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckj120ue80004jjf0jmmxeyri"},{"post_id":"ckj120udx0002jjf0nhlsce3b","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckj120ue80005jjf0f6jujzo3"},{"post_id":"ckj5hqcjy00003ff0obhjdk18","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckj5hqcl100033ff0scp74k3r"},{"post_id":"ckj5hqckr00013ff0rf8r8t9j","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckj5hqcl100043ff0b39g3n8d"},{"post_id":"ckj5hqckw00023ff0fn80ushs","category_id":"ckgssh0yl000l4wf0bh0atetq","_id":"ckj5hqcl100053ff0mcstdzl4"},{"post_id":"ckllsk7np0000ezf0nljrin4r","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckllsk7os0003ezf0jji4smtt"},{"post_id":"ckphri01c00003ef0aexnuh0d","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckphri01w00033ef0yookto4t"},{"post_id":"ckrt0nxrr0000zxf0k9h8i5lw","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"ckrt0nxsm0003zxf086mlz65f"},{"post_id":"cl1rpmkp00000zhf09oqtnx2o","category_id":"ckgssh0yo000s4wf0nqlti2ys","_id":"cl1rpmkpm0003zhf06n7w2wov"},{"post_id":"cl1rq81f300002kf0p7v8ph5s","category_id":"cl1rq81fg00012kf02owy2kn9","_id":"cl1rq81g500052kf0nqei6b61"}],"PostTag":[{"post_id":"ckgssh0xp00004wf0eis6qtyk","tag_id":"ckgssh0y200044wf0uxsmx1xc","_id":"ckgssh0y9000a4wf09zkn2xga"},{"post_id":"ckgssh0yb000b4wf0f4f8l9e9","tag_id":"ckgssh0y200044wf0uxsmx1xc","_id":"ckgssh0yh000g4wf00h6eqd0k"},{"post_id":"ckgssh0xw00024wf0ah6k6x8b","tag_id":"ckgssh0y800094wf0h6hvfoch","_id":"ckgssh0yj000i4wf050wltgdy"},{"post_id":"ckgssh0y300054wf03r9j1wi1","tag_id":"ckgssh0yh000f4wf0451fed1c","_id":"ckgssh0yn000p4wf0o34i74wy"},{"post_id":"ckgssh0zb00104wf0pr2rgtr9","tag_id":"ckgssh0y200044wf0uxsmx1xc","_id":"ckgssh0zg00154wf06e31b6vj"},{"post_id":"ckgssh0y700074wf08sstmtpq","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh0zi00184wf0umdpktzi"},{"post_id":"ckgssh0y700074wf08sstmtpq","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh0zp001d4wf0f8j95k4w"},{"post_id":"ckgssh0y700074wf08sstmtpq","tag_id":"ckgssh0yu000z4wf04m0t4krc","_id":"ckgssh0zq001g4wf0wnh9bfb0"},{"post_id":"ckgssh0zr001h4wf0cukf7xng","tag_id":"ckgssh0y800094wf0h6hvfoch","_id":"ckgssh100001n4wf0h36qhlr2"},{"post_id":"ckgssh0yd000c4wf0wwyj2onu","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh10900204wf0uxorft4k"},{"post_id":"ckgssh0yd000c4wf0wwyj2onu","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh10c00244wf0g79f0a6a"},{"post_id":"ckgssh0yd000c4wf0wwyj2onu","tag_id":"ckgssh0yu000z4wf04m0t4krc","_id":"ckgssh10e00284wf0j5t7ttxs"},{"post_id":"ckgssh0yd000c4wf0wwyj2onu","tag_id":"ckgssh103001r4wf0bdtqjy1d","_id":"ckgssh10j002c4wf0ylc5gvgz"},{"post_id":"ckgssh10a00214wf0i8bud1nc","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh10l002g4wf000wc2ttw"},{"post_id":"ckgssh10a00214wf0i8bud1nc","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh10n002k4wf0a5r0n7du"},{"post_id":"ckgssh10d00264wf0aihh4x41","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh10p002o4wf04it6ueip"},{"post_id":"ckgssh10d00264wf0aihh4x41","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh10q002s4wf0kjrtzhmj"},{"post_id":"ckgssh0yj000j4wf0z5hyfxk8","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh10t002w4wf0ll0e0mdl"},{"post_id":"ckgssh0yj000j4wf0z5hyfxk8","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh10v00304wf0sezkcyvq"},{"post_id":"ckgssh0yj000j4wf0z5hyfxk8","tag_id":"ckgssh0yu000z4wf04m0t4krc","_id":"ckgssh10z00344wf08p5addti"},{"post_id":"ckgssh0yj000j4wf0z5hyfxk8","tag_id":"ckgssh10n002l4wf0kzw0qt4t","_id":"ckgssh11000384wf03vhxgm85"},{"post_id":"ckgssh10p002p4wf0e4lqeig5","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh113003c4wf0m5vywz0n"},{"post_id":"ckgssh10t002x4wf0foob2swm","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh118003g4wf0hrovctue"},{"post_id":"ckgssh10t002x4wf0foob2swm","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh11a003k4wf049hyq3ch"},{"post_id":"ckgssh0yl000n4wf0w84mkneg","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh11f003n4wf0x4uh2bv9"},{"post_id":"ckgssh0yl000n4wf0w84mkneg","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh11j003s4wf07iz0bjdv"},{"post_id":"ckgssh0yl000n4wf0w84mkneg","tag_id":"ckgssh0yu000z4wf04m0t4krc","_id":"ckgssh11l003v4wf0o9ebnlvb"},{"post_id":"ckgssh10z00354wf0ae9f5cmd","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh11o00404wf0ab8rosyp"},{"post_id":"ckgssh10z00354wf0ae9f5cmd","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh11p00434wf0r7to1ud2"},{"post_id":"ckgssh113003d4wf0vsjg5owv","tag_id":"ckgssh0y800094wf0h6hvfoch","_id":"ckgssh12500484wf0ad3jsxpa"},{"post_id":"ckgssh0yn000q4wf0d0oidbxm","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh129004b4wf00d9w1p9d"},{"post_id":"ckgssh0yn000q4wf0d0oidbxm","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh12c004g4wf0u52rmala"},{"post_id":"ckgssh0yn000q4wf0d0oidbxm","tag_id":"ckgssh0yu000z4wf04m0t4krc","_id":"ckgssh12d004j4wf0n8g2lht0"},{"post_id":"ckgssh11a003l4wf0am95udsr","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh12f004o4wf0ix9a5ppz"},{"post_id":"ckgssh11a003l4wf0am95udsr","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh12h004r4wf00di3pq59"},{"post_id":"ckgssh11j003t4wf0ldwwhiez","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh12u004w4wf0vorsq8uz"},{"post_id":"ckgssh11j003t4wf0ldwwhiez","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh12w004z4wf05emamwes"},{"post_id":"ckgssh11j003t4wf0ldwwhiez","tag_id":"ckgssh0yu000z4wf04m0t4krc","_id":"ckgssh12y00534wf007kfxliq"},{"post_id":"ckgssh11j003t4wf0ldwwhiez","tag_id":"ckgssh10n002l4wf0kzw0qt4t","_id":"ckgssh12z00564wf0zv6v65ut"},{"post_id":"ckgssh0yp000u4wf0dp0syxvj","tag_id":"ckgssh11f003p4wf0amr8ezxd","_id":"ckgssh132005b4wf0zpy01fvl"},{"post_id":"ckgssh11l003w4wf0yhuj3se1","tag_id":"ckgssh0y800094wf0h6hvfoch","_id":"ckgssh133005e4wf0r9wzc1v9"},{"post_id":"ckgssh11o00414wf0jwtg4uef","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh135005i4wf0lvccbtxh"},{"post_id":"ckgssh11o00414wf0jwtg4uef","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh13l005m4wf0b8234zvx"},{"post_id":"ckgssh11o00414wf0jwtg4uef","tag_id":"ckgssh0yu000z4wf04m0t4krc","_id":"ckgssh13m005p4wf0d0mpzqwy"},{"post_id":"ckgssh11o00414wf0jwtg4uef","tag_id":"ckgssh10n002l4wf0kzw0qt4t","_id":"ckgssh13o005t4wf0ff468k37"},{"post_id":"ckgssh0zd00114wf0x6hff7w4","tag_id":"ckgssh11f003p4wf0amr8ezxd","_id":"ckgssh13r005w4wf0c2g9zsyi"},{"post_id":"ckgssh0zh00164wf0y25que0k","tag_id":"ckgssh11f003p4wf0amr8ezxd","_id":"ckgssh13t00604wf0ns7oby0j"},{"post_id":"ckgssh0zi00194wf08hfpcyow","tag_id":"ckgssh11f003p4wf0amr8ezxd","_id":"ckgssh13v00644wf09k79cap3"},{"post_id":"ckgssh12u004x4wf090hbcbdm","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh13y00684wf07jqv5e1i"},{"post_id":"ckgssh12u004x4wf090hbcbdm","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh140006c4wf0o2roxwkd"},{"post_id":"ckgssh0zp001e4wf0st5613gs","tag_id":"ckgssh11f003p4wf0amr8ezxd","_id":"ckgssh140006f4wf0jb7l5x8a"},{"post_id":"ckgssh0zp001e4wf0st5613gs","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh141006h4wf0v97zhkfo"},{"post_id":"ckgssh132005c4wf07lz3ergp","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh141006k4wf0nf5udgob"},{"post_id":"ckgssh132005c4wf07lz3ergp","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh142006m4wf0nlhdk0qg"},{"post_id":"ckgssh0zt001l4wf0ubeph1m7","tag_id":"ckgssh12x00524wf0m4rc23a8","_id":"ckgssh142006p4wf0gogqiwwy"},{"post_id":"ckgssh0zt001l4wf0ubeph1m7","tag_id":"ckgssh132005a4wf0kc1mxvtr","_id":"ckgssh14a006r4wf0hke6rxum"},{"post_id":"ckgssh101001o4wf0peev19vl","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh14b006u4wf0z3356quw"},{"post_id":"ckgssh101001o4wf0peev19vl","tag_id":"ckgssh135005j4wf0itpxxvlz","_id":"ckgssh14b006w4wf0upci34ea"},{"post_id":"ckgssh101001o4wf0peev19vl","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14c006y4wf0p3cmegz6"},{"post_id":"ckgssh103001s4wf0bafr6iq1","tag_id":"ckgssh13o005s4wf00gve3wwf","_id":"ckgssh14c006z4wf04dmlr115"},{"post_id":"ckgssh103001s4wf0bafr6iq1","tag_id":"ckgssh0yh000f4wf0451fed1c","_id":"ckgssh14d00714wf05h529eee"},{"post_id":"ckgssh105001u4wf0bv2x6usr","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh14d00724wf0f7h69kbr"},{"post_id":"ckgssh105001u4wf0bv2x6usr","tag_id":"ckgssh135005j4wf0itpxxvlz","_id":"ckgssh14e00744wf0ngppvji3"},{"post_id":"ckgssh105001u4wf0bv2x6usr","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14e00754wf0wfqhuifs"},{"post_id":"ckgssh108001y4wf0f6vqxrjn","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh14e00774wf0f105710m"},{"post_id":"ckgssh108001y4wf0f6vqxrjn","tag_id":"ckgssh135005j4wf0itpxxvlz","_id":"ckgssh14f00784wf0w3hgansp"},{"post_id":"ckgssh108001y4wf0f6vqxrjn","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14f007a4wf03cty3ore"},{"post_id":"ckgssh10h00294wf05d0yt558","tag_id":"ckgssh140006e4wf0zbmvfbjr","_id":"ckgssh14g007b4wf0hsvbdtp5"},{"post_id":"ckgssh10o002m4wf06mtgo9fu","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckgssh14g007d4wf047a98y1t"},{"post_id":"ckgssh10o002m4wf06mtgo9fu","tag_id":"ckgssh135005j4wf0itpxxvlz","_id":"ckgssh14g007e4wf0zewcliwy"},{"post_id":"ckgssh10o002m4wf06mtgo9fu","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14h007g4wf053v1u5tz"},{"post_id":"ckgssh11g003q4wf0aasnkg9o","tag_id":"ckgssh140006e4wf0zbmvfbjr","_id":"ckgssh14h007h4wf0fzts2vnt"},{"post_id":"ckgssh11p00444wf0hiaql9e5","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh14h007i4wf0e2jstmw0"},{"post_id":"ckgssh11p00444wf0hiaql9e5","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14i007k4wf0k4ijxr1g"},{"post_id":"ckgssh12600494wf064cacvot","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh14i007l4wf0bo6y0t8j"},{"post_id":"ckgssh12600494wf064cacvot","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14i007m4wf0avtlvnmd"},{"post_id":"ckgssh12a004c4wf0qduq4jiq","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh14i007n4wf014lijn62"},{"post_id":"ckgssh12a004c4wf0qduq4jiq","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14i007o4wf0jooza01r"},{"post_id":"ckgssh12c004h4wf0ua8g3p9m","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh14i007p4wf0n05sp0gm"},{"post_id":"ckgssh12c004h4wf0ua8g3p9m","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14i007q4wf03lggkn22"},{"post_id":"ckgssh12d004k4wf0wjizb137","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh14i007r4wf0u4ohl7ep"},{"post_id":"ckgssh12d004k4wf0wjizb137","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14j007s4wf0hkwt0gdm"},{"post_id":"ckgssh12g004p4wf0mcq2d0le","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh14j007t4wf0uczipfp2"},{"post_id":"ckgssh12g004p4wf0mcq2d0le","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14j007u4wf0dabx3hqo"},{"post_id":"ckgssh12h004s4wf0x11ebyuj","tag_id":"ckgssh12i004u4wf0xkie7ckt","_id":"ckgssh14j007v4wf0ko16t0nc"},{"post_id":"ckgssh12h004s4wf0x11ebyuj","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckgssh14j007w4wf0475uj4mh"},{"post_id":"ckgssh13o005u4wf0rbu2gfvq","tag_id":"ckgssh14h007f4wf0g47ufceg","_id":"ckgssh14j007x4wf0m9numdhr"},{"post_id":"ckgssh13v00654wf07aip7ze1","tag_id":"ckgssh14h007f4wf0g47ufceg","_id":"ckgssh14j007y4wf0mt58w9rb"},{"post_id":"ckhng3etm0000taf0pu4kpvro","tag_id":"ckgssh0y800094wf0h6hvfoch","_id":"ckhng3eub0002taf0wer89fy3"},{"post_id":"ckhng3eu50001taf00vnayg5a","tag_id":"ckgssh0y800094wf0h6hvfoch","_id":"ckhng3eud0003taf0w2aoh5t7"},{"post_id":"ckitrsiij00013wf0xqg3afv0","tag_id":"ckgssh0y800094wf0h6hvfoch","_id":"ckitrsiiy00043wf0nk2iznsr"},{"post_id":"ckllsk7np0000ezf0nljrin4r","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckllsk7oq0001ezf02diuuu99"},{"post_id":"ckllsk7np0000ezf0nljrin4r","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckllsk7os0002ezf0y2rlxd2i"},{"post_id":"ckphri01c00003ef0aexnuh0d","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckphri01t00013ef0g24igi3a"},{"post_id":"ckphri01c00003ef0aexnuh0d","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckphri01w00023ef05n9peyq6"},{"post_id":"ckrt0nxrr0000zxf0k9h8i5lw","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"ckrt0nxsj0001zxf0222orllj"},{"post_id":"ckrt0nxrr0000zxf0k9h8i5lw","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"ckrt0nxsl0002zxf0400ar2y1"},{"post_id":"cl1rpmkp00000zhf09oqtnx2o","tag_id":"ckgssh0yl000m4wf07vvo7fxp","_id":"cl1rpmkpl0001zhf0ll7qdnuz"},{"post_id":"cl1rpmkp00000zhf09oqtnx2o","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"cl1rpmkpm0002zhf0318x3amk"},{"post_id":"cl1rq81f300002kf0p7v8ph5s","tag_id":"cl1rq81fz00022kf0yjaa2g2i","_id":"cl1rq81g400032kf0cu3gby4m"},{"post_id":"cl1rq81f300002kf0p7v8ph5s","tag_id":"ckgssh0yo000t4wf0ab0ysiec","_id":"cl1rq81g500042kf0zdcviqxu"}],"Tag":[{"name":"C++","_id":"ckgssh0y200044wf0uxsmx1xc"},{"name":"Unity学习","_id":"ckgssh0y800094wf0h6hvfoch"},{"name":"CI","_id":"ckgssh0yh000f4wf0451fed1c"},{"name":"Python","_id":"ckgssh0yl000m4wf07vvo7fxp"},{"name":"Note","_id":"ckgssh0yo000t4wf0ab0ysiec"},{"name":"Django","_id":"ckgssh0yu000z4wf04m0t4krc"},{"name":"Conda","_id":"ckgssh103001r4wf0bdtqjy1d"},{"name":"实例","_id":"ckgssh10n002l4wf0kzw0qt4t"},{"name":"Game","_id":"ckgssh11f003p4wf0amr8ezxd"},{"name":"English","_id":"ckgssh12i004u4wf0xkie7ckt"},{"name":"linux","_id":"ckgssh12x00524wf0m4rc23a8"},{"name":"指令","_id":"ckgssh132005a4wf0kc1mxvtr"},{"name":"Core Programming","_id":"ckgssh135005j4wf0itpxxvlz"},{"name":"Jenkins","_id":"ckgssh13o005s4wf00gve3wwf"},{"name":"Git","_id":"ckgssh140006e4wf0zbmvfbjr"},{"name":"图形学","_id":"ckgssh14h007f4wf0g47ufceg"},{"name":"UE","_id":"cl1rq81fz00022kf0yjaa2g2i"}]}}