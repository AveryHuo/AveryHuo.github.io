<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GAMES104-NOTE3 | Avery的城堡</title><meta name="author" content="霍家鹏"><meta name="copyright" content="霍家鹏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 游戏引擎的工具链-基础 1.1 总览 在商业引擎中实际工具链的开发是多于引擎本身的 基本Foundation of Tool Chains • What is Game Engine Tool Chains • Complicated Tool GUI • How to Load Asset - Deserialization • How to Make a Robust Tools • H">
<meta property="og:type" content="article">
<meta property="og:title" content="GAMES104-NOTE3">
<meta property="og:url" content="http://www.hjp.wiki/2022/12/06/GAMES104_NOTE3/index.html">
<meta property="og:site_name" content="Avery的城堡">
<meta property="og:description" content="1. 游戏引擎的工具链-基础 1.1 总览 在商业引擎中实际工具链的开发是多于引擎本身的 基本Foundation of Tool Chains • What is Game Engine Tool Chains • Complicated Tool GUI • How to Load Asset - Deserialization • How to Make a Robust Tools • H">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.hjp.wiki/img/image-20221206143528541.png">
<meta property="article:published_time" content="2022-12-06T10:06:28.000Z">
<meta property="article:modified_time" content="2023-01-06T10:06:28.000Z">
<meta property="article:author" content="霍家鹏">
<meta property="article:tag" content="Engine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.hjp.wiki/img/image-20221206143528541.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GAMES104-NOTE3",
  "url": "http://www.hjp.wiki/2022/12/06/GAMES104_NOTE3/",
  "image": "http://www.hjp.wiki/img/image-20221206143528541.png",
  "datePublished": "2022-12-06T10:06:28.000Z",
  "dateModified": "2023-01-06T10:06:28.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "霍家鹏",
      "url": "http://www.hjp.wiki"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.hjp.wiki/2022/12/06/GAMES104_NOTE3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GAMES104-NOTE3',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Avery的城堡</span></a><a class="nav-page-title" href="/"><span class="site-name">GAMES104-NOTE3</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">GAMES104-NOTE3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-06T10:06:28.000Z" title="发表于 2022-12-06 18:06:28">2022-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-06T10:06:28.000Z" title="更新于 2023-01-06 18:06:28">2023-01-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%95%E6%93%8E/">引擎</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1>1. 游戏引擎的工具链-基础</h1>
<h2 id="1-1-总览">1.1 总览</h2>
<p>在商业引擎中实际工具链的开发是多于引擎本身的<br>
基本Foundation of Tool Chains<br>
• What is Game Engine Tool Chains<br>
• Complicated Tool GUI<br>
• How to Load Asset - Deserialization<br>
• How to Make a Robust Tools<br>
• How to Make Tool Chain<br>
• What You See is What You Get  (WYSIWYG)<br>
• One More Thing - Plugin</p>
<p>工具链更大的意义在于调合游戏开发各个环节的人的思维模式。</p>
<blockquote>
<p>那这么一个庞大的系统的话，最外的基础我们叫做<strong>DCC</strong>（Digital Content Creation，比如3DMax、Maya、ZBrush、PS、Houdini大量第三方软件产生资产和素材），通过游戏的工具链，进入我们整个游戏的Pipeline。这里有个术语叫做：<strong>ACP</strong>（Asset Conditioning Pipeline），工具链就在ACP这一层</p>
</blockquote>
<h2 id="1-3-工具链的GUI">1.3 工具链的GUI</h2>
<p>对于GUI模型，分两大类的实现方式</p>
<ul>
<li>
<p>Immediate Mode<br>
每一帧由游戏逻辑直接告诉渲染去画上去。<br>
缺点是逻辑方面业务压力大，扩展性不好，</p>
</li>
<li>
<p>Retain Mode<br>
当我要画一些UI的时候，我并不是直接画到屏幕上去，我先说我要画一个Box，大小、尺寸等，把这些信息一个个交给类似Graphics中的Command Buffer一样，将所有的指令全部存储在这里，到了GUI自己绘制的逻辑之后自己根据已经存储的指令，自己去画了。好处就是游戏的逻辑，与工具的GUI分开了，这个模型扩展性强、性能好，还有一点就是如果你不改变它，你就不需要更新它的指令，这也是非常符合游戏架构的理论模型<br>
如QT GUI, Unreal UMG, WPF GUI</p>
</li>
</ul>
<h2 id="1-4-工具链GUI的Design-Pattern">1.4 工具链GUI的Design Pattern</h2>
<p>对于Retain Mode的GUI实现，需要结合 DP进行才能保证扩展和持续性。</p>
<ul>
<li>MVC模式：1978年创建<br>
<strong>Model</strong>: The central component of the<br>
pattern, responsible for managing the data<br>
of the application.<br>
<strong>View</strong>: Any representation of information<br>
such as a chart, diagram or table.<br>
<strong>Controller</strong>: Accepts input and converts it to<br>
commands for the model or view.</li>
</ul>
<blockquote>
<p>将数据流清晰化了，Model单向的到View，View不能反过来写Model，所以可以理解为Model将数据输送给View了，但是Model本身并不会被弄脏，但是如果你想修改Model中Logic的数据的话，只能通过Controller，它能进行各种处理、过滤，然后去修改你的Model，这样一个环流的结构（因为已经变成了单形线），很清晰，容易切断和管理<br>
<img src="/img/image-20221206143528541.png" alt="image-20221206143528541"></p>
</blockquote>
<p>WEB前端有很多用处</p>
<ul>
<li>MVP<br>
MVP实现了把View与Model隔开，完全不知道model的存在！<br>
把所有的复杂度转到Presenter方。<br>
<strong>Model</strong>: An interface defining the data to be displayed or otherwise acted upon in the user interface.<br>
<strong>View</strong>: A passive interface that displays data (the model) and routes user commands (events) to the<br>
presenter to act upon that data.<br>
<strong>Presenter</strong>: Acts upon the model and the view. It retrieves data from repositories (the model), and<br>
formats it for display in the view.</li>
</ul>
<p><img src="/img/image-20221206143825987.png" alt="image-20221206143825987"></p>
<ul>
<li>MVVM<br>
与MVP类似也把View与Model分开，使用一个ViewModel东西，建立一个DataBinding机制。<br>
View与一个独立的xml文件的方式，把需要的绑定和UI完善出来。程序员实现ViewModel和Model.</li>
</ul>
<p><strong>View</strong>: using a WYSIWYG tool such as Dreamweaver,VS Blend and save as html/xaml , view state<br>
that MVC encodes in its View classes is not easy to represent.<br>
<strong>Binding</strong>: bind View Data to the Model ,no more code in View classes.<br>
<strong>ViewModel</strong> - Model of View: The Model is very likely to have a data types that cannot be mapped<br>
directly to controls,ViewModel contains data-transformers that convert Model types into View types.<br>
缺点： data-binding的调试不易，对于小型UI过于繁重了。</p>
<p><img src="/img/image-20221206143939744.png" alt="image-20221206143939744"></p>
<h2 id="1-5-序列化与反序列化">1.5 序列化与反序列化</h2>
<p><strong>Serialization</strong> 存出去，把数据变成一个二进制块。<br>
is the process of translating a<br>
data structure or object state into a format<br>
that can be stored (for example, in a file or<br>
memory data buffer) or transmitted (for<br>
example, over a computer network) and<br>
reconstructed later.</p>
<p>** Deserialization** 把二进制解成一个数据结构<br>
is the opposite operation,<br>
extracting a data structure from a series of<br>
bytes.</p>
<h2 id="1-6-序列化">1.6 序列化</h2>
<p>那如何把数据SAVE起来？</p>
<ul>
<li>
<p>Text Files: 使用Text文本格式的文件来存储<br>
如Json， YAML,  XML等。 Unity Editor使用YAML。 CryEngine使用XML/Json</p>
</li>
<li>
<p>Binary Files<br>
保存数据为二进制流，需要额外的工具进行读和取。<br>
Unity Runtime, Unity Editor (optional)<br>
CryEngine (optional)<br>
Unreal: UAsset</p>
</li>
</ul>
<blockquote>
<p>对比两种文件，二进制小非常多，且加载更快。Text Files更适合做为debug。</p>
</blockquote>
<ul>
<li>
<p>资产引用<br>
资产引用是一种去除大量重复资源数据的方式，通过查找依赖关系的方式</p>
</li>
<li>
<p>资源实例<br>
Data instance is a way to create a parent data that you can use<br>
as a base to make a wide variety of different children and can<br>
also be used directly</p>
</li>
</ul>
<p>那如何定义每个实例的特性呢？</p>
<ol>
<li>资源实例变体：<br>
如果一个model的material各个地方不同，那这里可以使用实例变体的方式</li>
<li>资源数据继承<br>
如果只有变体，可能还是会有大量的冗余部分，这里可以使用继承的特性</li>
</ol>
<h2 id="1-7-反序列化">1.7 反序列化</h2>
<p>如何把数据LOAD出来呢？<br>
并不能一上来就全部读出来，而是需要解析一个个语义。<br>
就如XML，对于游戏引擎的数据来说，解析就先得构建一个树状结构<br>
这样的树状结构，实际就是Asset底层结构。</p>
<p><img src="/img/image-20221206152404378.png" alt="image-20221206152404378"></p>
<ul>
<li>Endian<br>
用二进制做反序列化时，需要注意这个Endian<br>
同样结构，是把大byte放前面还是小byte放后面？</li>
</ul>
<p>Big Endian:<br>
begin with most significant byte<br>
end with least significant byte<br>
Little Endian:<br>
begin with least significant byte<br>
end with most significant byte</p>
<blockquote>
<p>Processor Endianness<br>
PowerPC (PPC) Big Endian<br>
Sun Sparc Big Endian<br>
IBM S/390 Big Endian<br>
Intel x86 (32 bit) Little Endian<br>
Intel x86_64 (64 bit) Little Endian<br>
ARM Bi (Big/Little) Endian</p>
</blockquote>
<h2 id="1-8-兼容性问题">1.8 兼容性问题</h2>
<p>Unreal的处理方案：<br>
为每一个资产有一个定义好的版本号（手写），如果数据没有，则塞一个default value，如果是多余数据，则跳过</p>
<p>Google的做法<br>
protocol buffers：unique number for field<br>
为每一个数据属性维护一个ID，在数据更新时只需要比较这个ID是否变化。<br>
<strong>Serialization</strong>:</p>
<ol>
<li>For every field, generate a “key” (fixed size) according to<br>
its field number and type.</li>
<li>Store field data with key, key is stored in the first few bytes.<br>
<strong>Deserialization</strong>:</li>
<li>Field not in schema but in data:<br>
key would not be recognized, skip the field.</li>
<li>Field in schema but not in data: set default value.</li>
</ol>
<h2 id="1-9-构建Robust-Tools">1.9 构建Robust Tools</h2>
<p>更健壮的工具</p>
<ul>
<li>Undo/ redo<br>
最核心的功能！！</li>
<li>Crash 自动存盘</li>
</ul>
<h2 id="1-10-Command模式">1.10 Command模式</h2>
<p>针对1.9的需求，将操作原子化为Command。<br>
建议应该在工具链的早期引入Command</p>
<p>Command原子化最经典的结构： UID，数据，操作/反操作， 序列化/反序列化<br>
<img src="/img/image-20221206154458958.png" alt="image-20221206154458958"></p>
<p>核心三类Command:</p>
<ol>
<li>Add<br>
• Data: Usually data is a copy of the runtime instance<br>
• Invoke: Create a runtime instance with data<br>
• Revoke: Delete the runtime instance</li>
<li>Delete<br>
• Data: Usually data is a copy of the runtime instance<br>
• Invoke: Delete the runtime instance<br>
• Revoke: Create a runtime instance with data</li>
<li>Update<br>
• Data: Usually data is the old and new values of the modified properties of the runtime instance and<br>
their property names<br>
• Invoke: Set the runtime instance property to the new value<br>
• Revoke: Set the runtime instance property to the old value</li>
</ol>
<h2 id="1-11-Data-Schema">1.11 Data Schema</h2>
<p>当针对不同的用户会有不同的工具，因此也有情况是相同的数据，对于不同的用户会表现为不同的工具。<br>
解决这类问题，需要把工具的数据进行细化，用统一的描述和定义，这样可以适配到不同的工具。<br>
这里引入Data Schema来描述一个数据<br>
A data schema is the formal description of the structures your system is working with.</p>
<ul>
<li>
<p>Schema基本元素：<br>
Abstraction of the basic building block of the world<br>
• Atomic Types: Int, Float, Double …<br>
• Class Type: Use atomic types to present complex data structure<br>
• Containers: Array, Map …</p>
</li>
<li>
<p>继承的特性<br>
数据间需要对相互之间及类型的继承，这样可以派生出各种变种和引用。</p>
</li>
<li>
<p>定义Schema的方式</p>
</li>
</ul>
<ol>
<li>使用独立的schema定义文件<br>
问题：<br>
需要一个自定义的代码转换器，这个转换器在使用过程中会出现迭代，报错等问题。<br>
对于行为的定义的不方便，这一点在方法2中得到解决。</li>
<li>定义在文件中<br>
问题：<br>
稳定性需要尤其重要，虽然可以定义行为，但是缺点是容易在定义schema时崩溃。</li>
</ol>
<p><img src="/img/image-20221206155647632.png" alt="image-20221206155647632"></p>
<h2 id="1-12-引擎数据">1.12 引擎数据</h2>
<p>三种方面：<br>
Runtime View:  关注更快的读取，更高效的处理<br>
Storage View: 节约空间，更快的写入速度<br>
Tools View: 更方面理解的显示，编辑的便利性（一个虚拟的存在，由工具的UI实现）</p>
<h2 id="1-13-Tools-View">1.13 Tools View</h2>
<p>工具设计的核心是如何去处理好这个Tools View</p>
<ol>
<li>Understandable</li>
<li>Various Editor Modes，自由适配的编辑器显示（高级与基础模式）</li>
</ol>
<h2 id="1-14-WYSIWYG">1.14 WYSIWYG</h2>
<p>所见即所得<br>
工具链的构建方式：</p>
<ol>
<li>
<p>Stand-alone Tools<br>
把工具链的代码独立开，保证引擎的纯净<br>
缺点：难以实现WYSIWYG</p>
</li>
<li>
<p>In Game Tools - 推荐<br>
在引擎Runtime的基础上构建工具链<br>
Pros<br>
• Access to all engine data directly<br>
• Easy to preview the game in the editor<br>
• Easy to make live in-game editing<br>
Cons<br>
• Complex engine architecture<br>
• Requires a complete engine UI system to make<br>
the editor UI<br>
• When the engine is crashing, the tools become<br>
unusable as well</p>
</li>
</ol>
<h2 id="1-15-PIE">1.15 PIE</h2>
<p>Play in editor<br>
直接在editor下就能play<br>
两种实现方式:</p>
<ol>
<li>
<p>Play in editor world<br>
Pros<br>
• Easy architecture tools layer<br>
• Quick state change<br>
Cons<br>
• 数据混乱的问题Game mode may cause data changes<br>
• 出现数据在editor下没问题，但runtime有问题<br>
Example<br>
• Piccolo</p>
</li>
<li>
<p>Play in PIE World<br>
把游戏数据复制一份，独立运行<br>
Unreal的模式<br>
Pros<br>
• Data separation<br>
• Easy to instantitate multiple game instances<br>
Cons<br>
• Architecture complex</p>
</li>
</ol>
<h2 id="1-16-Plugins">1.16 Plugins</h2>
<p>工具链也需要支持Plugin插件系统<br>
现代引擎重要的开发能力展现。</p>
<p><img src="/img/image-20221206161844756.png" alt="image-20221206161844756"></p>
<p>要求尽可能把功能API化，这样更方便实现扩展性需求，为插件调用打好基础。</p>
<h1>2. 游戏引擎的工具链-高级</h1>
<h2 id="2-1-总览">2.1 总览</h2>
<p>Applications &amp; Advanced Topic<br>
•Glance of Game Production<br>
•Architecture of A World Editor<br>
•Plugin Architecture<br>
•Design Narrative Tools<br>
•Reflection and Gameplay<br>
•Collaborative Editing</p>
<h2 id="2-2-Glance-of-Game-Production">2.2 Glance of Game Production</h2>
<ul>
<li>现代引擎工具链的挑战：</li>
</ul>
<ol>
<li>海量不同的数据</li>
<li>不同角色的思维方向</li>
<li>WYSIWYG 的实现复杂度</li>
</ol>
<h2 id="2-3-Architecture-of-A-World-Editor">2.3 Architecture of A World Editor</h2>
<p>以UE为例<br>
<img src="/img/image-20221207113638212.png" alt="总览"></p>
<ul>
<li>Editor Viewport<br>
• 与用户关联的主窗口 Main window of interaction between designers and game world<br>
• 一个编辑模式的游戏 Powered by a full game engine in special “editor” mode<br>
• 提供一系列的工具和编辑 Provides a variety of special gadgets and visualizers for editing</li>
</ul>
<blockquote>
<p>注意EditorOnly的代码的安全性问题</p>
</blockquote>
<ul>
<li>Editable Object</li>
</ul>
<ol>
<li>把游戏中的对象做为Editable</li>
<li>对不同的对象设计不同的编辑view</li>
<li>数据通过Schema自动反射生成编辑器界面</li>
</ol>
<ul>
<li>
<p>Content Browser<br>
资产管理器<br>
对于UE来说，这里可能实现跨项目共享资源</p>
</li>
<li>
<p>Mouse Picking<br>
鼠标选取<br>
实现方案：</p>
</li>
</ul>
<ol>
<li>Ray Casting<br>
实际使用的一个物理引擎<br>
缺点是性能不好，选择前后物体需要特殊处理（添加object id，以framebuffer取到对应的方式）。但优点是不需要cache，支持选中多个物体</li>
<li>RTT<br>
Pros:<br>
•Easy to implement range queries<br>
•Ability to complete queries quickly<br>
Cons:<br>
•Need to draw an extra picture<br>
•Obstructed objects cannot be selected</li>
</ol>
<ul>
<li>
<p>Object Transform的编辑</p>
</li>
<li>
<p>Terrain - Height Brush, Instance Brush（对对象进行实例化，但在大场景中对内存要求较高），自定义笔刷的功能</p>
</li>
<li>
<p>Environment</p>
<p>困难点：对于不同的环境，sky, terrain之类，应该有一套规则， 如铺路面，要满足地形路的高低</p>
<p>这里引入一个Rule System: 对于不同的环境需要给予一定规则。</p>
</li>
</ul>
<h2 id="2-4-Plugin机制">2.4 Plugin机制</h2>
<p><strong>任何的系统和对象类型都需要为一个编辑器的插件</strong></p>
<p>几种多Plugin的构建模型<br>
<img src="/img/image-20221221141817081.png" alt="image-20221221141817081"></p>
<p>以pipeline形式的构建则是一个前一个输出为后一个输入的方式<br>
<img src="/img/image-20221221141853592.png" alt="image-20221221141853592"></p>
<h2 id="2-5-Timeline">2.5 Timeline</h2>
<p>如Unreal中使用Sequencer的方式以每条Track规划每个对象的行为。<br>
用时间帧来处理，如剧情，声效，UI都可以用此种方式处理</p>
<h2 id="2-6-反射和游戏逻辑">2.6 反射和游戏逻辑</h2>
<p>反射： 为了保证代码的扩展性而生，在代码和工具之间构建一个桥梁</p>
<p>Mustache:</p>
<p><img src="/img/image-20221221183009318.png" alt="image-20221221183009318"></p>
<p>piccolo引擎的反射实现：<br>
使用clang，并结合Mustache的Code Rendering技术批量生成代码</p>
<ol>
<li>调用clang生成内存中的schema</li>
<li>根据写好的模板，调用 Mustache生成大量的accessable code</li>
</ol>
<h2 id="2-7-协同编辑">2.7 协同编辑</h2>
<p>协同最大的问题就是解决冲突</p>
<ul>
<li>
<p>分层的方法<br>
优点当然是把复杂的场景进行细化， 但缺点是在于强关联的多层工作，无法更好的处理</p>
</li>
<li>
<p>对世界进行划分<br>
优点是易于扩展一个世界，更好处理，缺点是对于跨世界的物体难处理</p>
</li>
<li>
<p>OFPA的方式<br>
优点： 较彻底地解决冲突问题<br>
问题是产生较多的小问题，把OFPA文件整合到level中时整个cook的过程会比较慢</p>
</li>
</ul>
<p><img src="/img/image-20221222104527263.png" alt="image-20221222104527263"></p>
<p>协同的另一个问题： 同步问题</p>
<ul>
<li>
<p>操作锁</p>
</li>
<li>
<p>资源锁</p>
</li>
<li>
<p>以上两种并不能解决undo redo的情况：<br>
解决方案1：基于Operation Transform（OT）的方法<br>
解决方案2： Conflict-free Replicated Data Type(CRDT)</p>
<p><img src="/img/image-20221222105224078.png" alt="image-20221222105224078"></p>
</li>
</ul>
<p>协同的问题： 竞争问题<br>
两种方案，更建议第二种，将结果先结算完再发到终端</p>
<p><img src="/img/image-20221222105354755.png" alt="image-20221222105354755"><br>
但这里有个隐患就是，这里的终端server需要保证稳定</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.hjp.wiki">霍家鹏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.hjp.wiki/2022/12/06/GAMES104_NOTE3/">http://www.hjp.wiki/2022/12/06/GAMES104_NOTE3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://www.hjp.wiki" target="_blank">Avery的城堡</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Engine/">Engine</a></div><div class="post-share"><div class="social-share" data-image="/img/image-20221206143528541.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/weixin.jpg" target="_blank"><img class="post-qr-code-img" src="/img/weixin.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/02/01/C++Review2/" title="C++ 复习2"><img class="cover" src="/img/image-20230202174221474.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++ 复习2</div></div><div class="info-2"><div class="info-item-1">一、概述 C++ 起源于1983年，1.0正式版于1998年发布又叫C++98。 2.0版本为C++11（即2011年推出的大版本）。 C++ 简单来说由 语言+标准库组成 C语言的缺点：数据-&gt; 函数的处理方式，导致数据一定是全局才能给各个函数处理。这时C++的面向对象思想就解决了这一问题 c++ 用 class 将member data和member function包在一起来创建object 延展文件名（extension file name）不一定是.h或.cpp，可能是.hpp甚至没有。 二、文件头与类 2.1 Header（头文件）中的防卫式声明（guard） 为了防止多次include复制执行，保证只被一次include，使用防卫式声明。 #ifndef __COMPLEX__#define __COMPLEX__内容#endif  建议所有头文件都有这个声明  2.2 头文件内容布局 前置声明 class complex;   类声明  class complex&#123;....&#125; +类定义 complex::function ... 2.3 ...</div></div></div></a><a class="pagination-related" href="/2022/11/24/GAMES104_NOTE2/" title="GAMES104-NOTE2"><img class="cover" src="/img/image-20221123153956216.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">GAMES104-NOTE2</div></div><div class="info-2"><div class="info-item-1">1.粒子系统 1.1 基础概念  Emitter 发射器 Particle System 把众多的Emitter结合到一起   游戏中的粒子系统的编辑核心就是如何组合Emitter    Spawn Position 发射生成点   Spawn Mode 生成的方式的种类，比如到达一定时机才进行Spawn发射   Simulate 粒子在空间的行为 使用最简单的显式积分 旋转 重力和大小 一些物理特性，如落地的与地面相遇时反弹   Billboard Particle 最古老，每个粒子都是sprite, 面向相机 如果尺寸大，建议用Animated texture，texture表面不断变化   Mesh Particle 每个粒子都是Model， 碎片来自于爆炸   Ribbon Particle Particle拖出一条光带，如刀剑的拖尾的效果。 在飞行过程中会不断拉出一个个的控制点 使用Catmull-Rom 曲线，把曲线拉得更光滑   1.2 Rendering  Particle Sort Mode   Global的方式 对于整个System进行排序，性能消耗大 通过...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/11/24/GAMES104_NOTE2/" title="GAMES104-NOTE2"><img class="cover" src="/img/image-20221123153956216.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-24</div><div class="info-item-2">GAMES104-NOTE2</div></div><div class="info-2"><div class="info-item-1">1.粒子系统 1.1 基础概念  Emitter 发射器 Particle System 把众多的Emitter结合到一起   游戏中的粒子系统的编辑核心就是如何组合Emitter    Spawn Position 发射生成点   Spawn Mode 生成的方式的种类，比如到达一定时机才进行Spawn发射   Simulate 粒子在空间的行为 使用最简单的显式积分 旋转 重力和大小 一些物理特性，如落地的与地面相遇时反弹   Billboard Particle 最古老，每个粒子都是sprite, 面向相机 如果尺寸大，建议用Animated texture，texture表面不断变化   Mesh Particle 每个粒子都是Model， 碎片来自于爆炸   Ribbon Particle Particle拖出一条光带，如刀剑的拖尾的效果。 在飞行过程中会不断拉出一个个的控制点 使用Catmull-Rom 曲线，把曲线拉得更光滑   1.2 Rendering  Particle Sort Mode   Global的方式 对于整个System进行排序，性能消耗大 通过...</div></div></div></a><a class="pagination-related" href="/2023/02/01/GAMES104_NOTE4/" title="GAMES104-NOTE4"><img class="cover" src="/img/image-20230106174810993.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="info-item-2">GAMES104-NOTE4</div></div><div class="info-2"><div class="info-item-1">1. 引擎中的GamePlay玩法 GamePlay is Everything 1.1 总览 • Event Mechanism • Script System • Visual Script • Character, Control and Camera GamePlay的挑战  各个子系统之间的协作 对于一些游戏中，可能存在各种类型玩法 如何针对市场情况，做出快速迭代  1.2 Event Mechanism  Publish-subscribe Pattern   发送者 -&gt; 事件注册到Dispatcher Dispatcher送到各个GO中 GO返回Callback 因此需要三个组件： 组件1： Event Definition 这里的问题是，游戏的玩法多样性导致无法从程序层面预先定义好类型。UE的解决方案下是允许自定义类，生成可编辑的界面。 但另一个问题是，这样还是会需要重编译代码，对于UE来说，允许一种C++代码编译出的DLL的注入机制。  组件2：Callback Registration 预先注册一个callback函数句柄，由某个时刻被Invoke。 ...</div></div></div></a><a class="pagination-related" href="/2022/10/19/GAMES104_NOTE1/" title="GAMES104-NOTE1"><img class="cover" src="/img/1608804894728513117.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-19</div><div class="info-item-2">GAMES104-NOTE1</div></div><div class="info-2"><div class="info-item-1">1.游戏引擎导论  什么是游戏引擎   底层框架 生产力工具 复杂性的系统艺术集合   核心难点：   游戏引擎最重要的难点是Realtime，必须在33毫秒之内将结果计算出来，是所有系统的计算结果计算出来，这就是现代游戏引擎设计的核心难点。 游戏引擎不仅仅是一系列的算法，更是生产力的工具，需要成熟的工具链   学习的方式： 以framework为基准，自上往下再细致学习研究  2. 分层  Tool Layer 工具层 Function Layer 基本功能层 Resource Layer 资源层，包括数据等 Core Layer 核心层，内存管理，容器分配，数学运算模块，脚本运行时环境 Platform Layer 平台层，操作系统，平台文件系统，Graphics API, Platform SDK  2.1 Resource Layer: 以特定引擎的格式统一化导入 从Resource到Asset，通过Importer转换到引擎下 通过一个reference文件数据记录关联 GUID  做为唯一识别号  Runtime 资源管理器， 虚拟的文件系统加载和卸载Asset 管理...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/my.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">霍家鹏</div><div class="author-info-description">Keep going! Keep study!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AveryHuo"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">1. 游戏引擎的工具链-基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%B7%A5%E5%85%B7%E9%93%BE%E7%9A%84GUI"><span class="toc-number">1.2.</span> <span class="toc-text">1.3 工具链的GUI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%B7%A5%E5%85%B7%E9%93%BEGUI%E7%9A%84Design-Pattern"><span class="toc-number">1.3.</span> <span class="toc-text">1.4 工具链GUI的Design Pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">1.5 序列化与反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">1.6 序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.6.</span> <span class="toc-text">1.7 反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">1.8 兼容性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E6%9E%84%E5%BB%BARobust-Tools"><span class="toc-number">1.8.</span> <span class="toc-text">1.9 构建Robust Tools</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-Command%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.9.</span> <span class="toc-text">1.10 Command模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-Data-Schema"><span class="toc-number">1.10.</span> <span class="toc-text">1.11 Data Schema</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE"><span class="toc-number">1.11.</span> <span class="toc-text">1.12 引擎数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-Tools-View"><span class="toc-number">1.12.</span> <span class="toc-text">1.13 Tools View</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-WYSIWYG"><span class="toc-number">1.13.</span> <span class="toc-text">1.14 WYSIWYG</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-PIE"><span class="toc-number">1.14.</span> <span class="toc-text">1.15 PIE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-16-Plugins"><span class="toc-number">1.15.</span> <span class="toc-text">1.16 Plugins</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">2. 游戏引擎的工具链-高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%80%BB%E8%A7%88"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Glance-of-Game-Production"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Glance of Game Production</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Architecture-of-A-World-Editor"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Architecture of A World Editor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Plugin%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Plugin机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Timeline"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 Timeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 反射和游戏逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 协同编辑</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/25/C++Review3/" title="C++ 复习3">C++ 复习3</a><time datetime="2023-02-25T07:09:05.000Z" title="发表于 2023-02-25 15:09:05">2023-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/20/C++11NewFeatures/" title="C++ 11新特性">C++ 11新特性</a><time datetime="2023-02-20T02:03:22.000Z" title="发表于 2023-02-20 10:03:22">2023-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/C++Review2/" title="C++ 复习2"><img src="/img/image-20230202174221474.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 复习2"/></a><div class="content"><a class="title" href="/2023/02/01/C++Review2/" title="C++ 复习2">C++ 复习2</a><time datetime="2023-02-01T14:43:40.000Z" title="发表于 2023-02-01 22:43:40">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/GAMES104_NOTE4/" title="GAMES104-NOTE4"><img src="/img/image-20230106174810993.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAMES104-NOTE4"/></a><div class="content"><a class="title" href="/2023/02/01/GAMES104_NOTE4/" title="GAMES104-NOTE4">GAMES104-NOTE4</a><time datetime="2023-02-01T14:43:40.000Z" title="发表于 2023-02-01 22:43:40">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/GAMES104_NOTE3/" title="GAMES104-NOTE3"><img src="/img/image-20221206143528541.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAMES104-NOTE3"/></a><div class="content"><a class="title" href="/2022/12/06/GAMES104_NOTE3/" title="GAMES104-NOTE3">GAMES104-NOTE3</a><time datetime="2022-12-06T10:06:28.000Z" title="发表于 2022-12-06 18:06:28">2022-12-06</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 霍家鹏</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.2.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>