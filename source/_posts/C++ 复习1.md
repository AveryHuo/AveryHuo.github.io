---
title: C++ 复习1
categories:
- C and CPlusPlus
tags: 
- C++
---

#### 关于无符号与有符号数
* 无符号不能为负数
* 循环如果使用无符号计数，以>=为条件将导致死循环

#### C++ 11的初始化方法
```c++
int a{0};
```

#### extern的使用
* 对于希望分离成多个文件独立编译的变量，使用extern公开出去
* 声明一个变量并extern出去，但注意不要声明+定义一起，否则失去了extern作用了
* extern变更的声明可以在多个文件，但定义只能在一个文件

#### 复合类型：引用与指针
* 引用类型一旦初始化就与初始对象绑定在一起，不可以更换绑定。且必须在定义时赋值。
* 引用类型不可以与值绑定
* 指针可以不在声明时初始化，指针是一个对象
* 指针赋值之间类型必须相同
* C++ 11的标准提供了nullptr为指针初始化为空。 引用cstdlib标准库中，还可以用NULL为指针初始化
* 任何非0的指针都为true.
* void＊指针，可用于存放任意对象的地址，但不能直接操作指针所指的对象，可理解为操作内存空间

#### 理解复合类型
* 对于一个变量，要理解其类型，最简单的办法从右向左阅读变量的定义，离变量名最近的对变量有最直接的影响。
```c++
int i = 42;
int *p;
int *&r = p; //r是对指针p的一个引用类型变量

r = &i; //给r赋值，就是给p的地址赋值，因此此时 p的值指向了i的地址
*r = 0;//i的值也为0
```

* const 限定符， 声明了const后就不能改变其值，但可以使用非常量来初始化const值
* const 在多文件中的使用：在一个文件中用extern声明同时定义，其他文件中仅extern声明即可。
* const声明的任何类型都不可以改值！
* const指针， 即指针指向的地址是不能改变的
```c++
int *errNumb = 0;
int *const curErr = &errNumb;//curErr指针的指向的地址不能改变
const double pi = 3.14;
const double *const pip = &pi;// pip指向常量pi的常量指针
```
* 顶层const与底层const:　从变量名的左侧开始算，底层到高层。最右侧的为顶层const, 指针符左侧为底层const.
* 拷贝的操作必须两对象都具有相同的底层const
* 一般来说非常量可转换为常量。

#### 常量表达式 constexpr
具有以下两个条件的可称为常量表达式：
1. 表达式左侧的变量需定义为常量
2. 表达式右侧的值是不用到运行时就能确定的。

C++ 11的标准规定，可以使用constexpr 让编译器验证是否为常量表达式，也可定义函数为constexpr 这样就可以在常量表达式中使用。
```c++
constexpr int mf =20;
constexpr int limit = mf+1;
constexpr int sz = size(); //size()一定要用constexpr声明。
```

* constexpr 定义指针，表达此指针为常量指针，因此根据常量指针的特点，必须进行初始化。
* 注意constexpr定义后的指针就为常量指针，即此const为指针对象的顶层const
```c++
const int *p = nullptr;
constexpr int *q = nullptr;
//p与q是非常不同的，p是一个指针，指向常量。 q是一个常量指针，其地址不能改。
```

#### 类型别名
使用typedef 为类型起一个别名：
```c++
typedef int ss;
```

* C++ 11 新标准可使用using语法替换typedef
```c++
using ss = int;
```
* 特别注意当有const在最左侧声明时，带指针的类型别名解释不能直接替换后来翻译，如：
```c++
typedef char *pstring; //类型别名为指向char的指针
const pstring a;//a是指向char的常量指针
//const char* a;//a是指向const char的指针，与const pstring a表示不同！

```

#### Auto类型说明符 (C++11)

不需要强制为某个变量指定类型的声明方式
* 注意： auto一般会忽略掉顶层的const，当auto引用时！才会保留const
* auto多变量声明类型必须一样
```c++
int i = 0;
const int ci = i;
//以下错误，因为n和p的类型不同，n是整型指针，ci是整型常量指针。
auto &n = i, *p = &ci;
```

#### decltype类型说明符（C++11）

使用decltype可取出表达式或变量的类型，以此类型再声明变量。

* 注意：与auto不同的是decltype的值与其内的变量或表达式密切相关，同时也可使用到顶层const和引用。
* 注意：带括号的表达式或变量，使用decltype时，将必定！返回对应结果的引用类型。而且普通无多个括号时，只有表达式或变量是引用类型才为引用。
```c++
decltype((i)) d; // 错误，d的类型最终为int &, 引用类型必须初始化才行
```

#### 关于结构体
C++11新标准规定可以为结构体内的变量设置初始值

#### 关于using的用法
 ```c++
 using std:cin;
 using namespace std;
 ```
 
 * 注意一般不要在头文件中使用using


#### string
* string相加的注意
```c++
string s1 = "H"+"s"; //错误，无法确定为string类型
```
* string的size()返回的size_type，不确定具体类型，但一定是无符号的，所以比对时一定注意。

#### for ： （C++ 11）
类似于foreach，for 与： 结合取出对象。
