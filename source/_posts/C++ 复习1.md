---
title: C++ 复习1
categories:
- C and CPlusPlus
tags: 
- C++
---

#### 关于无符号与有符号数
* 无符号不能为负数
* 循环如果使用无符号计数，以>=为条件将导致死循环

#### C++ 11的初始化方法
```c++
int a{0};
```

#### extern的使用
* 对于希望分离成多个文件独立编译的变量，使用extern公开出去
* 声明一个变量并extern出去，但注意不要声明+定义一起，否则失去了extern作用了
* extern变更的声明可以在多个文件，但定义只能在一个文件

#### 复合类型：引用与指针
* 引用类型一旦初始化就与初始对象绑定在一起，不可以更换绑定。且必须在定义时赋值。
* 引用类型不可以与值绑定
* 指针可以不在声明时初始化，指针是一个对象
* 指针赋值之间类型必须相同
* C++ 11的标准提供了nullptr为指针初始化为空。 引用cstdlib标准库中，还可以用NULL为指针初始化
* 任何非0的指针都为true.
* void＊指针，可用于存放任意对象的地址，但不能直接操作指针所指的对象，可理解为操作内存空间

#### 理解复合类型
* 对于一个变量，要理解其类型，最简单的办法从右向左阅读变量的定义，离变量名最近的对变量有最直接的影响。
```c++
int i = 42;
int *p;
int *&r = p; //r是对指针p的一个引用类型变量

r = &i; //给r赋值，就是给p的地址赋值，因此此时 p的值指向了i的地址
*r = 0;//i的值也为0
```

* const 限定符， 声明了const后就不能改变其值，但可以使用非常量来初始化const值
* const 在多文件中的使用：在一个文件中用extern声明同时定义，其他文件中仅extern声明即可。
* const声明的任何类型都不可以改值！
* const指针， 即指针指向的地址是不能改变的
```c++
int *errNumb = 0;
int *const curErr = &errNumb;//curErr指针的指向的地址不能改变
const double pi = 3.14;
const double *const pip = &pi;// pip指向常量pi的常量指针
```
* 顶层const与底层const:　从变量名的左侧开始算，底层到高层。最右侧的为顶层const, 指针符左侧为底层const.
* 拷贝的操作必须两对象都具有相同的底层const
* 一般来说非常量可转换为常量。

#### 常量表达式 constexpr
具有以下两个条件的可称为常量表达式：
1. 表达式左侧的变量需定义为常量
2. 表达式右侧的值是不用到运行时就能确定的。

C++ 11的标准规定，可以使用constexpr 让编译器验证是否为常量表达式，也可定义函数为constexpr 这样就可以在常量表达式中使用。
```c++
constexpr int mf =20;
constexpr int limit = mf+1;
constexpr int sz = size(); //size()一定要用constexpr声明。
```

* constexpr 定义指针，表达此指针为常量指针，因此根据常量指针的特点，必须进行初始化。
* 注意constexpr定义后的指针就为常量指针，即此const为指针对象的顶层const
```c++
const int *p = nullptr;
constexpr int *q = nullptr;
//p与q是非常不同的，p是一个指针，指向常量。 q是一个常量指针，其地址不能改。
```

#### 类型别名
使用typedef 为类型起一个别名：
```c++
typedef int ss;
```

* C++ 11 新标准可使用using语法替换typedef
```c++
using ss = int;
```
* 特别注意当有const在最左侧声明时，带指针的类型别名解释不能直接替换后来翻译，如：
```c++
typedef char *pstring; //类型别名为指向char的指针
const pstring a;//a是指向char的常量指针
//const char* a;//a是指向const char的指针，与const pstring a表示不同！

```