---
title: 内存管理
categories:
- Unity学习
tags: 
- Unity学习
---

## 物理内存

当指令不连贯时，将会产生大量的时间浪费，DOTS和ECS从这个方面优化了内存的访问性能。

![DOTS的目的](/img/1578646439353.png)

> 日志常见： OOM，显存大小无法分配过来的报错信息
![移动设备的区别](/img/1578646594733.png)

> 三级缓存：
> 台式：主流在8~16MB
> 移动端：高端如845，2M

## 虚拟内存


![虚拟内存](/img/1578646743161.png)
> 交换内存： 当操作系统内存不够时，尝试把不用的内存(deadmemory)交换到硬盘上，从而节省出更多物理内存。
> 为什么移动端没有内存交换：移动设备IO速度慢，存储器的可擦写次数较台式少。
> IOS提供了把不活跃的内存压缩起来放到一个特定空间。Virtual memory 很大。


## 内存寻址范围

可简单认为64位CPU寻址范围大。

## 安卓内存管理

![安卓内存](/img/1578647010062.png)

> Page: 一般4K一个Page
> 回收和分配以page为单位
> 用户态和内核态

> LMK, low memeory killer
> 分类：
> Native： adbd等，adb的守护线程
> System: 系统服务
> Persistent: 电话，信息，蓝牙等等
> Foreground: 应用
> Perceptible: 搜索等等
> Services： 服务，云服务等
> Home:主界面
> Previous: 之前上一个应用
> Cached:　后台

> 从低层开始往上杀。 Foreground其实就是闪退的表现。杀到System就重启了。
![优化级](/img/1578651845843.png)

## 安卓内存指标

![内存指标](/img/1578652129043.png)

> RSS: 当前APP所使用的所有内存
> PSS: 公共库分配出来的内存
> USS：只有自己使用的内存，一般在此处优化

> procrank 指令



## Unity内存管理

![Unity引擎](/img/1578652476304.png)

#### 1. Unity 内存按照分配方式分为：
 - Native Memory
- Managed Memory
- Editor & Runtime 是不同的
    - 不止是统计看到的内存大小不同，甚至是内存分配时机和方式也不同
    - Asset 在 Runtime 中如果不读取，是不会进内存的，但 Editor 打开就占内存。因为 Editor 不注重 Runtime 的表现，更注重编辑器中编辑时的流畅。
	- 但如果游戏庞大到几十个 G，如果第一次打开项目，会消耗很多时间，有的大的会几天，甚至到一周。

#### 2. Unity 内存按照管理者分为：
- 引擎管理内存，开发者一般使用不到
- 用户管理内存（应优先考虑）

#### 3. Unity 检测不到的内存
用户分配的 native 内存
- 自己写的 Native 插件（C++ 插件）， Unity 无法分析已经编译过的 C++ 是如何去分配和使用内存的。
- Lua 完全由自己管理内存，Unity 无法统计到内部的使用情况。

#### 4. Unity Native Memory 管理

Unity 重载了所有分配内存的操作符（C++ alloc、new），使用这些重载的时候，会需要一个额外的 memory label （Profiler-shaderlab-object-memory-detail-snapshot，里面的名字就是 label：指当前内存要分配到哪一个类型池里面）

- Allocator: 使用重载过的分配符去分配内存时，Allocator 会根据你的 memory label 分配到不同 Allocator 池里面，每个 Allocator 池 单独做自己的跟踪。因此当我们去 Runtime get memory label 下面的池时就可以问 Allocator，里面有多少东西 多少兆。
- NewAsRoot: Allocator 在 NewAsRoot （Memory  “island”（没听清）） 中生成。在这个 Memory Root 下面会有很多子内存：shader：当我们加载一个 Shader 进内存的时候，会生成一个 Shader 的 root。Shader 底下有很多数据：sub shader、Pass 等会作为 memory “island” (root) 的成员去依次分配。因此当我们最后统计 Runtime 的时候，我们会统计 Root，而不会统计成员，因为太多了没法统计。
- 及时返给unity: 因为是 C++ 的，因此当我们 delete、free 一个内存的时候会立刻返回内存给系统，与托管内存堆不一样。

#### 5. 最佳实践 Native 内存

- Scene
    - Unity 是一个 C++ 引擎，所有实体最终都会反映在 C++ 上，而不是托管堆里面。因此当我们实例化一个 GameObject 的时候，在 Unity 底层会构建一个或多个 Object 来存储这个 GameObject 的信息，例如很多 Components。因此当 Scene 有过多 GameObject 的时候，Native 内存就会显著上升。
    - 当我们看 Profiler，发现 Native 内存大量上升的时候，应先去检查 Scene。
- Audio
    - DSP buffer （声音的缓冲）
        - 当一个声音要播放的时候，它需要向 CPU 去发送指令——我要播放声音。但如果声音的数据量非常小，就会造成频繁地向 CPU 发送指令，会造成 I\O。
        - 当 Unity 用到 FMOD 声音引擎时（Unity 底层也用到 FMOD），会有一个 Buffer，当 Buffer 填充满了，才会向 CPU 发送“我要播放声音”的指令。
        - DSP buffer 会导致两种问题：
            - 如果（设置的） buffer 过大，会导致声音的延迟。要填充满 buffer 是要很多声音数据的，但声音数据又没这么大，因此会导致一定的**声音延迟**。
            - 如果 DSP buffer 太小，会导致 CPU 负担上升，满了就发，消耗增加。

            [Audio](https://docs.unity3d.com/Manual/class-AudioManager.html)

    - Force to mono
        - 在导入声音的时候有一个设置，很多音效师为了声音质量，会把声音设为双声道。但 95% 的声音，左右声道放的是完全一样的数据。这导致了 1M 的声音会变成 2M，体现在包体里和内存里。因此一般对于声音不是很敏感的游戏，会建议改成 Force to mono，强制单声道。
    - Format
    - Compression Format（看文档，有使用建议）