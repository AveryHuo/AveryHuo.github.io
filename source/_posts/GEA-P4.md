---
title: GEA-P4
categories:
- IT阅读
tags: 
- Game
---

## (5.1) 子系统的启动与关闭
游戏引擎由若干子系统组成，在启动时如果系统间有相互依赖，同销毁时的顺序也需要按要求。如B系统依赖A，则A需要先启动再启动B，销毁时则是B先销毁再销毁A。

#### 处理各子系统启动关闭的方式
* 1. 单例模式： 第一次使用时，构造函数中初始化所依赖的其他子系统
* 2. 【推荐】使用另一个管理器，统一管理所有的子系统启动与关闭。


## (5.2) 内存管理
内存影响性能的两个方面：
1. 动态内存分配 ：malloc或new。将比较低效，可以避免一次性分配 
2. CPU内存的高效性与普通大内存

#### 优化动态内存分配 
规则： Keep heap allocations to a minimum, and never allocate from the heap within a tight loop.

效率低下的原因： 1. 堆分配器的管理消耗。 2. 大部分操作系统free()函数调用需要切换模式。（用户切到内存，再切回来）
保证越少分配越好，从不要在update中申请堆内存。

#####  自定义动态内存分配器

1. Stack -Based Allocators 以栈为基础的分配器
 * 许多游戏以类似栈的方式分配内存。每当一个新的游戏关卡被加载时，内存就会被分配给它。一旦加载了该级别，就很少或不进行动态内存分配。在这一层的最后，它的数据被卸载，它的所有内存可以被释放。对于这些类型的内存分配，使用类似栈的数据结构是很有意义的。
 
 * 栈分配器是非常容易实现的。我们简单地使用malloc()或global new分配一个大的连续内存块，或者通过声明一个全局字节数组(在这种情况下，内存是从可执行文件的BSS段中有效分配的)。维护一个指向栈顶部的指针，这个指针下面的所有内存地址被认为是在使用中，而它上面的所有地址被认为是空闲的。顶端指针被初始化为栈中最低的内存地址。每个分配请求只是将指针按请求的字节数向上移动。只需将顶部指针按blockIt的大小向后移动，就可以释放最近分配的块。
 
 * 要意识到，对于栈分配器，内存不能以任意顺序释放。所有释放必须按照与分配它们相反的顺序执行。执行这些限制的一种简单方法是根本不允许释放单个块。替代的方案就是,我们可以提供一个函数栈顶部回滚之前标记位置,从而释放之间的所有块当前最高和回滚位置。
 
 * 非常重要的一点是，要总是将顶部指针回滚到两个分配好的内存块中间,否则新分配将覆盖最顶部的块的末端。为了确保正确地执行此操作，堆栈分配器通常提供一个函数，该函数返回表示堆栈当前顶部的标记。回滚函数然后将这些标记中的一个作为其参数。如图所示。栈分配器的接口通常看起来像这样。

![栈分配器的回收](/img/1599634350864.png)

> Double ended stack allocator 双端栈分配器

* 单个内存块实际上可以包含两个栈分配器——一个从块的底部向上分配，另一个从块的顶部向下分配。双端栈分配器很有用，因为它允许在底层栈的内存使用和顶层栈的内存使用之间进行权衡，从而更有效地使用内存。在某些情况下，两个栈可能使用大致相同的内存，并在块的中间相遇。在其他情况下，两个栈中的一个可能会比另一个栈消耗更多的内存，但是只要请求的内存总量不大于两个栈共享的内存块，所有分配请求仍然可以得到满足。
![双端栈分配器](/img/1599634811580.png)

2. 池子为基础的分配器： Pool Allocators
 
 * 预先申请一块大的内容，将元素放在一个链表结构上。
 * 初始时池子里链表空闲位是满的，当使用一个时，获取最后一个空闲位。当使用完成时，将其放回链表。分配和释放都是O(1)的消耗。
 * 链表设计时应注意使用指针指向 下一个空闲的内存块，而不是预先申请一个大的内存。





