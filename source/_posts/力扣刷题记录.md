---
title: 力扣刷题记录
categories:
- 算法
---
## 1. 两数之和
* 1. Two Sum

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

>示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

```c++
 vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        map<int, int> numsMap;
        
        for (int i = 0; i < nums.size(); i++)
        {
            int left = target - nums[i];

            if (numsMap.count(left) > 0) {
                result.push_back(numsMap[left]);
                result.push_back(i);
                break;
            }
            numsMap[nums[i]] = i;
        }

        return result;
    }
```

## 2.两数相加
* 2. Add Two Numbers
 
 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/add-two-numbers
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

>示例：
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

``` c++
 ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode(-1);//存放结果的链表
        ListNode* h = head;//移动指针
        int sum = 0;//每个位的加和结果
        bool carry = false;//进位标志
        while (l1 != NULL || l2 != NULL)
        {
            sum = 0;
            if (l1 != NULL)
            {
                sum += l1->val;
                l1 = l1->next;
            }
            if (l2 != NULL)
            {
                sum += l2->val;
                l2 = l2->next;
            }
            if (carry)
                sum++;
            h->next = new ListNode(sum % 10);
            h = h->next;
            carry = sum >= 10 ? true : false;
        }
        if (carry)
        {
            h->next = new ListNode(1);
        }
        ListNode* ptrDelete = head;
        head = head->next;
        delete ptrDelete;

        return head;
    }
```

## 3.无重复字符的最长子串
 * 3. Longest Substring Without Repeating Characters
   
 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

>示例 1:
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

>输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

>输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

``` c++
int lengthOfLongestSubstring(string s) {
        map<char, int> posMap;
        int ans = 0;
        int start = 0;
        int end = 0;

        while (end < s.length()) {
            char cur = s[end];
            if (posMap.count(cur) > 0) {
                start = max(posMap[cur],start);
            }
            ans = max(end - start + 1, ans);
            posMap[cur] = end + 1;
            end += 1;
        }

        return ans;
    }
```

## 4. 寻找两个正序数组的中位数
* 4. Median of Two Sorted Arrays
  
 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。
进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？


>示例 1：
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
示例 3：
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
示例 4：
输入：nums1 = [], nums2 = [1]
输出：1.00000
示例 5：
输入：nums1 = [2], nums2 = []
输出：2.00000

``` c++
int getKthElement(const vector<int>& nums1, const vector<int>& nums2, int k) {
        int m = nums1.size();
        int n = nums2.size();
        int index1 = 0, index2 = 0;

        while (true) {
            //处理边界
            if (index1 == m)
                return nums2[index2 + k -1];

            if (index2 == n)
                return nums1[index1 + k - 1];

            if (k == 1)
                return min(nums1[index1], nums2[index2]);

            //* 正式处理，查找两个二序列表中第K大的数 *//

            //拿出两个数组 k/2 -1位的数
            int nIndex1 = min(index1 + k / 2 - 1, m-1);
            int nIndex2 = min(index2 + k / 2 - 1,n-1);

            //数组二大！数组一的[0]-[k/2-1]被移去算法范围
            if (nums1[nIndex1] <= nums2[nIndex2]) {
                k -= nIndex1 + 1 - index1;//个数已经比较完，继续剩下的数的比较
                index1 = nIndex1 + 1;
            }
            else{//相关
                k -= nIndex2 + 1 - index2;//个数已经比较完，继续剩下的数的比较
                index2 = nIndex2 + 1;
            }
        }
    }
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int total = nums1.size() + nums2.size();

        if (total % 2 == 1) {
            //奇数个
            return getKthElement(nums1, nums2, (total+1) / 2);
        }
        else {
            //偶数个
            return (getKthElement(nums1, nums2, (total / 2)) + getKthElement(nums1, nums2, total/2 +1)) / 2.0;
        }
    }
```


## 26.删除排序数组中的重复项
* 26. Remove Duplicates from Sorted Array
 
 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

>示例 1:
给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。

>示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。

``` c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() ==0) return 0;
        int thumb = 0;
        
        for(int i = 1;i < nums.size(); i++){
            if(nums[i] != nums[thumb]){
                thumb ++;
                nums[thumb] = nums[i];
            }
        }
        return thumb+1;
    }
};
```

## 27. 移除元素
* 27. Remove Element

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-element
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

>示例 1:
给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。

>示例 2:
给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。

``` c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int thumb = 0;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] != val){
                nums[thumb] = nums[i];
                thumb ++;
            }
        }
        return thumb;
    }
};
```

## 28. 实现 strStr()
* 28. Implement strStr()

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/implement-strstr
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

>示例 1:
输入: haystack = "hello", needle = "ll"
输出: 2

>示例 2:
输入: haystack = "aaaaa", needle = "bba"
输出: -1

``` python
class Solution:
    def strStr(self, source: str, target: str) -> int:
        if source == target:
            return 0

        source_len = len(source)
        target_len = len(target)

        if target_len > source_len:
            return -1

        for i in range(source_len):
            target_index = i + target_len
            if target_index > source_len:
                continue
            if source[i:target_index] == target:
                return i

        return -1
```

## 29. 两数相除
* 29. Divide Two Integers

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/divide-two-integers
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
返回被除数 dividend 除以除数 divisor 得到的商。
整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

 
>示例 1:
输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = truncate(3.33333..) = truncate(3) = 3

>示例 2:
输入: dividend = 7, divisor = -3
输出: -2
解释: 7/-3 = truncate(-2.33333..) = -2
 

>提示：
被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。

``` python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        abs_dividend = abs(dividend)
        abs_divisor = abs(divisor)
        if abs_dividend < abs_divisor:
            return 0

        is_neg = 0
        if abs(dividend + divisor) != abs_dividend + abs_divisor:
            is_neg = 1
        ans = 0

        for i in range(31, -1, -1):
            print('abs_dividend >> %d : %d, %d, '% (i, abs_dividend >> i, abs_divisor))

            if abs_dividend >> i >= abs_divisor:
                ans += 1 << i
                abs_dividend -= abs_divisor << i
                print('good value: %d, %d'%(ans, abs_dividend))

        if is_neg and ans >= 2 ** 31:
            return -2 ** 31
        elif ans >= 2 ** 31:
            return 2 ** 31 - 1
        elif is_neg:
            return -ans
        else:
            return ans
```

## 30. 串联所有单词的子串
* 30. Substring with Concatenation of All Words

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。


>示例 1：
输入：
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。

>示例 2：
输入：
  s = "wordgoodgoodgoodbestword",
  words = ["word","good","best","word"]
输出：[]

``` python
class Solution(object):
    def findSubstring(self, s, words):
        from collections import Counter
        if not s or not words:return []
        one_word = len(words[0])
        all_len = len(words) * one_word
        n = len(s)
        words = Counter(words)
        res = []
        for i in range(0, n - all_len + 1):
            tmp = s[i:i+all_len]
            c_tmp = []
            for j in range(0, all_len, one_word):
                c_tmp.append(tmp[j:j+one_word])
            if Counter(c_tmp) == words:
                res.append(i)
        return res
```


## 41. 缺失的第一个正数
* 41. First Missing Positive
 
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/first-missing-positive
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

>示例 1:
输入: [1,2,0]
输出: 3

>示例 2:
输入: [3,4,-1,1]
输出: 2

>示例 3:
输入: [7,8,9,11,12]
输出: 1
 

>提示：
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。

``` c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
         // 总长
        int n = nums.size();
        // 1. 全部元素没有1，返回1
        bool noOne = true;
        for(int i = 0; i < nums.size();i++){
            if(nums[i] == 1)
            {
                noOne = false;
                break;
            }
        }
        if(noOne){
            return 1;
        }

        //2. 只有一个元素，且为[1]，则返回2
        if(n == 1)
        {
            return 2;
        }

        //3. 去<= 0与 > 总数的数，将其设为1
        for(int i = 0; i < n;i++){
            if(i == n-1){
                cout << nums[i] << endl;
            }
            if(nums[i] < 1 || nums[i] > n){
                nums[i] = 1;
            }
        }
  

        //4.遍历，当值 == 总数。第一个值设为负数. 当值 <= 总数，以值为下标设置为负值. 特别的，当值为总数时，将第一个值为负值！
         for(int i = 0; i < n; i++){
             int a = abs(nums[i]);
             if(a == n){
                 nums[0] = - abs(nums[0]);
             }else{
                nums[a] = - abs(nums[a]);
             }
         }

        for(int v: nums){
            cout << v << ",";
        }
        cout << endl;

        //5.遍历最新的数组中，发现有大于0，此索引就是丢失的最小正数
        for(int i = 1; i < n;i++){
            if(nums[i] > 0){
                return i;
            }
        }

        //6.5如果没有找到，第一值取出来如果是正数，则数为正数N
        if(nums[0] > 0){
            return n;
        }

        //7.如果以上走完了，返回n+1
        return n+1;
    }
};
```

## 80. 删除排序数组中的重复项 II
* 80. Remove Duplicates from Sorted Array II

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

>示例 1:
给定 nums = [1,1,1,2,2,3],
函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。
你不需要考虑数组中超出新长度后面的元素。

>示例 2:
给定 nums = [0,0,1,1,1,1,2,3,3],
函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。
你不需要考虑数组中超出新长度后面的元素。

>说明:
为什么返回数值是整数，但输出的答案是数组呢?

``` c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
      int i = 0;
        for (int n : nums) {
            if (i < 2 || n > nums[i-2]) nums[i++] = n;
        }
        return i;
    }
};
```

## 189. 旋转数组
* 189. Rotate Array

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rotate-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

>示例 1:
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

>示例 2:
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]

>说明:
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。

``` c++
class Solution {
public:
    void reverse(vector<int>& nums, int start, int end){
        for(int i = start,j = end; i < j; i++,j--){
            int ftmp = nums[j];
            nums[j] = nums[i];
            nums[i] = ftmp;
        }
    }

    void rotate(vector<int>& nums, int k) {
        if(k > nums.size()){
            k %= nums.size();
        }
        
        reverse(nums, 0, nums.size()-k-1);
        reverse(nums, nums.size()-k, nums.size()-1);
        reverse(nums, 0, nums.size()-1);
    }
};

```

## 299. 猜数字游戏
* 299. Bulls and Cows

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/bulls-and-cows
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：
你写出一个秘密数字，并请朋友猜这个数字是多少。
朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。
朋友根据提示继续猜，直到猜出秘密数字。
请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。

>xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。
>yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。
请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。

 

>示例 1:
输入: secret = "1807", guess = "7810"
输出: "1A3B"
解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。

>示例 2:
输入: secret = "1123", guess = "0111"
输出: "1A1B"
解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。

>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等

``` c++
class Solution {
public:
    string getHint(string secret, string guess) {
        int bulls = 0;
        int cows = 0;
        int ds[10]{0};
        int dg[10]{0};
        for(int i = 0; i < secret.size(); i++){
            int x = secret[i] - '0';
            int y = guess[i] - '0';
            if(secret[i] == guess[i]){
                bulls ++;    
            }
            ds[x] ++;
            dg[y] ++;
        }

        //算出相同元素总数，当然减掉之前算好的cows
        for(int i = 0;i < 10;i++){
            cows += min(ds[i],dg[i]);
        }
        cows -= bulls;
        ostringstream oss;
        oss << bulls << "A" << cows << "B" ;
        return oss.str();
    }

};  
```

## 51. N皇后 & 52. N皇后 II
* 51. N-Queens
* 52. N-Queens II
 
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/n-queens
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

![8皇后的一种解法](/img/1601178139148.png)

>51. 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。
每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
>52. 给定一个整数 n，返回 n 皇后不同的解决方案的数量。


``` python
class NQueen:
    def __init__(self):
        self.count = 0

    def do_nqueen(self, n):
        empty_sign = "[O]"
        queen_sign = "[1]"
        # 所有数组起点都以0开始

        # 1.定义所有解的容器，二维数组，第二维代表一个完整的解
        ans = []

        # 2.递归函数dfs
        def dfs(nums, row):
            # 如果找的行数与n相等了，说明已经找完了，得到一个解！
            if row == n:
                ans.append(nums[:]) # 注意不可用ans.append(nums)
                return
            # 逐列进行尝试，列的总数为n
            for i in range(n):
                # 每进行到一列，标记当前行皇后位置为此列
                nums[row] = i
                # 往下递归找到，一直找到底，找不到底循环会返回到此处！
                if valid(nums, row):
                    # print("当前找到第%d行的第%d列，此值可放皇后！"%(row, i))
                    dfs(nums, row+1)
                else:
                    pass
                    # print("当前找到第%d行的第%d列，不可放，回溯"%(row, i))

        # 3.检查函数valid
        def valid(nums, row):
            # 只找前面行的点， 皇后攻击规则，同列同行 和 对角线元素表示
            for r in range(row):
                if abs(nums[r] - nums[row]) == abs(r - row) or nums[r] == nums[row]:
                    return False
            return True

        # 4.执行, 从第0行开始找n数组长度中的位置
        dfs([None for _ in range(n)], 0)

        def get_row_list(row_val, count):
            result = []
            for i in range(count):
                if i == row_val:
                    result.append(queen_sign)
                else:
                    result.append(empty_sign)
            return result


        # 5.结果画出来
        result = [[] for _ in range(len(ans))]
        for i in range(len(ans)):
            for col in ans[i]:
                result[i].append("".join(get_row_list(col, n)))

        return result


myqueen = NQueen()
result = myqueen.do_nqueen(4)
print("解有%d个"%len(result))
for r in result:
    r = str(r)
    print(r+"\n\n")
```
## 144. 二叉树的前序遍历
* 144. Binary Tree Preorder Traversal
  
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

>给定一个二叉树，返回它的 前序 遍历。

>示例:
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 
输出: [1,2,3]

``` c++
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        if(root == NULL)
            return result;
        
        stack<TreeNode> ss;
        ss.push(*root);
        
        while(!ss.empty()){
            TreeNode cur = ss.top();
            ss.pop();

            result.push_back(cur.val);

            if(cur.right != NULL){
                ss.push(*cur.right);
            }
            if(cur.left != NULL){
                ss.push(*cur.left);
            }
        }
        return result;
    }
```






