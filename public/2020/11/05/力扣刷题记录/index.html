<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>力扣刷题记录 | Avery的城堡</title>
  <meta name="keywords" content>
  <meta name="description" content="力扣刷题记录 | Avery的城堡">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="这是关于我，有空再加吧">
<meta name="keywords" content="Learn+Study">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http://www.hjp.wiki/about/index.html">
<meta property="og:site_name" content="Avery的城堡">
<meta property="og:description" content="这是关于我，有空再加吧">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-09-08T03:23:20.891Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="about">
<meta name="twitter:description" content="这是关于我，有空再加吧">


<link rel="icon" href="/img/my.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0"></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="/js/iconfont.js?v=1.1.0"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="true">
  <input class="theme_blog_path" value>
  <input id="theme_shortcut" value="true">
  <input id="theme_highlight_on" value="true">
  <input id="theme_code_copy" value="true">
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/my.jpeg" />
</a>
<div class="author">
    <span>霍家鹏</span>
</div>

<div class="icon">
    
        
    
        
        <a title="github" href="https://github.com/AveryHuo" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        <a title="jianshu" href="https://www.jianshu.com/u/96df2dd41ded" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-jianshu"></use>
                </svg>
            
        </a>
        
    
        
        <a title="zhihu" href="https://www.zhihu.com/people/alvinxiao-peng" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-zhihu"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="oschina" href="https://my.oschina.net/u/138823" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-oschina"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="email" href="mailto:1024037035@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1024037035&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
</div>




<ul>
    <li><div class="all active" data-rel="All">All<small>(84)</small></div></li>
    
        
            
            <li><div data-rel="IT阅读">IT阅读<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Unity">Unity<small>(18)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据结构">数据结构<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数学">数学<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法">算法<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="图形学">图形学<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="CPlusPlus">CPlusPlus<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Python">Python<small>(20)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="Unity学习">Unity学习<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="英语学习">英语学习<small>(9)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="杂项资料">杂项资料<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="公司">公司<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工作相关">工作相关<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="UE">UE<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">About</a><a style="width: 50%"  class="friends">Friends</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="84">
<input type="hidden" id="yelog_site_word_count" value="107.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>实例</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图形学</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>指令</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C++</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CI</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Conda</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Core Programming</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Django</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>English</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Game</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Jenkins</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Note</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Python</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>UE</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unity学习</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All UE "
           href="/2022/04/09/UE5初入/"
           data-tag="Note,UE"
           data-author="" >
            <span class="post-title" title="UE5初入">UE5初入</span>
            <span class="post-date" title="2022-04-09 18:40:13">2022/04/09</span>
        </a>
        
        <a  class="All Python "
           href="/2022/04/09/python_5/"
           data-tag="Python,Note"
           data-author="" >
            <span class="post-title" title="Python Note 5">Python Note 5</span>
            <span class="post-date" title="2022-04-09 18:23:31">2022/04/09</span>
        </a>
        
        <a  class="All Python "
           href="/2021/08/01/Python源码剖析-Note2/"
           data-tag="Python,Note"
           data-author="" >
            <span class="post-title" title="Python源码剖析-Note2">Python源码剖析-Note2</span>
            <span class="post-date" title="2021-08-01 17:43:43">2021/08/01</span>
        </a>
        
        <a  class="All Python "
           href="/2021/06/04/Python源码剖析-Note1/"
           data-tag="Python,Note"
           data-author="" >
            <span class="post-title" title="Python源码剖析-Note1">Python源码剖析-Note1</span>
            <span class="post-date" title="2021-06-04 11:22:22">2021/06/04</span>
        </a>
        
        <a  class="All Python "
           href="/2021/02/26/Python知识汇总1/"
           data-tag="Python,Note"
           data-author="" >
            <span class="post-title" title="Python知识汇总1">Python知识汇总1</span>
            <span class="post-date" title="2021-02-26 11:56:02">2021/02/26</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/26/贝塞尔曲线/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="贝塞尔曲线">贝塞尔曲线</span>
            <span class="post-date" title="2020-12-26 17:16:48">2020/12/26</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/26/CSHARP的内置引用类型/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CSHARP的内置引用类型">CSHARP的内置引用类型</span>
            <span class="post-date" title="2020-12-26 17:16:48">2020/12/26</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/26/LUA与CSHARP交互/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LUA与CSHARP交互">LUA与CSHARP交互</span>
            <span class="post-date" title="2020-12-26 17:16:48">2020/12/26</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/23/CSHARP的GC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CSHARP的GC">CSHARP的GC</span>
            <span class="post-date" title="2020-12-23 14:46:38">2020/12/23</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/23/CSHARP的编译器/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CSHARP的编译器">CSHARP的编译器</span>
            <span class="post-date" title="2020-12-23 14:46:38">2020/12/23</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/23/CSHARP的Dictionary/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CSHARP的Dictionary">CSHARP的Dictionary</span>
            <span class="post-date" title="2020-12-23 14:46:38">2020/12/23</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/23/Lua源码研究/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Lua源码研究">Lua源码研究</span>
            <span class="post-date" title="2020-12-23 11:45:06">2020/12/23</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/23/Lua源码编译流程/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Lua源码编译流程">Lua源码编译流程</span>
            <span class="post-date" title="2020-12-23 11:45:06">2020/12/23</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/22/基于物理的渲染-PBR/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基于物理的渲染-PBR">基于物理的渲染-PBR</span>
            <span class="post-date" title="2020-12-22 12:22:00">2020/12/22</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/18/骨骼蒙皮动画(SkinnedMesh)的原理解析/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="骨骼蒙皮动画(SkinnedMesh)的原理解析">骨骼蒙皮动画(SkinnedMesh)的原理解析</span>
            <span class="post-date" title="2020-12-18 12:25:18">2020/12/18</span>
        </a>
        
        <a  class="All Unity学习 "
           href="/2020/12/18/ECSSamples研究/"
           data-tag="Unity学习"
           data-author="" >
            <span class="post-title" title="ECSSamples研究">ECSSamples研究</span>
            <span class="post-date" title="2020-12-18 12:25:18">2020/12/18</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/12/18/Unity内存剖析/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Unity内存剖析">Unity内存剖析</span>
            <span class="post-date" title="2020-12-18 12:25:18">2020/12/18</span>
        </a>
        
        <a  class="All Unity学习 "
           href="/2020/11/18/腾讯云开发-使用Unity开发服务器逻辑并自动部署/"
           data-tag="Unity学习"
           data-author="" >
            <span class="post-title" title="腾讯云开发-使用Unity开发服务器逻辑并自动部署">腾讯云开发-使用Unity开发服务器逻辑并自动部署</span>
            <span class="post-date" title="2020-11-18 21:32:05">2020/11/18</span>
        </a>
        
        <a  class="All Unity学习 "
           href="/2020/11/18/Playable动画系统研究/"
           data-tag="Unity学习"
           data-author="" >
            <span class="post-title" title="Playable动画系统研究">Playable动画系统研究</span>
            <span class="post-date" title="2020-11-18 18:30:28">2020/11/18</span>
        </a>
        
        <a  class="All 算法 "
           href="/2020/11/05/力扣刷题记录/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="力扣刷题记录">力扣刷题记录</span>
            <span class="post-date" title="2020-11-05 20:26:18">2020/11/05</span>
        </a>
        
        <a  class="All IT阅读 "
           href="/2020/10/15/GEA-P4/"
           data-tag="Game"
           data-author="" >
            <span class="post-title" title="GEA-P4">GEA-P4</span>
            <span class="post-date" title="2020-10-15 20:46:56">2020/10/15</span>
        </a>
        
        <a  class="All IT阅读 "
           href="/2020/10/15/GEA-P3/"
           data-tag="Game"
           data-author="" >
            <span class="post-title" title="GEA-P3">GEA-P3</span>
            <span class="post-date" title="2020-10-15 20:46:56">2020/10/15</span>
        </a>
        
        <a  class="All IT阅读 "
           href="/2020/10/15/GEA-P2/"
           data-tag="Game"
           data-author="" >
            <span class="post-title" title="GEA-P2">GEA-P2</span>
            <span class="post-date" title="2020-10-15 20:46:56">2020/10/15</span>
        </a>
        
        <a  class="All 图形学 "
           href="/2020/09/27/计算机图形学编程笔记2/"
           data-tag="图形学"
           data-author="" >
            <span class="post-title" title="计算机图形学编程笔记2">计算机图形学编程笔记2</span>
            <span class="post-date" title="2020-09-27 18:19:22">2020/09/27</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/27/Python 杂项/"
           data-tag="Python,Note"
           data-author="" >
            <span class="post-title" title="Python 杂项">Python 杂项</span>
            <span class="post-date" title="2020-09-27 12:18:01">2020/09/27</span>
        </a>
        
        <a  class="All 工作相关 "
           href="/2020/09/22/Addressable打包流程/"
           data-tag="CI"
           data-author="" >
            <span class="post-title" title="Addressable打包流程">Addressable打包流程</span>
            <span class="post-date" title="2020-09-22 21:20:32">2020/09/22</span>
        </a>
        
        <a  class="All IT阅读 "
           href="/2020/09/09/IT-English/"
           data-tag="Game,English"
           data-author="" >
            <span class="post-title" title="Game Engine Architecture - English">Game Engine Architecture - English</span>
            <span class="post-date" title="2020-09-09 10:46:51">2020/09/09</span>
        </a>
        
        <a  class="All IT阅读 "
           href="/2020/09/09/GEA-P1/"
           data-tag="Game"
           data-author="" >
            <span class="post-title" title="GEA-P1">GEA-P1</span>
            <span class="post-date" title="2020-09-09 10:46:51">2020/09/09</span>
        </a>
        
        <a  class="All Unity学习 "
           href="/2020/09/08/Addressable 研究/"
           data-tag="Unity学习"
           data-author="" >
            <span class="post-title" title="Addressable 研究">Addressable 研究</span>
            <span class="post-date" title="2020-09-08 14:59:26">2020/09/08</span>
        </a>
        
        <a  class="All 数据结构 "
           href="/2020/09/08/数据结构-数组链表结构/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构-数组,链表结构">数据结构-数组,链表结构</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 数据结构 "
           href="/2020/09/08/排序算法/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="排序算法">排序算法</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/09/08/性能优化相关/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="性能优化相关">性能优化相关</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 公司 "
           href="/2020/09/08/最新Addressable资源打包与加载框架/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="最新Addressable资源打包与加载框架">最新Addressable资源打包与加载框架</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 数据结构 "
           href="/2020/09/08/数据结构-笔记1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构-图">数据结构-图</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/09/08/数据结构在Charp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构在C#">数据结构在C#</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 算法 "
           href="/2020/09/08/深度优先与广度优先算法/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度优先与广度优先算法">深度优先与广度优先算法</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 图形学 "
           href="/2020/09/08/计算机图形学编程笔记1/"
           data-tag="图形学"
           data-author="" >
            <span class="post-title" title="计算机图形学编程笔记1">计算机图形学编程笔记1</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 算法 "
           href="/2020/09/08/算法课程笔记1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Coursera算法课笔记1">Coursera算法课笔记1</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 数学 "
           href="/2020/09/08/线性代数-笔记1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性代数-笔记1">线性代数-笔记1</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 数据结构 "
           href="/2020/09/08/递归算法/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="递归算法">递归算法</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 公司 "
           href="/2020/09/08/客户端更换Git指南/"
           data-tag="Git"
           data-author="" >
            <span class="post-title" title="客户端更换Git指南">客户端更换Git指南</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/天天生鲜项目实例/"
           data-tag="Python,Note,Django,实例"
           data-author="" >
            <span class="post-title" title="天天生鲜项目实例P1">天天生鲜项目实例P1</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/天天生鲜项目实例P2/"
           data-tag="Python,Note,Django,实例"
           data-author="" >
            <span class="post-title" title="天天生鲜项目实例P2">天天生鲜项目实例P2</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 英语学习 "
           href="/2020/09/08/开言_Bargaining in the market/"
           data-tag="Note,English"
           data-author="" >
            <span class="post-title" title="开言_Bargaining in the market">开言_Bargaining in the market</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 英语学习 "
           href="/2020/09/08/开言_Happy Hour Drinks with Coworks/"
           data-tag="Note,English"
           data-author="" >
            <span class="post-title" title="开言_Happy Hour Drinks with Coworks">开言_Happy Hour Drinks with Coworks</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 英语学习 "
           href="/2020/09/08/开言- To tip or not to tip/"
           data-tag="Note,English"
           data-author="" >
            <span class="post-title" title="开言">开言</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 英语学习 "
           href="/2020/09/08/常用单词学习/"
           data-tag="Note,English"
           data-author="" >
            <span class="post-title" title="常用单词学习">常用单词学习</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 英语学习 "
           href="/2020/09/08/开言体验营 - Day1/"
           data-tag="Note,English"
           data-author="" >
            <span class="post-title" title="开言体验营 - Day1">开言体验营 - Day1</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 英语学习 "
           href="/2020/09/08/开言体验营 - Day4/"
           data-tag="Note,English"
           data-author="" >
            <span class="post-title" title="开言体验营 - Day4">开言体验营 - Day4</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 英语学习 "
           href="/2020/09/08/开言体验营 - Day2/"
           data-tag="Note,English"
           data-author="" >
            <span class="post-title" title="开言体验营 - Day2">开言体验营 - Day2</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 英语学习 "
           href="/2020/09/08/开言体验营 - Day5/"
           data-tag="Note,English"
           data-author="" >
            <span class="post-title" title="开言体验营 - Day5">开言体验营 - Day5</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 英语学习 "
           href="/2020/09/08/开言学习笔记1/"
           data-tag="Note,English"
           data-author="" >
            <span class="post-title" title="开言学习笔记1">开言学习笔记1</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/python_2/"
           data-tag="Python,Note"
           data-author="" >
            <span class="post-title" title="Python Note 2">Python Note 2</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/python_1/"
           data-tag="Python,Note"
           data-author="" >
            <span class="post-title" title="Python Note 1">Python Note 1</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 算法 "
           href="/2020/09/08/动态规划/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态规划">动态规划</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity学习 "
           href="/2020/09/08/内存管理/"
           data-tag="Unity学习"
           data-author="" >
            <span class="post-title" title="内存管理">内存管理</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 算法 "
           href="/2020/09/08/力扣刷题顺序/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="力扣刷题顺序">力扣刷题顺序</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/python_4/"
           data-tag="Python,Note"
           data-author="" >
            <span class="post-title" title="Python Note 4">Python Note 4</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity学习 "
           href="/2020/09/08/四元数旋转函数学习/"
           data-tag="Unity学习"
           data-author="" >
            <span class="post-title" title="四元数旋转函数学习">四元数旋转函数学习</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 公司 "
           href="/2020/09/08/UI系统制作流程/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UI系统制作流程">UI系统制作流程</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Twisted  介绍/"
           data-tag="Python,Note,Core Programming"
           data-author="" >
            <span class="post-title" title="Twisted  介绍">Twisted  介绍</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 杂项资料 "
           href="/2020/09/08/VS Code最佳插件/"
           data-tag="Note"
           data-author="" >
            <span class="post-title" title="VS Code最佳插件">VS Code最佳插件</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All "
           href="/2020/09/08/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity学习 "
           href="/2020/09/08/LWRP官方说明/"
           data-tag="Unity学习"
           data-author="" >
            <span class="post-title" title="LWRP官方说明">LWRP官方说明</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All "
           href="/2020/09/08/Linux与window常用指令/"
           data-tag="linux,指令"
           data-author="" >
            <span class="post-title" title="Linux与window常用指令">Linux与window常用指令</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Python Core Programming Note 1/"
           data-tag="Python,Note,Core Programming"
           data-author="" >
            <span class="post-title" title="Python Core Programming Note 1">Python Core Programming Note 1</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 工作相关 "
           href="/2020/09/08/Jenkins打包事项/"
           data-tag="CI,Jenkins"
           data-author="" >
            <span class="post-title" title="Jenkins打包事项">Jenkins打包事项</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Python Core Programming Note 3/"
           data-tag="Python,Note,Core Programming"
           data-author="" >
            <span class="post-title" title="Python Core Programming Note 3">Python Core Programming Note 3</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Python Core Programming Note 2/"
           data-tag="Python,Note,Core Programming"
           data-author="" >
            <span class="post-title" title="Python Core Programming Note 2">Python Core Programming Note 2</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Python_3/"
           data-tag="Python,Note"
           data-author="" >
            <span class="post-title" title="Python Note 3">Python Note 3</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All 公司 "
           href="/2020/09/08/Smargit  简单使用说明/"
           data-tag="Git"
           data-author="" >
            <span class="post-title" title="Smargit  简单使用说明">Smargit  简单使用说明</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/09/08/Shader Variant/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shader Variant">Shader Variant</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All CPlusPlus "
           href="/2020/09/08/C++ 复习1/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++ 复习1">C++ 复习1</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/09/08/DOTS-事件/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DOTS-事件">DOTS-事件</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Centos 部署 Django/"
           data-tag="Python,Note,Django"
           data-author="" >
            <span class="post-title" title="Centos 部署 Django">Centos 部署 Django</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All CPlusPlus "
           href="/2020/09/08/C与C++开源项目学习/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C与C++开源项目学习">C与C++开源项目学习</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Conda 常用操作/"
           data-tag="Python,Note,Django,Conda"
           data-author="" >
            <span class="post-title" title="Conda 常用操作">Conda 常用操作</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/09/08/DrawCall优化/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="网络游戏同步方案">网络游戏同步方案</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Django 实例 Web Application/"
           data-tag="Python,Note,Django,实例"
           data-author="" >
            <span class="post-title" title="Django 实例 Web Application">Django 实例 Web Application</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Django  初步构建/"
           data-tag="Python,Note,Django"
           data-author="" >
            <span class="post-title" title="Django  初步构建">Django  初步构建</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Python "
           href="/2020/09/08/Django  初始测试/"
           data-tag="Python,Note,Django"
           data-author="" >
            <span class="post-title" title="Django  初始测试">Django  初始测试</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/09/08/ECS框架的思考/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ECS框架的思考">ECS框架的思考</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All Unity "
           href="/2020/09/08/ECS-研究学习/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DOTS-研究学习">DOTS-研究学习</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <a  class="All CPlusPlus "
           href="/2020/09/08/Effective C++学习记录/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="Effective C++学习记录">Effective C++学习记录</span>
            <span class="post-date" title="2020-09-08 11:23:20">2020/09/08</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-力扣刷题记录" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">力扣刷题记录</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2020-11-05 20:26:18'>2020-11-05 20:26</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:13.3k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两数之和"><span class="toc-text">1. 两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-两数相加"><span class="toc-text">2.两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-无重复字符的最长子串"><span class="toc-text">3.无重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-寻找两个正序数组的中位数"><span class="toc-text">4. 寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-最长回文子串"><span class="toc-text">5. 最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Z-字形变换"><span class="toc-text">6.Z 字形变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-整数反转"><span class="toc-text">7. 整数反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-字符串转换整数-atoi"><span class="toc-text">8. 字符串转换整数 (atoi)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-回文数"><span class="toc-text">9.回文数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-正则表达式匹配"><span class="toc-text">10. 正则表达式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-盛最多水的容器"><span class="toc-text">11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-电话号码的字母组合"><span class="toc-text">17. 电话号码的字母组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-三数之和"><span class="toc-text">15.三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-删除链表的倒数第N个节点"><span class="toc-text">19.删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-有效的括号"><span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-括号生成"><span class="toc-text">22. 括号生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-删除排序数组中的重复项"><span class="toc-text">26.删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-移除元素"><span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-实现-strStr"><span class="toc-text">28. 实现 strStr()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-两数相除"><span class="toc-text">29. 两数相除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-串联所有单词的子串"><span class="toc-text">30. 串联所有单词的子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-缺失的第一个正数"><span class="toc-text">41. 缺失的第一个正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-接雨水"><span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N皇后-amp-52-N皇后-II"><span class="toc-text">51. N皇后 &amp; 52. N皇后 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-颜色分类"><span class="toc-text">75. 颜色分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-最小覆盖子串"><span class="toc-text">76.最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80-删除排序数组中的重复项-II"><span class="toc-text">80. 删除排序数组中的重复项 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#127-单词接龙"><span class="toc-text">127. 单词接龙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#129-求根到叶子节点数字之和"><span class="toc-text">129.求根到叶子节点数字之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-环形链表"><span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-环形链表-II"><span class="toc-text">142. 环形链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-二叉树的前序遍历"><span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-旋转数组"><span class="toc-text">189. 旋转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-回文链表"><span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-移动零"><span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#287-寻找重复数"><span class="toc-text">287. 寻找重复数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#299-猜数字游戏"><span class="toc-text">299. 猜数字游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#463-岛屿的周长"><span class="toc-text">463. 岛屿的周长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1207-独一无二的出现次数"><span class="toc-text">1207.独一无二的出现次数</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两数之和"><span class="toc-text">1. 两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-两数相加"><span class="toc-text">2.两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-无重复字符的最长子串"><span class="toc-text">3.无重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-寻找两个正序数组的中位数"><span class="toc-text">4. 寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-最长回文子串"><span class="toc-text">5. 最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Z-字形变换"><span class="toc-text">6.Z 字形变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-整数反转"><span class="toc-text">7. 整数反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-字符串转换整数-atoi"><span class="toc-text">8. 字符串转换整数 (atoi)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-回文数"><span class="toc-text">9.回文数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-正则表达式匹配"><span class="toc-text">10. 正则表达式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-盛最多水的容器"><span class="toc-text">11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-电话号码的字母组合"><span class="toc-text">17. 电话号码的字母组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-三数之和"><span class="toc-text">15.三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-删除链表的倒数第N个节点"><span class="toc-text">19.删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-有效的括号"><span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-括号生成"><span class="toc-text">22. 括号生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-删除排序数组中的重复项"><span class="toc-text">26.删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-移除元素"><span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-实现-strStr"><span class="toc-text">28. 实现 strStr()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-两数相除"><span class="toc-text">29. 两数相除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-串联所有单词的子串"><span class="toc-text">30. 串联所有单词的子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-缺失的第一个正数"><span class="toc-text">41. 缺失的第一个正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-接雨水"><span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N皇后-amp-52-N皇后-II"><span class="toc-text">51. N皇后 &amp; 52. N皇后 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-颜色分类"><span class="toc-text">75. 颜色分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-最小覆盖子串"><span class="toc-text">76.最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80-删除排序数组中的重复项-II"><span class="toc-text">80. 删除排序数组中的重复项 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#127-单词接龙"><span class="toc-text">127. 单词接龙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#129-求根到叶子节点数字之和"><span class="toc-text">129.求根到叶子节点数字之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-环形链表"><span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-环形链表-II"><span class="toc-text">142. 环形链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-二叉树的前序遍历"><span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-旋转数组"><span class="toc-text">189. 旋转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-回文链表"><span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-移动零"><span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#287-寻找重复数"><span class="toc-text">287. 寻找重复数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#299-猜数字游戏"><span class="toc-text">299. 猜数字游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#463-岛屿的周长"><span class="toc-text">463. 岛屿的周长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1207-独一无二的出现次数"><span class="toc-text">1207.独一无二的出现次数</span></a></li></ol></div></p>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><ul>
<li><ol>
<li>Two Sum</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
</blockquote>
<blockquote>
<p>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<pre><code class="c++"> vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; result;
        map&lt;int, int&gt; numsMap;

        for (int i = 0; i &lt; nums.size(); i++)
        {
            int left = target - nums[i];

            if (numsMap.count(left) &gt; 0) {
                result.push_back(numsMap[left]);
                result.push_back(i);
                break;
            }
            numsMap[nums[i]] = i;
        }

        return result;
    }</code></pre>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><ul>
<li><ol start="2">
<li>Add Two Numbers</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</li>
</ul>
<blockquote>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<blockquote>
<p>示例：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<pre><code class="c++"> ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode(-1);//存放结果的链表
        ListNode* h = head;//移动指针
        int sum = 0;//每个位的加和结果
        bool carry = false;//进位标志
        while (l1 != NULL || l2 != NULL)
        {
            sum = 0;
            if (l1 != NULL)
            {
                sum += l1-&gt;val;
                l1 = l1-&gt;next;
            }
            if (l2 != NULL)
            {
                sum += l2-&gt;val;
                l2 = l2-&gt;next;
            }
            if (carry)
                sum++;
            h-&gt;next = new ListNode(sum % 10);
            h = h-&gt;next;
            carry = sum &gt;= 10 ? true : false;
        }
        if (carry)
        {
            h-&gt;next = new ListNode(1);
        }
        ListNode* ptrDelete = head;
        head = head-&gt;next;
        delete ptrDelete;

        return head;
    }</code></pre>
<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><ul>
<li><ol start="3">
<li>Longest Substring Without Repeating Characters</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</li>
</ul>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
</blockquote>
<blockquote>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
</blockquote>
<blockquote>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<pre><code class="c++">int lengthOfLongestSubstring(string s) {
        map&lt;char, int&gt; posMap;
        int ans = 0;
        int start = 0;
        int end = 0;

        while (end &lt; s.length()) {
            char cur = s[end];
            if (posMap.count(cur) &gt; 0) {
                start = max(posMap[cur],start);
            }
            ans = max(end - start + 1, ans);
            posMap[cur] = end + 1;
            end += 1;
        }

        return ans;
    }</code></pre>
<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h2><ul>
<li><ol start="4">
<li>Median of Two Sorted Arrays</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</li>
</ul>
<blockquote>
<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>
</blockquote>
<blockquote>
<p>示例 1：<br>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：<br>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br>示例 3：<br>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000<br>示例 4：<br>输入：nums1 = [], nums2 = [1]<br>输出：1.00000<br>示例 5：<br>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p>
</blockquote>
<pre><code class="c++">int getKthElement(const vector&lt;int&gt;&amp; nums1, const vector&lt;int&gt;&amp; nums2, int k) {
        int m = nums1.size();
        int n = nums2.size();
        int index1 = 0, index2 = 0;

        while (true) {
            //处理边界
            if (index1 == m)
                return nums2[index2 + k -1];

            if (index2 == n)
                return nums1[index1 + k - 1];

            if (k == 1)
                return min(nums1[index1], nums2[index2]);

            //* 正式处理，查找两个二序列表中第K大的数 *//

            //拿出两个数组 k/2 -1位的数
            int nIndex1 = min(index1 + k / 2 - 1, m-1);
            int nIndex2 = min(index2 + k / 2 - 1,n-1);

            //数组二大！数组一的[0]-[k/2-1]被移去算法范围
            if (nums1[nIndex1] &lt;= nums2[nIndex2]) {
                k -= nIndex1 + 1 - index1;//个数已经比较完，继续剩下的数的比较
                index1 = nIndex1 + 1;
            }
            else{//相关
                k -= nIndex2 + 1 - index2;//个数已经比较完，继续剩下的数的比较
                index2 = nIndex2 + 1;
            }
        }
    }
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int total = nums1.size() + nums2.size();

        if (total % 2 == 1) {
            //奇数个
            return getKthElement(nums1, nums2, (total+1) / 2);
        }
        else {
            //偶数个
            return (getKthElement(nums1, nums2, (total / 2)) + getKthElement(nums1, nums2, total/2 +1)) / 2.0;
        }
    }</code></pre>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><ul>
<li><ol start="5">
<li>Longest Palindromic Substring</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p>
</blockquote>
<blockquote>
<p>暴力解法：</p>
</blockquote>
<pre><code class="c++">bool validatePalindrome(string s, int i, int j) {
    while (i &lt; j) {
        if (s[i] != s[j]) {
            return false;
        }
        i++;
        j--;
    }
    return true;
}
string QuestionHandler::longestPalindrome(string s) {

    if (s == &quot;&quot; || s.length() &lt; 2)
        return s;

    int begin = 0;
    int maxLen = 1;
    for (int i = 0; i &lt; s.length()-1; i++)
    {
        for (int j = i+1; j &lt; s.length(); j++)
        {
            if (((j - i + 1) &gt; maxLen) &amp;&amp; validatePalindrome(s, i, j)) {
                maxLen = (j - i + 1);
                begin = i;
            }
        }
    }
    return s.substr(begin, maxLen);
}</code></pre>
<blockquote>
<p>中心扩散法</p>
</blockquote>
<pre><code class="c++">int expandAroundCenter(string s, int left, int right) {
    int len = s.length();
    int i = left;
    int j = right;
    while (i &gt;= 0 &amp;&amp; j &lt; len) {
        if (s[i] == s[j]) {
            i--;
            j++;
        }
        else {
            break;
        }
    }

    return j - i +1 - 2;
}
string QuestionHandler::longestPalindrome(string s) {
    if (s == &quot;&quot; || s.length() &lt; 2)
        return s;

    int begin = 0;
    int maxLen = 1;
    for (int i = 0; i &lt; s.length() - 1; i++)
    {
        int oddLen = expandAroundCenter(s, i, i);
        int eveLen = expandAroundCenter(s, i, i+1);

        int curMaxLen = max(oddLen, eveLen);
        if (curMaxLen &gt; maxLen) {
            maxLen = curMaxLen;
            begin = i - (curMaxLen - 1) / 2;
        }
    }

    return s.substr(begin, maxLen);

}</code></pre>
<blockquote>
<p>动态规划</p>
</blockquote>
<pre><code class="c++">string QuestionHandler::longestPalindrome(string s) {
    if (s == &quot;&quot; || s.length() &lt; 2)
        return s;

    int len = s.length();
    int begin = 0;
    int maxLen = 1;
    vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));
    for (int j = 1; j &lt; len; j++) {
        for (int i = 0; i &lt; j; i++) {
            if (s[i] != s[j]) {
                dp[i][j] = 0;
            }
            else {
                if (j - i &lt; 3) {
                    dp[i][j] = 1;
                }
                else {
                    dp[i][j] = dp[i + 1][j - 1];
                }
            }

            if (dp[i][j] &amp;&amp; (j - i + 1) &gt; maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }

    return s.substr(begin, maxLen);
}</code></pre>
<p><img src="/img/1603943631534.png" alt="动态规划解法"></p>
<blockquote>
<p>Manacher算法 - O(n)</p>
</blockquote>
<pre><code class="c++">int expand(const string&amp; s, int left, int right) {
    while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) {
        --left;
        ++right;
    }
    return (right - left - 2) / 2;
}
string QuestionHandler::longestPalindrome(string s) {
    int start = 0, end = -1;
    string t = &quot;#&quot;;
    for (char c : s) {
        t += c;
        t += &#39;#&#39;;
    }
    t += &#39;#&#39;;
    s = t;

    vector&lt;int&gt; arm_len;
    int right = -1, j = -1;
    for (int i = 0; i &lt; s.size(); ++i) {
        int cur_arm_len;
        if (right &gt;= i) {
            int i_sym = j * 2 - i;
            int min_arm_len = min(arm_len[i_sym], right - i);
            cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);
        }
        else {
            cur_arm_len = expand(s, i, i);
        }
        arm_len.push_back(cur_arm_len);
        if (i + cur_arm_len &gt; right) {
            j = i;
            right = i + cur_arm_len;
        }
        if (cur_arm_len * 2 + 1 &gt; end - start) {
            start = i - cur_arm_len;
            end = i + cur_arm_len;
        }
    }

    string ans;
    for (int i = start; i &lt;= end; ++i) {
        if (s[i] != &#39;#&#39;) {
            ans += s[i];
        }
    }
    return ans;
}</code></pre>
<h2 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6.Z 字形变换"></a>6.Z 字形变换</h2><ul>
<li><ol start="6">
<li>ZigZag Conversion</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zigzag-conversion">https://leetcode-cn.com/problems/zigzag-conversion</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>L   C   I   R<br>E T O E S I I G<br>E   D   H   N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。<br>请你实现这个将字符串进行指定行数变换的函数：<br>string convert(string s, int numRows);<br>示例 1:<br>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”<br>示例 2:<br>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:<br>L     D     R<br>E   O E   I I<br>E C   I H   N<br>T     S     G</p>
</blockquote>
<pre><code class="c++">  string convert(string s, int numRows) {
        if (numRows == 1) return s;

        int rowIdx = 0;
        vector&lt;string&gt; rowStrs(numRows);
        bool goingDown = false;
        for (char c : s) {
            rowStrs[rowIdx] += c;
            if (rowIdx == 0 || rowIdx == numRows - 1) goingDown = !goingDown;
            rowIdx += goingDown ? 1 : -1;
        }

        string result;
        for (string row : rowStrs) result += row;
        return result;
    }</code></pre>
<h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><ul>
<li><ol start="7">
<li>Reverse Integer</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer">https://leetcode-cn.com/problems/reverse-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>示例 1:<br>输入: 123<br>输出: 321<br> 示例 2:<br>输入: -123<br>输出: -321<br>示例 3:<br>输入: 120<br>输出: 21</p>
</blockquote>
<pre><code class="c++">  int reverse(int x) {
         int ans = 0;
        while (x != 0) {
            if (ans &gt; 214748364 || ans &lt; -214748364) {
                return 0;
            }
            ans = ans*10 + x % 10;
            x /= 10;
        }

        return ans;
    }</code></pre>
<h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h2><ul>
<li><ol start="8">
<li>String to Integer (atoi)</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi">https://leetcode-cn.com/problems/string-to-integer-atoi</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br>提示：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>输入: “42”<br>输出: 42<br>示例 2:<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p>
</blockquote>
<pre><code class="c++">class Automaton {
    string state = &quot;start&quot;;
    unordered_map&lt;string, vector&lt;string&gt;&gt; table = {
        {&quot;start&quot;, {&quot;start&quot;, &quot;signed&quot;, &quot;in_number&quot;, &quot;end&quot;}},
        {&quot;signed&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;}},
        {&quot;in_number&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;in_number&quot;, &quot;end&quot;}},
        {&quot;end&quot;, {&quot;end&quot;, &quot;end&quot;, &quot;end&quot;, &quot;end&quot;}}
    };

    int get_col(char c) {
        if (isspace(c)) return 0;
        if (c == &#39;+&#39; or c == &#39;-&#39;) return 1;
        if (isdigit(c)) return 2;
        return 3;
    }
public:
    int sign = 1;
    long long ans = 0;

    void get(char c) {
        state = table[state][get_col(c)];
        if (state == &quot;in_number&quot;) {
            ans = ans * 10 + c - &#39;0&#39;;
            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);
        }
        else if (state == &quot;signed&quot;)
            sign = c == &#39;+&#39; ? 1 : -1;
    }
};

int myAtoi(string s) {
         Automaton automaton;
        for (char c : s)
            automaton.get(c);
        return automaton.sign * automaton.ans;
    }</code></pre>
<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h2><ul>
<li><ol start="9">
<li>Palindrome Number</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number">https://leetcode-cn.com/problems/palindrome-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>示例 1:<br>输入: 121<br>输出: true<br>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
</blockquote>
<pre><code class="c++"> bool isPalindrome(int x) {
        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {
            return false;
        }
        //后半段与前半段对比
        int revertedNumber = 0;
        while (x &gt; revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }

        return x == revertedNumber || x == revertedNumber / 10;
    }</code></pre>
<h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h2><ul>
<li><ol start="10">
<li>Regular Expression Matching</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching">https://leetcode-cn.com/problems/regular-expression-matching</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<blockquote>
<p>‘.’ 匹配任意单个字符<br>‘*‘ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
</blockquote>
<blockquote>
<p>示例 1：<br>输入：s = “aa” p = “a”<br>输出：false<br>解释：”a” 无法匹配 “aa” 整个字符串。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>输入：s = “aa” p = “a*”<br>输出：true<br>解释：因为 ‘*‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>输入：s = “ab” p = “.*“<br>输出：true<br>解释：”.*“ 表示可匹配零个或多个（’*‘）任意字符（’.’）。</p>
</blockquote>
<blockquote>
<p>示例 4：<br>输入：s = “aab” p = “c*a*b”<br>输出：true<br>解释：因为 ‘*‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>
</blockquote>
<blockquote>
<p>示例 5：<br>输入：s = “mississippi” p = “mis*is*p*.”<br>输出：false</p>
</blockquote>
<pre><code class="c++">bool isMatch(string s, string p) {
    // dp[i][j]表示str[1:i]和pattern[1:j]能否匹配，为0表示无法匹配，为1表示可以匹配
//
// 分析状态转移方程
//   对于dp[i][j]，如果str[i]与p[j]相同或者p[j]为.，则dp[i][j] = dp[i-1][j-1]，即与s[1:i-1]和p[1:j-1]的匹配情况相同
//   如果p[j]为*，则表示这个字符可以联合p[j-1]使用来匹配当前的s[i](这个选择可做可不做，但我们尽量去匹配字符串)
//   考虑p[j]为*，如果p前一个字符为.，显然可以用一次.*组合匹配到s[i]，如果p前一个字符p[j-1]不为.并且不与s[i]相同，则不能使用
//   综合考虑，若p[j]==&#39;*&#39;
//   1. 不选择替换，使用0次*，dp[i][j] = dp[i][j-2]
//   2. 当p[j-1]为.或者与s[i]相同时，可以使用一次替换，则dp[i][j] = dp[i-1][j]
//   两者求或 (因为我们尽可能去匹配字符串，所以只要有一种情况匹配成功，则匹配成功)
// 初始化主要考虑p去匹配一个空串的情况，和上面类似的分析过程即可得出结论

    //dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配
    vector&lt;vector&lt;bool&gt;&gt; dp(s.size() + 1, vector&lt;bool&gt;(p.size() + 1));
    dp[0][0] = true;

    //s 的前 0 个是否能被 p 的前 j 个匹配
    for (size_t j = 1; j &lt; p.size(); ++j)
    {
        if (p[j] == &#39;*&#39;)
        {
            dp[0][j + 1] = dp[0][j - 1];
        }
    }

    for (size_t i = 0; i &lt; s.size(); ++i)
    {
        for (size_t j = 0; j &lt; p.size(); ++j)
        {
            if (s[i] == p[j] || p[j] == &#39;.&#39;)//匹配单个字符  
            {
                dp[i + 1][j + 1] = dp[i][j];
            }
            else if (p[j] == &#39;*&#39; &amp;&amp; j &gt; 0)
            {
                if (s[i] != p[j - 1] &amp;&amp; p[j - 1] != &#39;.&#39;)//前一对字符匹配
                {
                    dp[i + 1][j + 1] = dp[i + 1][j - 1];
                }
                else
                {
                    dp[i + 1][j + 1] = dp[i][j + 1] || //*表示匹配超过一个字符(s[i]、s[i-1]和p[j-1])
                        //dp[i + 1][j] || //*表示只匹配一个字符（s[i]和p[j-1]）
                        dp[i + 1][j - 1];//*表示0个匹配
                }

            }
        }
    }

    return dp[s.size()][p.size()];
}</code></pre>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
</blockquote>
<blockquote>
<p>示例：<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p>
</blockquote>
<pre><code class="c++">int maxArea(vector&lt;int&gt;&amp; height) {
        int n = height.size();
        if (n &lt; 2)
            return 0;

        int maxVolume = 0;
        int left = 0;
        int right = n - 1;

        while(left &lt; right){
            //取左端与右端
            int lh = height[left];
            int rh = height[right];

            //计算体积
            int vol = min(lh, rh) * (right-left);
            //设置最大体积
            maxVolume = max(maxVolume, vol);

            //哪端的指针移动，取决于哪根柱子更低
            left += (lh &lt;= rh) ? 1 : 0;
            right -= (lh &gt; rh) ? 1 : 0;

            cout &lt;&lt; &quot;left:&quot;&lt;&lt;left&lt;&lt;&quot;,right:&quot;&lt;&lt;right&lt;&lt;endl;
        }


        return maxVolume;
    }</code></pre>
<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
</blockquote>
<p><img src="/img/1604578953107.png" alt="17"></p>
<blockquote>
<p>示例:<br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
</blockquote>
<pre><code class="c++">  vector&lt;string&gt; letterCombinations(string digits) {
        map&lt;int,vector&lt;char&gt;&gt; numsMap;
        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(2, vector&lt;char&gt;{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}));
        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(3, vector&lt;char&gt;{&#39;d&#39;, &#39;e&#39;, &#39;f&#39;}));
        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(4, vector&lt;char&gt;{&#39;g&#39;, &#39;h&#39;, &#39;i&#39;}));
        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(5, vector&lt;char&gt;{&#39;j&#39;, &#39;k&#39;, &#39;l&#39;}));
        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(6, vector&lt;char&gt;{&#39;m&#39;, &#39;n&#39;, &#39;o&#39;}));
        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(7, vector&lt;char&gt;{&#39;p&#39;, &#39;q&#39;, &#39;r&#39;,&#39;s&#39;}));
        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(8, vector&lt;char&gt;{&#39;t&#39;, &#39;u&#39;, &#39;v&#39;}));
        numsMap.insert(map&lt; int, vector&lt;char&gt;&gt;::value_type(9, vector&lt;char&gt;{&#39;w&#39;, &#39;x&#39;, &#39;y&#39;,&#39;z&#39;}));

        /*输入：&quot;23&quot;
            输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].*/
        map&lt;string, int&gt; resultMap;
        vector&lt;string&gt; result;

        for (int i = 0; i &lt; digits.size(); i++) {
            int v = digits[i] - &#39;0&#39;;
            if (numsMap.count(v) == 0) {
                result.clear();
                break;
            }
            vector&lt;char&gt; curChars = numsMap[v];
            if (i &gt; 0) {
                vector&lt;string&gt; tmpList;
                for(string val : result) {
                    for (char c : curChars) {
                        tmpList.push_back(val + c);
                    }
                }
                result.clear();
                result = tmpList;
            }
            else {
                for (auto it = curChars.begin(); it != curChars.end(); it++) {
                      char v = *it;
                    result.push_back(string (1,v));
                }
            }
        }

        return result;
    }</code></pre>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<blockquote>
<p>示例：<br>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
</blockquote>
<pre><code class="c++">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());   // -4  -1  -1  0  1  2
        vector&lt;vector&lt;int&gt;&gt; res;
        for(int i=0; i&lt;nums.size(); i++){
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]){
                continue;
            }
            int j = i+1, k = nums.size() -1;
            while(j &lt; k){
                if(j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]){
                    j++;
                    continue;
                }
                if(k &lt; nums.size()-1 &amp;&amp; nums[k] == nums[k+1]){
                    k--;
                    continue;
                }
                if(nums[j] + nums[k] &gt; -1*nums[i]){
                    k--;
                }else if(nums[j] + nums[k] &lt; -1*nums[i]){
                    j++;
                }else{
                    res.push_back({nums[i], nums[j], nums[k]});
                    j++, k--;
                }
            }
        }
        return res;
    }</code></pre>
<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：<br>给定的 n 保证是有效的。<br>进阶：<br>你能尝试使用一趟扫描实现吗？</p>
</blockquote>
<pre><code class="c++">  ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* slow = head;
        ListNode* fast = head;
        ListNode* pre = NULL;

        for (int i = 0; i &lt; n; i++)
        {
            fast = fast-&gt;next;
        }

        while (fast != NULL) {
            pre = slow;
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }

        if (pre != NULL) {
            pre-&gt;next = slow-&gt;next;
            return head;
        }
        else {
            return head-&gt;next;
        }

    }
</code></pre>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>输入: “()”<br>输出: true<br>示例 2:<br>输入: “()[]{}”<br>输出: true<br>示例 3:<br>输入: “(]”<br>输出: false<br>示例 4:<br>输入: “([)]”<br>输出: false<br>示例 5:<br>输入: “{[]}”<br>输出: true</p>
</blockquote>
<pre><code class="c++"> bool isValid(string s) {
        map&lt;char, char&gt; cMap = {
            {&#39;]&#39;,&#39;[&#39;},
            {&#39;}&#39;,&#39;{&#39;},
            {&#39;)&#39;,&#39;(&#39;},
        };

        if (s.size() % 2 == 1)//奇数必然不对
            return false;

        stack&lt;char&gt; cs;
        for (char c : s) {
            if (cMap.count(c)) {
                if (cs.empty() || cs.top() != cMap[c]) {
                    return false;
                }
                cs.pop();
            }
            else {
                cs.push(c);
            }
        }
        return cs.size() == 0;
    }</code></pre>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses">https://leetcode-cn.com/problems/generate-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
</blockquote>
<blockquote>
<p>示例：<br>输入：n = 3<br>输出：[<br>       “((()))”,<br>       “(()())”,<br>       “(())()”,<br>       “()(())”,<br>       “()()()”<br>     ]</p>
</blockquote>
<pre><code class="c++"> void LoopGetParanthesis(vector&lt;string&gt; &amp; result,string str,int left, int right) {
        if (left == 0 &amp;&amp; right == 0) {
            result.push_back(str);
            return;
        }

        //左右括号数相等，则只用左括号
        if (left == right) {
            LoopGetParanthesis(result, str + &quot;(&quot;, left - 1, right);
        }
        else if(left &lt; right){
            if (left &gt; 0) {
                LoopGetParanthesis(result, str + &quot;(&quot;, left-1, right);
            }
            LoopGetParanthesis(result, str + &quot;)&quot;, left, right - 1);
        }
    }
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; result;
        string str = &quot;&quot;;
        LoopGetParanthesis(result, str, n, n);

        return result;
    }</code></pre>
<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h2><ul>
<li><ol start="26">
<li>Remove Duplicates from Sorted Array</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</li>
</ul>
<blockquote>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<pre><code class="c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if(nums.size() ==0) return 0;
        int thumb = 0;

        for(int i = 1;i &lt; nums.size(); i++){
            if(nums[i] != nums[thumb]){
                thumb ++;
                nums[thumb] = nums[i];
            }
        }
        return thumb+1;
    }
};</code></pre>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><ul>
<li><ol start="27">
<li>Remove Element</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<pre><code class="c++">class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int thumb = 0;
        for(int i = 0; i &lt; nums.size(); i++){
            if(nums[i] != val){
                nums[thumb] = nums[i];
                thumb ++;
            }
        }
        return thumb;
    }
};</code></pre>
<h2 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h2><ul>
<li><ol start="28">
<li>Implement strStr()</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/implement-strstr">https://leetcode-cn.com/problems/implement-strstr</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p>
</blockquote>
<blockquote>
<p>示例 2:<br>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p>
</blockquote>
<pre><code class="python">class Solution:
    def strStr(self, source: str, target: str) -&gt; int:
        if source == target:
            return 0

        source_len = len(source)
        target_len = len(target)

        if target_len &gt; source_len:
            return -1

        for i in range(source_len):
            target_index = i + target_len
            if target_index &gt; source_len:
                continue
            if source[i:target_index] == target:
                return i

        return -1</code></pre>
<h2 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a>29. 两数相除</h2><ul>
<li><ol start="29">
<li>Divide Two Integers</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/divide-two-integers">https://leetcode-cn.com/problems/divide-two-integers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>返回被除数 dividend 除以除数 divisor 得到的商。<br>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
</blockquote>
<blockquote>
<p>示例 1:<br>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</p>
</blockquote>
<blockquote>
<p>示例 2:<br>输入: dividend = 7, divisor = -3<br>输出: -2<br>解释: 7/-3 = truncate(-2.33333..) = -2</p>
</blockquote>
<blockquote>
<p>提示：<br>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>
</blockquote>
<pre><code class="python">class Solution:
    def divide(self, dividend: int, divisor: int) -&gt; int:
        abs_dividend = abs(dividend)
        abs_divisor = abs(divisor)
        if abs_dividend &lt; abs_divisor:
            return 0

        is_neg = 0
        if abs(dividend + divisor) != abs_dividend + abs_divisor:
            is_neg = 1
        ans = 0

        for i in range(31, -1, -1):
            print(&#39;abs_dividend &gt;&gt; %d : %d, %d, &#39;% (i, abs_dividend &gt;&gt; i, abs_divisor))

            if abs_dividend &gt;&gt; i &gt;= abs_divisor:
                ans += 1 &lt;&lt; i
                abs_dividend -= abs_divisor &lt;&lt; i
                print(&#39;good value: %d, %d&#39;%(ans, abs_dividend))

        if is_neg and ans &gt;= 2 ** 31:
            return -2 ** 31
        elif ans &gt;= 2 ** 31:
            return 2 ** 31 - 1
        elif is_neg:
            return -ans
        else:
            return ans</code></pre>
<h2 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a>30. 串联所有单词的子串</h2><ul>
<li><ol start="30">
<li>Substring with Concatenation of All Words</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。<br>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p>
</blockquote>
<blockquote>
<p>示例 1：<br>输入：<br>  s = “barfoothefoobarman”,<br>  words = [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>输入：<br>  s = “wordgoodgoodgoodbestword”,<br>  words = [“word”,”good”,”best”,”word”]<br>输出：[]</p>
</blockquote>
<pre><code class="python">class Solution(object):
    def findSubstring(self, s, words):
        from collections import Counter
        if not s or not words:return []
        one_word = len(words[0])
        all_len = len(words) * one_word
        n = len(s)
        words = Counter(words)
        res = []
        for i in range(0, n - all_len + 1):
            tmp = s[i:i+all_len]
            c_tmp = []
            for j in range(0, all_len, one_word):
                c_tmp.append(tmp[j:j+one_word])
            if Counter(c_tmp) == words:
                res.append(i)
        return res</code></pre>
<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><ul>
<li><ol start="41">
<li>First Missing Positive</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/first-missing-positive">https://leetcode-cn.com/problems/first-missing-positive</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>输入: [1,2,0]<br>输出: 3</p>
</blockquote>
<blockquote>
<p>示例 2:<br>输入: [3,4,-1,1]<br>输出: 2</p>
</blockquote>
<blockquote>
<p>示例 3:<br>输入: [7,8,9,11,12]<br>输出: 1</p>
</blockquote>
<blockquote>
<p>提示：<br>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p>
</blockquote>
<pre><code class="c++">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
         // 总长
        int n = nums.size();
        // 1. 全部元素没有1，返回1
        bool noOne = true;
        for(int i = 0; i &lt; nums.size();i++){
            if(nums[i] == 1)
            {
                noOne = false;
                break;
            }
        }
        if(noOne){
            return 1;
        }

        //2. 只有一个元素，且为[1]，则返回2
        if(n == 1)
        {
            return 2;
        }

        //3. 去&lt;= 0与 &gt; 总数的数，将其设为1
        for(int i = 0; i &lt; n;i++){
            if(i == n-1){
                cout &lt;&lt; nums[i] &lt;&lt; endl;
            }
            if(nums[i] &lt; 1 || nums[i] &gt; n){
                nums[i] = 1;
            }
        }


        //4.遍历，当值 == 总数。第一个值设为负数. 当值 &lt;= 总数，以值为下标设置为负值. 特别的，当值为总数时，将第一个值为负值！
         for(int i = 0; i &lt; n; i++){
             int a = abs(nums[i]);
             if(a == n){
                 nums[0] = - abs(nums[0]);
             }else{
                nums[a] = - abs(nums[a]);
             }
         }

        for(int v: nums){
            cout &lt;&lt; v &lt;&lt; &quot;,&quot;;
        }
        cout &lt;&lt; endl;

        //5.遍历最新的数组中，发现有大于0，此索引就是丢失的最小正数
        for(int i = 1; i &lt; n;i++){
            if(nums[i] &gt; 0){
                return i;
            }
        }

        //6.5如果没有找到，第一值取出来如果是正数，则数为正数N
        if(nums[0] &gt; 0){
            return n;
        }

        //7.如果以上走完了，返回n+1
        return n+1;
    }
};</code></pre>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water">https://leetcode-cn.com/problems/trapping-rain-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>示例 1：</p>
</blockquote>
<p><img src="/img/1604063667003.png" alt="接雨水"></p>
<blockquote>
<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>示例 2：<br>输入：height = [4,2,0,3,2,5]<br>输出：9</p>
</blockquote>
<pre><code class="c++">  int trap(vector&lt;int&gt;&amp; height) {
        int left = 0, right = height.size() - 1;
        int ans = 0;
        int left_max = 0, right_max = 0;
        while (left &lt; right) {
            //情况1：左比右低，只有当左边最高柱比当前柱要高，则这个落差必定是能装水的。
            if (height[left] &lt; height[right]) {
                height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
                ++left;
            }
            else {//情况2：右比左低，只有当右边最高柱比当前柱要高，则这个落差必定是能装水的。
                height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
                --right;
            }
        }
        return ans;
    }</code></pre>
<h2 id="51-N皇后-amp-52-N皇后-II"><a href="#51-N皇后-amp-52-N皇后-II" class="headerlink" title="51. N皇后 &amp; 52. N皇后 II"></a>51. N皇后 &amp; 52. N皇后 II</h2><ul>
<li><ol start="51">
<li>N-Queens</li>
</ol>
</li>
<li><ol start="52">
<li>N-Queens II</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-queens">https://leetcode-cn.com/problems/n-queens</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
</blockquote>
<p><img src="/img/1601178139148.png" alt="8皇后的一种解法"></p>
<blockquote>
<ol start="51">
<li>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</li>
<li>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</li>
</ol>
</blockquote>
<pre><code class="python">class NQueen:
    def __init__(self):
        self.count = 0

    def do_nqueen(self, n):
        empty_sign = &quot;[O]&quot;
        queen_sign = &quot;[1]&quot;
        # 所有数组起点都以0开始

        # 1.定义所有解的容器，二维数组，第二维代表一个完整的解
        ans = []

        # 2.递归函数dfs
        def dfs(nums, row):
            # 如果找的行数与n相等了，说明已经找完了，得到一个解！
            if row == n:
                ans.append(nums[:]) # 注意不可用ans.append(nums)
                return
            # 逐列进行尝试，列的总数为n
            for i in range(n):
                # 每进行到一列，标记当前行皇后位置为此列
                nums[row] = i
                # 往下递归找到，一直找到底，找不到底循环会返回到此处！
                if valid(nums, row):
                    # print(&quot;当前找到第%d行的第%d列，此值可放皇后！&quot;%(row, i))
                    dfs(nums, row+1)
                else:
                    pass
                    # print(&quot;当前找到第%d行的第%d列，不可放，回溯&quot;%(row, i))

        # 3.检查函数valid
        def valid(nums, row):
            # 只找前面行的点， 皇后攻击规则，同列同行 和 对角线元素表示
            for r in range(row):
                if abs(nums[r] - nums[row]) == abs(r - row) or nums[r] == nums[row]:
                    return False
            return True

        # 4.执行, 从第0行开始找n数组长度中的位置
        dfs([None for _ in range(n)], 0)

        def get_row_list(row_val, count):
            result = []
            for i in range(count):
                if i == row_val:
                    result.append(queen_sign)
                else:
                    result.append(empty_sign)
            return result


        # 5.结果画出来
        result = [[] for _ in range(len(ans))]
        for i in range(len(ans)):
            for col in ans[i]:
                result[i].append(&quot;&quot;.join(get_row_list(col, n)))

        return result


myqueen = NQueen()
result = myqueen.do_nqueen(4)
print(&quot;解有%d个&quot;%len(result))
for r in result:
    r = str(r)
    print(r+&quot;\n\n&quot;)</code></pre>
<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>注意:<br>不能使用代码库中的排序函数来解决这道题。<br>示例:<br>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]<br>进阶：<br>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>
</blockquote>
<pre><code class="c++"> void sortColors(vector&lt;int&gt;&amp; nums) {
       int n = nums.size();
        int slow0 = 0, fast = 0, slow2 = n - 1;

        while (fast &lt;= slow2) {
            while (fast &lt;= slow2 &amp;&amp; nums[fast] == 2) {
                //当当前快指针为2时，移至结尾。如果换完后的nums[fast]还是2？则继续换
                nums[fast] = nums[slow2];
                nums[slow2--] = 2;
            }

            if (nums[fast] == 0) {
                nums[fast] = nums[slow0];
                nums[slow0++] = 0;
            }
            fast++;
        }
    }</code></pre>
<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-window-substring">https://leetcode-cn.com/problems/minimum-window-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。<br>示例：<br>输入：S = “ADOBECODEBANC”, T = “ABC”<br>输出：”BANC”</p>
</blockquote>
<blockquote>
<p>提示：<br>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p>
</blockquote>
<pre><code class="c++"> string minWindow(string s, string t) {
        if(s == t) return s;

        map&lt;char, int&gt; need, window;
        int tLen = t.length();//目标字符串
        int sLen = s.length();
        if (tLen == 0 || sLen == 0) return &quot;&quot;;
        if (sLen &lt; tLen )
            return &quot;&quot;;

        //先把t中的字符放到need表中，计数
        for (int i = 0; i &lt; tLen; i++) {
            char c = t[i];
            need[c] = ((need.count(c) == 0)?0:need[c]) + 1;
        }

        int left = 0, right = 0;
        int len = INT32_MAX, start = 0;
        int valid = 0; //已经匹配成功的字符种类数（非字符个数）

        //当右指针去到字符串末尾前
        while (right &lt; sLen) {
            char c = s[right];
            right++;//右指针向右滑

            //如果右指针现在滑到的字符是目标字符串的一个，那么更新窗口中的数据
            if (need.count(c) &gt; 0) {
                window[c] = ((window.count(c) == 0)?0:window[c]) + 1;
                if (window[c] == (need[c])) {
                    valid++;
                }
            }

            //窗口开始从左边收缩
            while (valid == need.size()) {
                if (right - left &lt; len) {
                    start = left;
                    len = right - left;
                }

                char d = s[left];
                left++;

                if (need.count(d) &gt; 0) {
                    if (window[d] == (need[d])) {
                        valid--;
                    }
                    window[d] = window[d] - 1;
                }
            }
        }
        return len == INT32_MAX ? &quot;&quot; : s.substr(start, len);
    }</code></pre>
<h2 id="80-删除排序数组中的重复项-II"><a href="#80-删除排序数组中的重复项-II" class="headerlink" title="80. 删除排序数组中的重复项 II"></a>80. 删除排序数组中的重复项 II</h2><ul>
<li><ol start="80">
<li>Remove Duplicates from Sorted Array II</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>给定 nums = [1,1,1,2,2,3],<br>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>给定 nums = [0,0,1,1,1,1,2,3,3],<br>函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?</p>
</blockquote>
<pre><code class="c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
      int i = 0;
        for (int n : nums) {
            if (i &lt; 2 || n &gt; nums[i-2]) nums[i++] = n;
        }
        return i;
    }
};</code></pre>
<h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a>127. 单词接龙</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-ladder">https://leetcode-cn.com/problems/word-ladder</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。</p>
</blockquote>
<blockquote>
<p>说明:<br>如果不存在这样的转换序列，返回 0。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出: 5<br>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。<br>示例 2:<br>输入:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>输出: 0<br>解释: endWord “cog” 不在字典中，所以无法进行转换。</p>
</blockquote>
<pre><code class="c++">class Solution {
    unordered_map&lt;string, int&gt; wordId;
    vector&lt;vector&lt;int&gt;&gt; edge;
    int nodeNum = 0;

    void addWord(string&amp; word) {
        if (!wordId.count(word)) {
            wordId[word] = nodeNum++;
            edge.emplace_back();
        }
    }

    void addEdge(string&amp; word) {
        addWord(word);
        int id1 = wordId[word];
        for (char&amp; it : word) {
            char tmp = it;
            it = &#39;*&#39;;
            addWord(word);
            int id2 = wordId[word];
            edge[id1].push_back(id2);
            edge[id2].push_back(id1);
            it = tmp;
        }
    }
public:
    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {
        for (string&amp; word : wordList) {
            addEdge(word);
        }
        addEdge(beginWord);
        if (!wordId.count(endWord)) {
            return 0;
        }
        vector&lt;int&gt; dis(nodeNum, INT_MAX);
        int beginId = wordId[beginWord], endId = wordId[endWord];
        dis[beginId] = 0;

        queue&lt;int&gt; que;
        que.push(beginId);
        while (!que.empty()) {
            int x = que.front();
            que.pop();
            if (x == endId) {
                return dis[endId] / 2 + 1;
            }
            for (int&amp; it : edge[x]) {
                if (dis[it] == INT_MAX) {
                    dis[it] = dis[x] + 1;
                    que.push(it);
                }
            }
        }
        return 0;
    }

};</code></pre>
<h2 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129.求根到叶子节点数字之和"></a>129.求根到叶子节点数字之和</h2><ul>
<li><ol start="129">
<li>Sum Root to Leaf Numbers</li>
</ol>
</li>
<li>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li>
</ul>
<blockquote>
<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。<br>计算从根到叶子节点生成的所有数字之和。<br>说明: 叶子节点是指没有子节点的节点。</p>
</blockquote>
<p>示例 1:<br>输入: [1,2,3]<br>    1<br>   / <br>  2   3<br>输出: 25<br>解释:<br>从根到叶子节点路径 1-&gt;2 代表数字 12.<br>从根到叶子节点路径 1-&gt;3 代表数字 13.<br>因此，数字总和 = 12 + 13 = 25.<br>示例 2:</p>
<p>输入: [4,9,0,5,1]<br>    4<br>   / <br>  9   0<br> / <br>5   1<br>输出: 1026<br>解释:<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>从根到叶子节点路径 4-&gt;0 代表数字 40.<br>因此，数字总和 = 495 + 491 + 40 = 1026.</p>
<pre><code class="c++">int bfs_sum(TreeNode* root) {
    if(root == NULL)
        return 0;
    int sum = 0;
    queue&lt;TreeNode*&gt; q;
    queue&lt;int&gt; qn;

    q.push(root);
    qn.push(root-&gt;val);

    while (!q.empty()) {
        TreeNode* node = q.front();
        int nodeVal = qn.front();
        q.pop();
        qn.pop();

        if ((node-&gt;left == NULL) &amp;&amp; (node-&gt;right == NULL)) {
            sum += nodeVal;
        }
        else {
            if (node-&gt;left != NULL) {
                q.push(node-&gt;left);
                qn.push(nodeVal * 10 + node-&gt;left-&gt;val);
            }
            if (node-&gt;right != NULL) {
                q.push(node-&gt;right);
                qn.push(nodeVal * 10 + node-&gt;right-&gt;val);
            }
        }
    }
    return sum;
}

int dfs_sum(TreeNode* node, int prevSum) {
    if(node == NULL)
        return 0;

    int sum = prevSum * 10 + node-&gt;val;
    //左右都没有值 
    if ((node-&gt;left == NULL) &amp;&amp;(node-&gt;right == NULL)) {
        return sum;
    }
    else {
        sum = dfs_sum(node-&gt;left, sum) + dfs_sum(node-&gt;right, sum);
    }

    return sum;
}

int sumNumbers(TreeNode* root) {
        //return dfs_sum(root, 0);
    return bfs_sum(root);
}</code></pre>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
</blockquote>
<blockquote>
<p>进阶<br>你能用 O(1)（即，常量）内存解决此问题吗？</p>
</blockquote>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<pre><code class="c++">    bool hasCycle(ListNode *head) {
        if(head == NULL)
            return false;
       ListNode* slow = head;
        ListNode* fast = head-&gt;next;
        while (slow != fast) {
            if (fast == NULL || fast-&gt;next == NULL)
            {
                return false;
            }

            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        return true;
    }</code></pre>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
</blockquote>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<pre><code class="c++">    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head;
        ListNode *fast = head;
        while(fast != NULL){
            if(fast-&gt;next == NULL)
                return nullptr;

            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;

            if(slow == fast){
                ListNode * ptr = head;
                while(ptr != slow){
                    ptr = ptr-&gt;next;
                    slow = slow-&gt;next;
                }
                return ptr;
            }
        }
        return nullptr;

    }</code></pre>
<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h2><ul>
<li><ol start="144">
<li>Binary Tree Preorder Traversal</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal">https://leetcode-cn.com/problems/binary-tree-preorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
</blockquote>
<blockquote>
<p>示例:<br>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3<br>输出: [1,2,3]</p>
</blockquote>
<pre><code class="c++">    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        if(root == NULL)
            return result;

        stack&lt;TreeNode&gt; ss;
        ss.push(*root);

        while(!ss.empty()){
            TreeNode cur = ss.top();
            ss.pop();

            result.push_back(cur.val);

            if(cur.right != NULL){
                ss.push(*cur.right);
            }
            if(cur.left != NULL){
                ss.push(*cur.left);
            }
        }
        return result;
    }</code></pre>
<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h2><ul>
<li><ol start="189">
<li>Rotate Array</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-array">https://leetcode-cn.com/problems/rotate-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
</blockquote>
<blockquote>
<p>示例 2:<br>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]</p>
</blockquote>
<blockquote>
<p>说明:<br>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p>
</blockquote>
<pre><code class="c++">class Solution {
public:
    void reverse(vector&lt;int&gt;&amp; nums, int start, int end){
        for(int i = start,j = end; i &lt; j; i++,j--){
            int ftmp = nums[j];
            nums[j] = nums[i];
            nums[i] = ftmp;
        }
    }

    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        if(k &gt; nums.size()){
            k %= nums.size();
        }

        reverse(nums, 0, nums.size()-k-1);
        reverse(nums, nums.size()-k, nums.size()-1);
        reverse(nums, 0, nums.size()-1);
    }
};
</code></pre>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p> 来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>请判断一个链表是否为回文链表。<br>示例 1:<br>输入: 1-&gt;2<br>输出: false<br>示例 2:<br>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p>
</blockquote>
<pre><code class="c++">ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) {
            ListNode* nextTemp = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    ListNode* endOfFirstHalf(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) {
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
        }
        return slow;
    }
    bool isPalindrome(ListNode* head) {
        if(head == NULL)
            return true;
        // 找到前半部分链表的尾节点并反转后半部分链表
        ListNode* firstHalfEnd = endOfFirstHalf(head);
        ListNode* secondHalfStart = reverseList(firstHalfEnd-&gt;next);

        // 判断是否回文
        ListNode* p1 = head;
        ListNode* p2 = secondHalfStart;
        bool result = true;
        while (result &amp;&amp; p2 != nullptr) {
            if (p1-&gt;val != p2-&gt;val) {
                result = false;
            }
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
        }

        // 还原链表并返回结果
        firstHalfEnd-&gt;next = reverseList(secondHalfStart);
        return result;
    }</code></pre>
<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><p> 来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>
</blockquote>
<pre><code class="c++"> void moveZeroes(vector&lt;int&gt;&amp; nums) {
       for (int lastNonZeroFoundAt = 0, cur = 0; cur &lt; nums.size(); cur++) {
            if (nums[cur] != 0) {
                swap(nums[lastNonZeroFoundAt], nums[cur]);
                lastNonZeroFoundAt++;
            }
        }
    }</code></pre>
<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number">https://leetcode-cn.com/problems/find-the-duplicate-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>示例 1:<br>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:<br>输入: [3,1,3,4,2]<br>输出: 3<br>说明：</p>
</blockquote>
<blockquote>
<p>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 O(1) 的空间。<br>时间复杂度小于 O(n2) 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。</p>
</blockquote>
<pre><code class="c++"> int findDuplicate(vector&lt;int&gt;&amp; nums) {
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }</code></pre>
<h2 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299. 猜数字游戏"></a>299. 猜数字游戏</h2><ul>
<li><ol start="299">
<li>Bulls and Cows</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bulls-and-cows">https://leetcode-cn.com/problems/bulls-and-cows</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：<br>你写出一个秘密数字，并请朋友猜这个数字是多少。<br>朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。<br>朋友根据提示继续猜，直到猜出秘密数字。<br>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。</p>
</blockquote>
<blockquote>
<p>xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。<br>yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。<br>请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>输入: secret = “1807”, guess = “7810”<br>输出: “1A3B”<br>解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>输入: secret = “1123”, guess = “0111”<br>输出: “1A1B”<br>解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。</p>
</blockquote>
<blockquote>
<p>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等</p>
</blockquote>
<pre><code class="c++">class Solution {
public:
    string getHint(string secret, string guess) {
        int bulls = 0;
        int cows = 0;
        int ds[10]{0};
        int dg[10]{0};
        for(int i = 0; i &lt; secret.size(); i++){
            int x = secret[i] - &#39;0&#39;;
            int y = guess[i] - &#39;0&#39;;
            if(secret[i] == guess[i]){
                bulls ++;    
            }
            ds[x] ++;
            dg[y] ++;
        }

        //算出相同元素总数，当然减掉之前算好的cows
        for(int i = 0;i &lt; 10;i++){
            cows += min(ds[i],dg[i]);
        }
        cows -= bulls;
        ostringstream oss;
        oss &lt;&lt; bulls &lt;&lt; &quot;A&quot; &lt;&lt; cows &lt;&lt; &quot;B&quot; ;
        return oss.str();
    }

};  </code></pre>
<h2 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a>463. 岛屿的周长</h2><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/island-perimeter">https://leetcode-cn.com/problems/island-perimeter</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。<br>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。<br>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
</blockquote>
<blockquote>
<p>示例 :<br>输入:<br>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]<br>输出: 16</p>
</blockquote>
<pre><code class="c++">class Solution {
    constexpr static int dx[4] = {0, 1, 0, -1};
    constexpr static int dy[4] = {1, 0, -1, 0};
public:
    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; m; ++j) {
                if (grid[i][j]) {
                    int cnt = 0;
                    for (int k = 0; k &lt; 4; ++k) {
                        int tx = i + dx[k];
                        int ty = j + dy[k];
                        if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || !grid[tx][ty]) {
                            cnt += 1;
                        }
                    }
                    ans += cnt;
                }
            }
        }
        return ans;
    }
};</code></pre>
<h2 id="1207-独一无二的出现次数"><a href="#1207-独一无二的出现次数" class="headerlink" title="1207.独一无二的出现次数"></a>1207.独一无二的出现次数</h2><ul>
<li><ol start="1207">
<li>Unique Number of Occurrences</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-number-of-occurrences">https://leetcode-cn.com/problems/unique-number-of-occurrences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。<br>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p>
</blockquote>
<blockquote>
<p>示例 1：<br>输入：arr = [1,2,2,1,1,3]<br>输出：true<br>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。<br>示例 2：<br>输入：arr = [1,2]<br>输出：false<br>示例 3：<br>输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]<br>输出：true</p>
</blockquote>
<pre><code class="c++">bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {
    map&lt;int, int&gt; posMap;
    for (int i = 0; i &lt; arr.size(); i++)
    {
        posMap[arr[i]] += 1;
    }

    set&lt;int&gt; uniqueSet;
    for (const auto&amp; item : posMap)
    {
        uniqueSet.insert(item.second);
    }

    return posMap.size() == uniqueSet.size();
}</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1024037035@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">Title:</span>力扣刷题记录</p>
    <p><span class="copy-title">Count:</span><span class="post-count">13.5k</span></p>
    <p><span class="copy-title">Author:</span><a  title="霍家鹏">霍家鹏</a></p>
    <p><span class="copy-title">Created At:</span>2020-11-05, 20:26:18</p>
    <p><span class="copy-title">Updated At:</span>2020-11-05, 20:26:18</p>
    <span class="copy-title">Url:</span><a class="post-url" href="/2020/11/05/力扣刷题记录/" title="力扣刷题记录">http://www.hjp.wiki/2020/11/05/力扣刷题记录/</a>
    <p>
        <span class="copy-title">Copyright:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">AveryHuo</a> Reprint please keep the original link and author.
    </p>
</div>



    <div id="comments">
    <script src="https://utteranc.es/client.js"
            repo="AveryHuo/AveryHuo.github.io"
            issue-term="pathname"
            theme="github-light"
            label="utteranc"
            crossorigin="anonymous"
            async>
    </script>
</div>




    




    </div>
    <div class="copyright">
        <p class="footer-entry"><span class="miit">
                <img src="/img/gov.png" title="中华人民共和国工业和信息化部">
                <a href="http://beian.miit.gov.cn/">粤ICP备2020091327号</a>
        </span>
    
    ©2018-2020 AveryHuo
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
