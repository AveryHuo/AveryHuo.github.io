<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>力扣刷题记录 | Avery的城堡</title><meta name="keywords" content="Learn+Study"><meta name="author" content="霍家鹏"><meta name="copyright" content="霍家鹏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc] 1. 两数之和    Two Sum    来源：力扣（LeetCode） 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;two-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应">
<meta property="og:type" content="article">
<meta property="og:title" content="力扣刷题记录">
<meta property="og:url" content="http://www.hjp.wiki/2022/05/19/LeetcodeNote/index.html">
<meta property="og:site_name" content="Avery的城堡">
<meta property="og:description" content="[toc] 1. 两数之和    Two Sum    来源：力扣（LeetCode） 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;two-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.hjp.wiki/img/1603943631534.png">
<meta property="article:published_time" content="2022-05-19T13:28:29.000Z">
<meta property="article:modified_time" content="2022-05-19T13:28:29.000Z">
<meta property="article:author" content="霍家鹏">
<meta property="article:tag" content="Learn+Study">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.hjp.wiki/img/1603943631534.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.hjp.wiki/2022/05/19/LeetcodeNote/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 霍家鹏","link":"链接: ","source":"来源: Avery的城堡","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '力扣刷题记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-19 21:28:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/my.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Avery的城堡</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">力扣刷题记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-19T13:28:29.000Z" title="发表于 2022-05-19 21:28:29">2022-05-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-19T13:28:29.000Z" title="更新于 2022-05-19 21:28:29">2022-05-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="力扣刷题记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>[toc]</p>
<h2 id="1-两数之和">1. 两数之和</h2>
<ul>
<li>
<ol>
<li>Two Sum</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
</blockquote>
<blockquote>
<p>示例:<br>
给定 nums = [2, 7, 11, 15], target = 9<br>
因为 nums[0] + nums[1] = 2 + 7 = 9<br>
所以返回 [0, 1]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">       map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numsMap;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> left = target - nums[i];</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (numsMap.<span class="built_in">count</span>(left) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               result.<span class="built_in">push_back</span>(numsMap[left]);</span><br><span class="line">               result.<span class="built_in">push_back</span>(i);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           numsMap[nums[i]] = i;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-两数相加">2.两数相加</h2>
<ul>
<li>
<ol start="2">
<li>Add Two Numbers</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<blockquote>
<p>示例：<br>
输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 0 -&gt; 8<br>
原因：342 + 465 = 807</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">       ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//存放结果的链表</span></span><br><span class="line">       ListNode* h = head;<span class="comment">//移动指针</span></span><br><span class="line">       <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//每个位的加和结果</span></span><br><span class="line">       <span class="type">bool</span> carry = <span class="literal">false</span>;<span class="comment">//进位标志</span></span><br><span class="line">       <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           sum = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (l1 != <span class="literal">NULL</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               sum += l1-&gt;val;</span><br><span class="line">               l1 = l1-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (l2 != <span class="literal">NULL</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               sum += l2-&gt;val;</span><br><span class="line">               l2 = l2-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (carry)</span><br><span class="line">               sum++;</span><br><span class="line">           h-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">           h = h-&gt;next;</span><br><span class="line">           carry = sum &gt;= <span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (carry)</span><br><span class="line">       &#123;</span><br><span class="line">           h-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode* ptrDelete = head;</span><br><span class="line">       head = head-&gt;next;</span><br><span class="line">       <span class="keyword">delete</span> ptrDelete;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-无重复字符的最长子串">3.无重复字符的最长子串</h2>
<ul>
<li>
<ol start="3">
<li>Longest Substring Without Repeating Characters</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
输入: “abcabcbb”<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>
示例 2:</p>
</blockquote>
<blockquote>
<p>输入: “bbbbb”<br>
输出: 1<br>
解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>
示例 3:</p>
</blockquote>
<blockquote>
<p>输入: “pwwkew”<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>
     请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; posMap;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> cur = s[end];</span><br><span class="line">            <span class="keyword">if</span> (posMap.<span class="built_in">count</span>(cur) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = <span class="built_in">max</span>(posMap[cur],start);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(end - start + <span class="number">1</span>, ans);</span><br><span class="line">            posMap[cur] = end + <span class="number">1</span>;</span><br><span class="line">            end += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-寻找两个正序数组的中位数">4. 寻找两个正序数组的中位数</h2>
<ul>
<li>
<ol start="4">
<li>Median of Two Sorted Arrays</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br>
进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>
</blockquote>
<blockquote>
<p>示例 1：<br>
输入：nums1 = [1,3], nums2 = [2]<br>
输出：2.00000<br>
解释：合并数组 = [1,2,3] ，中位数 2<br>
示例 2：<br>
输入：nums1 = [1,2], nums2 = [3,4]<br>
输出：2.50000<br>
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br>
示例 3：<br>
输入：nums1 = [0,0], nums2 = [0,0]<br>
输出：0.00000<br>
示例 4：<br>
输入：nums1 = [], nums2 = [1]<br>
输出：1.00000<br>
示例 5：<br>
输入：nums1 = [2], nums2 = []<br>
输出：2.00000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//处理边界</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m)</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k <span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index2 == n)</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//* 正式处理，查找两个二序列表中第K大的数 *//</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//拿出两个数组 k/2 -1位的数</span></span><br><span class="line">            <span class="type">int</span> nIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m<span class="number">-1</span>);</span><br><span class="line">            <span class="type">int</span> nIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//数组二大！数组一的[0]-[k/2-1]被移去算法范围</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[nIndex1] &lt;= nums2[nIndex2]) &#123;</span><br><span class="line">                k -= nIndex1 + <span class="number">1</span> - index1;<span class="comment">//个数已经比较完，继续剩下的数的比较</span></span><br><span class="line">                index1 = nIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//相关</span></span><br><span class="line">                k -= nIndex2 + <span class="number">1</span> - index2;<span class="comment">//个数已经比较完，继续剩下的数的比较</span></span><br><span class="line">                index2 = nIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//奇数个</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (total+<span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//偶数个</span></span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, (total / <span class="number">2</span>)) + <span class="built_in">getKthElement</span>(nums1, nums2, total/<span class="number">2</span> +<span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-最长回文子串">5. 最长回文子串</h2>
<ul>
<li>
<ol start="5">
<li>Longest Palindromic Substring</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>
示例 1：<br>
输入: “babad”<br>
输出: “bab”<br>
注意: “aba” 也是一个有效答案。<br>
示例 2：<br>
输入: “cbbd”<br>
输出: “bb”</p>
</blockquote>
<blockquote>
<p>暴力解法：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validatePalindrome</span><span class="params">(string s, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">QuestionHandler::longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span> || s.<span class="built_in">length</span>() &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>()<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; s.<span class="built_in">length</span>(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (((j - i + <span class="number">1</span>) &gt; maxLen) &amp;&amp; <span class="built_in">validatePalindrome</span>(s, i, j)) &#123;</span><br><span class="line">				maxLen = (j - i + <span class="number">1</span>);</span><br><span class="line">				begin = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中心扩散法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">expandAroundCenter</span><span class="params">(string s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> i = left;</span><br><span class="line">	<span class="type">int</span> j = right;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">			i--;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> j - i +<span class="number">1</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">QuestionHandler::longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span> || s.<span class="built_in">length</span>() &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> oddLen = <span class="built_in">expandAroundCenter</span>(s, i, i);</span><br><span class="line">		<span class="type">int</span> eveLen = <span class="built_in">expandAroundCenter</span>(s, i, i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> curMaxLen = <span class="built_in">max</span>(oddLen, eveLen);</span><br><span class="line">		<span class="keyword">if</span> (curMaxLen &gt; maxLen) &#123;</span><br><span class="line">			maxLen = curMaxLen;</span><br><span class="line">			begin = i - (curMaxLen - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLen);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态规划</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">QuestionHandler::longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span> || s.<span class="built_in">length</span>() &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">					dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (dp[i][j] &amp;&amp; (j - i + <span class="number">1</span>) &gt; maxLen) &#123;</span><br><span class="line">				maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">				begin = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/1603943631534.png" alt="动态规划解法"></p>
<blockquote>
<p>Manacher算法 - O(n)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">expand</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">		--left;</span><br><span class="line">		++right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (right - left - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">QuestionHandler::longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">-1</span>;</span><br><span class="line">	string t = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">		t += c;</span><br><span class="line">		t += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	t += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	s = t;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arm_len;</span><br><span class="line">	<span class="type">int</span> right = <span class="number">-1</span>, j = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="type">int</span> cur_arm_len;</span><br><span class="line">		<span class="keyword">if</span> (right &gt;= i) &#123;</span><br><span class="line">			<span class="type">int</span> i_sym = j * <span class="number">2</span> - i;</span><br><span class="line">			<span class="type">int</span> min_arm_len = <span class="built_in">min</span>(arm_len[i_sym], right - i);</span><br><span class="line">			cur_arm_len = <span class="built_in">expand</span>(s, i - min_arm_len, i + min_arm_len);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cur_arm_len = <span class="built_in">expand</span>(s, i, i);</span><br><span class="line">		&#125;</span><br><span class="line">		arm_len.<span class="built_in">push_back</span>(cur_arm_len);</span><br><span class="line">		<span class="keyword">if</span> (i + cur_arm_len &gt; right) &#123;</span><br><span class="line">			j = i;</span><br><span class="line">			right = i + cur_arm_len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur_arm_len * <span class="number">2</span> + <span class="number">1</span> &gt; end - start) &#123;</span><br><span class="line">			start = i - cur_arm_len;</span><br><span class="line">			end = i + cur_arm_len;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string ans;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">			ans += s[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-Z-字形变换">6.Z 字形变换</h2>
<ul>
<li>
<ol start="6">
<li>ZigZag Conversion</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zigzag-conversion">https://leetcode-cn.com/problems/zigzag-conversion</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>
比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：<br>
L   C   I   R<br>
E T O E S I I G<br>
E   D   H   N<br>
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。<br>
请你实现这个将字符串进行指定行数变换的函数：<br>
string convert(string s, int numRows);<br>
示例 1:<br>
输入: s = “LEETCODEISHIRING”, numRows = 3<br>
输出: “LCIRETOESIIGEDHN”<br>
示例 2:<br>
输入: s = “LEETCODEISHIRING”, numRows = 4<br>
输出: “LDREOEIIECIHNTSG”<br>
解释:<br>
L     D     R<br>
E   O E   I I<br>
E C   I H   N<br>
T     S     G</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> rowIdx = <span class="number">0</span>;</span><br><span class="line">      <span class="function">vector&lt;string&gt; <span class="title">rowStrs</span><span class="params">(numRows)</span></span>;</span><br><span class="line">      <span class="type">bool</span> goingDown = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">          rowStrs[rowIdx] += c;</span><br><span class="line">          <span class="keyword">if</span> (rowIdx == <span class="number">0</span> || rowIdx == numRows - <span class="number">1</span>) goingDown = !goingDown;</span><br><span class="line">          rowIdx += goingDown ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      string result;</span><br><span class="line">      <span class="keyword">for</span> (string row : rowStrs) result += row;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-整数反转">7. 整数反转</h2>
<ul>
<li>
<ol start="7">
<li>Reverse Integer</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-integer">https://leetcode-cn.com/problems/reverse-integer</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>
示例 1:<br>
输入: 123<br>
输出: 321<br>
 示例 2:<br>
输入: -123<br>
输出: -321<br>
示例 3:<br>
输入: 120<br>
输出: 21</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ans &gt; <span class="number">214748364</span> || ans &lt; <span class="number">-214748364</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          ans = ans*<span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">          x /= <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-字符串转换整数-atoi">8. 字符串转换整数 (atoi)</h2>
<ul>
<li>
<ol start="8">
<li>String to Integer (atoi)</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-to-integer-atoi">https://leetcode-cn.com/problems/string-to-integer-atoi</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br>
如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br>
在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br>
提示：<br>
本题中的空白字符只包括空格字符 ’ ’ 。<br>
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
输入: “42”<br>
输出: 42<br>
示例 2:<br>
输入: &quot;   -42&quot;<br>
输出: -42<br>
解释: 第一个非空白字符为 ‘-’, 它是一个负号。<br>
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>
示例 3:<br>
输入: “4193 with words”<br>
输出: 4193<br>
解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>
示例 4:<br>
输入: “words and 987”<br>
输出: 0<br>
解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>
因此无法执行有效的转换。<br>
示例 5:<br>
输入: “-91283472332”<br>
输出: -2147483648<br>
解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>
     因此返回 INT_MIN (−231) 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Automaton</span> &#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_col</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;in_number&quot;</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="type">long</span> <span class="type">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="type">long</span> <span class="type">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;signed&quot;</span>)</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">         Automaton automaton;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s)</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-回文数">9.回文数</h2>
<ul>
<li>
<ol start="9">
<li>Palindrome Number</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-number">https://leetcode-cn.com/problems/palindrome-number</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>
示例 1:<br>
输入: 121<br>
输出: true<br>
示例 2:<br>
输入: -121<br>
输出: false<br>
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>
示例 3:<br>
输入: 10<br>
输出: false<br>
解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//后半段与前半段对比</span></span><br><span class="line">       <span class="type">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">           revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">           x /= <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-正则表达式匹配">10. 正则表达式匹配</h2>
<ul>
<li>
<ol start="10">
<li>Regular Expression Matching</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching">https://leetcode-cn.com/problems/regular-expression-matching</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<blockquote>
<p>‘.’ 匹配任意单个字符<br>
‘*’ 匹配零个或多个前面的那一个元素<br>
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
</blockquote>
<p></p>
<blockquote>
<p>示例 1：<br>
输入：s = “aa” p = “a”<br>
输出：false<br>
解释：“a” 无法匹配 “aa” 整个字符串。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入：s = “aa” p = “a*”<br>
输出：true<br>
解释：因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：s = “ab” p = “.*”<br>
输出：true<br>
解释：“.*” 表示可匹配零个或多个（‘*’）任意字符（‘.’）。</p>
</blockquote>
<blockquote>
<p>示例 4：<br>
输入：s = “aab” p = “c*a*b”<br>
输出：true<br>
解释：因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>
</blockquote>
<blockquote>
<p>示例 5：<br>
输入：s = “mississippi” p = “mis*is*p*.”<br>
输出：false</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// dp[i][j]表示str[1:i]和pattern[1:j]能否匹配，为0表示无法匹配，为1表示可以匹配</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 分析状态转移方程</span></span><br><span class="line"><span class="comment">//   对于dp[i][j]，如果str[i]与p[j]相同或者p[j]为.，则dp[i][j] = dp[i-1][j-1]，即与s[1:i-1]和p[1:j-1]的匹配情况相同</span></span><br><span class="line"><span class="comment">//   如果p[j]为*，则表示这个字符可以联合p[j-1]使用来匹配当前的s[i](这个选择可做可不做，但我们尽量去匹配字符串)</span></span><br><span class="line"><span class="comment">//   考虑p[j]为*，如果p前一个字符为.，显然可以用一次.*组合匹配到s[i]，如果p前一个字符p[j-1]不为.并且不与s[i]相同，则不能使用</span></span><br><span class="line"><span class="comment">//   综合考虑，若p[j]==&#x27;*&#x27;</span></span><br><span class="line"><span class="comment">//   1. 不选择替换，使用0次*，dp[i][j] = dp[i][j-2]</span></span><br><span class="line"><span class="comment">//   2. 当p[j-1]为.或者与s[i]相同时，可以使用一次替换，则dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="comment">//   两者求或 (因为我们尽可能去匹配字符串，所以只要有一种情况匹配成功，则匹配成功)</span></span><br><span class="line"><span class="comment">// 初始化主要考虑p去匹配一个空串的情况，和上面类似的分析过程即可得出结论</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//s 的前 0 个是否能被 p 的前 j 个匹配</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; p.<span class="built_in">size</span>(); ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[<span class="number">0</span>][j + <span class="number">1</span>] = dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; p.<span class="built_in">size</span>(); ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>)<span class="comment">//匹配单个字符  </span></span><br><span class="line">			&#123;</span><br><span class="line">				dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i] != p[j - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">1</span>] != <span class="string">&#x27;.&#x27;</span>)<span class="comment">//前一对字符匹配</span></span><br><span class="line">				&#123;</span><br><span class="line">					dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>] || <span class="comment">//*表示匹配超过一个字符(s[i]、s[i-1]和p[j-1])</span></span><br><span class="line">						<span class="comment">//dp[i + 1][j] || //*表示只匹配一个字符（s[i]和p[j-1]）</span></span><br><span class="line">						dp[i + <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//*表示0个匹配</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][p.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-盛最多水的容器">11. 盛最多水的容器</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>
说明：你不能倾斜容器，且 n 的值至少为 2。</p>
</blockquote>
<blockquote>
<p>示例：<br>
输入：[1,8,6,2,5,4,8,3,7]<br>
输出：49</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxVolume = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//取左端与右端</span></span><br><span class="line">            <span class="type">int</span> lh = height[left];</span><br><span class="line">            <span class="type">int</span> rh = height[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算体积</span></span><br><span class="line">            <span class="type">int</span> vol = <span class="built_in">min</span>(lh, rh) * (right-left);</span><br><span class="line">            <span class="comment">//设置最大体积</span></span><br><span class="line">            maxVolume = <span class="built_in">max</span>(maxVolume, vol);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//哪端的指针移动，取决于哪根柱子更低</span></span><br><span class="line">            left += (lh &lt;= rh) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            right -= (lh &gt; rh) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;left:&quot;</span>&lt;&lt;left&lt;&lt;<span class="string">&quot;,right:&quot;</span>&lt;&lt;right&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxVolume;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-电话号码的字母组合">17. 电话号码的字母组合</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
</blockquote>
<p><img src="/img/1604578953107.png" alt="17"></p>
<blockquote>
<p>示例:<br>
输入：“23”<br>
输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>
说明:<br>
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">      map&lt;<span class="type">int</span>,vector&lt;<span class="type">char</span>&gt;&gt; numsMap;</span><br><span class="line">      numsMap.<span class="built_in">insert</span>(map&lt; <span class="type">int</span>, vector&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">value_type</span>(<span class="number">2</span>, vector&lt;<span class="type">char</span>&gt;&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;));</span><br><span class="line">      numsMap.<span class="built_in">insert</span>(map&lt; <span class="type">int</span>, vector&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, vector&lt;<span class="type">char</span>&gt;&#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;));</span><br><span class="line">      numsMap.<span class="built_in">insert</span>(map&lt; <span class="type">int</span>, vector&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">value_type</span>(<span class="number">4</span>, vector&lt;<span class="type">char</span>&gt;&#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;));</span><br><span class="line">      numsMap.<span class="built_in">insert</span>(map&lt; <span class="type">int</span>, vector&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">value_type</span>(<span class="number">5</span>, vector&lt;<span class="type">char</span>&gt;&#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;));</span><br><span class="line">      numsMap.<span class="built_in">insert</span>(map&lt; <span class="type">int</span>, vector&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">value_type</span>(<span class="number">6</span>, vector&lt;<span class="type">char</span>&gt;&#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;));</span><br><span class="line">      numsMap.<span class="built_in">insert</span>(map&lt; <span class="type">int</span>, vector&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">value_type</span>(<span class="number">7</span>, vector&lt;<span class="type">char</span>&gt;&#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;));</span><br><span class="line">      numsMap.<span class="built_in">insert</span>(map&lt; <span class="type">int</span>, vector&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">value_type</span>(<span class="number">8</span>, vector&lt;<span class="type">char</span>&gt;&#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;));</span><br><span class="line">      numsMap.<span class="built_in">insert</span>(map&lt; <span class="type">int</span>, vector&lt;<span class="type">char</span>&gt;&gt;::<span class="built_in">value_type</span>(<span class="number">9</span>, vector&lt;<span class="type">char</span>&gt;&#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*输入：&quot;23&quot;</span></span><br><span class="line"><span class="comment">          输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].*/</span></span><br><span class="line">      map&lt;string, <span class="type">int</span>&gt; resultMap;</span><br><span class="line">      vector&lt;string&gt; result;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; digits.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="type">int</span> v = digits[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">          <span class="keyword">if</span> (numsMap.<span class="built_in">count</span>(v) == <span class="number">0</span>) &#123;</span><br><span class="line">              result.<span class="built_in">clear</span>();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          vector&lt;<span class="type">char</span>&gt; curChars = numsMap[v];</span><br><span class="line">          <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              vector&lt;string&gt; tmpList;</span><br><span class="line">              <span class="keyword">for</span>(string val : result) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="type">char</span> c : curChars) &#123;</span><br><span class="line">                      tmpList.<span class="built_in">push_back</span>(val + c);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              result.<span class="built_in">clear</span>();</span><br><span class="line">              result = tmpList;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">auto</span> it = curChars.<span class="built_in">begin</span>(); it != curChars.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">                	<span class="type">char</span> v = *it;</span><br><span class="line">		    result.<span class="built_in">push_back</span>(<span class="built_in">string</span> (<span class="number">1</span>,v));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-三数之和">15.三数之和</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum">https://leetcode-cn.com/problems/3sum</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。<br>
注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<blockquote>
<p>示例：<br>
给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>
满足要求的三元组集合为：<br>
[<br>
[-1, 0, 1],<br>
[-1, -1, 2]<br>
]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());   <span class="comment">// -4  -1  -1  0  1  2</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = i+<span class="number">1</span>, k = nums.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nums[k] == nums[k+<span class="number">1</span>])&#123;</span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] + nums[k] &gt; <span class="number">-1</span>*nums[i])&#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j] + nums[k] &lt; <span class="number">-1</span>*nums[i])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                j++, k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第N个节点">19.删除链表的倒数第N个节点</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>
示例：<br>
给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>
说明：<br>
给定的 n 保证是有效的。<br>
进阶：<br>
你能尝试使用一趟扫描实现吗？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">      ListNode* slow = head;</span><br><span class="line">      ListNode* fast = head;</span><br><span class="line">      ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          fast = fast-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          pre = slow;</span><br><span class="line">          slow = slow-&gt;next;</span><br><span class="line">          fast = fast-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          pre-&gt;next = slow-&gt;next;</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h2 id="20-有效的括号">20. 有效的括号</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串，判断字符串是否有效。<br>
有效字符串需满足：<br>
左括号必须用相同类型的右括号闭合。<br>
左括号必须以正确的顺序闭合。<br>
注意空字符串可被认为是有效字符串。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
输入: “()”<br>
输出: true<br>
示例 2:<br>
输入: “()[]{}”<br>
输出: true<br>
示例 3:<br>
输入: “(]”<br>
输出: false<br>
示例 4:<br>
输入: “([)]”<br>
输出: false<br>
示例 5:<br>
输入: “{[]}”<br>
输出: true</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">       map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; cMap = &#123;</span><br><span class="line">           &#123;<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>&#125;,</span><br><span class="line">           &#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>)<span class="comment">//奇数必然不对</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       stack&lt;<span class="type">char</span>&gt; cs;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cMap.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (cs.<span class="built_in">empty</span>() || cs.<span class="built_in">top</span>() != cMap[c]) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               cs.<span class="built_in">pop</span>();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               cs.<span class="built_in">push</span>(c);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cs.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-括号生成">22. 括号生成</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses">https://leetcode-cn.com/problems/generate-parentheses</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
</blockquote>
<blockquote>
<p>示例：<br>
输入：n = 3<br>
输出：[<br>
“((()))”,<br>
“(()())”,<br>
“(())()”,<br>
“()(())”,<br>
“()()()”<br>
]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoopGetParanthesis</span><span class="params">(vector&lt;string&gt; &amp; result,string str,<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">           result.<span class="built_in">push_back</span>(str);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//左右括号数相等，则只用左括号</span></span><br><span class="line">       <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">           <span class="built_in">LoopGetParanthesis</span>(result, str + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">           <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">LoopGetParanthesis</span>(result, str + <span class="string">&quot;(&quot;</span>, left<span class="number">-1</span>, right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">LoopGetParanthesis</span>(result, str + <span class="string">&quot;)&quot;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">       vector&lt;string&gt; result;</span><br><span class="line">       string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="built_in">LoopGetParanthesis</span>(result, str, n, n);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="26-删除排序数组中的重复项">26.删除排序数组中的重复项</h2>
<ul>
<li>
<ol start="26">
<li>Remove Duplicates from Sorted Array</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
给定数组 nums = [1,1,2],<br>
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>
你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>
你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> thumb = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[thumb])&#123;</span><br><span class="line">                thumb ++;</span><br><span class="line">                nums[thumb] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thumb+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="27-移除元素">27. 移除元素</h2>
<ul>
<li>
<ol start="27">
<li>Remove Element</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
给定 nums = [3,2,2,3], val = 3,<br>
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>
你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>
注意这五个元素可为任意顺序。<br>
你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> thumb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">                nums[thumb] = nums[i];</span><br><span class="line">                thumb ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thumb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="28-实现-strStr">28. 实现 strStr()</h2>
<ul>
<li>
<ol start="28">
<li>Implement strStr()</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr">https://leetcode-cn.com/problems/implement-strstr</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>实现 strStr() 函数。<br>
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
输入: haystack = “hello”, needle = “ll”<br>
输出: 2</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: haystack = “aaaaa”, needle = “bba”<br>
输出: -1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, source: <span class="built_in">str</span>, target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> source == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        source_len = <span class="built_in">len</span>(source)</span><br><span class="line">        target_len = <span class="built_in">len</span>(target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target_len &gt; source_len:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(source_len):</span><br><span class="line">            target_index = i + target_len</span><br><span class="line">            <span class="keyword">if</span> target_index &gt; source_len:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> source[i:target_index] == target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="29-两数相除">29. 两数相除</h2>
<ul>
<li>
<ol start="29">
<li>Divide Two Integers</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divide-two-integers">https://leetcode-cn.com/problems/divide-two-integers</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>
返回被除数 dividend 除以除数 divisor 得到的商。<br>
整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
</blockquote>
<p></p>
<blockquote>
<p>示例 1:<br>
输入: dividend = 10, divisor = 3<br>
输出: 3<br>
解释: 10/3 = truncate(3.33333…) = truncate(3) = 3</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: dividend = 7, divisor = -3<br>
输出: -2<br>
解释: 7/-3 = truncate(-2.33333…) = -2</p>
</blockquote>
<blockquote>
<p>提示：<br>
被除数和除数均为 32 位有符号整数。<br>
除数不为 0。<br>
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        abs_dividend = <span class="built_in">abs</span>(dividend)</span><br><span class="line">        abs_divisor = <span class="built_in">abs</span>(divisor)</span><br><span class="line">        <span class="keyword">if</span> abs_dividend &lt; abs_divisor:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        is_neg = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(dividend + divisor) != abs_dividend + abs_divisor:</span><br><span class="line">            is_neg = <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;abs_dividend &gt;&gt; %d : %d, %d, &#x27;</span>% (i, abs_dividend &gt;&gt; i, abs_divisor))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> abs_dividend &gt;&gt; i &gt;= abs_divisor:</span><br><span class="line">                ans += <span class="number">1</span> &lt;&lt; i</span><br><span class="line">                abs_dividend -= abs_divisor &lt;&lt; i</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;good value: %d, %d&#x27;</span>%(ans, abs_dividend))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> is_neg <span class="keyword">and</span> ans &gt;= <span class="number">2</span> ** <span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">2</span> ** <span class="number">31</span></span><br><span class="line">        <span class="keyword">elif</span> ans &gt;= <span class="number">2</span> ** <span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> is_neg:</span><br><span class="line">            <span class="keyword">return</span> -ans</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="30-串联所有单词的子串">30. 串联所有单词的子串</h2>
<ul>
<li>
<ol start="30">
<li>Substring with Concatenation of All Words</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。<br>
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p>
</blockquote>
<blockquote>
<p>示例 1：<br>
输入：<br>
s = “barfoothefoobarman”,<br>
words = [“foo”,“bar”]<br>
输出：[0,9]<br>
解释：<br>
从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>
输出的顺序不重要, [9,0] 也是有效答案。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：<br>
s = “wordgoodgoodgoodbestword”,<br>
words = [“word”,“good”,“best”,“word”]<br>
输出：[]</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s, words</span>):</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> words:<span class="keyword">return</span> []</span><br><span class="line">        one_word = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">        all_len = <span class="built_in">len</span>(words) * one_word</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        words = Counter(words)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - all_len + <span class="number">1</span>):</span><br><span class="line">            tmp = s[i:i+all_len]</span><br><span class="line">            c_tmp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, all_len, one_word):</span><br><span class="line">                c_tmp.append(tmp[j:j+one_word])</span><br><span class="line">            <span class="keyword">if</span> Counter(c_tmp) == words:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="41-缺失的第一个正数">41. 缺失的第一个正数</h2>
<ul>
<li>
<ol start="41">
<li>First Missing Positive</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-missing-positive">https://leetcode-cn.com/problems/first-missing-positive</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
输入: [1,2,0]<br>
输出: 3</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: [3,4,-1,1]<br>
输出: 2</p>
</blockquote>
<blockquote>
<p>示例 3:<br>
输入: [7,8,9,11,12]<br>
输出: 1</p>
</blockquote>
<blockquote>
<p>提示：<br>
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 总长</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 1. 全部元素没有1，返回1</span></span><br><span class="line">        <span class="type">bool</span> noOne = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                noOne = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(noOne)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 只有一个元素，且为[1]，则返回2</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 去&lt;= 0与 &gt; 总数的数，将其设为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n<span class="number">-1</span>)&#123;</span><br><span class="line">                cout &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">1</span> || nums[i] &gt; n)&#123;</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.遍历，当值 == 总数。第一个值设为负数. 当值 &lt;= 总数，以值为下标设置为负值. 特别的，当值为总数时，将第一个值为负值！</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">             <span class="type">int</span> a = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">             <span class="keyword">if</span>(a == n)&#123;</span><br><span class="line">                 nums[<span class="number">0</span>] = - <span class="built_in">abs</span>(nums[<span class="number">0</span>]);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[a] = - <span class="built_in">abs</span>(nums[a]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v: nums)&#123;</span><br><span class="line">            cout &lt;&lt; v &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.遍历最新的数组中，发现有大于0，此索引就是丢失的最小正数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.5如果没有找到，第一值取出来如果是正数，则数为正数N</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.如果以上走完了，返回n+1</span></span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="42-接雨水">42. 接雨水</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water">https://leetcode-cn.com/problems/trapping-rain-water</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>
示例 1：</p>
</blockquote>
<p><img src="/img/1604063667003.png" alt="接雨水"></p>
<blockquote>
<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>
输出：6<br>
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>
示例 2：<br>
输入：height = [4,2,0,3,2,5]<br>
输出：9</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">          <span class="comment">//情况1：左比右低，只有当左边最高柱比当前柱要高，则这个落差必定是能装水的。</span></span><br><span class="line">          <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">              height[left] &gt;= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);</span><br><span class="line">              ++left;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;<span class="comment">//情况2：右比左低，只有当右边最高柱比当前柱要高，则这个落差必定是能装水的。</span></span><br><span class="line">              height[right] &gt;= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);</span><br><span class="line">              --right;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="51-N皇后-52-N皇后-II">51. N皇后 &amp; 52. N皇后 II</h2>
<ul>
<li>
<ol start="51">
<li>N-Queens</li>
</ol>
</li>
<li>
<ol start="52">
<li>N-Queens II</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens">https://leetcode-cn.com/problems/n-queens</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
</blockquote>
<p><img src="/img/1601178139148.png" alt="8皇后的一种解法"></p>
<blockquote>
<ol start="51">
<li>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>
每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</li>
<li>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NQueen</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_nqueen</span>(<span class="params">self, n</span>):</span><br><span class="line">        empty_sign = <span class="string">&quot;[O]&quot;</span></span><br><span class="line">        queen_sign = <span class="string">&quot;[1]&quot;</span></span><br><span class="line">        <span class="comment"># 所有数组起点都以0开始</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.定义所有解的容器，二维数组，第二维代表一个完整的解</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.递归函数dfs</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums, row</span>):</span><br><span class="line">            <span class="comment"># 如果找的行数与n相等了，说明已经找完了，得到一个解！</span></span><br><span class="line">            <span class="keyword">if</span> row == n:</span><br><span class="line">                ans.append(nums[:]) <span class="comment"># 注意不可用ans.append(nums)</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 逐列进行尝试，列的总数为n</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 每进行到一列，标记当前行皇后位置为此列</span></span><br><span class="line">                nums[row] = i</span><br><span class="line">                <span class="comment"># 往下递归找到，一直找到底，找不到底循环会返回到此处！</span></span><br><span class="line">                <span class="keyword">if</span> valid(nums, row):</span><br><span class="line">                    <span class="comment"># print(&quot;当前找到第%d行的第%d列，此值可放皇后！&quot;%(row, i))</span></span><br><span class="line">                    dfs(nums, row+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                    <span class="comment"># print(&quot;当前找到第%d行的第%d列，不可放，回溯&quot;%(row, i))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.检查函数valid</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">valid</span>(<span class="params">nums, row</span>):</span><br><span class="line">            <span class="comment"># 只找前面行的点， 皇后攻击规则，同列同行 和 对角线元素表示</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(nums[r] - nums[row]) == <span class="built_in">abs</span>(r - row) <span class="keyword">or</span> nums[r] == nums[row]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4.执行, 从第0行开始找n数组长度中的位置</span></span><br><span class="line">        dfs([<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_row_list</span>(<span class="params">row_val, count</span>):</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">                <span class="keyword">if</span> i == row_val:</span><br><span class="line">                    result.append(queen_sign)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append(empty_sign)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5.结果画出来</span></span><br><span class="line">        result = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ans))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ans)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> ans[i]:</span><br><span class="line">                result[i].append(<span class="string">&quot;&quot;</span>.join(get_row_list(col, n)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myqueen = NQueen()</span><br><span class="line">result = myqueen.do_nqueen(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解有%d个&quot;</span>%<span class="built_in">len</span>(result))</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">    r = <span class="built_in">str</span>(r)</span><br><span class="line">    <span class="built_in">print</span>(r+<span class="string">&quot;\n\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="75-颜色分类">75. 颜色分类</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>
注意:<br>
不能使用代码库中的排序函数来解决这道题。<br>
示例:<br>
输入: [2,0,2,1,1,0]<br>
输出: [0,0,1,1,2,2]<br>
进阶：<br>
一个直观的解决方案是使用计数排序的两趟扫描算法。<br>
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>
你能想出一个仅使用常数空间的一趟扫描算法吗？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> slow0 = <span class="number">0</span>, fast = <span class="number">0</span>, slow2 = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (fast &lt;= slow2) &#123;</span><br><span class="line">           <span class="keyword">while</span> (fast &lt;= slow2 &amp;&amp; nums[fast] == <span class="number">2</span>) &#123;</span><br><span class="line">               <span class="comment">//当当前快指针为2时，移至结尾。如果换完后的nums[fast]还是2？则继续换</span></span><br><span class="line">               nums[fast] = nums[slow2];</span><br><span class="line">               nums[slow2--] = <span class="number">2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (nums[fast] == <span class="number">0</span>) &#123;</span><br><span class="line">               nums[fast] = nums[slow0];</span><br><span class="line">               nums[slow0++] = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           fast++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串">76.最小覆盖子串</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring">https://leetcode-cn.com/problems/minimum-window-substring</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。<br>
示例：<br>
输入：S = “ADOBECODEBANC”, T = “ABC”<br>
输出：“BANC”</p>
</blockquote>
<blockquote>
<p>提示：<br>
如果 S 中不存这样的子串，则返回空字符串 “”。<br>
如果 S 中存在这样的子串，我们保证它是唯一的答案。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s == t) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">       map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">       <span class="type">int</span> tLen = t.<span class="built_in">length</span>();<span class="comment">//目标字符串</span></span><br><span class="line">       <span class="type">int</span> sLen = s.<span class="built_in">length</span>();</span><br><span class="line">       <span class="keyword">if</span> (tLen == <span class="number">0</span> || sLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">if</span> (sLen &lt; tLen )</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//先把t中的字符放到need表中，计数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tLen; i++) &#123;</span><br><span class="line">           <span class="type">char</span> c = t[i];</span><br><span class="line">           need[c] = ((need.<span class="built_in">count</span>(c) == <span class="number">0</span>)?<span class="number">0</span>:need[c]) + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> len = INT32_MAX, start = <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> valid = <span class="number">0</span>; <span class="comment">//已经匹配成功的字符种类数（非字符个数）</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//当右指针去到字符串末尾前</span></span><br><span class="line">       <span class="keyword">while</span> (right &lt; sLen) &#123;</span><br><span class="line">           <span class="type">char</span> c = s[right];</span><br><span class="line">           right++;<span class="comment">//右指针向右滑</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//如果右指针现在滑到的字符是目标字符串的一个，那么更新窗口中的数据</span></span><br><span class="line">           <span class="keyword">if</span> (need.<span class="built_in">count</span>(c) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               window[c] = ((window.<span class="built_in">count</span>(c) == <span class="number">0</span>)?<span class="number">0</span>:window[c]) + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (window[c] == (need[c])) &#123;</span><br><span class="line">                   valid++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//窗口开始从左边收缩</span></span><br><span class="line">           <span class="keyword">while</span> (valid == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                   start = left;</span><br><span class="line">                   len = right - left;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="type">char</span> d = s[left];</span><br><span class="line">               left++;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (need.<span class="built_in">count</span>(d) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (window[d] == (need[d])) &#123;</span><br><span class="line">                       valid--;</span><br><span class="line">                   &#125;</span><br><span class="line">                   window[d] = window[d] - <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> len == INT32_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="80-删除排序数组中的重复项-II">80. 删除排序数组中的重复项 II</h2>
<ul>
<li>
<ol start="80">
<li>Remove Duplicates from Sorted Array II</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
给定 nums = [1,1,1,2,2,3],<br>
函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。<br>
你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
给定 nums = [0,0,1,1,1,1,2,3,3],<br>
函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。<br>
你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<blockquote>
<p>说明:<br>
为什么返回数值是整数，但输出的答案是数组呢?</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">2</span> || n &gt; nums[i<span class="number">-2</span>]) nums[i++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="127-单词接龙">127. 单词接龙</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder">https://leetcode-cn.com/problems/word-ladder</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br>
每次转换只能改变一个字母。<br>
转换过程中的中间单词必须是字典中的单词。</p>
</blockquote>
<blockquote>
<p>说明:<br>
如果不存在这样的转换序列，返回 0。<br>
所有单词具有相同的长度。<br>
所有单词只由小写字母组成。<br>
字典中不存在重复的单词。<br>
你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
输入:<br>
beginWord = “hit”,<br>
endWord = “cog”,<br>
wordList = [“hot”,“dot”,“dog”,“lot”,“log”,“cog”]<br>
输出: 5<br>
解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>
返回它的长度 5。<br>
示例 2:<br>
输入:<br>
beginWord = “hit”<br>
endWord = “cog”<br>
wordList = [“hot”,“dot”,“dog”,“lot”,“log”]<br>
输出: 0<br>
解释: endWord “cog” 不在字典中，所以无法进行转换。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; wordId;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edge;</span><br><span class="line">    <span class="type">int</span> nodeNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordId.<span class="built_in">count</span>(word)) &#123;</span><br><span class="line">            wordId[word] = nodeNum++;</span><br><span class="line">            edge.<span class="built_in">emplace_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addWord</span>(word);</span><br><span class="line">        <span class="type">int</span> id1 = wordId[word];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; it : word) &#123;</span><br><span class="line">            <span class="type">char</span> tmp = it;</span><br><span class="line">            it = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="built_in">addWord</span>(word);</span><br><span class="line">            <span class="type">int</span> id2 = wordId[word];</span><br><span class="line">            edge[id1].<span class="built_in">push_back</span>(id2);</span><br><span class="line">            edge[id2].<span class="built_in">push_back</span>(id1);</span><br><span class="line">            it = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; word : wordList) &#123;</span><br><span class="line">            <span class="built_in">addEdge</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addEdge</span>(beginWord);</span><br><span class="line">        <span class="keyword">if</span> (!wordId.<span class="built_in">count</span>(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(nodeNum, INT_MAX)</span></span>;</span><br><span class="line">        <span class="type">int</span> beginId = wordId[beginWord], endId = wordId[endWord];</span><br><span class="line">        dis[beginId] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(beginId);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (x == endId) &#123;</span><br><span class="line">                <span class="keyword">return</span> dis[endId] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>&amp; it : edge[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[it] == INT_MAX) &#123;</span><br><span class="line">                    dis[it] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="129-求根到叶子节点数字之和">129.求根到叶子节点数字之和</h2>
<ul>
<li>
<ol start="129">
<li>Sum Root to Leaf Numbers</li>
</ol>
</li>
<li></li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>
例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。<br>
计算从根到叶子节点生成的所有数字之和。<br>
说明: 叶子节点是指没有子节点的节点。</p>
</blockquote>
<p>示例 1:<br>
输入: [1,2,3]<br>
1<br>
/ <br>
2   3<br>
输出: 25<br>
解释:<br>
从根到叶子节点路径 1-&gt;2 代表数字 12.<br>
从根到叶子节点路径 1-&gt;3 代表数字 13.<br>
因此，数字总和 = 12 + 13 = 25.<br>
示例 2:</p>
<p>输入: [4,9,0,5,1]<br>
4<br>
/ <br>
9   0<br>
 / <br>
5   1<br>
输出: 1026<br>
解释:<br>
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>
从根到叶子节点路径 4-&gt;0 代表数字 40.<br>
因此，数字总和 = 495 + 491 + 40 = 1026.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs_sum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	queue&lt;TreeNode*&gt; q;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; qn;</span><br><span class="line"></span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	qn.<span class="built_in">push</span>(root-&gt;val);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">		<span class="type">int</span> nodeVal = qn.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		qn.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((node-&gt;left == <span class="literal">NULL</span>) &amp;&amp; (node-&gt;right == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			sum += nodeVal;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				qn.<span class="built_in">push</span>(nodeVal * <span class="number">10</span> + node-&gt;left-&gt;val);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">				qn.<span class="built_in">push</span>(nodeVal * <span class="number">10</span> + node-&gt;right-&gt;val);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_sum</span><span class="params">(TreeNode* node, <span class="type">int</span> prevSum)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sum = prevSum * <span class="number">10</span> + node-&gt;val;</span><br><span class="line">	<span class="comment">//左右都没有值 </span></span><br><span class="line">	<span class="keyword">if</span> ((node-&gt;left == <span class="literal">NULL</span>) &amp;&amp;(node-&gt;right == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		sum = <span class="built_in">dfs_sum</span>(node-&gt;left, sum) + <span class="built_in">dfs_sum</span>(node-&gt;right, sum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//return dfs_sum(root, 0);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bfs_sum</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="141-环形链表">141. 环形链表</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle">https://leetcode-cn.com/problems/linked-list-cycle</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个链表，判断链表中是否有环。<br>
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>
如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
</blockquote>
<blockquote>
<p>进阶<br>
你能用 O(1)（即，常量）内存解决此问题吗？</p>
</blockquote>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1<br>
输出：true<br>
解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="142-环形链表-II">142. 环形链表 II</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
</blockquote>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1<br>
输出：返回索引为 1 的链表节点<br>
解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">            ListNode * ptr = head;</span><br><span class="line">            <span class="keyword">while</span>(ptr != slow)&#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="144-二叉树的前序遍历">144. 二叉树的前序遍历</h2>
<ul>
<li>
<ol start="144">
<li>Binary Tree Preorder Traversal</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal">https://leetcode-cn.com/problems/binary-tree-preorder-traversal</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
</blockquote>
<blockquote>
<p>示例:<br>
输入: [1,null,2,3]<br>
1<br>
<br>
2<br>
/<br>
3<br>
输出: [1,2,3]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    stack&lt;TreeNode&gt; ss;</span><br><span class="line">    ss.<span class="built_in">push</span>(*root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode cur = ss.<span class="built_in">top</span>();</span><br><span class="line">        ss.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        result.<span class="built_in">push_back</span>(cur.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ss.<span class="built_in">push</span>(*cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ss.<span class="built_in">push</span>(*cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="189-旋转数组">189. 旋转数组</h2>
<ul>
<li>
<ol start="189">
<li>Rotate Array</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array">https://leetcode-cn.com/problems/rotate-array</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
</blockquote>
<blockquote>
<p>示例 1:<br>
输入: [1,2,3,4,5,6,7] 和 k = 3<br>
输出: [5,6,7,1,2,3,4]<br>
解释:<br>
向右旋转 1 步: [7,1,2,3,4,5,6]<br>
向右旋转 2 步: [6,7,1,2,3,4,5]<br>
向右旋转 3 步: [5,6,7,1,2,3,4]</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: [-1,-100,3,99] 和 k = 2<br>
输出: [3,99,-1,-100]<br>
解释:<br>
向右旋转 1 步: [99,-1,-100,3]<br>
向右旋转 2 步: [3,99,-1,-100]</p>
</blockquote>
<blockquote>
<p>说明:<br>
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>
要求使用空间复杂度为 O(1) 的 原地 算法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start,j = end; i &lt; j; i++,j--)&#123;</span><br><span class="line">            <span class="type">int</span> ftmp = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = ftmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()-k<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, nums.<span class="built_in">size</span>()-k, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="234-回文链表">234. 回文链表</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>请判断一个链表是否为回文链表。<br>
示例 1:<br>
输入: 1-&gt;2<br>
输出: false<br>
示例 2:<br>
输入: 1-&gt;2-&gt;2-&gt;1<br>
输出: true</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">endOfFirstHalf</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode* firstHalfEnd = <span class="built_in">endOfFirstHalf</span>(head);</span><br><span class="line">        ListNode* secondHalfStart = <span class="built_in">reverseList</span>(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = secondHalfStart;</span><br><span class="line">        <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd-&gt;next = <span class="built_in">reverseList</span>(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="283-移动零">283. 移动零</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>
输入: [0,1,0,3,12]<br>
输出: [1,3,12,0,0]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> lastNonZeroFoundAt = <span class="number">0</span>, cur = <span class="number">0</span>; cur &lt; nums.<span class="built_in">size</span>(); cur++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[cur] != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">swap</span>(nums[lastNonZeroFoundAt], nums[cur]);</span><br><span class="line">               lastNonZeroFoundAt++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="287-寻找重复数">287. 寻找重复数</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number">https://leetcode-cn.com/problems/find-the-duplicate-number</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>
示例 1:<br>
输入: [1,3,4,2,2]<br>
输出: 2<br>
示例 2:<br>
输入: [3,1,3,4,2]<br>
输出: 3<br>
说明：</p>
</blockquote>
<blockquote>
<p>不能更改原数组（假设数组是只读的）。<br>
只能使用额外的 O(1) 的空间。<br>
时间复杂度小于 O(n2) 。<br>
数组中只有一个重复的数字，但它可能不止重复出现一次。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           slow = nums[slow];</span><br><span class="line">           fast = nums[nums[fast]];</span><br><span class="line">       &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">       slow = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">           slow = nums[slow];</span><br><span class="line">           fast = nums[fast];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slow;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="299-猜数字游戏">299. 猜数字游戏</h2>
<ul>
<li>
<ol start="299">
<li>Bulls and Cows</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bulls-and-cows">https://leetcode-cn.com/problems/bulls-and-cows</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：<br>
你写出一个秘密数字，并请朋友猜这个数字是多少。<br>
朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。<br>
朋友根据提示继续猜，直到猜出秘密数字。<br>
请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。</p>
</blockquote>
<blockquote>
<p>xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。<br>
yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。<br>
请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。</p>
</blockquote>
<p></p>
<blockquote>
<p>示例 1:<br>
输入: secret = “1807”, guess = “7810”<br>
输出: “1A3B”<br>
解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: secret = “1123”, guess = “0111”<br>
输出: “1A1B”<br>
解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。</p>
</blockquote>
<blockquote>
<p>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> bulls = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cows = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ds[<span class="number">10</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dg[<span class="number">10</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; secret.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = secret[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> y = guess[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(secret[i] == guess[i])&#123;</span><br><span class="line">                bulls ++;    </span><br><span class="line">            &#125;</span><br><span class="line">            ds[x] ++;</span><br><span class="line">            dg[y] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//算出相同元素总数，当然减掉之前算好的cows</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            cows += <span class="built_in">min</span>(ds[i],dg[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cows -= bulls;</span><br><span class="line">        ostringstream oss;</span><br><span class="line">        oss &lt;&lt; bulls &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; cows &lt;&lt; <span class="string">&quot;B&quot;</span> ;</span><br><span class="line">        <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<h2 id="463-岛屿的周长">463. 岛屿的周长</h2>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/island-perimeter">https://leetcode-cn.com/problems/island-perimeter</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。<br>
网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。<br>
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
</blockquote>
<blockquote>
<p>示例 :<br>
输入:<br>
[[0,1,0,0],<br>
[1,1,1,0],<br>
[0,1,0,0],<br>
[1,1,0,0]]<br>
输出: 16</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">                    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        <span class="type">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="type">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || !grid[tx][ty]) &#123;</span><br><span class="line">                            cnt += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1207-独一无二的出现次数">1207.独一无二的出现次数</h2>
<ul>
<li>
<ol start="1207">
<li>Unique Number of Occurrences</li>
</ol>
</li>
</ul>
<p>来源：力扣（LeetCode）<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-number-of-occurrences">https://leetcode-cn.com/problems/unique-number-of-occurrences</a><br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<blockquote>
<p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。<br>
如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p>
</blockquote>
<blockquote>
<p>示例 1：<br>
输入：arr = [1,2,2,1,1,3]<br>
输出：true<br>
解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。<br>
示例 2：<br>
输入：arr = [1,2]<br>
输出：false<br>
示例 3：<br>
输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]<br>
输出：true</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; posMap;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		posMap[arr[i]] += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; uniqueSet;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : posMap)</span><br><span class="line">	&#123;</span><br><span class="line">		uniqueSet.<span class="built_in">insert</span>(item.second);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> posMap.<span class="built_in">size</span>() == uniqueSet.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/1603943631534.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/weixin.jpg" target="_blank"><img class="post-qr-code-img" src="/img/weixin.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/19/LWRPDesc/"><img class="prev-cover" src="/img/1578468743022.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LWRP官方说明</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/19/LeetcodeOrder/"><img class="next-cover" src="/img/1587017641511.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">力扣刷题顺序</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/my.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">霍家鹏</div><div class="author-info__description">Keep going! Keep study!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AveryHuo"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AveryHuo" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jackhamsir@sina.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎！欢迎来到我的博客空间，这里有我平时的学习心得和记录。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.</span> <span class="toc-text">1. 两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.</span> <span class="toc-text">2.两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">3.无重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">4. 寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">5. 最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">6.</span> <span class="toc-text">6.Z 字形变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="toc-number">7.</span> <span class="toc-text">7. 整数反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi"><span class="toc-number">8.</span> <span class="toc-text">8. 字符串转换整数 (atoi)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">9.回文数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">10.</span> <span class="toc-text">10. 正则表达式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">12.</span> <span class="toc-text">17. 电话号码的字母组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">13.</span> <span class="toc-text">15.三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">14.</span> <span class="toc-text">19.删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">15.</span> <span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">16.</span> <span class="toc-text">22. 括号生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">17.</span> <span class="toc-text">26.删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">18.</span> <span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E5%AE%9E%E7%8E%B0-strStr"><span class="toc-number">19.</span> <span class="toc-text">28. 实现 strStr()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="toc-number">20.</span> <span class="toc-text">29. 两数相除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="toc-number">21.</span> <span class="toc-text">30. 串联所有单词的子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">41. 缺失的第一个正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">23.</span> <span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E-52-N%E7%9A%87%E5%90%8E-II"><span class="toc-number">24.</span> <span class="toc-text">51. N皇后 &amp; 52. N皇后 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-number">25.</span> <span class="toc-text">75. 颜色分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">26.</span> <span class="toc-text">76.最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II"><span class="toc-number">27.</span> <span class="toc-text">80. 删除排序数组中的重复项 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="toc-number">28.</span> <span class="toc-text">127. 单词接龙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-number">29.</span> <span class="toc-text">129.求根到叶子节点数字之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">30.</span> <span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-number">31.</span> <span class="toc-text">142. 环形链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">32.</span> <span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">33.</span> <span class="toc-text">189. 旋转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">34.</span> <span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">35.</span> <span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="toc-number">36.</span> <span class="toc-text">287. 寻找重复数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#299-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="toc-number">37.</span> <span class="toc-text">299. 猜数字游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF"><span class="toc-number">38.</span> <span class="toc-text">463. 岛屿的周长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="toc-number">39.</span> <span class="toc-text">1207.独一无二的出现次数</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/20/C++11NewFeatures/" title="C++ 11新特性">C++ 11新特性</a><time datetime="2023-02-25T07:07:26.000Z" title="更新于 2023-02-25 15:07:26">2023-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/20/C++Review3/" title="C++ 复习3">C++ 复习3</a><time datetime="2023-02-24T02:03:22.000Z" title="更新于 2023-02-24 10:03:22">2023-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/GAMES104_NOTE4/" title="GAMES104-NOTE4"><img src="/img/image-20230106174810993.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAMES104-NOTE4"/></a><div class="content"><a class="title" href="/2023/02/01/GAMES104_NOTE4/" title="GAMES104-NOTE4">GAMES104-NOTE4</a><time datetime="2023-02-18T09:36:27.000Z" title="更新于 2023-02-18 17:36:27">2023-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/C++Review2/" title="C++ 复习2"><img src="/img/image-20230202174221474.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 复习2"/></a><div class="content"><a class="title" href="/2023/02/01/C++Review2/" title="C++ 复习2">C++ 复习2</a><time datetime="2023-02-16T08:03:33.000Z" title="更新于 2023-02-16 16:03:33">2023-02-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/19/C++Review1/" title="C++ 复习1">C++ 复习1</a><time datetime="2023-02-01T07:38:50.000Z" title="更新于 2023-02-01 15:38:50">2023-02-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By 霍家鹏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn"><img class="icp-icon" src="icp图片"><span>粤ICP备2020091327号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>