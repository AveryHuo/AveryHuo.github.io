<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++ 复习2 | Avery的城堡</title><meta name="keywords" content="C++"><meta name="author" content="霍家鹏"><meta name="copyright" content="霍家鹏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、概述 C++ 起源于1983年，1.0正式版于1998年发布又叫C++98。 2.0版本为C++11（即2011年推出的大版本）。 C++ 简单来说由 语言+标准库组成 C语言的缺点：数据-&gt; 函数的处理方式，导致数据一定是全局才能给各个函数处理。这时C++的面向对象思想就解决了这一问题 c++ 用 class 将member data和member function包在一起来创建obj">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 复习2">
<meta property="og:url" content="http://www.hjp.wiki/2023/02/01/C++Review2/index.html">
<meta property="og:site_name" content="Avery的城堡">
<meta property="og:description" content="一、概述 C++ 起源于1983年，1.0正式版于1998年发布又叫C++98。 2.0版本为C++11（即2011年推出的大版本）。 C++ 简单来说由 语言+标准库组成 C语言的缺点：数据-&gt; 函数的处理方式，导致数据一定是全局才能给各个函数处理。这时C++的面向对象思想就解决了这一问题 c++ 用 class 将member data和member function包在一起来创建obj">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.hjp.wiki/img/image-20230202174221474.png">
<meta property="article:published_time" content="2023-02-01T14:43:40.000Z">
<meta property="article:modified_time" content="2023-02-16T08:03:33.000Z">
<meta property="article:author" content="霍家鹏">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.hjp.wiki/img/image-20230202174221474.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.hjp.wiki/2023/02/01/C++Review2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 霍家鹏","link":"链接: ","source":"来源: Avery的城堡","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 复习2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-16 16:03:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/my.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">97</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Avery的城堡</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++ 复习2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-01T14:43:40.000Z" title="发表于 2023-02-01 22:43:40">2023-02-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-16T08:03:33.000Z" title="更新于 2023-02-16 16:03:33">2023-02-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CPlusPlus/">CPlusPlus</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ 复习2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="一、概述">一、概述</h2>
<p>C++ 起源于1983年，1.0正式版于1998年发布又叫C++98。 2.0版本为C++11（即2011年推出的大版本）。<br>
C++ 简单来说由 语言+标准库组成</p>
<p>C语言的缺点：数据-&gt; 函数的处理方式，导致数据一定是全局才能给各个函数处理。这时C++的面向对象思想就解决了这一问题<br>
c++ 用 class 将member data和member function包在一起来创建object<br>
延展文件名（extension file name）不一定是.h或.cpp，可能是.hpp甚至没有。</p>
<h2 id="二、文件头与类">二、文件头与类</h2>
<h3 id="2-1-Header（头文件）中的防卫式声明（guard）">2.1 Header（头文件）中的防卫式声明（guard）</h3>
<p>为了防止多次include复制执行，保证只被一次include，使用防卫式声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line">内容</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议所有头文件都有这个声明</p>
</blockquote>
<h3 id="2-2-头文件内容布局">2.2 头文件内容布局</h3>
<p>前置声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>; </span><br></pre></td></tr></table></figure>
<ul>
<li>类声明</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;....&#125;</span><br></pre></td></tr></table></figure>
<p>+类定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">complex::function ...</span><br></pre></td></tr></table></figure>
<h3 id="2-3-模板类的初探">2.3 模板类的初探</h3>
<p>根据使用者需要的类型来决定：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">complex</span>(T r = <span class="number">0</span>, T i = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">re</span>(r),<span class="built_in">im</span>(i)   <span class="comment">//initialization list（初值列，初始列）</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;);</span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125; <span class="comment">//函数若在class body内定义，便会自动定义完成，变自动成为inline候选人</span></span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    T re,im;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> complex&amp; __doapl(complex*, <span class="type">const</span> complex&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1.2</span>,<span class="number">2.1</span>)</span></span>;</span><br><span class="line"><span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-inline">2.4 inline</h3>
<p>相较于没有inline标识，会更快，通常于class内定义的函数会成为inline的候选人。对外部的需要自己加inline来设置。</p>
<blockquote>
<p>只是给编译器的建议，是否能变成inline取决于编译器是否能够。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">imag</span><span class="params">(<span class="type">const</span> complex&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-构造函数">2.5 构造函数</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>，<span class="number">1</span>)</span></span>;</span><br><span class="line">complex c2;</span><br><span class="line">complex* p = <span class="keyword">new</span> <span class="built_in">complex</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造函数还可以给默认值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span>(T r = <span class="number">0</span>, T i = <span class="number">0</span>) : <span class="built_in">re</span>(r),<span class="built_in">im</span>(i)   <span class="comment">//initialization list（初值列，初始列）&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>初值列与初始列的写法与写到函数内实质上是一样的。但区别的是，变量的赋值分为初始化和赋值化阶段，初值列就是分出来初始化的阶段。</p>
<blockquote>
<p>不带指针的类，多半不用写析构函数</p>
</blockquote>
<h3 id="2-6-函数重载">2.6 函数重载</h3>
<p>常出现在构造函数上。对于有默认参数的情况下，重载可能会错误</p>
<h3 id="2-7-Private域的构造函数">2.7 Private域的构造函数</h3>
<p>一般情况下，构造函数不放在private，因此放在private就不允许创建了。<br>
但是对于单例模式下就可以使用private构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">setup</span>()&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-const">2.8 const</h3>
<p>对于不改变数据的函数的，在花括号前加const。但const也需要保证统一性，如果在类对象为const时，则不可以调用非const函数了。如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; c1.<span class="built_in">real</span>(); <span class="comment">//如果real()没加const标识，这里就会报错</span></span><br><span class="line">cout &lt;&lt; c1.<span class="built_in">imag</span>(); <span class="comment">//如果 imag()没加const标识，这里就会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="2-9-pass-by-value-refrence">2.9 pass by value/refrence</h3>
<ol>
<li>value<br>
整个压到函数栈里</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span>(T r = <span class="number">0</span>, T i = <span class="number">0</span>) </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>reference<br>
推荐：尽量传引用<br>
底层就是指针的形式，传引用就是传指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果函数体内修改，则会报错。注意如果不加const，则会对原地址内内容影响</span></span><br><span class="line">complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;);</span><br></pre></td></tr></table></figure>
<h3 id="2-10-return-by-value-refrence">2.10 return by value/refrence</h3>
<ol>
<li>value</li>
<li>reference<br>
传递者无需知道接收者是以reference形式传递。<br>
推荐使用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;);</span><br></pre></td></tr></table></figure>
<h3 id="2-11-friend">2.11 friend</h3>
<p>friend函数内可以直接拿对象中的Private数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> complex&amp; __doapl(complex*, <span class="type">const</span> complex&amp;);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doapl (complex* ths,<span class="type">const</span> complex&amp; r)&#123;</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class内对于其他同类对象来说，是互为友元的！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">func</span><span class="params">(complex &amp;param)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> param.re + param.im;<span class="comment">//不报错，可以直接拿到re, im私有变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下调用是成功的</span></span><br><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1.3</span>,<span class="number">4.5</span>)</span></span>;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; b;</span><br><span class="line">std::cout &lt;&lt; b.<span class="built_in">func</span>(a) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="2-12-传递方式的选择">2.12 传递方式的选择</h3>
<p>对于函数体内新建对象的返回，不能传引用，因为此对象为局部的，离开函数即被销毁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp; __doapl(complex* ths, <span class="type">const</span> complex&amp; r)&#123;</span><br><span class="line">    ths-&gt;re += r.re;    <span class="comment">//第一参数将会被改动</span></span><br><span class="line">    ths-&gt;im += r.im;    <span class="comment">//第二参数不会被改动</span></span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp; complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex&amp; r)&#123;</span><br><span class="line">    <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">imag</span><span class="params">(<span class="type">const</span> complex&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">real</span><span class="params">(<span class="type">const</span> complex&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">real</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-13-操作符重载">2.13 操作符重载</h3>
<p>在C++中，操作符运算也可以是一种函数<br>
成员函数(带有this指针的情况)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c2 += c1 成员函数内的第一个参数实际应为this，但被默认隐藏了，这个this就是c2</span></span><br><span class="line"><span class="keyword">inline</span> complex&amp; </span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex&amp; r)&#123;</span><br><span class="line">    <span class="keyword">return</span> __doapl(<span class="keyword">this</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个有趣的事情是，可以把返回值改为void，这样也能支持c2+=c1，但无法支持c3+=c2+=c1这种连串的表达式。</span></span><br></pre></td></tr></table></figure>
<p>非成员函数，没有this的pointer，全域的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">imag</span><span class="params">(<span class="type">const</span> complex&lt;T&gt;&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">imag</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">real</span><span class="params">(<span class="type">const</span> complex&lt;T&gt;&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">real</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> complex&lt;T&gt;</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&lt;T&gt;&amp; x, <span class="type">const</span> complex&lt;T&gt;&amp; y)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>&lt;T&gt;(<span class="built_in">real</span>(x) + <span class="built_in">real</span>(y),</span><br><span class="line">                   <span class="built_in">imag</span>(x) + <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> complex&lt;T&gt;</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&lt;T&gt;&amp; x, <span class="type">const</span> T&amp; y)&#123;<span class="comment">//这里需要对y参数加const，不然就无法使用实际的右值做为参数，加了const可以做为右值使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>&lt;T&gt;(<span class="built_in">real</span>(x) + y, <span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> complex&lt;T&gt;</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> T&amp; x,<span class="type">const</span> complex&lt;T&gt;&amp; y)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>&lt;T&gt;(x + <span class="built_in">real</span>(y), <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数是可以改成return by reference</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> complex&lt;T&gt;</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> complex&lt;T&gt;&amp;</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;/</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> complex&lt;T&gt;</span><br><span class="line"><span class="keyword">operator</span> - (<span class="type">const</span> complex&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>&lt;T&gt;(-<span class="built_in">real</span>(x), -<span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1.3</span>,<span class="number">4.5</span>)</span></span>;</span><br><span class="line"><span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1.3</span>,<span class="number">4.5</span>)</span></span>;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; c;</span><br><span class="line">c = a + b;</span><br><span class="line">std::cout &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; std::endl;</span><br><span class="line">c = b + <span class="number">5.1</span>;</span><br><span class="line">std::cout &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; std::endl;</span><br><span class="line">c = <span class="number">5.1</span> + a;</span><br><span class="line">std::cout &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; std::endl;</span><br><span class="line">c = + a; <span class="comment">// 1.3</span></span><br><span class="line">std::cout &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; std::endl;</span><br><span class="line">c = - a; <span class="comment">// -1.3</span></span><br><span class="line">std::cout &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>共轭复数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//共轭复数：实部相同，虚部相反</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> complex&lt;T&gt; <span class="title">conj</span><span class="params">(<span class="type">const</span> complex&lt;T&gt;&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>&lt;T&gt;(<span class="built_in">real</span>(x), -<span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-14-临时对象">2.14 临时对象</h3>
<p>直接在类型后用（）生成临时对象，代码离开后就被销毁。标准库中大量使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span>&lt;<span class="type">double</span>&gt;(<span class="number">1.4</span>,<span class="number">4.5</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-15-符号">2.15 &lt;&lt; 符号</h3>
<p>output operator 输出运算符：此类运算符，只能为非成员函数，全局。因此相当于值入ostream对象中，无法用在成员函数</p>
<p>&lt;&lt; ： 右侧往左侧作用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="type">const</span> complex&lt;T&gt; &amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; x.<span class="built_in">real</span>() &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; x.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; c;</span><br></pre></td></tr></table></figure>
<h3 id="2-16-class-关注点总结">2.16 class 关注点总结</h3>
<ol>
<li>构造函数的初始值定义</li>
<li>函数的const定义</li>
<li>参数传递尽量用reference</li>
<li>return 的reference的考虑</li>
<li>数据需要在private，函数多数是public</li>
</ol>
<h2 id="三、设计类-BIG-Three">三、设计类-BIG Three</h2>
<h3 id="3-1-BIG-Three-1-拷贝构造">3.1 BIG Three 1 - 拷贝构造</h3>
<p>当构造函数，接收的是与自己相同类型的引用时，这个称为拷贝构造</p>
<h3 id="3-2-BIG-Three-2-拷贝赋值">3.2 BIG Three 2 - 拷贝赋值</h3>
<p>流程：自我检测（指针相同？） + 清空自己内容 + 拷贝源 + 目标赋值操作<br>
对比拷贝构造，当变量不是已构造的方式位于左值时，以赋值的方式时就为拷贝赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下两行完全等价,因为s2都是新创建出来的对象</span></span><br><span class="line"><span class="function">String <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">String s2 = s1; </span><br></pre></td></tr></table></figure>
<h3 id="3-3-BIG-Three-3-析构">3.3 BIG Three 3 - 析构</h3>
<p>销毁时调用</p>
<blockquote>
<p>string的设计，方案1是在char前加一个长度符，如pascal使用的方式的，另一种方案，就是把在结尾添加一个\0的结尾符，如C/C++的实现方案</p>
</blockquote>
<h3 id="3-4-带指针成员的类一定要有BIG-Three">3.4 带指针成员的类一定要有BIG Three</h3>
<p>因此编译器默认生成的拷贝函数，是浅拷贝，导致内存泄漏</p>
<h3 id="3-5-BIG-Three的实现：">3.5 BIG Three的实现：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *ctr = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp;);<span class="comment">// copy constructor</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp;); <span class="comment">// copy assignment</span></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">get_cstr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_data;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> * m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须为非成员函数，原理实际上是cout的运算符重载实现！</span></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="type">const</span> String &amp;x)&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; x.<span class="built_in">get_cstr</span>() &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="title">String::String</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ctr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ctr)&#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(ctr)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, ctr);</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Normal constructor- has value&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span> [<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Normal constructor- no value&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="title">String::String</span><span class="params">(<span class="type">const</span> String &amp;src)</span> </span>&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span> [<span class="built_in">strlen</span>(src.<span class="built_in">get_cstr</span>()) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, src.<span class="built_in">get_cstr</span>());</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Copy constructor&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String &amp;String::<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;src) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;src)&#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Self copy=  skip&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span> [<span class="built_in">strlen</span>(src.<span class="built_in">get_cstr</span>()) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, src.<span class="built_in">get_cstr</span>());</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;copy=&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::~<span class="built_in">String</span>() &#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;deconstruct&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>; </span><br><span class="line"><span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;Hello2&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">d1</span><span class="params">(s1)</span></span>; </span><br><span class="line">String d2 = s1; <span class="comment">//注意这个还是拷贝构造函数，因为是创建</span></span><br><span class="line">d2 = s2;</span><br></pre></td></tr></table></figure>
<h2 id="四、栈，堆与内存管理">四、栈，堆与内存管理</h2>
<p>32位机器中，一个指针是个四个字节</p>
<h3 id="4-1-栈stack">4.1 栈stack</h3>
<p>存在于某个作用域内的内存空间。如调用函数时，函数本身即生成一个stack用于存放接收的参数。在函数体内声明的任何变量，都在这个stack内。</p>
<h3 id="4-2-堆heap">4.2 堆heap</h3>
<p>system heap，由操作系统提供一块全局的内存空间，这块空间需要动态去取得。</p>
<p>实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 栈上</span></span><br><span class="line">complex * p= <span class="keyword">new</span> <span class="built_in">complex</span>(<span class="number">3</span>); <span class="comment">// 堆上</span></span><br><span class="line"><span class="function"><span class="type">static</span> complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">//静态变量，虽然在栈上，但不会销毁，直到程序结束</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-作用域内存泄漏">4.3 作用域内存泄漏</h3>
<p>作用域内的定义的指针会在离开时结束生命，所以在所指的内容不销毁的情况下，会造成指针无法获取销毁</p>
<h3 id="4-4-new的原理">4.4 new的原理</h3>
<p>C++的new的过程：<br>
以 下以这个为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Complex * pc = new Complex(1,2)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex *pc;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Complex));</span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;Complex *&gt;(mem);</span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="4-5-delete的过程">4.5 delete的过程</h3>
<p>以下为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String * ps = new String(&quot;Hello&quot;);</span><br><span class="line">delete ps;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex::~<span class="built_in">Complex</span>(ps);<span class="comment">//析构</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;<span class="comment">//释放内存</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-6-内存管理">4.6 内存管理</h3>
<p>操作系统默认是16的倍数分配，且头尾的cookie即为分配的大小的16进制，最后一位表示放出去则为1，回收回来即为0<br>
<img src="/img/image-20230202174221474.png" alt="image-20230202174221474"></p>
<p>对于数组的情况<br>
<img src="/img/image-20230202181136848.png" alt="image-20230202181136848"></p>
<blockquote>
<p>对于数组new完没有用delete[]而只用delete的情况，实际上delete也会释放整块的空间，但是必须连上括号才会让编译器知道需要调用几次析构，所以实际上对于没有指针的类是可以支持delete没有array，但从规范上还是要求搭配使用</p>
</blockquote>
<p><img src="/img/image-20230202181416205.png" alt="image-20230202181416205"></p>
<blockquote>
<p>引用符号出现在typename后面，表示引用，出现在变量前面，表示取地址</p>
</blockquote>
<h2 id="五、类扩展">五、类扩展</h2>
<h3 id="5-1-static">5.1 static</h3>
<p>对于非成员函数，会有一个隐藏的this指针来管理此类函数，因为函数需要处理多个实例数据，这时当前对象的地址就被会传入进去。</p>
<ul>
<li>在变量或函数前加static让其变为静态，静态函数只能处理静态数据。</li>
<li>静态函数可以通过classname或object来调用。<br>
初步优化的单例简单写法：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-cout">5.2 cout</h3>
<p>cout 是标准库中继承自ostream的类，其中实现了各种类型的&lt;&lt;运算符</p>
<h3 id="5-3-类模板">5.3 类模板</h3>
<p>使用 template class T 的方式实现类模板</p>
<h3 id="5-4-namespace">5.4 namespace</h3>
<p>与C#的类似，把代码块包装起来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//使用2</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="comment">//使用3 直接使用</span></span><br><span class="line">std::cout </span><br></pre></td></tr></table></figure>
<h2 id="六、类关系-Composition">六、类关系-Composition</h2>
<h3 id="6-1-复合关系，拥有。has-a-实心菱形为起点，指向包含的对象">6.1 复合关系，拥有。has-a, 实心菱形为起点，指向包含的对象</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">dequeue&lt;T&gt; c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-Adaptor模式">6.2 Adaptor模式</h3>
<p>适配器，理解为封装的思想，进行适配改造。</p>
<h3 id="6-3-构造与析构">6.3 构造与析构</h3>
<p>构造： 先构造内部的Component，再构造自己。 默认行为下，编译器会先调用Component的默认构造函数，如果需要指定构造函数，需要在当前类构造下做出指定。<br>
析构：先析构自己，再析构各个component。 在函数内也需要先释放自己的资源，再释放components</p>
<h2 id="七、类关系-Delegation">七、类关系-Delegation</h2>
<p>Composition by reference. 空心菱形指向目标对象。<br>
如下则是String与StringRep委托关系，此种实现叫pImpl, pointer to implementation，或者Handle and Body。 String就是Handle，StringRep就是Body。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StringRep * rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Copy on write, 对于共享环境下的写入操作，产生一个副本来做做为对象，以不影响其他引用。</p>
</blockquote>
<h2 id="八、类关系-Inheritance">八、类关系-Inheritance</h2>
<p>is-a 继承， 子类指向父类，终点使用空心三角形。</p>
<h3 id="8-1-子类对象包着父类的东西，父类以一个PART形式存在于子类。">8.1 子类对象包着父类的东西，父类以一个PART形式存在于子类。</h3>
<p>public继承</p>
<p>以下继承主要为了继承父类的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node</span>: <span class="keyword">public</span> _List_node_base&#123;</span><br><span class="line">	_Tp _M_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-构造与析构">8.2 构造与析构</h3>
<p>构造，由内而外（父就是内）：先父类的default构造，再子类自己的<br>
析构，由外而内： 先执行自己，再执行父类的</p>
<p>基类的析构必须是virtual ，否则 会出现Undefined behavior</p>
<blockquote>
<p>当子类有组合关系存在时，构造仍然是以父类最先的方式再子类Component最后再是子类自己</p>
</blockquote>
<h3 id="8-3-virtual">8.3 virtual</h3>
<p>基类的函数默认为非虚函数 ， impure virtual 为添加virtual的函数，希望子类去重定义。<br>
pure virtual纯虚函数，同时添加const = 0在后面，表示一定要子类重定义。</p>
<h2 id="九、常见的设计模式">九、常见的设计模式</h2>
<h3 id="9-1-Template-Method">9.1 Template Method</h3>
<p>这是一种设计模式：设计一个函数为虚函数，且在父类流程（框架中）是固定会执行的，留下此函数让未来的子类来实现。</p>
<h3 id="9-1-观察者模式">9.1 观察者模式</h3>
<p>使用委托+继承<br>
<img src="/img/image-20230207142409951.png" alt="image-20230207142409951"></p>
<h3 id="9-2-Composite">9.2 Composite</h3>
<p><img src="/img/image-20230207143817602.png" alt="image-20230207143817602"></p>
<h3 id="9-3-Prototype">9.3 Prototype</h3>
<p>一种解法：子类必须有一个静态自己，必须有一个私有构造并在其中调用父类的addprototype，让父类调用到clone生成自己<br>
<img src="/img/image-20230207150459069.png" alt="image-20230207150459069"></p>
<p>实现细节：父类<br>
<img src="/img/image-20230207151629369.png" alt="image-20230207151629369"></p>
<p>实现细节：子类</p>
<p><img src="/img/image-20230207153822048.png" alt="image-20230207153822048"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEARN01_IMAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEARN01_IMAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImageType.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Image* <span class="title">FindAndClone</span><span class="params">(ImageType)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Image* <span class="title">GetPrototype</span><span class="params">(ImageType)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">AddPrototype</span><span class="params">(Image* p)</span></span>&#123;</span><br><span class="line">        Prototypes[NextSlot++] = p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ImageType <span class="title">getImageType</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Image* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> Image* Prototypes[<span class="number">10</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> NextSlot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Image* Image::Prototypes[];</span><br><span class="line"><span class="type">int</span> Image::NextSlot;</span><br><span class="line"></span><br><span class="line"><span class="function">Image* <span class="title">Image::FindAndClone</span><span class="params">(ImageType t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NextSlot; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Prototypes[i]-&gt;<span class="built_in">getImageType</span>() == t)</span><br><span class="line">            <span class="keyword">return</span> Prototypes[i]-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Image* <span class="title">Image::GetPrototype</span><span class="params">(ImageType t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NextSlot; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Prototypes[i]-&gt;<span class="built_in">getImageType</span>() == t)</span><br><span class="line">            <span class="keyword">return</span> Prototypes[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LEARN01_IMAGE_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEARN01_LANDANDSATIMAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEARN01_LANDANDSATIMAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LandAndSatImage</span>:<span class="keyword">public</span> Image&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LandAndSatImage</span>(<span class="type">int</span> dummy)&#123;</span><br><span class="line">        _id = count++;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Construct LandAndSatImage:&quot;</span> &lt;&lt; _id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;_id&lt;&lt;<span class="string">&quot;:Draw LandAndSatImage&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Image* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LandAndSatImage</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ImageType <span class="title">getImageType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LSAT;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LandAndSatImage</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Deconstruct LandAndSatImage:&quot;</span> &lt;&lt; _id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">static</span> LandAndSatImage _LandAndSatImage;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="built_in">LandAndSatImage</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;add LandAndSatImage prototype&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">AddPrototype</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LandAndSatImage LandAndSatImage::_LandAndSatImage;</span><br><span class="line"><span class="type">int</span> LandAndSatImage::count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LEARN01_LANDANDSATIMAGE_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEARN01_SPOTIMAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEARN01_SPOTIMAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotImage</span>:<span class="keyword">public</span> Image&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SpotImage</span>(<span class="type">int</span> dummy)&#123;</span><br><span class="line">        _id = count++;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Construct SpotImage:&quot;</span> &lt;&lt; _id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;_id&lt;&lt;<span class="string">&quot;:Draw SpotImage&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Image* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SpotImage</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ImageType <span class="title">getImageType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SPOT;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SpotImage</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Deconstruct SpotImage:&quot;</span> &lt;&lt; _id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">static</span> SpotImage _SpotImage;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="built_in">SpotImage</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;add SpotImage prototype&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">AddPrototype</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SpotImage SpotImage::_SpotImage;</span><br><span class="line"><span class="type">int</span> SpotImage::count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LEARN01_SPOTIMAGE_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------------------------- Prototype ----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">LandAndSatImage * lsatInstance1 = <span class="built_in">static_cast</span>&lt;LandAndSatImage*&gt;(Image::<span class="built_in">GetPrototype</span>(LSAT));</span><br><span class="line">lsatInstance1-&gt;<span class="built_in">Draw</span>();</span><br><span class="line"><span class="comment">//    delete lsatInstance1; //删除原型就没了，后面就无法使用了</span></span><br><span class="line"></span><br><span class="line">LandAndSatImage * lsatInstance2 = <span class="built_in">static_cast</span>&lt;LandAndSatImage*&gt;(Image::<span class="built_in">FindAndClone</span>(LSAT));</span><br><span class="line">lsatInstance2-&gt;<span class="built_in">Draw</span>();</span><br><span class="line"><span class="keyword">delete</span> lsatInstance2;</span><br><span class="line"></span><br><span class="line">LandAndSatImage * lsatInstance3 = <span class="built_in">static_cast</span>&lt;LandAndSatImage*&gt;(Image::<span class="built_in">FindAndClone</span>(LSAT));</span><br><span class="line">lsatInstance3-&gt;<span class="built_in">Draw</span>();</span><br><span class="line"><span class="keyword">delete</span> lsatInstance3;</span><br><span class="line"></span><br><span class="line">SpotImage * spotInstance = <span class="built_in">static_cast</span>&lt;SpotImage*&gt;(Image::<span class="built_in">FindAndClone</span>(SPOT));</span><br><span class="line">spotInstance-&gt;<span class="built_in">Draw</span>();</span><br><span class="line"><span class="keyword">delete</span> spotInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OUTPUT</span></span><br><span class="line">add LandAndSatImage prototype</span><br><span class="line">add SpotImage prototype</span><br><span class="line">------------------------------------- Prototype ----------------------------</span><br><span class="line"><span class="number">0</span>:Draw LandAndSatImage</span><br><span class="line">Construct LandAndSatImage:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>:Draw LandAndSatImage</span><br><span class="line">Deconstruct LandAndSatImage:<span class="number">1</span></span><br><span class="line">Construct LandAndSatImage:<span class="number">2</span></span><br><span class="line"><span class="number">2</span>:Draw LandAndSatImage</span><br><span class="line">Deconstruct LandAndSatImage:<span class="number">2</span></span><br><span class="line">Construct SpotImage:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>:Draw SpotImage</span><br><span class="line">Deconstruct SpotImage:<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">Deconstruct SpotImage:<span class="number">0</span></span><br><span class="line">Deconstruct LandAndSatImage:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="10、Conversion-Function-转换函数">10、Conversion Function 转换函数</h2>
<p>操作符重载的语法基础上，把返回值省略掉，函数名以类型名，不允许有参数。 这种形式定义一个转换函数。 一般情况下转换函数是const的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>):<span class="built_in">m_num</span>(num), <span class="built_in">m_den</span>(den)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="type">double</span> n = (<span class="type">double</span>)m_num / m_den;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">    <span class="type">int</span> m_den;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> m = <span class="number">54.0</span> + f ;</span><br><span class="line">cout &lt;&lt; m &lt;&lt; endl; <span class="comment">//54.6</span></span><br></pre></td></tr></table></figure>
<h2 id="11-Non-explicit-one-argument-ctor">11. Non-explicit-one-argument ctor</h2>
<p>三个部分：</p>
<ol>
<li>Non-explicit 非强制指定，即显式</li>
<li>one-argument 表示有一个实参，这里带默认值的参数可以不算进来</li>
<li>ctor 构造函数</li>
</ol>
<p>如下代码实现Non-explicit-one-argument ctor</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction2</span>(<span class="type">double</span> num, <span class="type">int</span> den=<span class="number">1</span>):<span class="built_in">m_num</span>(num), <span class="built_in">m_den</span>(den)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fraction2 construct:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fraction2 conversition double:&quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">        <span class="type">double</span> n = (<span class="type">double</span>)m_num / m_den;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    Fraction2&amp; <span class="keyword">operator</span>+(<span class="type">const</span> Fraction2&amp; other)&#123;<span class="comment">//const带上下面使用会报错，不带则不会</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fraction2 add:&quot;</span> &lt;&lt; m_num &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; other.m_num&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_num += other.m_num;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_den += other.m_den;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_num;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDen</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_den;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">    <span class="type">int</span> m_den;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; os, <span class="type">const</span> Fraction2 &amp; frac)&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; frac.<span class="built_in">getNum</span>() &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; frac.<span class="built_in">getDen</span>() &lt;&lt;<span class="string">&#x27;)&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction2 <span class="title">f2</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction2 fr2 = f2 + <span class="number">54</span>;</span><br><span class="line">cout &lt;&lt; fr2 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Fraction2 construct:<span class="number">3</span></span><br><span class="line">Fraction2 conversition <span class="type">double</span>:<span class="number">3</span></span><br><span class="line">Fraction2 construct:<span class="number">54.6</span></span><br><span class="line">(<span class="number">54</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子里，课程侯老师说会出现两条路，导致Error【ambiguous】冲突，一条是fr2 由两个Fraction2对象转换而来，一条是fr2则double的数直接调用conversion再构造而来。 如果+操作符不加const，则编译器会使用conversion转换，即使用第二条路，如果带了const,则可以选择两条路，则会出现ambiguous冲突。 说白了就是没有const，编译器就知道了怎么选择了，不纠结了，所以运算符重载还是加个const</p>
</blockquote>
<p>如下代码实现 explicit-one_argument ctor</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction3</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Fraction3</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>)</span>:m_num(num), m_den(den)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="type">double</span> n = (<span class="type">double</span>)m_num / m_den;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    Fraction3&amp; <span class="keyword">operator</span>+(Fraction3&amp; other)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_num += other.m_num;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_den += other.m_den;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">    <span class="type">int</span> m_den;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这样调用编译器会报错，提示无法把54隐式转换成Fraction</span></span><br><span class="line"><span class="comment">//    Fraction3 f3(3,5);</span></span><br><span class="line"><span class="comment">//    Fraction3 fr3 = 54 + f3 ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; fr3 &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>
<h2 id="12-pointer-like-classes">12. pointer-like classes</h2>
<p>智能指针<br>
实例如下：注意实参要传引用，否则将是个拷贝地址，导致输出错误</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPtr</span>(T *target):<span class="built_in">t</span>(target)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SmartPtr</span>(T&amp; target):<span class="built_in">t</span>(&amp;target)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Fraction2 <span class="title">fTest</span><span class="params">(<span class="number">30</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;Fraction2&gt; <span class="title">sptr</span><span class="params">(fTest)</span></span>;</span><br><span class="line">cout &lt;&lt; sptr-&gt;<span class="built_in">getNum</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Fraction2 construct:<span class="number">30</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>应用在迭代器中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span>&#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());&#125;</span><br></pre></td></tr></table></figure>
<p>对于ite-&gt;method()这样的调用， 想当于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo::<span class="built_in">method</span>();</span><br><span class="line">(*ite).<span class="built_in">method</span>();</span><br><span class="line">(&amp;(*ite))-&gt;<span class="built_in">method</span>();</span><br></pre></td></tr></table></figure>
<p><img src="/img/image-20230208161927997.png" alt="image-20230208161927997"></p>
<h2 id="13-function-like-classes">13. function-like classes</h2>
<p>把类或struct做为一个函数来调用，注意调用时需要两个括号，第一个用于生成临时对象实例第二个调用操作运算符<br>
如下实例中，通过一个父类继承为子类的类型生成别名，此父类的大小为0（实际输出为1）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyUnaryFunc</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Arg first_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result second_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">MyPair</span>: <span class="keyword">public</span> MyUnaryFunc&lt;T1, T2&gt;&#123;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">MyPair</span>(): <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;;</span><br><span class="line">    <span class="built_in">MyPair</span>(<span class="type">const</span> T1&amp; a, <span class="type">const</span> T2&amp; b): <span class="built_in">first</span>(a), <span class="built_in">second</span>(b)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">identity</span>: <span class="keyword">public</span> MyUnaryFunc&lt;T, T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp;</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span>&#123;<span class="keyword">return</span> t;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">P</span>&gt;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">select1st</span>: <span class="keyword">public</span> MyUnaryFunc&lt;P, <span class="keyword">typename</span> P::first_type&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="keyword">typename</span> P::first_type&amp;</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> P&amp; t)</span></span>&#123;<span class="keyword">return</span> t.first;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">P</span>&gt;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">select2nd</span>: <span class="keyword">public</span> MyUnaryFunc&lt;P, <span class="keyword">typename</span> P::second_type&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="keyword">typename</span> P::second_type&amp;</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> P&amp; t)</span></span>&#123;<span class="keyword">return</span> t.second;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyPair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="keyword">typename</span> MyPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::first_type select_pair1 = select1st&lt;MyPair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;()(p);</span><br><span class="line">cout &lt;&lt; select_pair1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出 1</span></span><br></pre></td></tr></table></figure>
<h2 id="14-namespaces">14. namespaces</h2>
<p>习惯上建议在开始写C++文件时，都加上namespaces。方便日后扩展时不会千万类名冲突，如上例中的pair就容易与标准库中重名冲突。</p>
<h2 id="15-类模板与函数模板">15. 类模板与函数模板</h2>
<p>类模板使用如2.13的complex的写法，而函数模板，则如13。注意只有在模板内的typename和class是共通的，由于历史原因，class更早期就有，后面就有了typename。<br>
使用模板的默认参数，类似于函数默认值的方式，为缺少参数自动添加缺省值！</p>
<h2 id="16-成员模板">16. 成员模板</h2>
<p>在类的成员中，也有需要定义模板的地方，标准库中多数用在构造函数上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">MyPair</span>: <span class="keyword">public</span> MyUnaryFunc&lt;T1, T2&gt;&#123;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">MyPair</span>(): <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;;</span><br><span class="line">    <span class="built_in">MyPair</span>(<span class="type">const</span> T1&amp; a, <span class="type">const</span> T2&amp; b): <span class="built_in">first</span>(a), <span class="built_in">second</span>(b)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U1, <span class="keyword">class</span> U2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">MyPair</span><span class="params">(<span class="type">const</span> MyPair&lt;U1, U2&gt; &amp;p)</span>:first(p.first), second(p.second)&#123;</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyPair&lt;SubClass, SubClass&gt; classPair1;</span><br><span class="line">MyPair&lt;BaseClass, BaseClass&gt; classPair2;</span><br><span class="line"></span><br><span class="line"><span class="function">MyPair&lt;BaseClass, BaseClass&gt; <span class="title">TestPair1</span><span class="params">(classPair1)</span></span>;</span><br><span class="line"><span class="function">MyPair&lt;SubClass, SubClass&gt; <span class="title">TestPair2</span><span class="params">(classPair2)</span></span>;<span class="comment">//报错，无法从把父类转子类</span></span><br></pre></td></tr></table></figure>
<h2 id="17-特化与偏特化">17. 特化与偏特化</h2>
<p>可以理解为与模板的泛化相反，指定类型，偏特化则是对部分参数进行特化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span>&lt;<span class="type">int</span>, std::string&gt;: <span class="keyword">public</span> MyUnaryFunc&lt;<span class="type">int</span>, std::string&gt;&#123;</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    std::string second;</span><br><span class="line">    <span class="built_in">MyPair</span>(): <span class="built_in">first</span>(<span class="number">0</span>), <span class="built_in">second</span>(<span class="string">&quot;d&quot;</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dsa&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyPair</span>(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> std::string&amp; b): <span class="built_in">first</span>(a), <span class="built_in">second</span>(b)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;aaa&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U1, <span class="keyword">class</span> U2&gt;</span></span><br><span class="line"><span class="function">            <span class="title">MyPair</span><span class="params">(<span class="type">const</span> MyPair&lt;U1, U2&gt; &amp;p)</span>:first(p.first), second(p.second)&#123;</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span>&lt;std::string , T&gt;: <span class="keyword">public</span> MyUnaryFunc&lt;<span class="type">int</span>, T&gt;&#123;</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    std::string second;</span><br><span class="line">    <span class="built_in">MyPair</span>(): <span class="built_in">first</span>(<span class="number">0</span>), <span class="built_in">second</span>(<span class="built_in">T</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;KKK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyPair</span>(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> T&amp; b): <span class="built_in">first</span>(a), <span class="built_in">second</span>(b)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;KKKK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U1, <span class="keyword">class</span> U2&gt;</span></span><br><span class="line"><span class="function">            <span class="title">MyPair</span><span class="params">(<span class="type">const</span> MyPair&lt;U1, U2&gt; &amp;p)</span>:first(p.first), second(p.second)&#123;</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="18-template-template-parameter">18.template template parameter</h2>
<p>对于模板中再放入模板的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line">    <span class="built_in">XCls</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ttp: container&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">SmartPtr</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SmartPtr&lt;T&gt; c;</span><br><span class="line">    <span class="built_in">XCls2</span>():<span class="built_in">c</span>(<span class="keyword">new</span> T)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ttp: ptr&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Squence</span>=std::deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> XCls3&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Squence c;</span><br><span class="line">    <span class="built_in">XCls3</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;this is not ttp&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">XCls&lt;<span class="type">int</span>, Lst&gt; xcl_obj;</span><br><span class="line">XCls2&lt;<span class="type">int</span>, shared_ptr&gt; xcl2_sp;</span><br><span class="line"><span class="comment">//    XCls2&lt;int, unique_ptr&gt; xcl2_up;//报错 由于unique_ptr有多个template，需要强制指明</span></span><br><span class="line"><span class="comment">//    XCls2&lt;string, weak_ptr&gt; xcl2_wp; //报错 由于weak_ptr未实现构造</span></span><br><span class="line">XCls2&lt;<span class="type">int</span>, auto_ptr&gt; xcl2_ap;</span><br><span class="line">XCls3&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; xcl3_obj;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于模板的默认值的情况，这种不属于模板模板参数，因为还是必须指明模板参数。如上例XCls3<br>
这里注意选中MSVC的编译器，使用CLANG会阻止定义模板模板参数，只能改为如下的方式：但无法按原样使用<br>
<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20875033/clang-vs-vcerror-declaration-of-t-shadows-template-parameter">关于clang的提示错误</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Container</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, Container&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="19-关于-cplusplus">19.关于__cplusplus</h2>
<p>返回当前C++标准的值，msvc环境下需要添加编译选项，否则永远输出199711。</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/reference/zc-cplusplus?view=msvc-170">MSVC官方解释</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (MSVC)</span><br><span class="line">    <span class="built_in">add_compile_options</span>(/Zc:__cplusplus)</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure>
<h2 id="20-三个c-11的主题">20.三个c++11的主题</h2>
<h3 id="20-1-可变参数模板">20.1 可变参数模板</h3>
<p>语法上支持…，可以直接解包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法一</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;... args)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl; <span class="comment">//cout &lt;&lt; sizeof...(args) &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print(5, bitset&lt;15&gt;(370), &quot;abc&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Lst = list&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp;</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">ostream &amp;</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> T&amp; t, <span class="type">const</span> Args&amp;... args)</span></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print(cout, 5, bitset&lt;15&gt;(370), &quot;abc&quot;);</span></span><br></pre></td></tr></table></figure>
<h3 id="20-2-auto">20.2 auto</h3>
<p>类似于c#的var，可以自动获取类型，常用于迭代器</p>
<h3 id="20-3-range-base-iterator">20.3 range base iterator</h3>
<p>使用冒号解开容器，可以使用引用符来接收参数，这样就可以实现改值操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; m = &#123;<span class="number">1</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : m)&#123;</span><br><span class="line">cout &lt;&lt; i++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : m)&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="21-Reference">21. Reference</h2>
<p>引用可理解为一个代表关系，其自身与目标对象具有相同的大小和地址。 主要使用场景为函数参数和返回值。所谓“更优雅的指针”</p>
<p>对于函数重载的情况，注意引用符不会被写入签名中，而const修饰的函数是会被入签名的，因此可以使用const对函数标识为重载方。 对于参数的const，只对引用和指针进行修饰，影响函数签名，对值拷贝的变量不会修饰。</p>
<blockquote>
<p>这也可以理解，因为对值拷贝的参数的更改离开作用域后拷贝出来的值就会释放掉，因此重载const并没有意义。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//****** 以下两个签名相同 ******</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_method_a</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_method_a</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>&#123;&#125; <span class="comment">//报错，与上面一行的函数签名相同</span></span><br><span class="line"><span class="comment">// **********</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_method_a</span><span class="params">(<span class="type">int</span>&amp; a)</span><span class="type">const</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//****** 以下三个签名相同 ******</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_method_b</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_method_b</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a)</span></span>&#123;&#125; <span class="comment">//报错，与前一行函数签名相同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_method_b</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// **********</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_method_b</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_method_b</span><span class="params">(<span class="type">int</span>* a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_method_b</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* a)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> test_a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *test_ap = &amp;test_a;</span><br><span class="line"><span class="type">int</span> &amp;test_ar = test_a;</span><br><span class="line">cout &lt;&lt; test_ar &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; &amp;test_ar &lt;&lt; endl; <span class="comment">//1,010FF5A8</span></span><br><span class="line"><span class="type">int</span> test_b = <span class="number">2</span>;</span><br><span class="line">test_ar = test_b;</span><br><span class="line">cout &lt;&lt; test_ar &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; &amp;test_ar &lt;&lt; endl; <span class="comment">//2,010FF5A8</span></span><br><span class="line"><span class="type">int</span> &amp;test_br = test_ar;</span><br><span class="line">test_br = <span class="number">5</span>;</span><br><span class="line">cout &lt;&lt; test_ar &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; &amp;test_ar &lt;&lt; endl; <span class="comment">//5,010FF5A8</span></span><br><span class="line"></span><br><span class="line"><span class="function">SmartPtr&lt;<span class="type">int</span>&gt; <span class="title">test_smartptr_obj</span><span class="params">(test_a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> SmartPtr&lt;<span class="type">int</span>&gt; <span class="title">test_smartptr_obj2</span><span class="params">(test_a)</span></span>;</span><br><span class="line">test_smartptr_obj.<span class="built_in">test_method_a</span>(test_ar);  <span class="comment">// void test_method_a(int a)&#123;&#125;</span></span><br><span class="line">test_smartptr_obj2.<span class="built_in">test_method_a</span>(test_ar); <span class="comment">//void test_method_a(int&amp; a)const&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">test_smartptr_obj.<span class="built_in">test_method_b</span>(test_a); <span class="comment">//void test_method_b(int&amp; a)&#123;&#125;</span></span><br><span class="line">test_smartptr_obj.<span class="built_in">test_method_b</span>(&amp;test_a); <span class="comment">//void test_method_b(int* a)&#123;&#125;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> test_ac = test_a;</span><br><span class="line">test_smartptr_obj.<span class="built_in">test_method_b</span>(test_ac); <span class="comment">//void test_method_b(const int&amp; a)&#123;&#125;</span></span><br><span class="line">test_smartptr_obj.<span class="built_in">test_method_b</span>(&amp;test_ac);<span class="comment">//void test_method_b(const int* a)&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="22-vptr和vtbl">22.vptr和vtbl</h2>
<p>虚指针与虚表</p>
<p><img src="/img/image-20230215162530686.png" alt="image-20230215162530686"></p>
<ul>
<li>相同函数签名的函数或虚函数会直接覆写父类的同签名函数。</li>
<li><strong>当类中有虚函数的时候，对象就会多一个指针。（有多少个虚函数，就多一个指针，即vptr）</strong>，因此占用的内存，会多一个指针的空间（4字节）。</li>
<li>继承函数的本质是继承父类的函数的调用权，而不应理解为实体内容</li>
<li>vptr只会关联到虚函数上，与一般函数无关。vtbl里放的都是函数指针，指向虚函数。</li>
<li>调用函数则是动态绑定，通过指针p找到vptr，找到vtbl，再找到调用的函数。(*p-&gt;vptr[n])§，则调用第n个虚函数。</li>
<li>这种用法又称为 多态</li>
</ul>
<h2 id="23-关于this指针">23. 关于this指针</h2>
<p>通过对象来调用函数，这个对象的地址即是this pointer。<br>
对象在调用普通的函数时，实际上会在第一个参数隐式的传入this指针，这个机制被应用在lua和python的class设计上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMyDoc myDoc;</span><br><span class="line">myDoc.<span class="built_in">OnFileOpen</span>(); <span class="comment">// CMyDoc::OnFileOpen(&amp;myDoc) </span></span><br></pre></td></tr></table></figure>
<p>扩展：<br>
结合9.1的Template Method设计模式，在父类设计虚函数，父类的任意地方“假设”这个虚函数已经实现，直接使用。在如下例子中，这里的this是实际上是子类的this，通过虚指针找到虚表中的函数地址，进行调用，第一个参数传入的也为this.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CDocument.h:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDocument</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Serialize</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnFileOpen</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">Serialize</span>(); <span class="comment">// 这里解释为(*(this-&gt;vptr)[n])(this) 从虚表中找到此函数再执行。</span></span><br><span class="line">		...</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Application.h</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyDoc</span>:<span class="keyword">public</span> CDocument&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Serialize</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">main.cpp</span><br><span class="line">CMyDoc myDoc;</span><br><span class="line">myDoc.<span class="built_in">OnFileOpen</span>();</span><br></pre></td></tr></table></figure>
<h2 id="24-动态绑定">24. 动态绑定</h2>
<p>通过虚函数实现用父类的指针调用到子类的函数。<br>
对于指针p调用虚函数的过程如下C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*(p-&gt;vptr)[n])(p)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;BaseClass vfunc1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span>: <span class="keyword">public</span> BaseClass&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SubClass vfunc1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">BaseClass *db_baseclass = <span class="keyword">new</span> SubClass;</span><br><span class="line">db_baseclass-&gt;<span class="built_in">vfunc1</span>();<span class="comment">// 这里实际调用的是子类</span></span><br></pre></td></tr></table></figure>
<h2 id="25-const">25. const</h2>
<p>除了顶层与底层const以外</p>
<ul>
<li>
<ol>
<li>需要注意const类实例只可以调用const标识的成员函数，但非const类实例则可以自由调用const成员函数和普通的成员函数。</li>
</ol>
</li>
</ul>
<blockquote>
<p>主要的原因是const实例对象在调用非const成员函数时，此函数无法证明是否内部没有修改类中的数据成员。因此C++设计者直接制定了此规则。如 string::print() 需要指明const，这样const的对象就可以调用。</p>
</blockquote>
<ul>
<li>
<ol start="2">
<li>当const和非const的同名函数同时存在时，const对象只会调用const函数，而非const只会调用非const函数。</li>
</ol>
</li>
</ul>
<p>扩展实例：<br>
字符串的中括号运算符重载：<br>
通过实现const与非const两个同函数名的重载，实现是否需要copy on write机制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">chatT <span class="keyword">operator</span>[] <span class="type">const</span>&#123;...&#125;</span><br><span class="line">reference <span class="keyword">operator</span>[] &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26-new与delete的重载">26. new与delete的重载</h2>
<p>当为[]数组，使用operator new[]与operator delete[]，此时new[]传入的大小为对象数组的总大小。</p>
<h3 id="26-1-全局重载：">26.1 全局重载：</h3>
<p>主要使用场景为内存池</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="title">my_alloc</span><span class="params">(<span class="type">size_t</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">my_free</span><span class="params">(<span class="type">void</span> * ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> s)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You alloc a size:&quot;</span> &lt;&lt; s;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">my_alloc</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> * ptr)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You free a size:&quot;</span> &lt;&lt; ptr;</span><br><span class="line">    <span class="built_in">my_free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-2-函数体内的重载：">26.2 函数体内的重载：</h3>
<p>注意delete[] 重载传入的size是数组的容量大小，而不是真正的内存大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> s)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base Class Alloc size:&quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">my_alloc</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> s)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base Class Alloc array size:&quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">my_alloc</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr, <span class="type">size_t</span> s)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base Class Delete array size:&quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">my_free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseClass *db_baseclass = <span class="keyword">new</span> SubClass;</span><br><span class="line">db_baseclass-&gt;<span class="built_in">vfunc1</span>();</span><br><span class="line"><span class="keyword">delete</span> db_baseclass;</span><br><span class="line">BaseClass *db_baseclasses = ::<span class="keyword">new</span> BaseClass[<span class="number">10</span>]; <span class="comment">//强制使用全局的重载</span></span><br><span class="line">db_baseclasses[<span class="number">0</span>].<span class="built_in">vfunc1</span>();</span><br><span class="line">::<span class="keyword">delete</span>[] db_baseclasses;<span class="comment">//强制使用全局的重载</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的sizeof在数组情况下，会多出4个字节，但实际测试并没有多出而是准确按照各个对象大小乘以数组大小得出。 这里存疑。</p>
</blockquote>
<h3 id="26-3-扩充参数">26.3 扩充参数</h3>
<p>又叫placement new<br>
对于new的重载可以添加额外的参数， 这里在标准库的string中有所使用。<br>
要求就是new函数第一个参数必须为size_t类型，delete函数必须为void* 。<br>
以下是测试例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> s, <span class="type">int</span> extra)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base Class Alloc size:&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;,extra:&quot;</span> &lt;&lt; extra &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">my_alloc</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">int</span> extra)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base Class Delete array extra:&quot;</span> &lt;&lt; extra &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">my_free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">BaseClass *db_baseclass = <span class="built_in">new</span>(<span class="number">23</span>) SubClass;</span><br><span class="line"><span class="keyword">delete</span> db_baseclass;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>delete的扩充参数形式的重载并不会被编译器调用，按候捷老师说的需要在构造函数的异常情况编译器才会调用对应的delete扩充参数函数，但实践无法显示这一结果。在此不纠结</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/image-20230202174221474.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/weixin.jpg" target="_blank"><img class="post-qr-code-img" src="/img/weixin.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/01/01/GAMES104_NOTE4/"><img class="next-cover" src="/img/image-20230106174810993.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GAMES104-NOTE4</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/19/C++Review1/" title="C++ 复习1"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-19</div><div class="title">C++ 复习1</div></div></a></div><div><a href="/2022/05/19/CProjectStudy/" title="C与C++开源项目学习"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-19</div><div class="title">C与C++开源项目学习</div></div></a></div><div><a href="/2022/05/19/EffectiveC++Record/" title="Effective C++学习记录"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-19</div><div class="title">Effective C++学习记录</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/my.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">霍家鹏</div><div class="author-info__description">Keep going! Keep study!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">97</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AveryHuo"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AveryHuo" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jackhamsir@sina.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎！欢迎来到我的博客空间，这里有我平时的学习心得和记录。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B4%E4%B8%8E%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">二、文件头与类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Header%EF%BC%88%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%89%E4%B8%AD%E7%9A%84%E9%98%B2%E5%8D%AB%E5%BC%8F%E5%A3%B0%E6%98%8E%EF%BC%88guard%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Header（头文件）中的防卫式声明（guard）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 头文件内容布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%88%9D%E6%8E%A2"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 模板类的初探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-inline"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 inline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-Private%E5%9F%9F%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 Private域的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-const"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-pass-by-value-refrence"><span class="toc-number">2.9.</span> <span class="toc-text">2.9 pass by value&#x2F;refrence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-return-by-value-refrence"><span class="toc-number">2.10.</span> <span class="toc-text">2.10 return by value&#x2F;refrence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-friend"><span class="toc-number">2.11.</span> <span class="toc-text">2.11 friend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">2.12.</span> <span class="toc-text">2.12 传递方式的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.13.</span> <span class="toc-text">2.13 操作符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-14-%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.14.</span> <span class="toc-text">2.14 临时对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-15-%E7%AC%A6%E5%8F%B7"><span class="toc-number">2.15.</span> <span class="toc-text">2.15 &lt;&lt; 符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-16-class-%E5%85%B3%E6%B3%A8%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">2.16.</span> <span class="toc-text">2.16 class 关注点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E7%B1%BB-BIG-Three"><span class="toc-number">3.</span> <span class="toc-text">三、设计类-BIG Three</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-BIG-Three-1-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 BIG Three 1 - 拷贝构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-BIG-Three-2-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 BIG Three 2 - 拷贝赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-BIG-Three-3-%E6%9E%90%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 BIG Three 3 - 析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%B8%A6%E6%8C%87%E9%92%88%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89BIG-Three"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 带指针成员的类一定要有BIG Three</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-BIG-Three%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 BIG Three的实现：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A0%88%EF%BC%8C%E5%A0%86%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">四、栈，堆与内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A0%88stack"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 栈stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%A0%86heap"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 堆heap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 作用域内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-new%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 new的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-delete%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 delete的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%B1%BB%E6%89%A9%E5%B1%95"><span class="toc-number">5.</span> <span class="toc-text">五、类扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-static"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-cout"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 cout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-namespace"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 namespace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B1%BB%E5%85%B3%E7%B3%BB-Composition"><span class="toc-number">6.</span> <span class="toc-text">六、类关系-Composition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%8B%A5%E6%9C%89%E3%80%82has-a-%E5%AE%9E%E5%BF%83%E8%8F%B1%E5%BD%A2%E4%B8%BA%E8%B5%B7%E7%82%B9%EF%BC%8C%E6%8C%87%E5%90%91%E5%8C%85%E5%90%AB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 复合关系，拥有。has-a, 实心菱形为起点，指向包含的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Adaptor%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 Adaptor模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 构造与析构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%B1%BB%E5%85%B3%E7%B3%BB-Delegation"><span class="toc-number">7.</span> <span class="toc-text">七、类关系-Delegation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%B1%BB%E5%85%B3%E7%B3%BB-Inheritance"><span class="toc-number">8.</span> <span class="toc-text">八、类关系-Inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8C%85%E7%9D%80%E7%88%B6%E7%B1%BB%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%8C%E7%88%B6%E7%B1%BB%E4%BB%A5%E4%B8%80%E4%B8%AAPART%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%9C%A8%E4%BA%8E%E5%AD%90%E7%B1%BB%E3%80%82"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 子类对象包着父类的东西，父类以一个PART形式存在于子类。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 构造与析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-virtual"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 virtual</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">九、常见的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-Template-Method"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 Template Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">9.1 观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Composite"><span class="toc-number">9.3.</span> <span class="toc-text">9.2 Composite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-Prototype"><span class="toc-number">9.4.</span> <span class="toc-text">9.3 Prototype</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81Conversion-Function-%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">10、Conversion Function 转换函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Non-explicit-one-argument-ctor"><span class="toc-number">11.</span> <span class="toc-text">11. Non-explicit-one-argument ctor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-pointer-like-classes"><span class="toc-number">12.</span> <span class="toc-text">12. pointer-like classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-function-like-classes"><span class="toc-number">13.</span> <span class="toc-text">13. function-like classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-namespaces"><span class="toc-number">14.</span> <span class="toc-text">14. namespaces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">15.</span> <span class="toc-text">15. 类模板与函数模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">16.</span> <span class="toc-text">16. 成员模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%89%B9%E5%8C%96%E4%B8%8E%E5%81%8F%E7%89%B9%E5%8C%96"><span class="toc-number">17.</span> <span class="toc-text">17. 特化与偏特化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-template-template-parameter"><span class="toc-number">18.</span> <span class="toc-text">18.template template parameter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%85%B3%E4%BA%8E-cplusplus"><span class="toc-number">19.</span> <span class="toc-text">19.关于__cplusplus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E4%B8%89%E4%B8%AAc-11%E7%9A%84%E4%B8%BB%E9%A2%98"><span class="toc-number">20.</span> <span class="toc-text">20.三个c++11的主题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">20.1.</span> <span class="toc-text">20.1 可变参数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-auto"><span class="toc-number">20.2.</span> <span class="toc-text">20.2 auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-range-base-iterator"><span class="toc-number">20.3.</span> <span class="toc-text">20.3 range base iterator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Reference"><span class="toc-number">21.</span> <span class="toc-text">21. Reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-vptr%E5%92%8Cvtbl"><span class="toc-number">22.</span> <span class="toc-text">22.vptr和vtbl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%85%B3%E4%BA%8Ethis%E6%8C%87%E9%92%88"><span class="toc-number">23.</span> <span class="toc-text">23. 关于this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">24.</span> <span class="toc-text">24. 动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-const"><span class="toc-number">25.</span> <span class="toc-text">25. const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-new%E4%B8%8Edelete%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">26.</span> <span class="toc-text">26. new与delete的重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-1-%E5%85%A8%E5%B1%80%E9%87%8D%E8%BD%BD%EF%BC%9A"><span class="toc-number">26.1.</span> <span class="toc-text">26.1 全局重载：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%9A"><span class="toc-number">26.2.</span> <span class="toc-text">26.2 函数体内的重载：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-3-%E6%89%A9%E5%85%85%E5%8F%82%E6%95%B0"><span class="toc-number">26.3.</span> <span class="toc-text">26.3 扩充参数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/C++Review2/" title="C++ 复习2"><img src="/img/image-20230202174221474.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 复习2"/></a><div class="content"><a class="title" href="/2023/02/01/C++Review2/" title="C++ 复习2">C++ 复习2</a><time datetime="2023-02-16T08:03:33.000Z" title="更新于 2023-02-16 16:03:33">2023-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/01/GAMES104_NOTE4/" title="GAMES104-NOTE4"><img src="/img/image-20230106174810993.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAMES104-NOTE4"/></a><div class="content"><a class="title" href="/2023/01/01/GAMES104_NOTE4/" title="GAMES104-NOTE4">GAMES104-NOTE4</a><time datetime="2023-02-01T14:36:20.000Z" title="更新于 2023-02-01 22:36:20">2023-02-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/19/C++Review1/" title="C++ 复习1">C++ 复习1</a><time datetime="2023-02-01T07:38:50.000Z" title="更新于 2023-02-01 15:38:50">2023-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/GAMES104_NOTE3/" title="GAMES104-NOTE3"><img src="/img/image-20221206143528541.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAMES104-NOTE3"/></a><div class="content"><a class="title" href="/2022/12/06/GAMES104_NOTE3/" title="GAMES104-NOTE3">GAMES104-NOTE3</a><time datetime="2023-01-06T10:06:28.000Z" title="更新于 2023-01-06 18:06:28">2023-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/24/GAMES104_NOTE2/" title="GAMES104-NOTE2"><img src="/img/image-20221123153956216.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAMES104-NOTE2"/></a><div class="content"><a class="title" href="/2022/11/24/GAMES104_NOTE2/" title="GAMES104-NOTE2">GAMES104-NOTE2</a><time datetime="2022-11-25T09:18:58.000Z" title="更新于 2022-11-25 17:18:58">2022-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By 霍家鹏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn"><img class="icp-icon" src="icp图片"><span>粤ICP备2020091327号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>